[
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/postcss.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/tailwind.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/vite.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/deployment/vercel.build.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/linting/commitlint.config.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/linting/eslint.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/App.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/Root.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/Navigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallery.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallerySubComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPageStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPrivacySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementViewToggle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/LeaderboardView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/ConflictResolutionModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/DexieDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/SyncStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardLayouts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardMain.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/FeatureCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/database/DatabaseDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/demo/SessionPersistenceDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/examples/IntegratedTaskManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackFAB.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/CurrentStatusSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/SessionHistorySection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/StatisticsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/goals/SpecialChallengeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AcceptInviteCodeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinking.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemoComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingLoading.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingPreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveInviteCodesDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveKeyholderDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AdminDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/InviteCodeCreationSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/KeyholderPasswordUnlock.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/LinkingMessageDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/RelationshipSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SessionControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SubmissiveRelationshipsDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TaskManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TypedKeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AchievementNotifications.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AppLayout.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setPageTitle'. Either include it or remove the dependency array. Outer scope values like 'navItems' aren't valid dependencies because mutating them doesn't re-render the component.",
        "line": 66,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 66,
        "endColumn": 35,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [location.pathname, setPageTitle]",
            "fix": { "range": [2108, 2137], "text": "[location.pathname, setPageTitle]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'closeMobileMenu'. Either include it or remove the dependency array.",
        "line": 72,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 72,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [closeMobileMenu, location.pathname]",
            "fix": { "range": [2350, 2369], "text": "[closeMobileMenu, location.pathname]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/Header.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/MobileMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/NavigationData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/EventList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/LogEventForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomSheet.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/PullToRefresh.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/SwipeableCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/TouchTarget.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/VirtualList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/PrivacyPolicyModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/privacy/PrivacyPolicyContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/notifications/NotificationToast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileErrorStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileRecentAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileStatistics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/PublicProfileHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/ErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/MigrationBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/PendingRequestsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipRequestForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/LogItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/ManualEntryForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardPunishmentStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/AccountSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DataControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DisplaySettingsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PersonalGoalSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PublicProfileSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ResetModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SecuritySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SessionEditSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ToggleSwitch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/system/OfflineStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/CountdownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/TaskItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/CooldownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/DenialCooldown.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/GoalDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/KeyholderRequirement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseCooldownMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseResumeButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ReasonModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/RestoreSessionPrompt.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionLoader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionRecoveryModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/ui/NotificationContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/consistency-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/goal-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/milestone-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/special-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/streak-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/task-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/challengeAchievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/session-goals-templates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AppContext.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.",
        "line": 158,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 158,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setState]",
            "fix": { "range": [4486, 4488], "text": "[setState]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AuthContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/SyncContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/ToastProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useAccountLinkingDemo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useDexieSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useOfflineDemo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/firebase.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/useAccountLinking.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (270). Maximum allowed is 150.",
        "line": 30,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 349,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Account Linking Hook\n * React hook for managing keyholder-wearer account linking\n */\nimport { useState, useCallback, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AccountLinkingService } from \"../../services/auth/account-linking\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  AccountLinkingState,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useAccountLinking\");\n\n// Query keys\nconst QUERY_KEYS = {\n  relationships: (userId: string) => [\"adminRelationships\", userId],\n  validation: (code: string) => [\"linkCodeValidation\", code],\n  adminSession: (relationshipId: string) => [\"adminSession\", relationshipId],\n} as const;\n\nexport const useAccountLinking = () => {\n  const { user } = useAuthState();\n  const queryClient = useQueryClient();\n\n  // Local state\n  const [state, setState] = useState<AccountLinkingState>({\n    isGeneratingCode: false,\n    currentLinkCode: null,\n    linkCodeError: null,\n    isUsingCode: false,\n    codeUsageError: null,\n    adminRelationships: [],\n    selectedWearerId: null,\n    currentAdminSession: null,\n    isAdminSessionActive: false,\n    showQRCode: false,\n    showDisconnectionDialog: false,\n    showPermissionEditor: false,\n  });\n\n  // ==================== QUERIES ====================\n\n  // Get admin relationships for current user\n  const {\n    data: relationships = [],\n    isLoading: isLoadingRelationships,\n    error: relationshipsError,\n  } = useQuery({\n    queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n    queryFn: () => AccountLinkingService.getAdminRelationships(user!.uid),\n    enabled: !!user,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Update local state when relationships change\n  useEffect(() => {\n    setState((prev) => ({ ...prev, adminRelationships: relationships }));\n  }, [relationships]);\n\n  // ==================== MUTATIONS ====================\n\n  // Generate link code\n  const generateLinkCodeMutation = useMutation({\n    mutationFn: (request: GenerateLinkCodeRequest) =>\n      AccountLinkingService.generateLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isGeneratingCode: true,\n        linkCodeError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<LinkCodeResponse>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentLinkCode: response.data!,\n          isGeneratingCode: false,\n        }));\n        logger.info(\"Link code generated successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: response.error || \"Failed to generate link code\",\n          isGeneratingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        linkCodeError: error.message,\n        isGeneratingCode: false,\n      }));\n      logger.error(\"Failed to generate link code\", { error });\n    },\n  });\n\n  // Use link code\n  const useLinkCodeMutation = useMutation({\n    mutationFn: (request: UseLinkCodeRequest) =>\n      AccountLinkingService.redeemLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isUsingCode: true,\n        codeUsageError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          isUsingCode: false,\n        }));\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Link code used successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: response.error || \"Failed to use link code\",\n          isUsingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        codeUsageError: error.message,\n        isUsingCode: false,\n      }));\n      logger.error(\"Failed to use link code\", { error });\n    },\n  });\n\n  // Update relationship\n  const updateRelationshipMutation = useMutation({\n    mutationFn: (request: UpdateRelationshipRequest) =>\n      AccountLinkingService.updateRelationship(request),\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success) {\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Relationship updated successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to update relationship\", { error });\n    },\n  });\n\n  // Start admin session\n  const startAdminSessionMutation = useMutation({\n    mutationFn: (relationshipId: string) =>\n      AccountLinkingService.startAdminSession(relationshipId),\n    onSuccess: (response: ApiResponse<AdminSession>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentAdminSession: response.data!,\n          isAdminSessionActive: true,\n        }));\n        logger.info(\"Admin session started successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to start admin session\", { error });\n    },\n  });\n\n  // ==================== CALLBACK FUNCTIONS ====================\n\n  const generateLinkCode = useCallback(\n    (request: GenerateLinkCodeRequest = {}) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: \"Authentication required\",\n        }));\n        return;\n      }\n      generateLinkCodeMutation.mutate(request);\n    },\n    [user, generateLinkCodeMutation],\n  );\n\n  const redeemLinkCode = useCallback(\n    (request: UseLinkCodeRequest) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: \"Authentication required\",\n        }));\n        return;\n      }\n      useLinkCodeMutation.mutate(request);\n    },\n    [user, useLinkCodeMutation],\n  );\n\n  const updateRelationship = useCallback(\n    (request: UpdateRelationshipRequest) => {\n      updateRelationshipMutation.mutate(request);\n    },\n    [updateRelationshipMutation],\n  );\n\n  const startAdminSession = useCallback(\n    (relationshipId: string) => {\n      startAdminSessionMutation.mutate(relationshipId);\n    },\n    [startAdminSessionMutation],\n  );\n\n  const disconnectKeyholder = useCallback(\n    (relationshipId: string, reason?: string) => {\n      updateRelationship({\n        relationshipId,\n        status: \"terminated\",\n        terminationReason: reason,\n      });\n    },\n    [updateRelationship],\n  );\n\n  const clearLinkCode = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n    }));\n  }, []);\n\n  const clearAllErrors = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n      codeUsageError: null,\n    }));\n  }, []);\n\n  const setSelectedWearer = useCallback((wearerId: string | null) => {\n    setState((prev) => ({ ...prev, selectedWearerId: wearerId }));\n  }, []);\n\n  // Combined toggle function for boolean state properties\n  const toggleStateProperty = useCallback(\n    (\n      property: keyof Pick<\n        AccountLinkingState,\n        \"showQRCode\" | \"showDisconnectionDialog\" | \"showPermissionEditor\"\n      >,\n    ) => {\n      setState((prev) => ({ ...prev, [property]: !prev[property] }));\n    },\n    [],\n  );\n\n  const toggleQRCode = useCallback(\n    () => toggleStateProperty(\"showQRCode\"),\n    [toggleStateProperty],\n  );\n  const toggleDisconnectionDialog = useCallback(\n    () => toggleStateProperty(\"showDisconnectionDialog\"),\n    [toggleStateProperty],\n  );\n  const togglePermissionEditor = useCallback(\n    () => toggleStateProperty(\"showPermissionEditor\"),\n    [toggleStateProperty],\n  );\n\n  // ==================== DERIVED STATE ====================\n\n  // User role calculations\n  const userRoles = useMemo(\n    () => ({\n      isKeyholder: relationships.some((r) => r.keyholderId === user?.uid),\n      isWearer: relationships.some((r) => r.wearerId === user?.uid),\n      hasActiveRelationships: relationships.some((r) => r.status === \"active\"),\n    }),\n    [relationships, user?.uid],\n  );\n\n  // Relationship filtering\n  const relationshipsByRole = useMemo(\n    () => ({\n      keyholderRelationships: relationships.filter(\n        (r) => r.keyholderId === user?.uid,\n      ),\n      wearerRelationships: relationships.filter(\n        (r) => r.wearerId === user?.uid,\n      ),\n    }),\n    [relationships, user?.uid],\n  );\n\n  const selectedRelationship = state.selectedWearerId\n    ? relationships.find((r) => r.wearerId === state.selectedWearerId)\n    : null;\n\n  // ==================== RETURN OBJECT ====================\n\n  return {\n    // State\n    ...state,\n    relationships,\n    isLoadingRelationships,\n    relationshipsError,\n\n    // Derived state\n    ...userRoles,\n    selectedRelationship,\n    ...relationshipsByRole,\n\n    // Actions\n    generateLinkCode,\n    redeemLinkCode,\n    updateRelationship,\n    startAdminSession,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearAllErrors,\n    setSelectedWearer,\n    toggleQRCode,\n    toggleDisconnectionDialog,\n    togglePermissionEditor,\n\n    // Loading states\n    isGeneratingCode: generateLinkCodeMutation.isPending,\n    isUsingCode: useLinkCodeMutation.isPending,\n    isUpdatingRelationship: updateRelationshipMutation.isPending,\n    isStartingSession: startAdminSessionMutation.isPending,\n  };\n};\n\n// ==================== ADDITIONAL HOOKS ====================\n\n/**\n * Hook for validating link codes\n */\nexport const useLinkCodeValidation = (code: string) => {\n  return useQuery({\n    queryKey: QUERY_KEYS.validation(code),\n    queryFn: () => AccountLinkingService.validateLinkCode(code),\n    enabled: code.length > 0,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n};\n\n/**\n * Hook for admin access validation\n */\nexport const useAdminAccess = (wearerId: string) => {\n  const { user } = useAuthState();\n  const { relationships } = useAccountLinking();\n\n  const adminRelationship = relationships.find(\n    (r) =>\n      r.keyholderId === user?.uid &&\n      r.wearerId === wearerId &&\n      r.status === \"active\",\n  );\n\n  const hasAccess = !!adminRelationship;\n  const permissions = adminRelationship?.permissions || null;\n  const security = adminRelationship?.security || null;\n\n  const canPerformAction = useCallback(\n    (action: keyof typeof permissions) => {\n      return hasAccess && permissions?.[action] === true;\n    },\n    [hasAccess, permissions],\n  );\n\n  return {\n    hasAccess,\n    adminRelationship,\n    permissions,\n    security,\n    canPerformAction,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievement-gallery-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/useLeaderboardActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/usePrivacySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/auth-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/emergency-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/events-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/queryClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/tasks-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useAuth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEmergency.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEventQueries.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useEventMutations' has too many lines (184). Maximum allowed is 150.",
        "line": 89,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 307,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Events TanStack Query Hooks\n * Manages event log data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { eventDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBEvent, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useEventsQuery\");\n\n/**\n * Query for getting all events for a user\n */\nexport function useEventsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"events\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const events = await eventDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(userId).catch((error) => {\n          logger.warn(\"Background events sync failed\", { error });\n        });\n      }\n\n      return events;\n    },\n    ...cacheConfig.events, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting recent events (last 30 days)\n */\nexport function useRecentEventsQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"recent\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents\n        .filter((event) => event.timestamp >= thirtyDaysAgo)\n        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Query for getting events by type\n */\nexport function useEventsByTypeQuery(\n  userId: string | undefined,\n  eventType: EventType,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"type\", userId, eventType],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents.filter((event) => event.type === eventType);\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for event operations\n */\nexport function useEventMutations() {\n  const queryClient = useQueryClient();\n\n  const createEvent = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      type: EventType;\n      timestamp: Date;\n      notes?: string;\n      duration?: number;\n      isPrivate?: boolean;\n      sessionId?: string;\n      metadata?: Record<string, unknown>;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const { notes, duration, ...restParams } = params;\n      const eventData = {\n        ...restParams,\n        isPrivate: restParams.isPrivate ?? false, // Ensure isPrivate is always defined\n        details: {\n          notes,\n          duration,\n        },\n      };\n      const event = await eventDBService.createEvent(eventData);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event creation sync failed\", { error });\n        });\n      }\n\n      return event;\n    },\n    onSuccess: (data, variables) => {\n      // Add event to the cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return [data];\n          return [data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create event\", { error });\n    },\n  });\n\n  const updateEvent = useMutation({\n    mutationFn: async (params: {\n      eventId: string;\n      userId: string;\n      updates: Partial<DBEvent>;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedEvent = await eventDBService.updateEvent(\n        params.eventId,\n        params.updates,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event update sync failed\", { error });\n        });\n      }\n\n      return updatedEvent;\n    },\n    onSuccess: (data, variables) => {\n      // Update event in cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.map((event) =>\n            event.id === variables.eventId\n              ? { ...event, ...(data as Partial<DBEvent>) }\n              : event,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update event\", { error });\n    },\n  });\n\n  const deleteEvent = useMutation({\n    mutationFn: async (params: { eventId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await eventDBService.deleteEvent(params.eventId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event deletion sync failed\", { error });\n        });\n      }\n\n      return params.eventId;\n    },\n    onSuccess: (eventId, variables) => {\n      // Remove event from cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.filter((event) => event.id !== eventId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete event\", { error });\n    },\n  });\n\n  const bulkCreateEvents = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      events: Array<{\n        type: EventType;\n        timestamp: Date;\n        notes?: string;\n        duration?: number;\n        isPrivate?: boolean;\n        sessionId?: string;\n        metadata?: Record<string, unknown>;\n      }>;\n    }) => {\n      // 1. Create all events in local Dexie\n      const createdEvents = await Promise.all(\n        params.events.map((eventData) => {\n          const { notes, duration, ...restEventData } = eventData;\n          return eventDBService.createEvent({\n            ...restEventData,\n            userId: params.userId,\n            isPrivate: restEventData.isPrivate ?? false, // Ensure isPrivate is always defined\n            details: {\n              notes,\n              duration,\n            },\n          });\n        }),\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Bulk event creation sync failed\", { error });\n        });\n      }\n\n      return createdEvents;\n    },\n    onSuccess: (data, variables) => {\n      // Add all events to cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return data;\n          return [...data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to bulk create events\", { error });\n    },\n  });\n\n  return {\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    bulkCreateEvents,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useOfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSessionQuery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettingsQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTaskQuery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/dataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useConflictResolution.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (333). Maximum allowed is 150.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (31). Maximum allowed is 25.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeRealTimeSync', 'loadPendingConflicts', 'loadRelationshipSyncStatus', 'loadSyncHistory', and 'loadSyncPermissions'. Either include them or remove the dependency array.",
        "line": 151,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 151,
        "endColumn": 49,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]",
            "fix": {
              "range": [4192, 4235],
              "text": "[userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'performBackgroundSync'. Either include it or remove the dependency array.",
        "line": 167,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 167,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [performBackgroundSync, realTimeSyncEnabled, syncPermissions]",
            "fix": {
              "range": [4812, 4850],
              "text": "[performBackgroundSync, realTimeSyncEnabled, syncPermissions]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Data Synchronization Hook\n * Handles multi-user data sync, relationship data, and conflict resolution\n * with proper privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { SyncResult } from \"../../types/database\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateOverallSyncQuality,\n  getLastSuccessfulSync,\n  getSyncInterval,\n} from \"../../utils/dataSyncHelpers\";\nimport { useConflictResolution } from \"./useConflictResolution\";\nimport { useSyncBackup } from \"./useSyncBackup\";\nimport { useSyncMonitoring } from \"./useSyncMonitoring\";\n\nconst logger = serviceLogger(\"useDataSync\");\n\n// ==================== INTERFACES ====================\n\nimport type {\n  SyncStatus,\n  RelationshipSyncStatus,\n  DataConflict,\n  SyncPermissions,\n  SyncMetrics,\n  SyncScope,\n  DataEntityType,\n  RelationshipSyncResult,\n} from \"./types/dataSync\";\nimport type * as _Types from \"./types/dataSync\";\nexport type * from \"./types/dataSync\";\n\n// Complex sync orchestration hook requires many statements for proper state management\n// eslint-disable-next-line max-statements\nexport const useDataSync = (userId: string) => {\n  // ==================== STATE ====================\n\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    state: \"idle\",\n    lastSync: null,\n    progress: 0,\n    message: \"Ready to sync\",\n    error: null,\n  });\n\n  const [relationshipSync, setRelationshipSync] = useState<\n    RelationshipSyncStatus[]\n  >([]);\n\n  const [conflicts, setConflicts] = useState<DataConflict[]>([]);\n\n  const [syncPermissions, setSyncPermissions] = useState<SyncPermissions>({\n    allowDataSharing: true,\n    shareSessionData: true,\n    shareGoalData: true,\n    shareTaskData: true,\n    shareEventData: false,\n    allowRealTimeSync: false,\n    syncFrequency: \"moderate\",\n    privacyLevel: \"relationship_only\",\n  });\n\n  const [syncMetrics, setSyncMetrics] = useState<SyncMetrics>({\n    totalSyncs: 0,\n    successfulSyncs: 0,\n    failedSyncs: 0,\n    averageSyncTime: 0,\n    dataTransferred: 0,\n    conflictsResolved: 0,\n    lastSuccessfulSync: null,\n    reliabilityScore: 100,\n  });\n\n  const [realTimeSyncEnabled, setRealTimeSyncEnabled] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== SUB-HOOKS ====================\n\n  const conflictResolution = useConflictResolution({\n    conflicts,\n    setConflicts,\n    setSyncMetrics,\n  });\n\n  const syncBackup = useSyncBackup({ userId });\n\n  const syncMonitoring = useSyncMonitoring({ conflicts, syncMetrics });\n\n  // ==================== COMPUTED VALUES ====================\n\n  const isSyncing = useMemo(\n    () => syncStatus.state === \"syncing\",\n    [syncStatus.state],\n  );\n\n  const hasConflicts = useMemo(() => conflicts.length > 0, [conflicts.length]);\n\n  const syncQuality = useMemo(\n    () => calculateOverallSyncQuality(relationshipSync),\n    [relationshipSync],\n  );\n\n  const lastSuccessfulSync = useMemo(\n    () => getLastSuccessfulSync(syncMetrics),\n    [syncMetrics],\n  );\n\n  const needsAttention = useMemo(\n    () =>\n      conflicts.some((c) => c.priority === \"high\" || c.priority === \"critical\"),\n    [conflicts],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSync = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load sync state and configuration\n        await Promise.all([\n          loadSyncPermissions(),\n          loadSyncHistory(),\n          loadPendingConflicts(),\n          loadRelationshipSyncStatus(),\n        ]);\n\n        // Initialize real-time sync if enabled\n        if (syncPermissions.allowRealTimeSync) {\n          await initializeRealTimeSync();\n        }\n      } catch (err) {\n        logger.error(\"Failed to initialize data sync\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize sync\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSync();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, syncPermissions.allowRealTimeSync]);\n\n  // ==================== REAL-TIME SYNC ====================\n\n  useEffect(() => {\n    if (!realTimeSyncEnabled || !syncPermissions.allowRealTimeSync) return;\n\n    const syncInterval = getSyncInterval(syncPermissions.syncFrequency);\n    const interval = setInterval(() => {\n      performBackgroundSync();\n    }, syncInterval);\n\n    return () => clearInterval(interval);\n    // performBackgroundSync is stable (no deps)\n    // realTimeSyncEnabled and syncPermissions trigger re-setup of interval when changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [realTimeSyncEnabled, syncPermissions]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSyncPermissions = useCallback(async () => {\n    try {\n      // Load user's sync preferences from database\n      logger.debug(\"Loading sync permissions\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync permissions\", { error });\n    }\n  }, [userId]);\n\n  const loadSyncHistory = useCallback(async () => {\n    try {\n      // Load sync metrics and history\n      logger.debug(\"Loading sync history\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync history\", { error });\n    }\n  }, [userId]);\n\n  const loadPendingConflicts = useCallback(async () => {\n    try {\n      // Load unresolved conflicts\n      setConflicts([]);\n      logger.debug(\"Loading pending conflicts\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load pending conflicts\", { error });\n    }\n  }, [userId]);\n\n  const loadRelationshipSyncStatus = useCallback(async () => {\n    try {\n      // Load sync status for all relationships\n      setRelationshipSync([]);\n      logger.debug(\"Loading relationship sync status\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load relationship sync status\", { error });\n    }\n  }, [userId]);\n\n  // ==================== MANUAL SYNC OPERATIONS ====================\n\n  const forceSyncAll = useCallback(async (): Promise<SyncResult> => {\n    try {\n      logger.debug(\"Starting force sync all\", { userId });\n\n      setSyncStatus({\n        state: \"syncing\",\n        lastSync: null,\n        progress: 0,\n        message: \"Starting synchronization...\",\n        error: null,\n      });\n\n      // Simulate sync process\n      for (let i = 0; i <= 100; i += 20) {\n        setSyncStatus((prev) => ({\n          ...prev,\n          progress: i,\n          message: `Syncing... ${i}%`,\n        }));\n        await new Promise((resolve) => setTimeout(resolve, 200));\n      }\n\n      const result: SyncResult = {\n        success: true,\n        operations: {\n          uploaded: 15,\n          downloaded: 8,\n          conflicts: 2,\n        },\n        conflicts: [],\n        timestamp: new Date(),\n      };\n\n      setSyncStatus({\n        state: \"completed\",\n        lastSync: new Date(),\n        progress: 100,\n        message: \"Sync completed successfully\",\n        error: null,\n      });\n\n      // Update metrics\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        successfulSyncs: prev.successfulSyncs + 1,\n        lastSuccessfulSync: new Date(),\n      }));\n\n      logger.info(\"Force sync completed successfully\", { result });\n      return result;\n    } catch (error) {\n      logger.error(\"Force sync failed\", { error });\n\n      setSyncStatus({\n        state: \"error\",\n        lastSync: null,\n        progress: 0,\n        message: \"Sync failed\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        failedSyncs: prev.failedSyncs + 1,\n      }));\n\n      throw error;\n    }\n  }, [userId]);\n\n  const syncRelationshipData = useCallback(\n    async (relationshipId: string): Promise<RelationshipSyncResult> => {\n      try {\n        logger.debug(\"Syncing relationship data\", { relationshipId });\n\n        const startTime = Date.now();\n\n        // Find relationship sync status\n        const relationshipStatus = relationshipSync.find(\n          (rs) => rs.relationshipId === relationshipId,\n        );\n        if (!relationshipStatus) {\n          throw new Error(\"Relationship not found\");\n        }\n\n        // Perform relationship-specific sync\n        const result: RelationshipSyncResult = {\n          relationshipId,\n          success: true,\n          syncedCollections: [\"sessions\", \"goals\", \"tasks\"],\n          conflictsFound: 1,\n          conflictsResolved: 0,\n          metrics: {\n            duration: Date.now() - startTime,\n            itemsSynced: 12,\n            bytesTransferred: 4096,\n          },\n        };\n\n        // Update relationship sync status\n        setRelationshipSync((prev) =>\n          prev.map((rs) =>\n            rs.relationshipId === relationshipId\n              ? { ...rs, lastSync: new Date() }\n              : rs,\n          ),\n        );\n\n        logger.info(\"Relationship sync completed\", { relationshipId, result });\n        return result;\n      } catch (error) {\n        logger.error(\"Relationship sync failed\", { error, relationshipId });\n\n        return {\n          relationshipId,\n          success: false,\n          syncedCollections: [],\n          conflictsFound: 0,\n          conflictsResolved: 0,\n          error: error instanceof Error ? error.message : \"Unknown error\",\n          metrics: {\n            duration: 0,\n            itemsSynced: 0,\n            bytesTransferred: 0,\n          },\n        };\n      }\n    },\n    [relationshipSync],\n  );\n\n  // ==================== PRIVACY AND PERMISSIONS ====================\n\n  const updateSyncPermissions = useCallback(\n    async (permissions: Partial<SyncPermissions>): Promise<void> => {\n      try {\n        logger.debug(\"Updating sync permissions\", { permissions });\n\n        const updatedPermissions = { ...syncPermissions, ...permissions };\n        setSyncPermissions(updatedPermissions);\n\n        // Update real-time sync based on new permissions\n        if (\n          updatedPermissions.allowRealTimeSync !==\n          syncPermissions.allowRealTimeSync\n        ) {\n          if (updatedPermissions.allowRealTimeSync) {\n            await initializeRealTimeSync();\n          } else {\n            setRealTimeSyncEnabled(false);\n          }\n        }\n\n        logger.info(\"Sync permissions updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update sync permissions\", { error });\n        throw error;\n      }\n    },\n    [syncPermissions, initializeRealTimeSync],\n  );\n\n  const configureSyncScope = useCallback(\n    async (scope: SyncScope): Promise<void> => {\n      try {\n        logger.debug(\"Configuring sync scope\", { scope });\n        // Configure what data gets synced\n        logger.info(\"Sync scope configured successfully\");\n      } catch (error) {\n        logger.error(\"Failed to configure sync scope\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== REAL-TIME SYNC ====================\n\n  const enableRealtimeSync = useCallback(\n    (entityTypes: DataEntityType[]): void => {\n      try {\n        logger.debug(\"Enabling realtime sync\", { entityTypes });\n        setRealTimeSyncEnabled(true);\n        // Set up WebSocket connections or other real-time mechanisms\n        logger.info(\"Realtime sync enabled successfully\");\n      } catch (error) {\n        logger.error(\"Failed to enable realtime sync\", { error });\n      }\n    },\n    [],\n  );\n\n  const disableRealtimeSync = useCallback((): void => {\n    try {\n      logger.debug(\"Disabling realtime sync\");\n      setRealTimeSyncEnabled(false);\n      // Clean up real-time connections\n      logger.info(\"Realtime sync disabled successfully\");\n    } catch (error) {\n      logger.error(\"Failed to disable realtime sync\", { error });\n    }\n  }, []);\n\n  // ==================== PRIVATE HELPER FUNCTIONS ====================\n\n  const initializeRealTimeSync = useCallback(async (): Promise<void> => {\n    try {\n      logger.debug(\"Initializing real-time sync\");\n      setRealTimeSyncEnabled(true);\n      // Set up WebSocket connections, event listeners, etc.\n    } catch (error) {\n      logger.error(\"Failed to initialize real-time sync\", { error });\n    }\n  }, []);\n\n  const performBackgroundSync = useCallback(async (): Promise<void> => {\n    try {\n      // Perform lightweight background sync\n      logger.debug(\"Performing background sync\");\n    } catch (error) {\n      logger.error(\"Background sync failed\", { error });\n    }\n  }, []);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Sync state\n    syncStatus,\n    relationshipSync,\n    conflicts,\n    syncMetrics,\n\n    // Manual sync operations\n    forceSyncAll,\n    syncRelationshipData,\n\n    // Conflict resolution (from useConflictResolution hook)\n    resolveConflict: conflictResolution.resolveConflict,\n    resolveAllConflicts: conflictResolution.resolveAllConflicts,\n\n    // Privacy and permissions\n    updateSyncPermissions,\n    configureSyncScope,\n\n    // Real-time sync\n    enableRealtimeSync,\n    disableRealtimeSync,\n\n    // Backup and recovery (from useSyncBackup hook)\n    createBackup: syncBackup.createBackup,\n    restoreFromBackup: syncBackup.restoreFromBackup,\n\n    // Monitoring (from useSyncMonitoring hook)\n    getSyncHealth: syncMonitoring.getSyncHealth,\n    getSyncHistory: syncMonitoring.getSyncHistory,\n\n    // Computed values\n    isSyncing,\n    hasConflicts,\n    syncQuality,\n    lastSuccessfulSync,\n    needsAttention,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (394). Maximum allowed is 150.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 546,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (33). Maximum allowed is 25.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 546,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievementStatistics', 'loadComparativeStatistics', 'loadGoalStatistics', 'loadPredictiveAnalytics', 'loadRecommendations', 'loadSessionStatistics', and 'loadSharedStatistics'. Either include them or remove the dependency array.",
        "line": 245,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 245,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]",
            "fix": {
              "range": [6726, 6750],
              "text": "[userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Comprehensive Statistics Hook\n * Provides analytics and insights for both users and keyholders\n * with appropriate privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateImprovementScore,\n  calculateConsistencyRating,\n  calculateOverallProgress,\n  calculateKeyholderSatisfaction,\n} from \"../../utils/statisticsHelpers\";\nimport {\n  getStatsForPeriod as calculateStatsForPeriod,\n  getMonthlyTrends as calculateMonthlyTrends,\n  getWeeklyBreakdown as calculateWeeklyBreakdown,\n  compareWithPrevious as compareMetricsWithPrevious,\n  getBenchmarkComparisons as calculateBenchmarkComparisons,\n} from \"../../utils/statistics/calculations\";\nimport {\n  generateKeyholderDashboard,\n  generateRelationshipComparison,\n} from \"../../utils/statistics/keyholder\";\nimport {\n  generatePredictiveInsights,\n  generateRecommendations,\n} from \"../../utils/statistics/predictions\";\n\nconst logger = serviceLogger(\"useStatistics\");\n\n// ==================== INTERFACES ====================\n\n// Re-export all types from the types file\nexport type * from \"./types/statistics\";\n\nimport type {\n  SessionStatistics,\n  GoalStatistics,\n  AchievementStatistics,\n  ComparativeStatistics,\n  SharedStatistics,\n  PredictiveAnalytics,\n  RecommendationEngine,\n  TimePeriod,\n  PeriodStatistics as _PeriodStatistics,\n  MonthlyTrends as _MonthlyTrends,\n  WeeklyBreakdown as _WeeklyBreakdown,\n  ComparisonResult as _ComparisonResult,\n  BenchmarkData as _BenchmarkData,\n  KeyholderDashboardStats as _KeyholderDashboardStats,\n  KeyholderStatisticsView,\n  RelationshipComparisonStats as _RelationshipComparisonStats,\n  PredictiveInsights as _PredictiveInsights,\n  Recommendation as _Recommendation,\n  StatisticsExport,\n  StatisticType,\n  ExportFormat,\n} from \"./types/statistics\";\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex statistics aggregation hook requires many statements for comprehensive metrics\n// eslint-disable-next-line max-statements\nexport const useStatistics = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessionStats, setSessionStats] = useState<SessionStatistics>({\n    totalSessionTime: 0,\n    averageSessionLength: 0,\n    longestSession: 0,\n    shortestSession: 0,\n    sessionsThisWeek: 0,\n    sessionsThisMonth: 0,\n    sessionFrequency: {\n      daily: 0,\n      weekly: 0,\n      monthly: 0,\n      trend: \"stable\",\n    },\n    completionRate: 0,\n    goalAchievementRate: 0,\n    satisfactionRating: 0,\n    trends: [],\n    streaks: {\n      current: 0,\n      longest: 0,\n      type: \"session_consistency\",\n    },\n  });\n\n  const [goalStats, setGoalStats] = useState<GoalStatistics>({\n    totalGoals: 0,\n    completedGoals: 0,\n    activeGoals: 0,\n    completionRate: 0,\n    averageCompletionTime: 0,\n    mostCommonGoalTypes: [],\n    hardestGoalTypes: [],\n    goalStreaks: {\n      current: 0,\n      longest: 0,\n      type: \"goal_completion\",\n    },\n  });\n\n  const [achievementStats, setAchievementStats] =\n    useState<AchievementStatistics>({\n      totalAchievements: 0,\n      recentAchievements: [],\n      achievementsByCategory: [],\n      rareAchievements: [],\n      achievementPoints: 0,\n      percentileRank: 0,\n    });\n\n  const [comparativeStats, setComparativeStats] =\n    useState<ComparativeStatistics>({\n      userPercentile: 50,\n      averageUserStats: sessionStats,\n      personalBest: {\n        longestSession: 0,\n        mostGoalsInSession: 0,\n        longestStreak: 0,\n        highestSatisfactionRating: 0,\n        bestMonth: {\n          month: \"\",\n          year: 0,\n          totalTime: 0,\n          sessionCount: 0,\n        },\n      },\n      improvements: {\n        sessionLength: { improvement: 0, timeframe: \"month\" },\n        consistency: { improvement: 0, timeframe: \"month\" },\n        goalCompletion: { improvement: 0, timeframe: \"month\" },\n      },\n    });\n\n  const [sharedStats, setSharedStats] = useState<SharedStatistics>({\n    allowedMetrics: [],\n    keyholderView: {\n      sessionOverview: {\n        totalSessions: 0,\n        averageDuration: 0,\n        lastSessionDate: new Date(),\n      },\n      goalProgress: {\n        activeGoals: 0,\n        completionRate: 0,\n      },\n      behaviorPatterns: {\n        consistency: 0,\n        pauseFrequency: 0,\n        improvementTrend: \"stable\",\n      },\n      allowedInsights: [],\n    },\n    lastSharedAt: new Date(),\n    sharingLevel: \"basic\",\n  });\n\n  const [_predictiveAnalytics, setPredictiveAnalytics] =\n    useState<PredictiveAnalytics>({\n      nextSessionPrediction: {\n        suggestedDuration: 0,\n        successProbability: 0,\n        optimalStartTime: new Date(),\n        riskFactors: [],\n      },\n      goalRecommendations: [],\n      improvementOpportunities: [],\n      trendPredictions: [],\n    });\n\n  const [_recommendations, setRecommendations] = useState<RecommendationEngine>(\n    {\n      sessionRecommendations: [],\n      goalRecommendations: [],\n      behaviorInsights: [],\n      personalizedTips: [],\n    },\n  );\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const improvementScore = useMemo(\n    () => calculateImprovementScore(sessionStats.trends),\n    [sessionStats.trends],\n  );\n\n  const consistencyRating = useMemo(\n    () => calculateConsistencyRating(sessionStats),\n    [sessionStats],\n  );\n\n  const overallProgress = useMemo(\n    () => calculateOverallProgress(goalStats),\n    [goalStats],\n  );\n\n  const keyholderSatisfaction = useMemo(\n    () => calculateKeyholderSatisfaction(sharedStats),\n    [sharedStats],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeStatistics = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load all statistics data\n        await Promise.all([\n          loadSessionStatistics(),\n          loadGoalStatistics(),\n          loadAchievementStatistics(),\n          loadComparativeStatistics(),\n          loadSharedStatistics(),\n          loadPredictiveAnalytics(),\n          loadRecommendations(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize statistics\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize statistics\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeStatistics();\n    // Callback functions are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessionStatistics = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Calculate session statistics from historical data\n      const mockStats: SessionStatistics = {\n        totalSessionTime: 7200, // 2 hours\n        averageSessionLength: 3600, // 1 hour\n        longestSession: 7200,\n        shortestSession: 1800,\n        sessionsThisWeek: 3,\n        sessionsThisMonth: 12,\n        sessionFrequency: {\n          daily: 0.4,\n          weekly: 3,\n          monthly: 12,\n          trend: \"stable\",\n        },\n        completionRate: 85,\n        goalAchievementRate: 75,\n        satisfactionRating: 4.2,\n        trends: [],\n        streaks: {\n          current: 5,\n          longest: 12,\n          type: \"session_consistency\",\n        },\n      };\n\n      setSessionStats(mockStats);\n    } catch (error) {\n      logger.error(\"Failed to load session statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadGoalStatistics = useCallback(async () => {\n    try {\n      // Calculate goal statistics from historical goal data\n      setGoalStats({\n        totalGoals: 25,\n        completedGoals: 20,\n        activeGoals: 3,\n        completionRate: 80,\n        averageCompletionTime: 48, // hours\n        mostCommonGoalTypes: [],\n        hardestGoalTypes: [],\n        goalStreaks: {\n          current: 3,\n          longest: 8,\n          type: \"goal_completion\",\n        },\n      });\n    } catch (error) {\n      logger.error(\"Failed to load goal statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadAchievementStatistics = useCallback(async () => {\n    try {\n      // Load achievement data\n      setAchievementStats({\n        totalAchievements: 15,\n        recentAchievements: [],\n        achievementsByCategory: [],\n        rareAchievements: [],\n        achievementPoints: 1500,\n        percentileRank: 75,\n      });\n    } catch (error) {\n      logger.error(\"Failed to load achievement statistics\", { error });\n    }\n  }, []);\n\n  const loadComparativeStatistics = useCallback(async () => {\n    try {\n      // Load comparative data (anonymized benchmarks)\n      setComparativeStats((prev) => ({\n        ...prev,\n        userPercentile: 72,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load comparative statistics\", { error });\n    }\n  }, []); // sessionStats not actually used for computation\n\n  const loadSharedStatistics = useCallback(async () => {\n    try {\n      if (!relationshipId) return;\n\n      // Load keyholder-specific statistics view\n      const keyholderView: KeyholderStatisticsView = {\n        sessionOverview: {\n          totalSessions: sessionStats.sessionsThisMonth,\n          averageDuration: sessionStats.averageSessionLength,\n          lastSessionDate: new Date(),\n        },\n        goalProgress: {\n          activeGoals: goalStats.activeGoals,\n          completionRate: goalStats.completionRate,\n        },\n        behaviorPatterns: {\n          consistency: consistencyRating,\n          pauseFrequency: 0.2,\n          improvementTrend: \"improving\",\n        },\n        allowedInsights: [\"session_duration\", \"goal_completion\"],\n      };\n\n      setSharedStats((prev) => ({\n        ...prev,\n        keyholderView,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load shared statistics\", { error });\n    }\n  }, [\n    relationshipId,\n    consistencyRating,\n    sessionStats.sessionsThisMonth,\n    sessionStats.averageSessionLength,\n    goalStats.activeGoals,\n    goalStats.completionRate,\n  ]);\n\n  const loadPredictiveAnalytics = useCallback(async () => {\n    try {\n      // Generate predictive insights based on historical data\n      setPredictiveAnalytics({\n        nextSessionPrediction: {\n          suggestedDuration: sessionStats.averageSessionLength * 1.1,\n          successProbability: 85,\n          optimalStartTime: new Date(),\n          riskFactors: [],\n        },\n        goalRecommendations: [],\n        improvementOpportunities: [],\n        trendPredictions: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load predictive analytics\", { error });\n    }\n  }, [sessionStats.averageSessionLength]);\n\n  const loadRecommendations = useCallback(async () => {\n    try {\n      // Generate personalized recommendations\n      setRecommendations({\n        sessionRecommendations: [],\n        goalRecommendations: [],\n        behaviorInsights: [],\n        personalizedTips: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load recommendations\", { error });\n    }\n  }, []); // Static data for recommendations\n\n  // ==================== TIME-BASED QUERIES ====================\n\n  const getStatsForPeriod = useCallback(\n    (period: TimePeriod) => calculateStatsForPeriod(period),\n    [],\n  );\n\n  const getMonthlyTrends = useCallback(\n    (months: number) => calculateMonthlyTrends(months),\n    [],\n  );\n\n  const getWeeklyBreakdown = useCallback(() => calculateWeeklyBreakdown(), []);\n\n  // ==================== COMPARATIVE ANALYSIS ====================\n\n  const compareWithPrevious = useCallback(\n    (period: TimePeriod) => compareMetricsWithPrevious(period, sessionStats),\n    [sessionStats],\n  );\n\n  const getBenchmarkComparisons = useCallback(\n    () => calculateBenchmarkComparisons(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== KEYHOLDER FEATURES ====================\n\n  const getKeyholderDashboard = useCallback(\n    () =>\n      generateKeyholderDashboard(consistencyRating, sessionStats, goalStats),\n    [consistencyRating, sessionStats, goalStats],\n  );\n\n  const getRelationshipComparison = useCallback(\n    () => generateRelationshipComparison(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== PREDICTIVE ANALYTICS ====================\n\n  const getPredictiveInsights = useCallback(\n    () => generatePredictiveInsights(),\n    [],\n  );\n\n  const getRecommendations = useCallback(() => generateRecommendations(), []);\n\n  // ==================== EXPORT AND SHARING ====================\n\n  const exportStatistics = useCallback(\n    async (format: ExportFormat): Promise<StatisticsExport> => {\n      try {\n        logger.debug(\"Exporting statistics\", { format, userId });\n\n        const exportData = {\n          sessionStats,\n          goalStats,\n          achievementStats,\n          exportedAt: new Date(),\n        };\n\n        return {\n          format,\n          data: exportData,\n          generatedAt: new Date(),\n          fileSize: JSON.stringify(exportData).length,\n          downloadUrl: \"https://example.com/download/stats\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to export statistics\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionStats, goalStats, achievementStats],\n  );\n\n  const shareWithKeyholder = useCallback(\n    async (statTypes: StatisticType[]): Promise<void> => {\n      try {\n        if (!relationshipId) {\n          throw new Error(\"No keyholder relationship found\");\n        }\n\n        logger.debug(\"Sharing statistics with keyholder\", { statTypes });\n\n        setSharedStats((prev) => ({\n          ...prev,\n          allowedMetrics: statTypes,\n          lastSharedAt: new Date(),\n        }));\n\n        logger.info(\"Statistics shared with keyholder successfully\");\n      } catch (error) {\n        logger.error(\"Failed to share statistics with keyholder\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Statistics\n    sessionStats,\n    goalStats,\n    achievementStats,\n    comparativeStats,\n\n    // Time-based queries\n    getStatsForPeriod,\n    getMonthlyTrends,\n    getWeeklyBreakdown,\n\n    // Comparative analysis\n    compareWithPrevious,\n    getBenchmarkComparisons,\n\n    // Keyholder features\n    getKeyholderDashboard,\n    getRelationshipComparison,\n\n    // Predictive analytics\n    getPredictiveInsights,\n    getRecommendations,\n\n    // Export and sharing\n    exportStatistics,\n    shareWithKeyholder,\n\n    // Computed values\n    improvementScore,\n    consistencyRating,\n    overallProgress,\n    keyholderSatisfaction,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncBackup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncMonitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/account-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/display-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/gamification-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/goals-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/personal-goals-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/types/Goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useAccountSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useDisplaySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGameification.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (376). Maximum allowed is 150.",
        "line": 46,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 517,
        "endColumn": 2
      },
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 46,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 517,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGameification Hook - Enhanced Gamification System\n *\n * Comprehensive gamification system beyond basic achievements, including challenges,\n * leaderboards, seasons, and social features.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  PlayerProfile,\n  Challenge,\n  Leaderboard,\n  Season,\n  SocialGameFeatures,\n  Badge as _Badge,\n  ExperienceSource,\n  LevelResult,\n  LevelUpResult,\n  ChallengeCompletion,\n  LeaderboardRank,\n  FriendComparison,\n  SeasonalReward,\n  ExperienceEvent,\n} from \"../../types/gamification\";\nimport { logger } from \"../../utils/logging\";\nimport { GamificationStorageService } from \"../../services/gamificationStorage\";\nimport {\n  DEFAULT_PLAYER_PROFILE,\n  LEVEL_THRESHOLDS,\n  SAMPLE_CHALLENGES,\n} from \"../../constants/gamification\";\nimport {\n  generateSampleLeaderboards,\n  generateSeasonalRewards,\n  createBadgeFromReward,\n  generateLevelRewards,\n  getPlayerTitle,\n  getUnlockedFeatures,\n} from \"./gamification-utils\";\n\n/**\n * Enhanced Gamification Hook\n * Complex gamification logic with multiple queries, mutations, and game mechanics\n */\nexport const useGameification = (userId: string) => {\n  const queryClient = useQueryClient();\n\n  // Get player profile\n  const { data: playerProfile = DEFAULT_PLAYER_PROFILE } =\n    useQuery<PlayerProfile>({\n      queryKey: [\"gamification\", \"profile\", userId],\n      queryFn: () => {\n        const stored =\n          GamificationStorageService.getPlayerProfile<PlayerProfile>();\n        return stored\n          ? { ...DEFAULT_PLAYER_PROFILE, ...stored }\n          : DEFAULT_PLAYER_PROFILE;\n      },\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000,\n    });\n\n  // Get active challenges\n  const { data: activeChallenges = [] } = useQuery<Challenge[]>({\n    queryKey: [\"gamification\", \"challenges\", userId],\n    queryFn: () => {\n      const userChallenges =\n        GamificationStorageService.getChallenges<Challenge>();\n      return [...SAMPLE_CHALLENGES, ...userChallenges].filter(\n        (c) => !c.isCompleted,\n      );\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get leaderboards\n  const { data: leaderboards = [] } = useQuery<Leaderboard[]>({\n    queryKey: [\"gamification\", \"leaderboards\"],\n    queryFn: async () => {\n      // Simulate leaderboard data\n      return generateSampleLeaderboards();\n    },\n    staleTime: 5 * 60 * 1000,\n    refetchInterval: 10 * 60 * 1000,\n  });\n\n  // Get current season\n  const { data: currentSeason } = useQuery<Season | null>({\n    queryKey: [\"gamification\", \"season\"],\n    queryFn: () => {\n      return {\n        id: \"season-winter-2024\",\n        name: \"Winter Challenge 2024\",\n        description:\n          \"Embrace the cold season with special winter-themed challenges\",\n        theme: \"winter\",\n        startDate: new Date(\"2024-12-01\"),\n        endDate: new Date(\"2024-02-28\"),\n        rewards: generateSeasonalRewards(),\n        challenges: [\"winter-endurance\", \"cold-discipline\"],\n        leaderboards: [\"winter-champions\"],\n        isActive: true,\n      };\n    },\n    staleTime: 60 * 60 * 1000, // 1 hour\n  });\n\n  // Get social features\n  const { data: socialFeatures } = useQuery<SocialGameFeatures>({\n    queryKey: [\"gamification\", \"social\", userId],\n    queryFn: () => {\n      const stored =\n        GamificationStorageService.getSocialFeatures<SocialGameFeatures>();\n      return stored\n        ? stored\n        : {\n            friends: [],\n            pendingRequests: [],\n            recentActivity: [],\n            groups: [],\n            comparisons: [],\n          };\n    },\n    enabled: Boolean(userId) && playerProfile.preferences.allowSocialFeatures,\n    staleTime: 2 * 60 * 1000,\n  });\n\n  // Get experience history\n  const { data: experienceHistory = [] } = useQuery<ExperienceEvent[]>({\n    queryKey: [\"gamification\", \"experience\", userId],\n    queryFn: () => {\n      return GamificationStorageService.getExperienceHistory<ExperienceEvent>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Accept challenge mutation\n  const acceptChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge accepted\", { challengeId, userId });\n\n      // In a real implementation, this would register the user for the challenge\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Complete challenge mutation\n  const completeChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string): Promise<ChallengeCompletion> => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge completed\", { challengeId, userId });\n\n      // Mark challenge as completed\n      const updatedChallenges = activeChallenges.map((c) =>\n        c.id === challengeId\n          ? {\n              ...c,\n              isCompleted: true,\n              progress: { ...c.progress, percentage: 100 },\n            }\n          : c,\n      );\n      GamificationStorageService.setChallenges(updatedChallenges);\n\n      // Calculate rewards\n      const experienceGained = challenge.rewards.reduce(\n        (total, reward) =>\n          reward.type === \"experience\" ? total + reward.value : total,\n        0,\n      );\n\n      // Add experience\n      const levelResult = await addExperienceInternal(\n        experienceGained,\n        ExperienceSource.CHALLENGE_COMPLETE,\n      );\n\n      // Create completion result\n      const completion: ChallengeCompletion = {\n        challengeId,\n        completedAt: new Date(),\n        rewards: challenge.rewards,\n        experience: experienceGained,\n        newBadges: challenge.rewards\n          .filter((r) => r.type === \"badge\")\n          .map((r) => createBadgeFromReward(r)),\n        levelUp: levelResult.leveledUp\n          ? {\n              newLevel: levelResult.newLevel,\n              rewards: [],\n              unlockedFeatures: [],\n            }\n          : undefined,\n      };\n\n      // Update stats\n      const updatedProfile = {\n        ...playerProfile,\n        stats: {\n          ...playerProfile.stats,\n          challengesCompleted: playerProfile.stats.challengesCompleted + 1,\n          totalExperience:\n            playerProfile.stats.totalExperience + experienceGained,\n        },\n      };\n      GamificationStorageService.setPlayerProfile(updatedProfile);\n      queryClient.setQueryData(\n        [\"gamification\", \"profile\", userId],\n        updatedProfile,\n      );\n\n      return completion;\n    },\n  });\n\n  // Add experience mutation\n  const addExperienceMutation = useMutation({\n    mutationFn: async ({\n      amount,\n      source,\n    }: {\n      amount: number;\n      source: ExperienceSource;\n    }): Promise<LevelResult> => {\n      return addExperienceInternal(amount, source);\n    },\n  });\n\n  // Internal add experience function\n  const addExperienceInternal = async (\n    amount: number,\n    source: ExperienceSource,\n  ): Promise<LevelResult> => {\n    const oldLevel = playerProfile.level;\n    const newExperience = playerProfile.experience + amount;\n\n    // Calculate new level\n    let newLevel = oldLevel;\n    for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {\n      if (newExperience >= LEVEL_THRESHOLDS[i]) {\n        newLevel = i + 1;\n      } else {\n        break;\n      }\n    }\n\n    const experienceToNext =\n      newLevel < LEVEL_THRESHOLDS.length\n        ? LEVEL_THRESHOLDS[newLevel] - newExperience\n        : 0;\n\n    // Create experience event\n    const experienceEvent: ExperienceEvent = {\n      id: `exp-${Date.now()}`,\n      source,\n      amount,\n      description: `Gained ${amount} XP from ${source}`,\n      timestamp: new Date(),\n    };\n\n    // Update experience history\n    const updatedHistory = [experienceEvent, ...experienceHistory].slice(\n      0,\n      100,\n    );\n    GamificationStorageService.setExperienceHistory(updatedHistory);\n    queryClient.setQueryData(\n      [\"gamification\", \"experience\", userId],\n      updatedHistory,\n    );\n\n    // Update profile\n    const updatedProfile = {\n      ...playerProfile,\n      level: newLevel,\n      experience: newExperience,\n      experienceToNext,\n      stats: {\n        ...playerProfile.stats,\n        totalExperience: playerProfile.stats.totalExperience + amount,\n      },\n      lastActive: new Date(),\n    };\n\n    GamificationStorageService.setPlayerProfile(updatedProfile);\n    queryClient.setQueryData(\n      [\"gamification\", \"profile\", userId],\n      updatedProfile,\n    );\n\n    logger.info(\"Experience added\", {\n      amount,\n      source,\n      oldLevel,\n      newLevel,\n      userId,\n    });\n\n    return {\n      leveledUp: newLevel > oldLevel,\n      oldLevel,\n      newLevel,\n      experience: amount,\n    };\n  };\n\n  // Check level up\n  const checkLevelUp = useCallback(async (): Promise<LevelUpResult | null> => {\n    const _currentLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level - 1] || 0;\n    const nextLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level] || Infinity;\n\n    if (playerProfile.experience >= nextLevelThreshold) {\n      const newLevel = playerProfile.level + 1;\n      const rewards = generateLevelRewards(newLevel);\n\n      return {\n        newLevel,\n        rewards,\n        newTitle: getPlayerTitle(newLevel),\n        unlockedFeatures: getUnlockedFeatures(newLevel),\n      };\n    }\n\n    return null;\n  }, [playerProfile]);\n\n  // Get leaderboard rank\n  const getLeaderboardRank = useCallback(\n    async (leaderboardId: string): Promise<LeaderboardRank> => {\n      const leaderboard = leaderboards.find((l) => l.id === leaderboardId);\n      if (!leaderboard) throw new Error(\"Leaderboard not found\");\n\n      // Find user's rank (simulated)\n      const userRank =\n        Math.floor(Math.random() * leaderboard.totalParticipants) + 1;\n      const percentile =\n        ((leaderboard.totalParticipants - userRank) /\n          leaderboard.totalParticipants) *\n        100;\n\n      return {\n        category: leaderboard.category,\n        period: leaderboard.period,\n        rank: userRank,\n        totalParticipants: leaderboard.totalParticipants,\n        percentile,\n        value: playerProfile.stats.totalExperience,\n      };\n    },\n    [leaderboards, playerProfile],\n  );\n\n  // Compare with friends\n  const compareWithFriends = useCallback(async (): Promise<\n    FriendComparison[]\n  > => {\n    if (!socialFeatures?.friends) return [];\n\n    return socialFeatures.friends.map((friend) => ({\n      friendId: friend.userId,\n      friendName: friend.displayName,\n      categories: [\n        {\n          category: \"Level\",\n          playerValue: playerProfile.level,\n          friendValue: friend.level,\n          difference: playerProfile.level - friend.level,\n          status:\n            playerProfile.level > friend.level\n              ? \"ahead\"\n              : playerProfile.level < friend.level\n                ? \"behind\"\n                : \"tied\",\n        },\n        {\n          category: \"Experience\",\n          playerValue: playerProfile.experience,\n          friendValue: Math.floor(Math.random() * 10000),\n          difference: 0,\n          status: \"tied\",\n        },\n      ],\n      overallComparison: \"ahead\",\n    }));\n  }, [socialFeatures, playerProfile]);\n\n  // Send challenge to friend\n  const sendChallenge = useCallback(\n    async (friendId: string, challengeId: string) => {\n      logger.info(\"Challenge sent to friend\", {\n        friendId,\n        challengeId,\n        userId,\n      });\n      // In a real implementation, this would create a challenge invitation\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Get seasonal rewards\n  const getSeasonalRewards = useCallback(async (): Promise<\n    SeasonalReward[]\n  > => {\n    return currentSeason?.rewards || [];\n  }, [currentSeason]);\n\n  // Claim seasonal reward\n  const claimSeasonalReward = useCallback(\n    async (rewardId: string) => {\n      logger.info(\"Seasonal reward claimed\", { rewardId, userId });\n      // In a real implementation, this would claim the reward and update user data\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Computed properties\n  const currentLevel = playerProfile.level;\n  const progressToNext =\n    playerProfile.experienceToNext > 0\n      ? ((playerProfile.experience -\n          (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0)) /\n          ((LEVEL_THRESHOLDS[playerProfile.level] ||\n            playerProfile.experienceToNext) -\n            (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0))) *\n        100\n      : 100;\n\n  const activeChallengeCount = activeChallenges.length;\n  const completedChallengesThisWeek = playerProfile.stats.challengesCompleted; // Simplified\n\n  const rank =\n    leaderboards.length > 0\n      ? leaderboards[0].entries.findIndex((e) => e.userId === userId) + 1 || 0\n      : 0;\n\n  const hasUnclaimedRewards =\n    currentSeason?.rewards.some((r) => !r.claimed) || false;\n\n  return {\n    // Player state\n    playerProfile,\n    activeChallenges,\n    leaderboards,\n    currentSeason,\n    socialFeatures,\n    experienceHistory,\n\n    // Challenge management\n    acceptChallenge: acceptChallengeMutation.mutate,\n    completeChallenge: completeChallengeMutation.mutate,\n    getChallengeProgress: (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      return challenge?.progress;\n    },\n\n    // Experience and leveling\n    addExperience: addExperienceMutation.mutate,\n    checkLevelUp,\n\n    // Leaderboard features\n    getLeaderboardRank,\n    joinLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Joined leaderboard\", { leaderboardId, userId });\n    },\n    leaveLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Left leaderboard\", { leaderboardId, userId });\n    },\n\n    // Social features\n    compareWithFriends,\n    sendChallenge,\n\n    // Seasonal events\n    getSeasonalRewards,\n    claimSeasonalReward,\n\n    // Loading states\n    isAcceptingChallenge: acceptChallengeMutation.isPending,\n    isCompletingChallenge: completeChallengeMutation.isPending,\n    isAddingExperience: addExperienceMutation.isPending,\n\n    // Results\n    lastChallengeCompletion: completeChallengeMutation.data,\n    lastLevelResult: addExperienceMutation.data,\n\n    // Computed properties\n    currentLevel,\n    progressToNext,\n    activeChallengeCount,\n    completedChallengesThisWeek,\n    rank,\n    hasUnclaimedRewards,\n\n    // Quick stats\n    totalExperience: playerProfile.stats.totalExperience,\n    totalBadges: playerProfile.badges.length,\n    currentStreak: playerProfile.stats.currentStreak,\n\n    // Errors\n    error:\n      acceptChallengeMutation.error ||\n      completeChallengeMutation.error ||\n      addExperienceMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGoals.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (451). Maximum allowed is 150.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (26). Maximum allowed is 25.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGoals Hook - Enhanced Goal System\n *\n * Advanced goal system with AI recommendations, collaborative goals, and\n * comprehensive progress analytics.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  EnhancedGoal,\n  CollaborativeGoal,\n  GoalRecommendation,\n  GoalAnalytics,\n  GoalTemplate,\n  CreateGoalRequest,\n  GoalUpdate,\n  OptimizedGoalPlan,\n  CollaborationInvite,\n  GoalInsights,\n  GoalPredictions,\n  CompletionTrends,\n  GoalType,\n  GoalCategory,\n  GoalDifficulty,\n  GoalStatus,\n} from \"../../types/goals\";\nimport { logger } from \"../../utils/logging\";\nimport {\n  getGoalInsights,\n  getPredictiveAnalytics as getPredictiveAnalyticsHelper,\n  getCompletionTrends as getCompletionTrendsHelper,\n} from \"../../utils/goalsHelpers\";\nimport { GoalStorageService } from \"../../services/goalStorage\";\n\n// Enhanced goal state\n\nimport type * as _Types from \"./types/Goals\";\nexport type * from \"./types/Goals\";\nimport { DEFAULT_TEMPLATES } from \"./goals-utils\";\n\n// Complex goal management hook with multiple goal types and collaborative features\n// eslint-disable-next-line max-statements\nexport const useGoals = (userId?: string, relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get personal goals\n  const { data: personalGoals = [] } = useQuery<EnhancedGoal[]>({\n    queryKey: [\"goals\", \"personal\", userId],\n    queryFn: () => {\n      return GoalStorageService.getPersonalGoals<EnhancedGoal>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get collaborative goals\n  const { data: collaborativeGoals = [] } = useQuery<CollaborativeGoal[]>({\n    queryKey: [\"goals\", \"collaborative\", userId, relationshipId],\n    queryFn: () => {\n      return GoalStorageService.getCollaborativeGoals<CollaborativeGoal>();\n    },\n    enabled: Boolean(userId) && Boolean(relationshipId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get goal templates\n  const { data: goalTemplates = DEFAULT_TEMPLATES } = useQuery<GoalTemplate[]>({\n    queryKey: [\"goals\", \"templates\"],\n    queryFn: () => {\n      const stored = GoalStorageService.getGoalTemplates<GoalTemplate>();\n      return stored.length > 0\n        ? [...DEFAULT_TEMPLATES, ...stored]\n        : DEFAULT_TEMPLATES;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get AI recommendations\n  const { data: recommendedGoals = [] } = useQuery<GoalRecommendation[]>({\n    queryKey: [\"goals\", \"recommendations\", userId],\n    queryFn: async () => {\n      // Simulate AI recommendation generation\n      await new Promise((resolve) => setTimeout(resolve, 800));\n\n      return generateSmartRecommendations(personalGoals, collaborativeGoals);\n    },\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    refetchInterval: 30 * 60 * 1000, // 30 minutes\n  });\n\n  // Get goal analytics\n  const { data: goalAnalytics } = useQuery<GoalAnalytics>({\n    queryKey: [\"goals\", \"analytics\", userId],\n    queryFn: () => calculateGoalAnalytics(personalGoals, collaborativeGoals),\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Create goal mutation\n  const createGoalMutation = useMutation({\n    mutationFn: async (request: CreateGoalRequest) => {\n      const newGoal: EnhancedGoal = {\n        id: `goal-${Date.now()}`,\n        type: request.type,\n        category: request.category,\n        title: request.title,\n        description: request.description,\n        target: request.target,\n        progress: {\n          current: 0,\n          target: request.target.value,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones:\n            request.milestones?.map((m) => ({\n              ...m,\n              id: `milestone-${Date.now()}-${Math.random()}`,\n              achieved: false,\n            })) || [],\n          lastUpdated: new Date(),\n        },\n        milestones:\n          request.milestones?.map((m) => ({\n            ...m,\n            id: `milestone-${Date.now()}-${Math.random()}`,\n            achieved: false,\n          })) || [],\n        aiGenerated: false,\n        difficulty: request.difficulty,\n        estimatedCompletion: calculateEstimatedCompletion(\n          request.difficulty,\n          request.target,\n        ),\n        createdAt: new Date(),\n        tags: request.tags || [],\n        isPublic: request.isPublic || false,\n      };\n\n      const updated = [...personalGoals, newGoal];\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal created\", { goalId: newGoal.id, title: newGoal.title });\n      return newGoal;\n    },\n  });\n\n  // Update goal mutation\n  const updateGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      updates,\n    }: {\n      goalId: string;\n      updates: GoalUpdate;\n    }) => {\n      const goalIndex = personalGoals.findIndex((g) => g.id === goalId);\n      if (goalIndex === -1) throw new Error(\"Goal not found\");\n\n      const updatedGoal: EnhancedGoal = {\n        ...personalGoals[goalIndex],\n        ...updates,\n      };\n      const updated = [...personalGoals];\n      updated[goalIndex] = updatedGoal;\n\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal updated\", { goalId, updates });\n      return updatedGoal;\n    },\n  });\n\n  // Delete goal mutation\n  const deleteGoalMutation = useMutation({\n    mutationFn: async (goalId: string) => {\n      const updated = personalGoals.filter((g) => g.id !== goalId);\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal deleted\", { goalId });\n    },\n  });\n\n  // Generate goal from prompt mutation\n  const generateGoalFromPromptMutation = useMutation({\n    mutationFn: async (prompt: string) => {\n      logger.info(\"Generating goal from prompt\", { prompt });\n\n      // Simulate AI processing\n      await new Promise((resolve) => setTimeout(resolve, 1500));\n\n      const aiGoal: EnhancedGoal = {\n        id: `ai-goal-${Date.now()}`,\n        type: GoalType.DURATION,\n        category: GoalCategory.CHASTITY,\n        title: \"AI-Generated Chastity Goal\",\n        description: `Generated from: \"${prompt}\"`,\n        target: {\n          type: \"duration\",\n          value: 14,\n          unit: \"days\",\n          description: \"14 days of commitment\",\n        },\n        progress: {\n          current: 0,\n          target: 14,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones: [],\n          lastUpdated: new Date(),\n        },\n        milestones: [\n          {\n            id: \"ai-milestone-1\",\n            name: \"First Week\",\n            description: \"Complete 7 days\",\n            target: 7,\n            achieved: false,\n          },\n          {\n            id: \"ai-milestone-2\",\n            name: \"Final Goal\",\n            description: \"Complete 14 days\",\n            target: 14,\n            achieved: false,\n          },\n        ],\n        aiGenerated: true,\n        difficulty: GoalDifficulty.MEDIUM,\n        estimatedCompletion: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n        createdAt: new Date(),\n        tags: [\"ai-generated\"],\n        isPublic: false,\n      };\n\n      return aiGoal;\n    },\n  });\n\n  // Optimize goal plan mutation\n  const optimizeGoalPlanMutation = useMutation({\n    mutationFn: async (goalIds: string[]) => {\n      const goalsToOptimize = personalGoals.filter((g) =>\n        goalIds.includes(g.id),\n      );\n\n      // Simulate optimization processing\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      const optimizedPlan: OptimizedGoalPlan = {\n        goals: goalsToOptimize,\n        timeline: generateTimeline(goalsToOptimize),\n        conflicts: detectConflicts(goalsToOptimize),\n        recommendations: generatePlanRecommendations(goalsToOptimize),\n        estimatedCompletion: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days\n      };\n\n      return optimizedPlan;\n    },\n  });\n\n  // Share goal mutation\n  const shareGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      logger.info(\"Sharing goal\", { goalId, targetUserId });\n      // In a real implementation, this would create a sharing record\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Invite collaborator mutation\n  const inviteCollaboratorMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      const invite: CollaborationInvite = {\n        id: `invite-${Date.now()}`,\n        goalId,\n        inviterId: userId!,\n        inviteeId: targetUserId,\n        permissions: {\n          canEdit: false,\n          canDelete: false,\n          canInviteOthers: false,\n          canViewProgress: true,\n          canAddMilestones: false,\n        },\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        status: \"pending\",\n      };\n\n      logger.info(\"Collaboration invite sent\", {\n        inviteId: invite.id,\n        goalId,\n        targetUserId,\n      });\n      return invite;\n    },\n  });\n\n  // Helper functions\n  const generateSmartRecommendations = (\n    personal: EnhancedGoal[],\n    _collaborative: CollaborativeGoal[],\n  ): GoalRecommendation[] => {\n    const recommendations: GoalRecommendation[] = [];\n\n    // Analyze completed goals to suggest similar ones\n    const completedGoals = personal.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const activeCategories = new Set(personal.map((g) => g.category));\n\n    // Suggest goals in successful categories\n    completedGoals.forEach((goal) => {\n      if (Math.random() > 0.7) {\n        // 30% chance to recommend\n        recommendations.push({\n          id: `rec-${Date.now()}-${Math.random()}`,\n          type: goal.type,\n          category: goal.category,\n          title: `Advanced ${goal.category} Challenge`,\n          description: `Based on your success with \"${goal.title}\"`,\n          difficulty:\n            goal.difficulty === GoalDifficulty.EASY\n              ? GoalDifficulty.MEDIUM\n              : GoalDifficulty.HARD,\n          estimatedDuration: 30,\n          reasoning: `You successfully completed similar goals in the ${goal.category} category`,\n          confidence: 0.8,\n          similarGoals: [goal.id],\n          successRate: 0.75,\n        });\n      }\n    });\n\n    // Suggest unexplored categories\n    const allCategories = Object.values(GoalCategory);\n    const unexploredCategories = allCategories.filter(\n      (cat) => !activeCategories.has(cat),\n    );\n\n    unexploredCategories.forEach((category) => {\n      if (Math.random() > 0.8) {\n        // 20% chance\n        recommendations.push({\n          id: `exp-${Date.now()}-${Math.random()}`,\n          type: GoalType.MILESTONE,\n          category,\n          title: `Explore ${category}`,\n          description: `Try something new in the ${category} category`,\n          difficulty: GoalDifficulty.EASY,\n          estimatedDuration: 14,\n          reasoning: `Diversifying goal categories can improve overall success`,\n          confidence: 0.6,\n          similarGoals: [],\n          successRate: 0.65,\n        });\n      }\n    });\n\n    return recommendations.slice(0, 5); // Limit to 5 recommendations\n  };\n\n  const calculateGoalAnalytics = (\n    personal: EnhancedGoal[],\n    collaborative: CollaborativeGoal[],\n  ): GoalAnalytics => {\n    const allGoals = [...personal, ...collaborative];\n    const completed = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const active = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    );\n\n    const categoryDistribution = Object.values(GoalCategory).reduce(\n      (acc, cat) => {\n        acc[cat] = allGoals.filter((g) => g.category === cat).length;\n        return acc;\n      },\n      {} as Record<GoalCategory, number>,\n    );\n\n    const difficultyDistribution = Object.values(GoalDifficulty).reduce(\n      (acc, diff) => {\n        acc[diff] = allGoals.filter((g) => g.difficulty === diff).length;\n        return acc;\n      },\n      {} as Record<GoalDifficulty, number>,\n    );\n\n    return {\n      totalGoals: allGoals.length,\n      completedGoals: completed.length,\n      activeGoals: active.length,\n      completionRate:\n        allGoals.length > 0 ? (completed.length / allGoals.length) * 100 : 0,\n      averageCompletionTime: calculateAverageCompletionTime(completed),\n      categoryDistribution,\n      difficultyDistribution,\n      monthlyProgress: generateMonthlyProgress(allGoals),\n      streaks: calculateStreaks(completed),\n    };\n  };\n\n  const calculateEstimatedCompletion = (\n    difficulty: GoalDifficulty,\n    target: { value?: number; unit?: string },\n  ): Date => {\n    const baseDays = target.value || 30;\n    const multiplier = {\n      [GoalDifficulty.EASY]: 1,\n      [GoalDifficulty.MEDIUM]: 1.5,\n      [GoalDifficulty.HARD]: 2,\n      [GoalDifficulty.EXTREME]: 3,\n    };\n\n    return new Date(\n      Date.now() + baseDays * multiplier[difficulty] * 24 * 60 * 60 * 1000,\n    );\n  };\n\n  const calculateAverageCompletionTime = (\n    completed: EnhancedGoal[],\n  ): number => {\n    if (completed.length === 0) return 0;\n\n    const totalDays = completed.reduce((acc, goal) => {\n      if (goal.completedAt && goal.startedAt) {\n        return (\n          acc +\n          (goal.completedAt.getTime() - goal.startedAt.getTime()) /\n            (24 * 60 * 60 * 1000)\n        );\n      }\n      return acc;\n    }, 0);\n\n    return totalDays / completed.length;\n  };\n\n  const generateMonthlyProgress = (_goals: EnhancedGoal[]) => {\n    // Simplified monthly progress calculation\n    return Array.from({ length: 6 }, (_, i) => ({\n      month: new Date(\n        Date.now() - i * 30 * 24 * 60 * 60 * 1000,\n      ).toLocaleDateString(\"en-US\", { month: \"short\" }),\n      goalsStarted: Math.floor(Math.random() * 5),\n      goalsCompleted: Math.floor(Math.random() * 3),\n      totalProgress: Math.floor(Math.random() * 100),\n    }));\n  };\n\n  const calculateStreaks = (_completed: EnhancedGoal[]) => {\n    return Object.values(GoalCategory).map((category) => ({\n      category,\n      currentStreak: Math.floor(Math.random() * 10),\n      longestStreak: Math.floor(Math.random() * 20),\n      lastGoalCompleted: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n    }));\n  };\n\n  const generateTimeline = (goals: EnhancedGoal[]) => {\n    return goals.map((goal) => ({\n      date: goal.estimatedCompletion,\n      goals: [goal.id],\n      milestones: goal.milestones.map((m) => m.id),\n      estimatedEffort: 4, // hours\n    }));\n  };\n\n  const detectConflicts = (_goals: EnhancedGoal[]) => {\n    // Simplified conflict detection\n    return [];\n  };\n\n  const generatePlanRecommendations = (_goals: EnhancedGoal[]) => {\n    return [\n      {\n        type: \"reorder\" as const,\n        description: \"Consider starting easier goals first to build momentum\",\n        impact: \"Improved success rate\",\n        effort: \"Low\",\n      },\n    ];\n  };\n\n  // Analytics functions using helpers\n  const getGoalInsightsCallback = useCallback(\n    (): GoalInsights => getGoalInsights(),\n    [],\n  );\n\n  const getPredictiveAnalyticsCallback = useCallback(\n    (): GoalPredictions => getPredictiveAnalyticsHelper(personalGoals),\n    [personalGoals],\n  );\n\n  const getCompletionTrendsCallback = useCallback(\n    (): CompletionTrends => getCompletionTrendsHelper(),\n    [],\n  );\n\n  return {\n    // Goal state\n    personalGoals,\n    collaborativeGoals,\n    recommendedGoals,\n    goalAnalytics,\n    goalTemplates,\n\n    // Goal management\n    createGoal: createGoalMutation.mutate,\n    updateGoal: updateGoalMutation.mutate,\n    deleteGoal: deleteGoalMutation.mutate,\n\n    // AI features\n    getSmartRecommendations: () => recommendedGoals,\n    generateGoalFromPrompt: generateGoalFromPromptMutation.mutate,\n    optimizeGoalPlan: optimizeGoalPlanMutation.mutate,\n\n    // Collaboration\n    shareGoal: shareGoalMutation.mutate,\n    inviteCollaborator: inviteCollaboratorMutation.mutate,\n    acceptCollaboration: async (inviteId: string) => {\n      logger.info(\"Collaboration accepted\", { inviteId });\n    },\n\n    // Analytics\n    getGoalInsights: getGoalInsightsCallback,\n    getPredictiveAnalytics: getPredictiveAnalyticsCallback,\n    getCompletionTrends: getCompletionTrendsCallback,\n\n    // Loading states\n    isCreating: createGoalMutation.isPending,\n    isUpdating: updateGoalMutation.isPending,\n    isDeleting: deleteGoalMutation.isPending,\n    isGenerating: generateGoalFromPromptMutation.isPending,\n    isOptimizing: optimizeGoalPlanMutation.isPending,\n\n    // Computed properties\n    activeGoalsCount: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    ).length,\n    completionRate: goalAnalytics ? goalAnalytics.completionRate : 0,\n    averageCompletionTime: goalAnalytics\n      ? goalAnalytics.averageCompletionTime\n      : 0,\n    hasCollaborativeGoals: collaborativeGoals.length > 0,\n    needsAttention: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.BEHIND,\n    ).length,\n\n    // Results\n    lastOptimization: optimizeGoalPlanMutation.data,\n    lastGeneratedGoal: generateGoalFromPromptMutation.data,\n\n    // Errors\n    error:\n      createGoalMutation.error ||\n      updateGoalMutation.error ||\n      deleteGoalMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useLogEventForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useManualEntry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/usePersonalGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useReporting.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (278). Maximum allowed is 150.",
        "line": 214,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 553,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useReporting Hook - Advanced Reporting & Analytics\n *\n * Comprehensive reporting system with custom reports, data visualization,\n * and export capabilities for detailed analysis.\n */\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { ReportStorageService } from \"../../services/reportStorage\";\n\n// Report types\nexport enum ReportType {\n  SUMMARY = \"summary\",\n  DETAILED = \"detailed\",\n  ANALYTICS = \"analytics\",\n  CUSTOM = \"custom\",\n}\n\n// Export formats\nexport enum ExportFormat {\n  JSON = \"json\",\n  CSV = \"csv\",\n  PDF = \"pdf\",\n  XLSX = \"xlsx\",\n}\n\n// Report template\nexport interface ReportTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: ReportType;\n  parameters: ReportParameter[];\n  defaultParameters: Record<string, string | number | boolean | Date>;\n}\n\n// Report parameter\nexport interface ReportParameter {\n  name: string;\n  type: \"string\" | \"number\" | \"date\" | \"boolean\" | \"select\";\n  required: boolean;\n  options?: string[];\n  default?: string | number | boolean | Date;\n}\n\n// Report parameters\nexport interface ReportParameters {\n  dateRange: {\n    start: Date;\n    end: Date;\n  };\n  includeDetails: boolean;\n  groupBy?: string;\n  filters: Record<string, string | number | boolean | Date>;\n}\n\n// Generated report\nexport interface GeneratedReport {\n  id: string;\n  templateId: string;\n  name: string;\n  parameters: ReportParameters;\n  data: Record<string, unknown> | unknown[];\n  generatedAt: Date;\n  generatedBy: string;\n  size: number;\n}\n\n// Custom report definition\nexport interface CustomReportDefinition {\n  name: string;\n  description: string;\n  dataSource: string;\n  fields: string[];\n  filters: ReportFilter[];\n  grouping?: string[];\n  sorting?: ReportSort[];\n}\n\n// Report filter\nexport interface ReportFilter {\n  field: string;\n  operator: \"equals\" | \"contains\" | \"greater\" | \"less\" | \"between\";\n  value: string | number | boolean | Date;\n}\n\n// Report sort\nexport interface ReportSort {\n  field: string;\n  direction: \"asc\" | \"desc\";\n}\n\n// Custom report\nexport interface CustomReport {\n  id: string;\n  definition: CustomReportDefinition;\n  createdAt: Date;\n  lastRun?: Date;\n}\n\n// Report schedule\nexport interface ReportSchedule {\n  frequency: \"daily\" | \"weekly\" | \"monthly\";\n  time: string;\n  recipients: string[];\n  format: ExportFormat;\n  enabled: boolean;\n}\n\n// Scheduled report\nexport interface ScheduledReport {\n  id: string;\n  reportId: string;\n  schedule: ReportSchedule;\n  nextRun: Date;\n  lastRun?: Date;\n}\n\n// Report export\nexport interface ReportExport {\n  id: string;\n  reportId: string;\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data export\nexport interface DataExport {\n  id: string;\n  dataType: string;\n  filters: DataFilter[];\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data filter\nexport interface DataFilter {\n  field: string;\n  value: string | number | boolean | Date;\n}\n\n// Reporting preferences\nexport interface ReportingPreferences {\n  defaultFormat: ExportFormat;\n  autoRefresh: boolean;\n  refreshInterval: number;\n  maxReports: number;\n}\n\n// Default templates\nconst DEFAULT_TEMPLATES: ReportTemplate[] = [\n  {\n    id: \"session-summary\",\n    name: \"Session Summary\",\n    description: \"Summary of chastity sessions over time\",\n    type: ReportType.SUMMARY,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"includeDetails\",\n        type: \"boolean\",\n        required: false,\n        default: false,\n      },\n    ],\n    defaultParameters: {\n      includeDetails: false,\n    },\n  },\n  {\n    id: \"achievement-progress\",\n    name: \"Achievement Progress\",\n    description: \"Progress on achievements and goals\",\n    type: ReportType.ANALYTICS,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"category\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"duration\", \"behavior\", \"goals\"],\n      },\n    ],\n    defaultParameters: {\n      category: \"all\",\n    },\n  },\n  {\n    id: \"behavioral-analysis\",\n    name: \"Behavioral Analysis\",\n    description: \"Analysis of behavioral patterns and events\",\n    type: ReportType.DETAILED,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"eventTypes\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"sessions\", \"events\", \"tasks\"],\n      },\n    ],\n    defaultParameters: {\n      eventTypes: \"all\",\n    },\n  },\n];\n\n/**\n * Advanced Reporting Hook\n */\nexport const useReporting = (userId?: string, _relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get available templates\n  const { data: availableReports = DEFAULT_TEMPLATES } = useQuery<\n    ReportTemplate[]\n  >({\n    queryKey: [\"reports\", \"templates\"],\n    queryFn: () => DEFAULT_TEMPLATES,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get custom reports\n  const { data: customReports = [] } = useQuery<CustomReport[]>({\n    queryKey: [\"reports\", \"custom\", userId],\n    queryFn: () => {\n      return ReportStorageService.getCustomReports<CustomReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get recent reports\n  const { data: recentReports = [] } = useQuery<GeneratedReport[]>({\n    queryKey: [\"reports\", \"recent\", userId],\n    queryFn: () => {\n      return ReportStorageService.getRecentReports<GeneratedReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get preferences\n  const { data: preferences } = useQuery<ReportingPreferences>({\n    queryKey: [\"reports\", \"preferences\", userId],\n    queryFn: () => {\n      const stored =\n        ReportStorageService.getPreferences<ReportingPreferences>();\n      return stored\n        ? stored\n        : {\n            defaultFormat: ExportFormat.JSON,\n            autoRefresh: false,\n            refreshInterval: 300000, // 5 minutes\n            maxReports: 50,\n          };\n    },\n    enabled: Boolean(userId),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Generate report mutation\n  const generateReportMutation = useMutation({\n    mutationFn: async ({\n      templateId,\n      parameters,\n    }: {\n      templateId: string;\n      parameters: ReportParameters;\n    }) => {\n      const template = availableReports.find((t) => t.id === templateId);\n      if (!template) throw new Error(\"Template not found\");\n\n      logger.info(\"Generating report\", { templateId, parameters });\n\n      // Simulate report generation\n      const reportData = await generateReportData(templateId, parameters);\n\n      const report: GeneratedReport = {\n        id: `report-${Date.now()}`,\n        templateId,\n        name: template.name,\n        parameters,\n        data: reportData,\n        generatedAt: new Date(),\n        generatedBy: userId || \"anonymous\",\n        size: JSON.stringify(reportData).length,\n      };\n\n      // Store in recent reports\n      const updated = [report, ...recentReports].slice(\n        0,\n        preferences?.maxReports || 50,\n      );\n      ReportStorageService.setRecentReports(updated);\n      queryClient.setQueryData([\"reports\", \"recent\", userId], updated);\n\n      return report;\n    },\n  });\n\n  // Create custom report mutation\n  const createCustomReportMutation = useMutation({\n    mutationFn: async (definition: CustomReportDefinition) => {\n      const customReport: CustomReport = {\n        id: `custom-${Date.now()}`,\n        definition,\n        createdAt: new Date(),\n      };\n\n      const updated = [...customReports, customReport];\n      ReportStorageService.setCustomReports(updated);\n      queryClient.setQueryData([\"reports\", \"custom\", userId], updated);\n\n      logger.info(\"Custom report created\", { reportId: customReport.id });\n      return customReport;\n    },\n  });\n\n  // Schedule report mutation\n  const scheduleReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      schedule,\n    }: {\n      reportId: string;\n      schedule: ReportSchedule;\n    }) => {\n      const scheduledReport: ScheduledReport = {\n        id: `schedule-${Date.now()}`,\n        reportId,\n        schedule,\n        nextRun: calculateNextRun(schedule),\n      };\n\n      logger.info(\"Report scheduled\", {\n        reportId,\n        schedule: scheduledReport.id,\n      });\n      return scheduledReport;\n    },\n  });\n\n  // Export report mutation\n  const exportReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      format,\n    }: {\n      reportId: string;\n      format: ExportFormat;\n    }) => {\n      const report = recentReports.find((r) => r.id === reportId);\n      if (!report) throw new Error(\"Report not found\");\n\n      const exportData = await exportReportData(report, format);\n\n      const exportResult: ReportExport = {\n        id: `export-${Date.now()}`,\n        reportId,\n        format,\n        url: exportData.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n      };\n\n      logger.info(\"Report exported\", {\n        reportId,\n        format,\n        exportId: exportResult.id,\n      });\n      return exportResult;\n    },\n  });\n\n  // Export raw data mutation\n  const exportRawDataMutation = useMutation({\n    mutationFn: async ({\n      dataType,\n      filters,\n      format,\n    }: {\n      dataType: string;\n      filters: DataFilter[];\n      format: ExportFormat;\n    }) => {\n      const rawData = await getRawData(dataType, filters);\n      const exportResult = await exportData(rawData, format);\n\n      const dataExport: DataExport = {\n        id: `data-export-${Date.now()}`,\n        dataType,\n        filters,\n        format,\n        url: exportResult.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\n      };\n\n      logger.info(\"Raw data exported\", {\n        dataType,\n        format,\n        exportId: dataExport.id,\n      });\n      return dataExport;\n    },\n  });\n\n  // Helper functions\n  const generateReportData = async (\n    templateId: string,\n    parameters: ReportParameters,\n  ) => {\n    // In a real implementation, this would query actual data\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    return {\n      summary: {\n        totalSessions: Math.floor(Math.random() * 100),\n        averageDuration: Math.floor(Math.random() * 72),\n        longestSession: Math.floor(Math.random() * 168),\n      },\n      details: parameters.includeDetails ? generateDetailedData() : null,\n      generatedAt: new Date().toISOString(),\n    };\n  };\n\n  const generateDetailedData = () => ({\n    sessions: Array.from({ length: 10 }, (_, i) => ({\n      id: i + 1,\n      startDate: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n      duration: Math.floor(Math.random() * 72),\n      events: Math.floor(Math.random() * 5),\n    })),\n  });\n\n  const calculateNextRun = (schedule: ReportSchedule): Date => {\n    const now = new Date();\n    const timeParts = schedule.time.split(\":\").map(Number);\n    const hours = timeParts[0] ?? 0;\n    const minutes = timeParts[1] ?? 0;\n\n    const nextRun = new Date(now);\n    nextRun.setHours(hours, minutes, 0, 0);\n\n    if (nextRun <= now) {\n      switch (schedule.frequency) {\n        case \"daily\":\n          nextRun.setDate(nextRun.getDate() + 1);\n          break;\n        case \"weekly\":\n          nextRun.setDate(nextRun.getDate() + 7);\n          break;\n        case \"monthly\":\n          nextRun.setMonth(nextRun.getMonth() + 1);\n          break;\n      }\n    }\n\n    return nextRun;\n  };\n\n  const exportReportData = async (\n    report: GeneratedReport,\n    format: ExportFormat,\n  ) => {\n    // Simulate export processing\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    const blob = new Blob([JSON.stringify(report.data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n\n    return { url };\n  };\n\n  const getRawData = async (dataType: string, filters: DataFilter[]) => {\n    // Simulate data retrieval\n    await new Promise((resolve) => setTimeout(resolve, 800));\n    return { dataType, filters, records: [] };\n  };\n\n  const exportData = async (\n    data: Record<string, unknown> | unknown[],\n    format: ExportFormat,\n  ) => {\n    const blob = new Blob([JSON.stringify(data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n    return { url };\n  };\n\n  const getContentType = (format: ExportFormat): string => {\n    switch (format) {\n      case ExportFormat.JSON:\n        return \"application/json\";\n      case ExportFormat.CSV:\n        return \"text/csv\";\n      case ExportFormat.PDF:\n        return \"application/pdf\";\n      case ExportFormat.XLSX:\n        return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      default:\n        return \"application/octet-stream\";\n    }\n  };\n\n  return {\n    // Available reports and templates\n    availableReports,\n    customReports,\n    recentReports,\n    preferences,\n\n    // Actions\n    generateReport: generateReportMutation.mutate,\n    createCustomReport: createCustomReportMutation.mutate,\n    scheduleReport: scheduleReportMutation.mutate,\n    exportReport: exportReportMutation.mutate,\n    exportRawData: exportRawDataMutation.mutate,\n\n    // Loading states\n    isGenerating: generateReportMutation.isPending,\n    isCreatingCustom: createCustomReportMutation.isPending,\n    isScheduling: scheduleReportMutation.isPending,\n    isExporting:\n      exportReportMutation.isPending || exportRawDataMutation.isPending,\n\n    // Results\n    lastGeneratedReport: generateReportMutation.data,\n    lastExport: exportReportMutation.data || exportRawDataMutation.data,\n\n    // Computed properties\n    totalReports: recentReports.length,\n    hasScheduledReports: false, // Would check actual scheduled reports\n    lastReportDate:\n      recentReports.length > 0 ? recentReports[0].generatedAt : null,\n    hasCustomReports: customReports.length > 0,\n\n    // Errors\n    error:\n      generateReportMutation.error ||\n      createCustomReportMutation.error ||\n      scheduleReportMutation.error ||\n      exportReportMutation.error ||\n      exportRawDataMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useRuleEditor.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useRuleEditor' has too many lines (172). Maximum allowed is 150.",
        "line": 75,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Rule Editor Hook\n *\n * Extracts rule management logic from RuleEditor component.\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface Rule {\n  id: string;\n  title: string;\n  description: string;\n  enabled: boolean;\n  conditions: Condition[];\n  actions: RuleAction[];\n}\n\nexport interface Condition {\n  type: string;\n  value: unknown;\n}\n\nexport interface RuleAction {\n  type: string;\n  value: unknown;\n}\n\nexport interface CreateRuleInput {\n  title: string;\n  description?: string;\n}\n\nexport interface UpdateRuleInput {\n  title?: string;\n  description?: string;\n  enabled?: boolean;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  message: string;\n}\n\nexport interface UseRuleEditorReturn {\n  rules: Rule[];\n  currentRule: Rule | null;\n  isLoading: boolean;\n  createRule: (rule: CreateRuleInput) => Promise<Rule>;\n  updateRule: (id: string, updates: UpdateRuleInput) => Promise<Rule>;\n  deleteRule: (id: string) => Promise<void>;\n  toggleRule: (id: string, enabled: boolean) => Promise<void>;\n  setCurrentRule: (rule: Rule | null) => void;\n  resetEditor: () => void;\n  validateRule: (rule: Rule) => ValidationResult;\n  isRuleValid: boolean;\n  validationErrors: string[];\n  testRule: (\n    rule: Rule,\n    testData: Record<string, unknown>,\n  ) => Promise<TestResult>;\n  isTesting: boolean;\n  addCondition: (condition: Condition) => void;\n  removeCondition: (index: number) => void;\n  updateCondition: (index: number, condition: Condition) => void;\n  addAction: (action: RuleAction) => void;\n  removeAction: (index: number) => void;\n  updateAction: (index: number, action: RuleAction) => void;\n}\n\nexport function useRuleEditor(): UseRuleEditorReturn {\n  const [rules, setRules] = useState<Rule[]>([]);\n  const [currentRule, setCurrentRule] = useState<Rule | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isTesting, setIsTesting] = useState(false);\n  const [validationErrors, setValidationErrors] = useState<string[]>([]);\n\n  const createRule = useCallback(\n    async (rule: CreateRuleInput): Promise<Rule> => {\n      const newRule: Rule = {\n        id: `rule-${Date.now()}`,\n        title: rule.title,\n        description: rule.description || \"\",\n        enabled: true,\n        conditions: [],\n        actions: [],\n      };\n      setRules((prev) => [...prev, newRule]);\n      return newRule;\n    },\n    [],\n  );\n\n  const updateRule = useCallback(\n    async (id: string, updates: UpdateRuleInput): Promise<Rule> => {\n      let updatedRule: Rule | null = null;\n      setRules((prev) =>\n        prev.map((r) => {\n          if (r.id === id) {\n            updatedRule = { ...r, ...updates };\n            return updatedRule;\n          }\n          return r;\n        }),\n      );\n      if (!updatedRule) throw new Error(\"Rule not found\");\n      return updatedRule;\n    },\n    [],\n  );\n\n  const deleteRule = useCallback(async (id: string): Promise<void> => {\n    setRules((prev) => prev.filter((r) => r.id !== id));\n  }, []);\n\n  const toggleRule = useCallback(\n    async (id: string, enabled: boolean): Promise<void> => {\n      await updateRule(id, { enabled });\n    },\n    [updateRule],\n  );\n\n  const resetEditor = useCallback(() => {\n    setCurrentRule(null);\n    setValidationErrors([]);\n  }, []);\n\n  const validateRule = useCallback((rule: Rule): ValidationResult => {\n    const errors: string[] = [];\n    if (!rule.title) errors.push(\"Title is required\");\n    if (rule.conditions.length === 0)\n      errors.push(\"At least one condition is required\");\n    if (rule.actions.length === 0)\n      errors.push(\"At least one action is required\");\n    setValidationErrors(errors);\n    return { valid: errors.length === 0, errors };\n  }, []);\n\n  const testRule = useCallback(\n    async (\n      _rule: Rule,\n      _testData: Record<string, unknown>,\n    ): Promise<TestResult> => {\n      setIsTesting(true);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        return { passed: true, message: \"Rule test passed\" };\n      } finally {\n        setIsTesting(false);\n      }\n    },\n    [],\n  );\n\n  const addCondition = useCallback(\n    (condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: [...currentRule.conditions, condition],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeCondition = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateCondition = useCallback(\n    (index: number, condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.map((c, i) =>\n            i === index ? condition : c,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const addAction = useCallback(\n    (action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: [...currentRule.actions, action],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeAction = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateAction = useCallback(\n    (index: number, action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.map((a, i) =>\n            i === index ? action : a,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    rules,\n    currentRule,\n    isLoading,\n    createRule,\n    updateRule,\n    deleteRule,\n    toggleRule,\n    setCurrentRule,\n    resetEditor,\n    validateRule,\n    isRuleValid: validationErrors.length === 0,\n    validationErrors,\n    testRule,\n    isTesting,\n    addCondition,\n    removeCondition,\n    updateCondition,\n    addAction,\n    removeAction,\n    updateAction,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/multi-wearer-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSystem.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (265). Maximum allowed is 150.",
        "line": 140,
        "column": 35,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 477,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'refreshData'. Either include it or remove the dependency array.",
        "line": 438,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 441,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]",
            "fix": {
              "range": [13081, 13185],
              "text": "[keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'endAdminSession'. Either include it or remove the dependency array.",
        "line": 451,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 451,
        "endColumn": 26,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [endAdminSession, state.adminSession]",
            "fix": { "range": [13570, 13590], "text": "[endAdminSession, state.adminSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useKeyholderSystem Hook\n * Unified management interface for all keyholder functionality\n * Acts as the primary entry point for keyholder operations\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { useAuthState } from \"../../contexts\";\nimport { useKeyholderRelationships } from \"../useKeyholderRelationships\";\nimport {\n  KeyholderRelationship,\n  KeyholderPermissions as _KeyholderPermissions,\n} from \"../../types/core\";\nimport { Task } from \"../../types\";\nimport { InviteCode } from \"../../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderSystem\");\n\n// ==================== TYPES ====================\n\nexport interface KeyholderStats {\n  totalSubmissives: number;\n  activeRelationships: number;\n  totalSessions: number;\n  averageSessionDuration: number;\n  totalRewardsGiven: number;\n  totalPunishmentsGiven: number;\n  lastActivity: Date | null;\n}\n\nexport interface KeyholderStatus {\n  isActiveKeyholder: boolean;\n  hasPermissions: boolean;\n  canCreateInvites: boolean;\n  maxRelationships: number;\n  currentRelationships: number;\n}\n\nexport interface AdminSession {\n  id: string;\n  keyholderId: string;\n  relationshipId: string;\n  startTime: Date;\n  expiresAt: Date;\n  permissions: string[];\n  isActive: boolean;\n  lastActivity: Date;\n}\n\nexport interface KeyholderSystemState {\n  // Active relationships where user is keyholder\n  activeRelationships: KeyholderRelationship[];\n  // Current admin session if active\n  adminSession: AdminSession | null;\n  // Overall keyholder status and permissions\n  keyholderStatus: KeyholderStatus;\n  // Quick stats for dashboard\n  stats: KeyholderStats;\n  // Currently selected relationship for operations\n  selectedRelationship: KeyholderRelationship | null;\n  // Loading states\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n}\n\nexport interface InviteOptions {\n  expirationHours?: number;\n  maxUses?: number;\n  customNote?: string;\n}\n\nexport interface BulkOperations {\n  startSessions: (\n    relationshipIds: string[],\n    options?: { duration?: number; message?: string },\n  ) => Promise<void>;\n  stopSessions: (relationshipIds: string[], reason?: string) => Promise<void>;\n  sendMessages: (relationshipIds: string[], message: string) => Promise<void>;\n  assignTasks: (\n    relationshipIds: string[],\n    task: Omit<Task, \"id\" | \"createdAt\">,\n  ) => Promise<void>;\n}\n\nexport interface KeyholderSystemActions {\n  // Relationship management\n  createInviteCode: (options?: InviteOptions) => Promise<string | null>;\n  acceptSubmissive: (\n    inviteCode: string,\n  ) => Promise<KeyholderRelationship | null>;\n  removeSubmissive: (relationshipId: string) => Promise<void>;\n\n  // Session management\n  startAdminSession: (relationshipId: string) => Promise<AdminSession | null>;\n  endAdminSession: () => Promise<void>;\n\n  // Multi-user operations\n  switchActiveRelationship: (relationshipId: string) => void;\n  getBulkOperations: () => BulkOperations;\n\n  // Data management\n  refreshData: () => Promise<void>;\n  resetError: () => void;\n}\n\n// ==================== INITIAL STATE ====================\n\nconst initialKeyholderStatus: KeyholderStatus = {\n  isActiveKeyholder: false,\n  hasPermissions: false,\n  canCreateInvites: false,\n  maxRelationships: 5, // Default limit\n  currentRelationships: 0,\n};\n\nconst initialStats: KeyholderStats = {\n  totalSubmissives: 0,\n  activeRelationships: 0,\n  totalSessions: 0,\n  averageSessionDuration: 0,\n  totalRewardsGiven: 0,\n  totalPunishmentsGiven: 0,\n  lastActivity: null,\n};\n\nconst initialState: KeyholderSystemState = {\n  activeRelationships: [],\n  adminSession: null,\n  keyholderStatus: initialKeyholderStatus,\n  stats: initialStats,\n  selectedRelationship: null,\n  isLoading: false,\n  isInitialized: false,\n  error: null,\n};\n\n// ==================== MAIN HOOK ====================\n\nexport const useKeyholderSystem = (keyholderId?: string) => {\n  const { user } = useAuthState();\n  const keyholderRelationships = useKeyholderRelationships();\n\n  // Use provided keyholderId or fall back to current user\n  const effectiveKeyholderId = keyholderId || user?.uid;\n\n  const [state, setState] = useState<KeyholderSystemState>(initialState);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const computedValues = useMemo(() => {\n    const { activeRelationships, adminSession, keyholderStatus } = state;\n\n    return {\n      hasActiveRelationships: activeRelationships.length > 0,\n      canStartAdminSession: adminSession === null,\n      activeRelationshipCount: activeRelationships.length,\n      hasMaxRelationships:\n        keyholderStatus.currentRelationships >=\n        keyholderStatus.maxRelationships,\n      selectedRelationshipId: state.selectedRelationship?.id || null,\n    };\n  }, [state]);\n\n  // ==================== ACTIONS ====================\n\n  const refreshData = useCallback(async () => {\n    if (!effectiveKeyholderId) return;\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      logger.debug(\"Refreshing keyholder system data\", {\n        keyholderId: effectiveKeyholderId,\n      });\n\n      // Get relationships from the existing hook\n      await keyholderRelationships.loadRelationships();\n\n      const keyholderRelationshipsList =\n        keyholderRelationships.relationships.asKeyholder;\n\n      // Calculate keyholder status and stats\n      const { keyholderStatus, stats } = calculateKeyholderStatusAndStats(\n        keyholderRelationshipsList,\n        keyholderRelationships,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        activeRelationships: keyholderRelationshipsList,\n        keyholderStatus,\n        stats,\n        isLoading: false,\n        isInitialized: true,\n      }));\n\n      logger.info(\"Keyholder system data refreshed\", {\n        relationshipCount: keyholderRelationshipsList.length,\n        activeCount: stats.activeRelationships,\n      });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : \"Failed to refresh keyholder data\";\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      logger.error(\"Failed to refresh keyholder system data\", {\n        error: error as Error,\n      });\n    }\n  }, [effectiveKeyholderId, keyholderRelationships]);\n\n  const createInviteCode = useCallback(\n    async (options: InviteOptions = {}): Promise<string | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Creating invite code\", {\n          keyholderId: effectiveKeyholderId,\n          options,\n        });\n\n        const inviteCode = await keyholderRelationships.createInviteCode(\n          options.expirationHours,\n        );\n\n        return await handleInviteCodeCreation(inviteCode, refreshData);\n      } catch (error) {\n        return handleInviteCodeError(error, setState);\n      }\n    },\n    [effectiveKeyholderId, keyholderRelationships, refreshData],\n  );\n\n  const acceptSubmissive = useCallback(\n    async (inviteCode: string): Promise<KeyholderRelationship | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Accepting submissive\", {\n          keyholderId: effectiveKeyholderId,\n          inviteCode,\n        });\n\n        const success =\n          await keyholderRelationships.acceptInviteCode(inviteCode);\n\n        return await handleSubmissiveAcceptance(\n          success,\n          refreshData,\n          state.activeRelationships,\n        );\n      } catch (error) {\n        return handleSubmissiveAcceptanceError(error, setState);\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.activeRelationships,\n    ],\n  );\n\n  const removeSubmissive = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      if (!effectiveKeyholderId) return;\n\n      try {\n        logger.debug(\"Removing submissive\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        await keyholderRelationships.endRelationship(relationshipId);\n\n        // Refresh data to update state\n        await refreshData();\n\n        // Clear selected relationship if it was the removed one\n        if (state.selectedRelationship?.id === relationshipId) {\n          setState((prev) => ({ ...prev, selectedRelationship: null }));\n        }\n      } catch (error) {\n        logger.error(\"Failed to remove submissive\", { error: error as Error });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to remove submissive\",\n        }));\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.selectedRelationship,\n    ],\n  );\n\n  const switchActiveRelationship = useCallback(\n    (relationshipId: string) => {\n      const relationship = state.activeRelationships.find(\n        (rel) => rel.id === relationshipId,\n      );\n      if (relationship) {\n        setState((prev) => ({ ...prev, selectedRelationship: relationship }));\n        logger.debug(\"Switched active relationship\", { relationshipId });\n      }\n    },\n    [state.activeRelationships],\n  );\n\n  // Admin session management (placeholder implementation)\n  const startAdminSession = useCallback(\n    async (relationshipId: string): Promise<AdminSession | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Starting admin session\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        // TODO: Implement actual admin session creation\n        const adminSession: AdminSession = {\n          id: `admin_${Date.now()}`,\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n          startTime: new Date(),\n          expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes\n          permissions: [\"session_control\", \"task_management\", \"rewards\"], // Default permissions\n          isActive: true,\n          lastActivity: new Date(),\n        };\n\n        setState((prev) => ({ ...prev, adminSession }));\n\n        logger.info(\"Admin session started\", { sessionId: adminSession.id });\n        return adminSession;\n      } catch (error) {\n        logger.error(\"Failed to start admin session\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to start admin session\",\n        }));\n        return null;\n      }\n    },\n    [effectiveKeyholderId],\n  );\n\n  const endAdminSession = useCallback(async (): Promise<void> => {\n    if (!state.adminSession) return;\n\n    try {\n      logger.debug(\"Ending admin session\", {\n        sessionId: state.adminSession.id,\n      });\n\n      // TODO: Implement actual admin session cleanup\n      setState((prev) => ({ ...prev, adminSession: null }));\n\n      logger.info(\"Admin session ended\");\n    } catch (error) {\n      logger.error(\"Failed to end admin session\", { error: error as Error });\n      setState((prev) => ({\n        ...prev,\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to end admin session\",\n      }));\n    }\n  }, [state.adminSession]);\n\n  const getBulkOperations = useCallback((): BulkOperations => {\n    return {\n      startSessions: async (\n        relationshipIds: string[],\n        options?: { duration?: number; message?: string },\n      ) => {\n        logger.debug(\"Bulk starting sessions\", { relationshipIds, options });\n        // TODO: Implement bulk session start\n      },\n      stopSessions: async (relationshipIds: string[], reason?: string) => {\n        logger.debug(\"Bulk stopping sessions\", { relationshipIds, reason });\n        // TODO: Implement bulk session stop\n      },\n      sendMessages: async (relationshipIds: string[], message: string) => {\n        logger.debug(\"Bulk sending messages\", { relationshipIds, message });\n        // TODO: Implement bulk messaging\n      },\n      assignTasks: async (\n        relationshipIds: string[],\n        task: Omit<Task, \"id\" | \"createdAt\">,\n      ) => {\n        logger.debug(\"Bulk assigning tasks\", { relationshipIds, task });\n        // TODO: Implement bulk task assignment\n      },\n    };\n  }, []);\n\n  const resetError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  // ==================== EFFECTS ====================\n\n  // Initialize data when user changes\n  useEffect(() => {\n    if (effectiveKeyholderId && !state.isInitialized) {\n      refreshData();\n    }\n  }, [effectiveKeyholderId, state.isInitialized, refreshData]);\n\n  // Auto-refresh when relationships data changes\n  useEffect(() => {\n    if (\n      keyholderRelationships.relationships.asKeyholder.length !==\n      state.activeRelationships.length\n    ) {\n      refreshData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    keyholderRelationships.relationships.asKeyholder.length,\n    state.activeRelationships.length,\n  ]);\n\n  // Admin session auto-expiry\n  useEffect(() => {\n    if (state.adminSession && state.adminSession.expiresAt < new Date()) {\n      logger.info(\"Admin session expired, ending session\");\n      endAdminSession();\n    }\n    // endAdminSession is stable as it only depends on state.adminSession which is already in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [state.adminSession]);\n\n  // ==================== RETURN ====================\n\n  const actions: KeyholderSystemActions = {\n    createInviteCode,\n    acceptSubmissive,\n    removeSubmissive,\n    startAdminSession,\n    endAdminSession,\n    switchActiveRelationship,\n    getBulkOperations,\n    refreshData,\n    resetError,\n  };\n\n  return {\n    // State\n    ...state,\n\n    // Computed\n    ...computedValues,\n\n    // Actions\n    ...actions,\n  };\n};\n\nexport type UseKeyholderSystemReturn = ReturnType<typeof useKeyholderSystem>;\n\n// Helper functions for useKeyholderSystem\nfunction calculateKeyholderStatusAndStats(\n  keyholderRelationshipsList: KeyholderRelationship[],\n  keyholderRelationships: Record<string, unknown>,\n): { keyholderStatus: KeyholderStatus; stats: KeyholderStats } {\n  // Calculate keyholder status\n  const keyholderStatus: KeyholderStatus = {\n    isActiveKeyholder: keyholderRelationshipsList.length > 0,\n    hasPermissions: keyholderRelationshipsList.some(\n      (rel) =>\n        rel.permissions && Object.values(rel.permissions).some((perm) => perm),\n    ),\n    canCreateInvites: keyholderRelationships.canCreateInviteCode\n      ? keyholderRelationships.canCreateInviteCode()\n      : false,\n    maxRelationships: 5, // Could be user-specific in the future\n    currentRelationships: keyholderRelationshipsList.length,\n  };\n\n  // Calculate basic stats\n  const stats: KeyholderStats = {\n    totalSubmissives: keyholderRelationshipsList.length,\n    activeRelationships: keyholderRelationshipsList.filter(\n      (rel) => rel.status === \"active\",\n    ).length,\n    totalSessions: 0, // TODO: Calculate from session data\n    averageSessionDuration: 0, // TODO: Calculate from session data\n    totalRewardsGiven: 0, // TODO: Calculate from reward data\n    totalPunishmentsGiven: 0, // TODO: Calculate from punishment data\n    lastActivity: null, // TODO: Calculate from activity data\n  };\n\n  return { keyholderStatus, stats };\n}\n\nasync function handleInviteCodeCreation(\n  inviteCode: InviteCode | null,\n  refreshData: () => Promise<void>,\n): Promise<string | null> {\n  if (inviteCode) {\n    // Refresh data to update state\n    await refreshData();\n    return inviteCode.code;\n  }\n  return null;\n}\n\nfunction handleInviteCodeError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to create invite code\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to create invite code\",\n  }));\n  return null;\n}\n\nasync function handleSubmissiveAcceptance(\n  success: boolean,\n  refreshData: () => Promise<void>,\n  activeRelationships: KeyholderRelationship[],\n): Promise<KeyholderRelationship | null> {\n  if (success) {\n    // Refresh data to get the new relationship\n    await refreshData();\n\n    // Return the newest relationship (should be the one just created)\n    const newestRelationship = activeRelationships.sort(\n      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),\n    )[0];\n\n    return newestRelationship || null;\n  }\n  return null;\n}\n\nfunction handleSubmissiveAcceptanceError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to accept submissive\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to accept submissive\",\n  }));\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useMultiWearer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useSessionControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useHapticFeedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/usePullToRefresh.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useTouchGestures.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useViewport.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'updateSafeAreaInsets' and 'updateViewport'. Either include them or remove the dependency array.",
        "line": 124,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 124,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [updateSafeAreaInsets, updateViewport]",
            "fix": { "range": [3158, 3160], "text": "[updateSafeAreaInsets, updateViewport]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/profile-achievements-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileAchievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfilePrivacy.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileSharing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/usePublicProfile.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/notification-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/notification-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/presence-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/presence-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/realtime-sync-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/realtime-sync-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useLiveTimerComposed.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerControl.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (201). Maximum allowed is 150.",
        "line": 30,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 256,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerSubscriptions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer/useTimerSync.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'updateIntervalRef' and 'updateTimerProgress'. Either include them or remove the dependency array.",
        "line": 134,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 134,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncInterval, updateIntervalRef, updateTimerProgress]",
            "fix": {
              "range": [3892, 3906],
              "text": "[syncInterval, updateIntervalRef, updateTimerProgress]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'syncActiveTimers' and 'syncIntervalRef'. Either include them or remove the dependency array.",
        "line": 148,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 148,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncActiveTimers, syncInterval, syncIntervalRef]",
            "fix": {
              "range": [4337, 4351],
              "text": "[syncActiveTimers, syncInterval, syncIntervalRef]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useNotifications.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/usePresence.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'activityTimeoutRef', 'lastActivityRef', and 'setAway'. Either include them or remove the dependency array.",
        "line": 101,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 101,
        "endColumn": 58,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]",
            "fix": {
              "range": [2580, 2632],
              "text": "[autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setAway', 'setOffline', and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 167,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 167,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setAway, setOffline, setOnline]",
            "fix": { "range": [4547, 4549], "text": "[setAway, setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setOffline' and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 184,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 184,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setOffline, setOnline]",
            "fix": { "range": [5024, 5026], "text": "[setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useRealtimeSync-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useRealtimeSync.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (245). Maximum allowed is 150.",
        "line": 40,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 360,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 40,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 360,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'stopHeartbeat'. Either include it or remove the dependency array.",
        "line": 86,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 86,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [stopHeartbeat]",
            "fix": { "range": [2496, 2498], "text": "[stopHeartbeat]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sendMessage'. Either include it or remove the dependency array.",
        "line": 122,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 122,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [heartbeatInterval, sendMessage]",
            "fix": { "range": [3578, 3597], "text": "[heartbeatInterval, sendMessage]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'handleChannelJoined', 'handleChannelLeft', and 'handleRealtimeUpdate'. Either include them or remove the dependency array.",
        "line": 175,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 175,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]",
            "fix": {
              "range": [5028, 5030],
              "text": "[handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'syncState.activeChannels'. Either include it or remove the dependency array.",
        "line": 242,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 250,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, startHeartbeat, stopHeartbeat, attemptReconnect, sendMessage, handleMessage, syncState.activeChannels, maxReconnectAttempts]",
            "fix": {
              "range": [6855, 6995],
              "text": "[userId, startHeartbeat, stopHeartbeat, attemptReconnect, sendMessage, handleMessage, syncState.activeChannels, maxReconnectAttempts]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/relationship-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/task-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipEventOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipInvites.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 91,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 91,
        "endColumn": 34,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipList.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadRelationships'. Either include it or remove the dependency array.",
        "line": 82,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 82,
        "endColumn": 14,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadRelationships, userId]",
            "fix": { "range": [2493, 2501], "text": "[loadRelationships, userId]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipPermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTaskOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useAuditLog.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/usePermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useSecuritySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/session-goals-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/PauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/SessionGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useCooldownState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalComputedValues.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalInitialization.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievements', 'loadActiveGoals', 'loadGoalHistory', 'loadGoalTemplates', 'loadKeyholderGoals', and 'loadProgress'. Either include them or remove the dependency array. If 'loadActiveGoals' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 69,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 69,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]",
            "fix": {
              "range": [1881, 1905],
              "text": "[userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updateActiveGoalProgress'. Either include it or remove the dependency array. If 'updateActiveGoalProgress' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 79,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 79,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [updateActiveGoalProgress]",
            "fix": { "range": [2212, 2214], "text": "[updateActiveGoalProgress]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalMutations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalProgress.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useGoalTemplates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useKeyholderGoalManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseDurationTracking.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updatePauseDuration'. Either include it or remove the dependency array. If 'updatePauseDuration' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 27,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 27,
        "endColumn": 56,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]",
            "fix": {
              "range": [808, 858],
              "text": "[pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseResume.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (177). Maximum allowed is 150.",
        "line": 36,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 241,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useCallback, useEffect, useRef } from \"react\";\nimport { doc, setDoc } from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\n\n/**\n * @typedef {Object} PauseEvent\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {string} reason\n * @property {number} [duration]\n */\n\n/**\n * @typedef {Object} PauseResumeState\n * @property {boolean} isPaused\n * @property {Date|null} pauseStartTime\n * @property {number} totalPauseTime\n * @property {PauseEvent[]} pauseEvents\n * @property {Date|null} cooldownEndTime\n */\n\n/**\n * @typedef {Object} PauseResumeOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {boolean} sessionActive\n * @property {Function} [onStateChange]\n */\n\n/**\n * Hook for managing session pause/resume functionality\n * @param {PauseResumeOptions} options\n * @returns {Object}\n */\nexport const usePauseResume = ({\n  userId,\n  isAuthReady,\n  sessionActive,\n  onStateChange,\n}) => {\n  const [pauseState, setPauseState] = useState({\n    isPaused: false,\n    pauseStartTime: null,\n    totalPauseTime: 0,\n    pauseEvents: [],\n    cooldownEndTime: null,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const pauseTimerRef = useRef(null);\n  const cooldownTimerRef = useRef(null);\n\n  const saveStateToFirestore = useCallback(\n    async (newState) => {\n      if (!userId || !isAuthReady) {\n        return;\n      }\n\n      try {\n        const userDocRef = doc(db, \"users\", userId);\n        await setDoc(\n          userDocRef,\n          { pauseResumeState: newState },\n          { merge: true },\n        );\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to save pause state\",\n        );\n      }\n    },\n    [userId, isAuthReady],\n  );\n\n  const pauseSession = useCallback(\n    async (reason = \"Manual pause\") => {\n      if (!sessionActive || pauseState.isPaused) {\n        setError(\"Cannot pause: session not active or already paused\");\n        return;\n      }\n\n      // Check cooldown\n      if (\n        pauseState.cooldownEndTime &&\n        new Date() < pauseState.cooldownEndTime\n      ) {\n        const remainingTime = Math.ceil(\n          (pauseState.cooldownEndTime.getTime() - new Date().getTime()) / 1000,\n        );\n        setError(\n          `Pause is on cooldown. Try again in ${remainingTime} seconds.`,\n        );\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const pauseStartTime = new Date();\n        const newPauseEvent = {\n          id: crypto.randomUUID(),\n          startTime: pauseStartTime,\n          reason,\n        };\n\n        const newState = {\n          ...pauseState,\n          isPaused: true,\n          pauseStartTime,\n          pauseEvents: [...pauseState.pauseEvents, newPauseEvent],\n        };\n\n        setPauseState(newState);\n        await saveStateToFirestore(newState);\n        if (onStateChange) onStateChange(newState);\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to pause session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [sessionActive, pauseState, saveStateToFirestore, onStateChange],\n  );\n\n  const resumeSession = useCallback(async () => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      setError(\"Cannot resume: session not paused\");\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const resumeTime = new Date();\n      const pauseDuration = Math.floor(\n        (resumeTime.getTime() - pauseState.pauseStartTime.getTime()) / 1000,\n      );\n\n      // Update the last pause event with end time and duration\n      const updatedPauseEvents = [...pauseState.pauseEvents];\n      const lastEventIndex = updatedPauseEvents.length - 1;\n      if (lastEventIndex >= 0) {\n        updatedPauseEvents[lastEventIndex] = {\n          ...updatedPauseEvents[lastEventIndex],\n          endTime: resumeTime,\n          duration: pauseDuration,\n        };\n      }\n\n      // Set cooldown (12 hours from now)\n      const cooldownEndTime = new Date(\n        resumeTime.getTime() + 12 * 60 * 60 * 1000,\n      );\n\n      const newState = {\n        ...pauseState,\n        isPaused: false,\n        pauseStartTime: null,\n        totalPauseTime: pauseState.totalPauseTime + pauseDuration,\n        pauseEvents: updatedPauseEvents,\n        cooldownEndTime,\n      };\n\n      setPauseState(newState);\n      await saveStateToFirestore(newState);\n      if (onStateChange) onStateChange(newState);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to resume session\");\n    } finally {\n      setIsLoading(false);\n    }\n  }, [pauseState, saveStateToFirestore, onStateChange]);\n\n  const getCurrentPauseDuration = useCallback(() => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      return 0;\n    }\n    return Math.floor(\n      (new Date().getTime() - pauseState.pauseStartTime.getTime()) / 1000,\n    );\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Timer to update current pause duration\n  useEffect(() => {\n    if (pauseState.isPaused && pauseState.pauseStartTime) {\n      pauseTimerRef.current = setInterval(() => {\n        // Force re-render to update current pause duration in UI\n        setPauseState((prev) => ({ ...prev }));\n      }, 1000);\n    } else {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n        pauseTimerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n      }\n    };\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Cooldown timer\n  useEffect(() => {\n    if (pauseState.cooldownEndTime && pauseState.cooldownEndTime > new Date()) {\n      const timeUntilCooldownEnd =\n        pauseState.cooldownEndTime.getTime() - new Date().getTime();\n\n      cooldownTimerRef.current = setTimeout(() => {\n        setPauseState((prev) => ({ ...prev, cooldownEndTime: null }));\n      }, timeUntilCooldownEnd);\n    }\n\n    return () => {\n      if (cooldownTimerRef.current) {\n        clearTimeout(cooldownTimerRef.current);\n      }\n    };\n  }, [pauseState.cooldownEndTime]);\n\n  return {\n    pauseState,\n    isLoading,\n    error,\n    pauseSession,\n    resumeSession,\n    getCurrentPauseDuration,\n    canPause:\n      sessionActive &&\n      !pauseState.isPaused &&\n      (!pauseState.cooldownEndTime || new Date() >= pauseState.cooldownEndTime),\n    canResume: pauseState.isPaused,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseResume.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (298). Maximum allowed is 150.",
        "line": 60,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 430,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 60,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 430,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sessionId'. Either include it or remove the dependency array.",
        "line": 139,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 139,
        "endColumn": 61,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]",
            "fix": {
              "range": [4297, 4352],
              "text": "[keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeKeyholderOverrides', 'loadCooldownState', 'loadPauseAnalytics', 'loadPauseHistory', and 'loadPauseState'. Either include them or remove the dependency array.",
        "line": 184,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 184,
        "endColumn": 33,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]",
            "fix": {
              "range": [5518, 5545],
              "text": "[sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Pause/Resume System Hook (Refactored)\n * Provides advanced pause/resume functionality with keyholder overrides,\n * intelligent cooldown management, and comprehensive analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { PauseCooldownService } from \"../../services/PauseCooldownService\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type {\n  PauseStatus as _PauseStatus,\n  CooldownState as _CooldownState,\n  KeyholderOverrideCapabilities,\n  PauseHistoryEntry as _PauseHistoryEntry,\n  PauseAnalytics,\n  PauseReason,\n  PauseRequestStatus,\n  OverrideRequestStatus,\n  PausePattern,\n  CooldownAnalytics,\n} from \"../../types/pauseResume\";\nimport {\n  calculatePauseFrequency,\n  calculateCooldownDuration,\n  calculatePauseAnalytics,\n  analyzePausePatterns,\n  calculateCooldownEffectiveness,\n} from \"../../utils/pauseAnalytics\";\nimport {\n  calculatePauseDuration,\n  updatePauseHistoryOnResume,\n  updatePauseStatusOnResume,\n  createKeyholderOverrides,\n} from \"../../utils/pauseResumeHelpers\";\nimport { usePauseState } from \"./usePauseState\";\nimport { useCooldownState } from \"./useCooldownState\";\nimport { usePauseDurationTracking } from \"./usePauseDurationTracking\";\n\nconst logger = serviceLogger(\"usePauseResume\");\n\nconst createInitialKeyholderOverrides = (): KeyholderOverrideCapabilities => ({\n  canOverrideCooldown: false,\n  canForcePause: false,\n  canForceResume: false,\n  canModifyCooldownDuration: false,\n  requiresReason: true,\n});\n\nconst createInitialPauseAnalytics = (): PauseAnalytics => ({\n  totalPauses: 0,\n  averagePauseDuration: 0,\n  pauseFrequency: 0,\n  emergencyPauseCount: 0,\n  keyholderInitiatedCount: 0,\n  cooldownViolations: 0,\n  patterns: [],\n});\n\n// Complex pause/resume logic with cooldown management and analytics\n// eslint-disable-next-line max-statements\nexport const usePauseResume = (sessionId: string, relationshipId?: string) => {\n  // Use sub-hooks for state management\n  const {\n    pauseStatus,\n    pauseHistory,\n    setPauseStatus,\n    setPauseHistory,\n    startPause,\n    updatePauseDuration,\n  } = usePauseState(sessionId);\n\n  const { cooldownState, startCooldown, clearCooldown } = useCooldownState();\n\n  const [keyholderOverrides, setKeyholderOverrides] = useState(\n    createInitialKeyholderOverrides,\n  );\n  const [pauseAnalytics, setPauseAnalytics] = useState(\n    createInitialPauseAnalytics,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track pause duration\n  usePauseDurationTracking(pauseStatus, updatePauseDuration);\n\n  // Computed values\n  const canPause = useMemo(\n    () => !pauseStatus.isPaused && !cooldownState.isInCooldown,\n    [pauseStatus.isPaused, cooldownState.isInCooldown],\n  );\n\n  const canResume = useMemo(() => pauseStatus.isPaused, [pauseStatus.isPaused]);\n\n  const timeUntilNextPause = useMemo(() => {\n    if (!cooldownState.nextPauseAvailable) return 0;\n    return Math.max(\n      0,\n      Math.floor(\n        (cooldownState.nextPauseAvailable.getTime() - Date.now()) / 1000,\n      ),\n    );\n  }, [cooldownState.nextPauseAvailable]);\n\n  const hasKeyholderOverride = useMemo(\n    () => keyholderOverrides.canOverrideCooldown,\n    [keyholderOverrides.canOverrideCooldown],\n  );\n\n  const pauseFrequency = useMemo(\n    () => calculatePauseFrequency(pauseHistory),\n    [pauseHistory],\n  );\n\n  // Initialize keyholder overrides\n  const initializeKeyholderOverrides = useCallback(() => {\n    if (relationshipId) {\n      setKeyholderOverrides(createKeyholderOverrides());\n    }\n  }, [relationshipId]);\n\n  // Load data functions\n  const loadPauseState = useCallback(async () => {\n    // Integration with pause state service\n  }, []);\n\n  const loadCooldownState = useCallback(async () => {\n    try {\n      const cooldownInfo = await PauseCooldownService.canUserPause(sessionId);\n      if (cooldownInfo && !cooldownInfo.canPause) {\n        startCooldown(\n          cooldownInfo.cooldownRemaining || 0,\n          keyholderOverrides.canOverrideCooldown,\n        );\n      }\n    } catch (err) {\n      logger.error(\"Failed to load cooldown state\", { error: err });\n    }\n    // sessionId is a stable prop from the component, safe to omit from deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [keyholderOverrides.canOverrideCooldown, startCooldown]);\n\n  const loadPauseHistory = useCallback(async () => {\n    // Load pause history from service\n  }, []);\n\n  const loadPauseAnalytics = useCallback(async () => {\n    try {\n      const analytics = calculatePauseAnalytics(pauseHistory);\n      setPauseAnalytics(analytics);\n    } catch (err) {\n      logger.error(\"Failed to load pause analytics\", { error: err });\n    }\n  }, [pauseHistory]);\n\n  // Initialization\n  useEffect(() => {\n    const initializePauseSystem = async () => {\n      if (!sessionId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        initializeKeyholderOverrides();\n        await Promise.all([\n          loadPauseState(),\n          loadCooldownState(),\n          loadPauseHistory(),\n          loadPauseAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize pause system\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize pause system\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializePauseSystem();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId, relationshipId]);\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason: PauseReason): Promise<void> => {\n      if (!canPause) {\n        throw new Error(\"Cannot pause: either already paused or in cooldown\");\n      }\n\n      try {\n        logger.debug(\"Pausing session\", { sessionId, reason });\n        startPause(reason);\n        logger.info(\"Session paused successfully\", { sessionId, reason });\n      } catch (err) {\n        logger.error(\"Failed to pause session\", { error: err });\n        throw err;\n      }\n    },\n    [canPause, sessionId, startPause],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    if (!canResume) {\n      throw new Error(\"Cannot resume: session is not paused\");\n    }\n\n    try {\n      logger.debug(\"Resuming session\", { sessionId });\n\n      const resumeTime = new Date();\n      const duration = calculatePauseDuration(\n        pauseStatus.pauseStartTime,\n        resumeTime,\n      );\n\n      setPauseStatus(updatePauseStatusOnResume(pauseStatus));\n      setPauseHistory((prev) =>\n        updatePauseHistoryOnResume(prev, resumeTime, duration),\n      );\n\n      const cooldownDur = calculateCooldownDuration(pauseAnalytics, duration);\n      startCooldown(cooldownDur, keyholderOverrides.canOverrideCooldown);\n\n      logger.info(\"Session resumed successfully\", {\n        sessionId,\n        pauseDuration: duration,\n      });\n    } catch (err) {\n      logger.error(\"Failed to resume session\", { error: err });\n      throw err;\n    }\n  }, [\n    canResume,\n    sessionId,\n    pauseStatus,\n    pauseAnalytics,\n    keyholderOverrides.canOverrideCooldown,\n    setPauseStatus,\n    setPauseHistory,\n    startCooldown,\n  ]);\n\n  // Emergency pause\n  const requestEmergencyPause = useCallback(\n    async (reason: string): Promise<PauseRequestStatus> => {\n      try {\n        logger.debug(\"Requesting emergency pause\", { sessionId, reason });\n\n        if (cooldownState.isInCooldown) {\n          logger.warn(\"Emergency pause bypassing cooldown\", { sessionId });\n        }\n\n        await pauseSession(\"emergency\");\n\n        return {\n          approved: true,\n          reason: \"Emergency pause approved automatically\",\n          requestId: `emergency_${Date.now()}`,\n          approvedBy: \"emergency_protocol\",\n          approvedAt: new Date(),\n        };\n      } catch (err) {\n        logger.error(\"Failed to request emergency pause\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `emergency_${Date.now()}`,\n        };\n      }\n    },\n    [sessionId, cooldownState.isInCooldown, pauseSession],\n  );\n\n  // Request cooldown override\n  const requestCooldownOverride = useCallback(\n    async (justification: string): Promise<OverrideRequestStatus> => {\n      if (!relationshipId) {\n        return {\n          approved: false,\n          reason: \"Cooldown override requires keyholder relationship\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n\n      try {\n        logger.debug(\"Requesting cooldown override\", {\n          sessionId,\n          justification,\n        });\n\n        return {\n          approved: false,\n          reason: \"Override request sent to keyholder\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      } catch (err) {\n        logger.error(\"Failed to request cooldown override\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n    },\n    [sessionId, relationshipId],\n  );\n\n  // Keyholder force pause\n  const keyholderForcePause = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForcePause) {\n        throw new Error(\"Keyholder does not have force pause permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing pause\", { sessionId, reason });\n        startPause(\"keyholder_request\", \"keyholder\");\n        logger.info(\"Keyholder force pause successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force pause\", { error: err });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForcePause, sessionId, startPause],\n  );\n\n  // Keyholder force resume\n  const keyholderForceResume = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForceResume) {\n        throw new Error(\"Keyholder does not have force resume permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing resume\", { sessionId, reason });\n        await resumeSession();\n        logger.info(\"Keyholder force resume successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force resume\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForceResume, sessionId, resumeSession],\n  );\n\n  // Keyholder override cooldown\n  const keyholderOverrideCooldown = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canOverrideCooldown) {\n        throw new Error(\n          \"Keyholder does not have cooldown override permissions\",\n        );\n      }\n\n      try {\n        logger.debug(\"Keyholder overriding cooldown\", { sessionId, reason });\n        clearCooldown();\n        logger.info(\"Keyholder cooldown override successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder cooldown override\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canOverrideCooldown, sessionId, clearCooldown],\n  );\n\n  // Analytics\n  const getPausePatterns = useCallback((): PausePattern[] => {\n    return analyzePausePatterns(pauseHistory);\n  }, [pauseHistory]);\n\n  const getCooldownEffectiveness = useCallback((): CooldownAnalytics => {\n    return {\n      effectiveness: calculateCooldownEffectiveness(\n        pauseHistory,\n        cooldownState,\n      ),\n      averageCooldownDuration: cooldownState.adaptiveDuration,\n      overrideFrequency: 0,\n      adaptiveAdjustments: 0,\n    };\n  }, [pauseHistory, cooldownState]);\n\n  return {\n    // Enhanced state\n    pauseStatus,\n    cooldownState,\n    keyholderOverrides,\n    pauseAnalytics,\n\n    // Basic actions\n    pauseSession,\n    resumeSession,\n\n    // Enhanced actions\n    requestEmergencyPause,\n    requestCooldownOverride,\n\n    // Keyholder actions\n    keyholderForcePause,\n    keyholderForceResume,\n    keyholderOverrideCooldown,\n\n    // Analytics\n    getPausePatterns,\n    getCooldownEffectiveness,\n\n    // Computed values\n    canPause,\n    canResume,\n    timeUntilNextPause,\n    hasKeyholderOverride,\n    pauseFrequency,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSession.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (214). Maximum allowed is 150.",
        "line": 35,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 276,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback, useRef } from \"react\";\nimport { doc, setDoc, onSnapshot, serverTimestamp } from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\n\n/**\n * @typedef {Object} Session\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {boolean} isActive\n * @property {number} [duration]\n * @property {string} [reason]\n */\n\n/**\n * @typedef {Object} SessionState\n * @property {Session|null} currentSession\n * @property {boolean} isSessionActive\n * @property {Date|null} sessionStartTime\n * @property {number} elapsedTime\n */\n\n/**\n * @typedef {Object} SessionOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {Function} [onSessionChange]\n */\n\n/**\n * Hook for managing user sessions\n * @param {SessionOptions} options\n * @returns {Object}\n */\nexport const useSession = ({ userId, isAuthReady, onSessionChange }) => {\n  const [sessionState, setSessionState] = useState({\n    currentSession: null,\n    isSessionActive: false,\n    sessionStartTime: null,\n    elapsedTime: 0,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const timerRef = useRef(null);\n  const unsubscribeRef = useRef(null);\n\n  const saveSessionToFirestore = useCallback(\n    async (sessionData) => {\n      if (!userId || !isAuthReady) {\n        return;\n      }\n\n      try {\n        const userDocRef = doc(db, \"users\", userId);\n        await setDoc(\n          userDocRef,\n          {\n            currentSession: sessionData,\n            sessionUpdatedAt: serverTimestamp(),\n          },\n          { merge: true },\n        );\n      } catch (err) {\n        setError(err instanceof Error ? err.message : \"Failed to save session\");\n      }\n    },\n    [userId, isAuthReady],\n  );\n\n  const startSession = useCallback(async () => {\n    if (sessionState.isSessionActive) {\n      setError(\"Session already active\");\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const startTime = new Date();\n      const newSession = {\n        id: crypto.randomUUID(),\n        startTime,\n        isActive: true,\n      };\n\n      const newState = {\n        currentSession: newSession,\n        isSessionActive: true,\n        sessionStartTime: startTime,\n        elapsedTime: 0,\n      };\n\n      setSessionState(newState);\n      await saveSessionToFirestore(newSession);\n      if (onSessionChange) onSessionChange(newSession);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to start session\");\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionState.isSessionActive, saveSessionToFirestore, onSessionChange]);\n\n  const endSession = useCallback(\n    async (reason) => {\n      if (!sessionState.isSessionActive || !sessionState.currentSession) {\n        setError(\"No active session to end\");\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const endTime = new Date();\n        const duration = sessionState.sessionStartTime\n          ? Math.floor(\n              (endTime.getTime() - sessionState.sessionStartTime.getTime()) /\n                1000,\n            )\n          : 0;\n\n        const endedSession = {\n          ...sessionState.currentSession,\n          endTime,\n          isActive: false,\n          duration,\n          reason,\n        };\n\n        const newState = {\n          currentSession: null,\n          isSessionActive: false,\n          sessionStartTime: null,\n          elapsedTime: 0,\n        };\n\n        setSessionState(newState);\n        await saveSessionToFirestore(endedSession);\n        if (onSessionChange) onSessionChange(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : \"Failed to end session\");\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [\n      sessionState.isSessionActive,\n      sessionState.currentSession,\n      sessionState.sessionStartTime,\n      saveSessionToFirestore,\n      onSessionChange,\n    ],\n  );\n\n  const updateSession = useCallback(\n    async (updates) => {\n      if (!sessionState.currentSession) {\n        setError(\"No active session to update\");\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const updatedSession = {\n          ...sessionState.currentSession,\n          ...updates,\n        };\n\n        setSessionState((prev) => ({\n          ...prev,\n          currentSession: updatedSession,\n        }));\n\n        await saveSessionToFirestore(updatedSession);\n        if (onSessionChange) onSessionChange(updatedSession);\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to update session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [sessionState.currentSession, saveSessionToFirestore, onSessionChange],\n  );\n\n  // Real-time session listener\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, \"users\", userId);\n    const unsubscribe = onSnapshot(\n      userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.currentSession) {\n            const session = {\n              ...data.currentSession,\n              startTime: data.currentSession.startTime?.toDate(),\n              endTime: data.currentSession.endTime?.toDate(),\n            };\n\n            setSessionState((prev) => ({\n              ...prev,\n              currentSession: session,\n              isSessionActive: session.isActive,\n              sessionStartTime: session.startTime,\n            }));\n          } else {\n            setSessionState({\n              currentSession: null,\n              isSessionActive: false,\n              sessionStartTime: null,\n              elapsedTime: 0,\n            });\n          }\n        }\n        setError(null);\n      },\n      (err) => {\n        setError(err.message);\n      },\n    );\n\n    unsubscribeRef.current = unsubscribe;\n    return () => {\n      if (unsubscribeRef.current) {\n        unsubscribeRef.current();\n      }\n    };\n  }, [userId, isAuthReady]);\n\n  // Timer for elapsed time\n  useEffect(() => {\n    if (sessionState.isSessionActive && sessionState.sessionStartTime) {\n      timerRef.current = setInterval(() => {\n        const elapsed = Math.floor(\n          (new Date().getTime() - sessionState.sessionStartTime.getTime()) /\n            1000,\n        );\n        setSessionState((prev) => ({\n          ...prev,\n          elapsedTime: elapsed,\n        }));\n      }, 1000);\n    } else {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, [sessionState.isSessionActive, sessionState.sessionStartTime]);\n\n  return {\n    sessionState,\n    isLoading,\n    error,\n    startSession,\n    endSession,\n    updateSession,\n    clearError: useCallback(() => setError(null), []),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSession.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (338). Maximum allowed is 150.",
        "line": 134,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 564,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 134,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 564,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAnalytics', 'loadCurrentSession', 'loadGoals', and 'loadHistory'. Either include them or remove the dependency array.",
        "line": 268,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 268,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]",
            "fix": {
              "range": [7423, 7447],
              "text": "[userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Session Management Hook\n * Provides comprehensive session management with keyholder integration,\n * goal tracking, and advanced analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { DBSession, DBGoal } from \"../../types/database\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { KeyholderRelationshipService } from \"../../services/KeyholderRelationshipService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSession\");\n\n// ==================== INTERFACES ====================\n\nexport interface SessionGoals {\n  personal: DBGoal[];\n  keyholderAssigned: DBGoal[];\n  active: DBGoal[];\n}\n\nexport interface SessionContext {\n  userId: string;\n  relationshipId?: string;\n  sessionType: \"self_managed\" | \"keyholder_managed\" | \"collaborative\";\n  permissions: SessionPermission[];\n}\n\nexport interface KeyholderInfo {\n  id: string;\n  name: string;\n  lastSeen: Date;\n}\n\nexport interface KeyholderSessionControls {\n  canModify: boolean;\n  canOverride: boolean;\n  activeKeyholder: KeyholderInfo;\n  controlHistory: ControlAction[];\n}\n\nexport interface SessionAnalytics {\n  averageSessionLength: number;\n  completionRate: number;\n  goalAchievementRate: number;\n  totalSessions: number;\n  consistencyScore: number;\n}\n\nexport interface SessionInsights {\n  predictedDuration: number;\n  optimalGoalDuration: number;\n  completionProbability: number;\n  riskFactors: string[];\n  recommendations: string[];\n}\n\nexport interface PredictiveAnalytics {\n  nextSessionPrediction: {\n    suggestedDuration: number;\n    successProbability: number;\n    recommendedGoals: string[];\n  };\n  weeklyTrend: {\n    direction: \"improving\" | \"declining\" | \"stable\";\n    confidence: number;\n  };\n}\n\nexport interface SessionHistoryEntry {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  goals: DBGoal[];\n  completedGoals: string[];\n  notes?: string;\n  rating?: number;\n}\n\nexport interface EnhancedSessionState {\n  currentSession: DBSession | null;\n  sessionContext: SessionContext;\n  keyholderControls: KeyholderSessionControls | null;\n  goals: SessionGoals;\n  history: SessionHistoryEntry[];\n  analytics: SessionAnalytics;\n}\n\nexport type SessionPermission =\n  | \"start_session\"\n  | \"end_session\"\n  | \"modify_goals\"\n  | \"pause_session\"\n  | \"self_modify\"\n  | \"override_restrictions\";\n\nexport interface ControlAction {\n  id: string;\n  action: string;\n  timestamp: Date;\n  reason?: string;\n  performedBy: \"keyholder\" | \"submissive\" | \"system\";\n}\n\nexport interface SessionModifications {\n  goalDuration?: number;\n  goals?: Partial<DBGoal>[];\n  notes?: string;\n  endReason?: string;\n}\n\nexport interface ModificationRequest {\n  id: string;\n  type: \"goal_change\" | \"early_end\" | \"time_extension\";\n  requestedBy: string;\n  reason: string;\n  details: Record<string, unknown>;\n  status: \"pending\" | \"approved\" | \"rejected\";\n  createdAt: Date;\n}\n\nexport interface ApprovalStatus {\n  approved: boolean;\n  reason?: string;\n  approvedBy?: string;\n  approvedAt?: Date;\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session management hook with analytics, goals, and keyholder controls\n// eslint-disable-next-line max-statements\nexport const useSession = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [goals, setGoals] = useState<SessionGoals>({\n    personal: [],\n    keyholderAssigned: [],\n    active: [],\n  });\n  const [_history, setHistory] = useState<SessionHistoryEntry[]>([]);\n  const [keyholderControls, setKeyholderControls] =\n    useState<KeyholderSessionControls | null>(null);\n  const [analytics, setAnalytics] = useState<SessionAnalytics>({\n    averageSessionLength: 0,\n    completionRate: 0,\n    goalAchievementRate: 0,\n    totalSessions: 0,\n    consistencyScore: 0,\n  });\n  const [relationship, setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const sessionContext = useMemo((): SessionContext => {\n    if (!userId) {\n      return {\n        userId: \"\",\n        sessionType: \"self_managed\",\n        permissions: [],\n      };\n    }\n\n    return {\n      userId,\n      relationshipId,\n      sessionType: relationshipId\n        ? keyholderControls?.canModify\n          ? \"keyholder_managed\"\n          : \"collaborative\"\n        : \"self_managed\",\n      permissions: derivePermissions(relationship, keyholderControls),\n    };\n  }, [userId, relationshipId, keyholderControls, relationship]);\n\n  const isActive = useMemo(\n    () => currentSession?.endTime == null && currentSession != null,\n    [currentSession],\n  );\n\n  const duration = useMemo(\n    () => (currentSession ? calculateDuration(currentSession) : 0),\n    [currentSession],\n  );\n\n  const goalProgress = useMemo(\n    () => calculateGoalProgress(currentSession, goals),\n    [currentSession, goals],\n  );\n\n  const isUnderKeyholderControl = useMemo(\n    () => !!relationshipId && !!keyholderControls,\n    [relationshipId, keyholderControls],\n  );\n\n  const canSelfModify = useMemo(\n    () =>\n      !keyholderControls?.canModify ||\n      sessionContext.permissions.includes(\"self_modify\"),\n    [keyholderControls, sessionContext.permissions],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSession = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship if provided\n        if (relationshipId) {\n          const relationships =\n            await KeyholderRelationshipService.getUserRelationships(userId);\n          const activeRelationship =\n            relationships.asSubmissive.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            ) ||\n            relationships.asKeyholder.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            );\n\n          setRelationship(activeRelationship || null);\n\n          if (activeRelationship) {\n            setKeyholderControls({\n              canModify:\n                activeRelationship.permissions.canLockSessions || false,\n              canOverride:\n                activeRelationship.permissions.canUnlockSessions || false,\n              activeKeyholder: {\n                id: activeRelationship.keyholderUserId,\n                name: \"Keyholder\", // Would get from user profile\n                lastSeen: new Date(),\n              },\n              controlHistory: [],\n            });\n          }\n        }\n\n        // Load current session, goals, history, and analytics\n        await Promise.all([\n          loadCurrentSession(),\n          loadGoals(),\n          loadHistory(),\n          loadAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSession();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadCurrentSession = useCallback(async () => {\n    // This would integrate with your existing session service\n    // For now, return mock data structure\n    setCurrentSession(null);\n  }, []); // userId is passed but not used in mock implementation\n\n  const loadGoals = useCallback(async () => {\n    // This would integrate with your existing goals service\n    setGoals({\n      personal: [],\n      keyholderAssigned: [],\n      active: [],\n    });\n  }, []); // userId and relationshipId are passed but not used in mock\n\n  const loadHistory = useCallback(async () => {\n    // This would integrate with your existing history service\n    setHistory([]);\n  }, []); // userId is passed but not used in mock\n\n  const loadAnalytics = useCallback(async () => {\n    // This would integrate with your existing analytics service\n    setAnalytics({\n      averageSessionLength: 0,\n      completionRate: 0,\n      goalAchievementRate: 0,\n      totalSessions: 0,\n      consistencyScore: 0,\n    });\n  }, []); // userId is passed but not used in mock\n\n  // ==================== SESSION LIFECYCLE ====================\n\n  const startSession = useCallback(\n    async (sessionGoals?: SessionGoals): Promise<DBSession> => {\n      if (!userId) throw new Error(\"User ID required to start session\");\n\n      try {\n        logger.debug(\"Starting new session\", {\n          userId,\n          hasGoals: !!sessionGoals,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"start_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to start session\");\n        }\n\n        // Create new session\n        const newSession: DBSession = {\n          id: `session_${Date.now()}`,\n          userId,\n          startTime: new Date(),\n          isPaused: false,\n          accumulatedPauseTime: 0,\n          isHardcoreMode: false,\n          keyholderApprovalRequired:\n            sessionContext.sessionType === \"keyholder_managed\",\n          syncStatus: \"pending\",\n          lastModified: new Date(),\n        };\n\n        // Add goals if provided\n        if (sessionGoals) {\n          await setGoals(sessionGoals);\n        }\n\n        setCurrentSession(newSession);\n        logger.info(\"Session started successfully\", {\n          sessionId: newSession.id,\n        });\n\n        return newSession;\n      } catch (error) {\n        logger.error(\"Failed to start session\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionContext],\n  );\n\n  const stopSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to stop\");\n\n      try {\n        logger.debug(\"Stopping session\", {\n          sessionId: currentSession.id,\n          reason,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"end_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to end session\");\n        }\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          endTime: new Date(),\n          endReason: reason,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        await loadHistory(); // Refresh history\n        await loadAnalytics(); // Refresh analytics\n\n        logger.info(\"Session stopped successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to stop session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, sessionContext, loadHistory, loadAnalytics],\n  );\n\n  // ==================== ENHANCED CONTROLS ====================\n\n  const modifySession = useCallback(\n    async (modifications: SessionModifications): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to modify\");\n\n      if (!canSelfModify) {\n        throw new Error(\"Session modification requires keyholder approval\");\n      }\n\n      try {\n        logger.debug(\"Modifying session\", {\n          sessionId: currentSession.id,\n          modifications,\n        });\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          ...modifications,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        logger.info(\"Session modified successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to modify session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, canSelfModify],\n  );\n\n  const setSessionGoals = useCallback(\n    async (sessionGoals: SessionGoals): Promise<void> => {\n      if (!sessionContext.permissions.includes(\"modify_goals\")) {\n        throw new Error(\"Goal modification requires appropriate permissions\");\n      }\n\n      try {\n        logger.debug(\"Setting session goals\", {\n          userId,\n          goalCount: sessionGoals.active.length,\n        });\n        setGoals(sessionGoals);\n        logger.info(\"Session goals updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to set session goals\", { error });\n        throw error;\n      }\n    },\n    [sessionContext.permissions, userId],\n  );\n\n  const requestModification = useCallback(\n    async (request: ModificationRequest): Promise<void> => {\n      if (!relationshipId)\n        throw new Error(\"Modification requests require active relationship\");\n\n      try {\n        logger.debug(\"Creating modification request\", {\n          requestId: request.id,\n          type: request.type,\n        });\n        // This would integrate with your notification/request system\n        logger.info(\"Modification request created successfully\", {\n          requestId: request.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to create modification request\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const requestKeyholderApproval = useCallback(\n    async (action: string): Promise<ApprovalStatus> => {\n      if (!keyholderControls) {\n        return { approved: true }; // Auto-approve if no keyholder control\n      }\n\n      try {\n        logger.debug(\"Requesting keyholder approval\", {\n          action,\n          keyholderId: keyholderControls.activeKeyholder.id,\n        });\n\n        // This would integrate with your keyholder notification system\n        // For now, return pending status\n        return {\n          approved: false,\n          reason: \"Approval request sent to keyholder\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to request keyholder approval\", { error });\n        throw error;\n      }\n    },\n    [keyholderControls],\n  );\n\n  // ==================== ANALYTICS AND INSIGHTS ====================\n\n  const getSessionInsights = useCallback((): SessionInsights => {\n    return {\n      predictedDuration: analytics.averageSessionLength,\n      optimalGoalDuration: analytics.averageSessionLength * 1.2,\n      completionProbability: analytics.completionRate,\n      riskFactors: [],\n      recommendations: [],\n    };\n  }, [analytics]);\n\n  const getPredictiveAnalytics = useCallback((): PredictiveAnalytics => {\n    return {\n      nextSessionPrediction: {\n        suggestedDuration: analytics.averageSessionLength,\n        successProbability: analytics.completionRate,\n        recommendedGoals: [\"Duration Goal\", \"Consistency Goal\"],\n      },\n      weeklyTrend: {\n        direction: \"stable\",\n        confidence: 0.8,\n      },\n    };\n  }, [analytics]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Enhanced state\n    session: currentSession,\n    context: sessionContext,\n    keyholderControls,\n    goals,\n    analytics,\n\n    // Session lifecycle\n    startSession,\n    stopSession,\n\n    // Enhanced controls\n    modifySession,\n    setGoals: setSessionGoals,\n    requestModification,\n\n    // Keyholder integration\n    requestKeyholderApproval,\n\n    // Analytics and insights\n    getSessionInsights,\n    getPredictiveAnalytics,\n\n    // Computed values\n    isActive,\n    duration,\n    goalProgress,\n    isUnderKeyholderControl,\n    canSelfModify,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction derivePermissions(\n  relationship: KeyholderRelationship | null,\n  controls: KeyholderSessionControls | null,\n): SessionPermission[] {\n  const permissions: SessionPermission[] = [];\n\n  if (!relationship || !controls) {\n    // Self-managed session - all permissions\n    return [\n      \"start_session\",\n      \"end_session\",\n      \"modify_goals\",\n      \"pause_session\",\n      \"self_modify\",\n    ];\n  }\n\n  // Keyholder-managed permissions\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"start_session\");\n  if (relationship.permissions.canUnlockSessions)\n    permissions.push(\"end_session\");\n  if (relationship.permissions.canEditGoals) permissions.push(\"modify_goals\");\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"pause_session\");\n  // Add basic self-modify permission for submissives\n  permissions.push(\"self_modify\");\n  if (controls.canOverride) permissions.push(\"override_restrictions\");\n\n  return permissions;\n}\n\nfunction calculateDuration(session: DBSession): number {\n  if (!session.startTime) return 0;\n\n  const endTime = session.endTime || new Date();\n  const totalTime = endTime.getTime() - session.startTime.getTime();\n\n  return Math.max(0, Math.floor(totalTime / 1000));\n}\n\nfunction calculateGoalProgress(\n  session: DBSession | null,\n  goals: SessionGoals,\n): number {\n  if (!session || goals.active.length === 0) return 0;\n\n  const completedGoals = goals.active.filter((goal) => goal.isCompleted).length;\n  return Math.floor((completedGoals / goals.active.length) * 100);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionGoals.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (203). Maximum allowed is 150.",
        "line": 46,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 283,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport {\n  doc,\n  setDoc,\n  onSnapshot,\n  collection,\n  addDoc,\n  query,\n  orderBy,\n  getDocs,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\n\n/**\n * @typedef {Object} Goal\n * @property {string} id\n * @property {string} title\n * @property {string} description\n * @property {number} targetDuration - in seconds\n * @property {boolean} isCompleted\n * @property {Date} createdAt\n * @property {Date} [completedAt]\n * @property {string} [reward]\n */\n\n/**\n * @typedef {Object} GoalsState\n * @property {Goal[]} goals\n * @property {Goal|null} activeGoal\n * @property {number} progress - percentage\n */\n\n/**\n * @typedef {Object} SessionGoalsOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} currentSessionDuration\n * @property {Function} [onGoalCompleted]\n */\n\n/**\n * Hook for managing session goals\n * @param {SessionGoalsOptions} options\n * @returns {Object}\n */\nexport const useSessionGoals = ({\n  userId,\n  isAuthReady,\n  currentSessionDuration,\n  onGoalCompleted,\n}) => {\n  const [goalsState, setGoalsState] = useState({\n    goals: [],\n    activeGoal: null,\n    progress: 0,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const saveGoalsToFirestore = useCallback(\n    async (goals) => {\n      if (!userId || !isAuthReady) {\n        return;\n      }\n\n      try {\n        const userDocRef = doc(db, \"users\", userId);\n        await setDoc(userDocRef, { goals }, { merge: true });\n      } catch (err) {\n        setError(err instanceof Error ? err.message : \"Failed to save goals\");\n      }\n    },\n    [userId, isAuthReady],\n  );\n\n  const addGoal = useCallback(\n    async (goalData) => {\n      if (!userId || !isAuthReady) {\n        setError(\"User not authenticated\");\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const newGoal = {\n          ...goalData,\n          id: crypto.randomUUID(),\n          isCompleted: false,\n          createdAt: new Date(),\n        };\n\n        const goalsCollection = collection(db, \"users\", userId, \"goals\");\n        await addDoc(goalsCollection, newGoal);\n\n        setGoalsState((prev) => ({\n          ...prev,\n          goals: [...prev.goals, newGoal],\n        }));\n      } catch (err) {\n        setError(err instanceof Error ? err.message : \"Failed to add goal\");\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [userId, isAuthReady],\n  );\n\n  const completeGoal = useCallback(\n    async (goalId) => {\n      if (!userId || !isAuthReady) {\n        setError(\"User not authenticated\");\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const updatedGoals = goalsState.goals.map((goal) =>\n          goal.id === goalId\n            ? { ...goal, isCompleted: true, completedAt: new Date() }\n            : goal,\n        );\n\n        const completedGoal = updatedGoals.find((goal) => goal.id === goalId);\n\n        setGoalsState((prev) => ({\n          ...prev,\n          goals: updatedGoals,\n          activeGoal: prev.activeGoal?.id === goalId ? null : prev.activeGoal,\n        }));\n\n        await saveGoalsToFirestore(updatedGoals);\n\n        if (completedGoal && onGoalCompleted) {\n          onGoalCompleted(completedGoal);\n        }\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to complete goal\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [\n      userId,\n      isAuthReady,\n      goalsState.goals,\n      saveGoalsToFirestore,\n      onGoalCompleted,\n    ],\n  );\n\n  const setActiveGoal = useCallback(\n    async (goalId) => {\n      const activeGoal = goalId\n        ? goalsState.goals.find((goal) => goal.id === goalId) || null\n        : null;\n\n      setGoalsState((prev) => ({\n        ...prev,\n        activeGoal,\n      }));\n\n      if (userId && isAuthReady) {\n        try {\n          const userDocRef = doc(db, \"users\", userId);\n          await setDoc(userDocRef, { activeGoalId: goalId }, { merge: true });\n        } catch (err) {\n          setError(\n            err instanceof Error ? err.message : \"Failed to set active goal\",\n          );\n        }\n      }\n    },\n    [goalsState.goals, userId, isAuthReady],\n  );\n\n  const fetchGoals = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const goalsCollection = collection(db, \"users\", userId, \"goals\");\n      const q = query(goalsCollection, orderBy(\"createdAt\", \"desc\"));\n      const querySnapshot = await getDocs(q);\n\n      const goals = querySnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n        createdAt: doc.data().createdAt?.toDate() || new Date(),\n        completedAt: doc.data().completedAt?.toDate(),\n      }));\n\n      setGoalsState((prev) => ({ ...prev, goals }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to fetch goals\");\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  // Load goals and active goal on mount\n  useEffect(() => {\n    fetchGoals();\n  }, [fetchGoals]);\n\n  // Listen for active goal updates\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, \"users\", userId);\n    const unsubscribe = onSnapshot(\n      userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.activeGoalId) {\n            const activeGoal = goalsState.goals.find(\n              (goal) => goal.id === data.activeGoalId,\n            );\n            setGoalsState((prev) => ({\n              ...prev,\n              activeGoal: activeGoal || null,\n            }));\n          }\n        }\n      },\n      (err) => {\n        setError(err.message);\n      },\n    );\n\n    return () => unsubscribe();\n  }, [userId, isAuthReady, goalsState.goals]);\n\n  // Calculate progress for active goal\n  useEffect(() => {\n    if (goalsState.activeGoal && currentSessionDuration > 0) {\n      const progress = Math.min(\n        (currentSessionDuration / goalsState.activeGoal.targetDuration) * 100,\n        100,\n      );\n\n      setGoalsState((prev) => ({ ...prev, progress }));\n\n      // Auto-complete goal if target reached\n      if (progress >= 100 && !goalsState.activeGoal.isCompleted) {\n        completeGoal(goalsState.activeGoal.id);\n      }\n    } else {\n      setGoalsState((prev) => ({ ...prev, progress: 0 }));\n    }\n  }, [goalsState.activeGoal, currentSessionDuration, completeGoal]);\n\n  const getNextGoal = useCallback(() => {\n    return (\n      goalsState.goals\n        .filter((goal) => !goal.isCompleted)\n        .sort((a, b) => a.targetDuration - b.targetDuration)[0] || null\n    );\n  }, [goalsState.goals]);\n\n  return {\n    goalsState,\n    isLoading,\n    error,\n    addGoal,\n    completeGoal,\n    setActiveGoal,\n    getNextGoal,\n    refreshGoals: fetchGoals,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistory.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (212). Maximum allowed is 150.",
        "line": 47,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 285,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport {\n  collection,\n  query,\n  orderBy,\n  limit,\n  startAfter,\n  getDocs,\n  doc,\n  deleteDoc,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\n\n/**\n * @typedef {Object} HistorySession\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} endTime\n * @property {number} duration\n * @property {string} [reason]\n * @property {Array} [pauseEvents]\n * @property {number} [totalPauseTime]\n * @property {number} [netDuration] - duration minus pause time\n */\n\n/**\n * @typedef {Object} HistoryFilters\n * @property {Object} [dateRange]\n * @property {Date} dateRange.start\n * @property {Date} dateRange.end\n * @property {number} [minDuration]\n * @property {number} [maxDuration]\n */\n\n/**\n * @typedef {Object} SessionHistoryOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} [pageSize=20]\n */\n\n/**\n * Hook for managing session history\n * @param {SessionHistoryOptions} options\n * @returns {Object}\n */\nexport const useSessionHistory = ({ userId, isAuthReady, pageSize = 20 }) => {\n  const [sessions, setSessions] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [filters, setFilters] = useState({});\n\n  const fetchSessions = useCallback(\n    async (append = false, lastDoc) => {\n      if (!userId || !isAuthReady) {\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const historyCollection = collection(\n          db,\n          \"users\",\n          userId,\n          \"sessionHistory\",\n        );\n        let q = query(\n          historyCollection,\n          orderBy(\"startTime\", \"desc\"),\n          limit(pageSize),\n        );\n\n        if (lastDoc) {\n          q = query(\n            historyCollection,\n            orderBy(\"startTime\", \"desc\"),\n            startAfter(lastDoc),\n            limit(pageSize),\n          );\n        }\n\n        const querySnapshot = await getDocs(q);\n        const newSessions = querySnapshot.docs.map((doc) => {\n          const data = doc.data();\n          return {\n            id: doc.id,\n            ...data,\n            startTime: data.startTime?.toDate() || new Date(),\n            endTime: data.endTime?.toDate() || new Date(),\n            pauseEvents:\n              data.pauseEvents?.map((event) => ({\n                ...event,\n                startTime: event.startTime?.toDate(),\n                endTime: event.endTime?.toDate(),\n              })) || [],\n          };\n        });\n\n        // Apply filters\n        const filteredSessions = newSessions.filter((session) => {\n          if (filters.dateRange) {\n            const sessionDate = session.startTime;\n            if (\n              sessionDate < filters.dateRange.start ||\n              sessionDate > filters.dateRange.end\n            ) {\n              return false;\n            }\n          }\n\n          if (filters.minDuration && session.duration < filters.minDuration) {\n            return false;\n          }\n\n          if (filters.maxDuration && session.duration > filters.maxDuration) {\n            return false;\n          }\n\n          return true;\n        });\n\n        setSessions((prev) =>\n          append ? [...prev, ...filteredSessions] : filteredSessions,\n        );\n        setHasMore(querySnapshot.docs.length === pageSize);\n      } catch (err) {\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to fetch session history\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [userId, isAuthReady, pageSize, filters],\n  );\n\n  const loadMore = useCallback(() => {\n    if (sessions.length > 0 && hasMore && !isLoading) {\n      const lastSession = sessions[sessions.length - 1];\n      fetchSessions(true, lastSession);\n    }\n  }, [sessions, hasMore, isLoading, fetchSessions]);\n\n  const deleteSession = useCallback(\n    async (sessionId) => {\n      if (!userId || !isAuthReady) {\n        setError(\"User not authenticated\");\n        return;\n      }\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const sessionDocRef = doc(\n          db,\n          \"users\",\n          userId,\n          \"sessionHistory\",\n          sessionId,\n        );\n        await deleteDoc(sessionDocRef);\n\n        setSessions((prev) =>\n          prev.filter((session) => session.id !== sessionId),\n        );\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to delete session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [userId, isAuthReady],\n  );\n\n  const updateFilters = useCallback((newFilters) => {\n    setFilters(newFilters);\n    setSessions([]);\n    setHasMore(true);\n  }, []);\n\n  const getStatistics = useCallback(() => {\n    const totalSessions = sessions.length;\n    const totalDuration = sessions.reduce(\n      (acc, session) => acc + session.duration,\n      0,\n    );\n    const averageDuration =\n      totalSessions > 0 ? totalDuration / totalSessions : 0;\n    const longestSession = sessions.reduce(\n      (max, session) => Math.max(max, session.duration),\n      0,\n    );\n    const shortestSession = sessions.reduce(\n      (min, session) => Math.min(min, session.duration),\n      Infinity,\n    );\n\n    // Calculate net duration (excluding pause time)\n    const totalNetDuration = sessions.reduce((acc, session) => {\n      const pauseTime = session.totalPauseTime || 0;\n      return acc + (session.duration - pauseTime);\n    }, 0);\n    const averageNetDuration =\n      totalSessions > 0 ? totalNetDuration / totalSessions : 0;\n\n    return {\n      totalSessions,\n      totalDuration,\n      averageDuration,\n      longestSession: longestSession === 0 ? 0 : longestSession,\n      shortestSession: shortestSession === Infinity ? 0 : shortestSession,\n      totalNetDuration,\n      averageNetDuration,\n    };\n  }, [sessions]);\n\n  const exportHistory = useCallback(() => {\n    if (sessions.length === 0) {\n      setError(\"No sessions to export\");\n      return;\n    }\n\n    try {\n      const dataToExport = {\n        exportedAt: new Date().toISOString(),\n        userId,\n        sessions: sessions.map((session) => ({\n          ...session,\n          startTime: session.startTime.toISOString(),\n          endTime: session.endTime.toISOString(),\n          pauseEvents: session.pauseEvents?.map((event) => ({\n            ...event,\n            startTime: event.startTime?.toISOString(),\n            endTime: event.endTime?.toISOString(),\n          })),\n        })),\n        statistics: getStatistics(),\n      };\n\n      const dataStr = JSON.stringify(dataToExport, null, 2);\n      const dataBlob = new Blob([dataStr], { type: \"application/json\" });\n      const url = URL.createObjectURL(dataBlob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = `session-history-${new Date().toISOString().slice(0, 10)}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to export history\");\n    }\n  }, [sessions, userId, getStatistics]);\n\n  // Initial load\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  return {\n    sessions,\n    isLoading,\n    error,\n    hasMore,\n    filters,\n    loadMore,\n    deleteSession,\n    updateFilters,\n    getStatistics,\n    exportHistory,\n    refresh: useCallback(() => {\n      setSessions([]);\n      setHasMore(true);\n      fetchSessions();\n    }, [fetchSessions]),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistory.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (351). Maximum allowed is 150.",
        "line": 54,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 494,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (30). Maximum allowed is 25.",
        "line": 54,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 494,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'calculateInsights', 'calculateTrends', 'loadPrivacySettings', and 'loadSessions'. Either include them or remove the dependency array.",
        "line": 178,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 185,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]",
            "fix": {
              "range": [5565, 5741],
              "text": "[userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session History Management Hook\n * Provides comprehensive session history with privacy controls,\n * data visualization support, and keyholder access management\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  createEmptyTrendData,\n  calculateOverallCompletionRate,\n  calculateLongestStreak,\n  calculatePauseFrequency,\n  calculateImprovementTrend,\n  calculateConsistencyScore,\n  calculateSessionLengthTrend,\n  calculateGoalCompletionTrend,\n  calculateConsistencyTrend,\n  calculatePauseFrequencyTrend,\n  calculateOverallProgressTrend,\n} from \"../../utils/sessionHistoryHelpers\";\nimport {\n  getSessionsByDateRange as getSessionsByDateRangeUtil,\n  getSessionsByGoal as getSessionsByGoalUtil,\n  searchSessions as searchSessionsUtil,\n  getKeyholderView as getKeyholderViewUtil,\n  getPerformanceTrends as getPerformanceTrendsUtil,\n  getGoalProgressHistory as getGoalProgressHistoryUtil,\n  getComparisonMetrics as getComparisonMetricsUtil,\n} from \"../../utils/session-history-helpers\";\nimport type {\n  HistoricalSession,\n  HistoryPrivacySettings,\n  KeyholderHistoryAccess,\n  HistoryInsights,\n  HistoryTrends,\n  HistorySearchQuery,\n  PersonalDataExport,\n  KeyholderHistoryView,\n  PerformanceTrends,\n  GoalProgressHistory,\n  ComparisonMetrics,\n} from \"./types/SessionHistory\";\n\n// Re-export types for backward compatibility\nexport type * from \"./types/SessionHistory\";\n\nconst logger = serviceLogger(\"useSessionHistory\");\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session history management with privacy controls and analytics\n// eslint-disable-next-line max-statements\nexport const useSessionHistory = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessions, setSessions] = useState<HistoricalSession[]>([]);\n  const [privacySettings, setPrivacySettings] =\n    useState<HistoryPrivacySettings>({\n      shareWithKeyholder: false,\n      shareDuration: true,\n      shareGoals: true,\n      sharePauses: false,\n      shareNotes: false,\n      shareRatings: false,\n      retentionPeriod: 365, // 1 year\n      allowExport: true,\n      anonymizeOldData: false,\n    });\n  const [keyholderAccess, setKeyholderAccess] =\n    useState<KeyholderHistoryAccess>({\n      hasAccess: false,\n      accessLevel: \"summary\",\n      canViewRatings: false,\n      canViewNotes: false,\n      canViewPauses: false,\n    });\n  const [insights, setInsights] = useState<HistoryInsights>({\n    totalSessions: 0,\n    totalEffectiveTime: 0,\n    averageSessionLength: 0,\n    longestSession: {} as HistoricalSession,\n    shortestSession: {} as HistoricalSession,\n    mostRecentSession: {} as HistoricalSession,\n    goalCompletionRate: 0,\n    pauseFrequency: 0,\n    improvementTrend: \"stable\",\n    consistencyScore: 0,\n  });\n  const [trends, setTrends] = useState<HistoryTrends>({\n    sessionLength: createEmptyTrendData(),\n    goalCompletion: createEmptyTrendData(),\n    consistency: createEmptyTrendData(),\n    pauseFrequency: createEmptyTrendData(),\n    overallProgress: createEmptyTrendData(),\n  });\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalSessions = useMemo(() => sessions.length, [sessions]);\n\n  const averageSessionLength = useMemo(\n    () =>\n      sessions.length > 0\n        ? sessions.reduce(\n            (sum, session) => sum + session.effectiveDuration,\n            0,\n          ) / sessions.length\n        : 0,\n    [sessions],\n  );\n\n  const goalCompletionRate = useMemo(\n    () => calculateOverallCompletionRate(sessions),\n    [sessions],\n  );\n\n  const longestStreak = useMemo(\n    () => calculateLongestStreak(sessions),\n    [sessions],\n  );\n\n  const hasPrivacyRestrictions = useMemo(\n    () => !privacySettings.shareWithKeyholder,\n    [privacySettings.shareWithKeyholder],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeHistory = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // Set keyholder access based on relationship permissions\n          setKeyholderAccess({\n            hasAccess: privacySettings.shareWithKeyholder,\n            accessLevel: privacySettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: privacySettings.shareRatings,\n            canViewNotes: privacySettings.shareNotes,\n            canViewPauses: privacySettings.sharePauses,\n          });\n        }\n\n        // Load historical data\n        await Promise.all([\n          loadSessions(),\n          loadPrivacySettings(),\n          calculateInsights(),\n          calculateTrends(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session history\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize session history\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeHistory();\n    // Store actions and stable callbacks should not be in dependency arrays\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    userId,\n    relationshipId,\n    privacySettings.shareWithKeyholder,\n    privacySettings.shareRatings,\n    privacySettings.shareNotes,\n    privacySettings.sharePauses,\n  ]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessions = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Load sessions with privacy filtering applied\n      const allSessions: HistoricalSession[] = [];\n\n      // Apply retention policy\n      const retentionDate = new Date();\n      retentionDate.setDate(\n        retentionDate.getDate() - privacySettings.retentionPeriod,\n      );\n\n      const filteredSessions = allSessions.filter(\n        (session) => session.startTime >= retentionDate,\n      );\n\n      setSessions(filteredSessions);\n    } catch (error) {\n      logger.error(\"Failed to load sessions\", { error });\n    }\n  }, [privacySettings.retentionPeriod]);\n\n  const loadPrivacySettings = useCallback(async () => {\n    try {\n      // Load user's privacy preferences from database\n      // For now, use defaults\n    } catch (error) {\n      logger.error(\"Failed to load privacy settings\", { error });\n    }\n  }, []);\n\n  const calculateInsights = useCallback(async () => {\n    try {\n      if (sessions.length === 0) return;\n\n      const totalEffectiveTime = sessions.reduce(\n        (sum, s) => sum + s.effectiveDuration,\n        0,\n      );\n      const sortedByDuration = [...sessions].sort(\n        (a, b) => b.effectiveDuration - a.effectiveDuration,\n      );\n      const sortedByDate = [...sessions].sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n\n      const newInsights: HistoryInsights = {\n        totalSessions: sessions.length,\n        totalEffectiveTime,\n        averageSessionLength: totalEffectiveTime / sessions.length,\n        longestSession: sortedByDuration[0],\n        shortestSession: sortedByDuration[sortedByDuration.length - 1],\n        mostRecentSession: sortedByDate[0],\n        goalCompletionRate: calculateOverallCompletionRate(sessions),\n        pauseFrequency: calculatePauseFrequency(sessions),\n        improvementTrend: calculateImprovementTrend(sessions),\n        consistencyScore: calculateConsistencyScore(sessions),\n      };\n\n      setInsights(newInsights);\n    } catch (error) {\n      logger.error(\"Failed to calculate insights\", { error });\n    }\n  }, [sessions]);\n\n  const calculateTrends = useCallback(async () => {\n    try {\n      const newTrends: HistoryTrends = {\n        sessionLength: calculateSessionLengthTrend(sessions),\n        goalCompletion: calculateGoalCompletionTrend(sessions),\n        consistency: calculateConsistencyTrend(sessions),\n        pauseFrequency: calculatePauseFrequencyTrend(sessions),\n        overallProgress: calculateOverallProgressTrend(sessions),\n      };\n\n      setTrends(newTrends);\n    } catch (error) {\n      logger.error(\"Failed to calculate trends\", { error });\n    }\n  }, [sessions]);\n\n  // ==================== DATA RETRIEVAL ====================\n\n  const getSessionsByDateRange = useCallback(\n    (start: Date, end: Date): HistoricalSession[] =>\n      getSessionsByDateRangeUtil(sessions, start, end),\n    [sessions],\n  );\n\n  const getSessionsByGoal = useCallback(\n    (goalType: string): HistoricalSession[] =>\n      getSessionsByGoalUtil(sessions, goalType),\n    [sessions],\n  );\n\n  const searchSessions = useCallback(\n    (query: HistorySearchQuery): HistoricalSession[] =>\n      searchSessionsUtil(sessions, query),\n    [sessions],\n  );\n\n  // ==================== PRIVACY MANAGEMENT ====================\n\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<HistoryPrivacySettings>): Promise<void> => {\n      try {\n        logger.debug(\"Updating privacy settings\", { settings });\n\n        const updatedSettings = { ...privacySettings, ...settings };\n        setPrivacySettings(updatedSettings);\n\n        // Update keyholder access based on new settings\n        if (relationshipId) {\n          setKeyholderAccess((prev) => ({\n            ...prev,\n            hasAccess: updatedSettings.shareWithKeyholder,\n            accessLevel: updatedSettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: updatedSettings.shareRatings,\n            canViewNotes: updatedSettings.shareNotes,\n            canViewPauses: updatedSettings.sharePauses,\n          }));\n        }\n\n        // Reload sessions if retention period changed\n        if (\n          settings.retentionPeriod &&\n          settings.retentionPeriod !== privacySettings.retentionPeriod\n        ) {\n          await loadSessions();\n        }\n\n        logger.info(\"Privacy settings updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update privacy settings\", { error });\n        throw error;\n      }\n    },\n    [privacySettings, relationshipId, loadSessions],\n  );\n\n  const exportPersonalData =\n    useCallback(async (): Promise<PersonalDataExport> => {\n      try {\n        logger.debug(\"Exporting personal data\", { userId });\n\n        const exportData: PersonalDataExport = {\n          exportId: `export_${Date.now()}`,\n          generatedAt: new Date(),\n          format: \"json\",\n          data: {\n            sessions,\n            goals: sessions.flatMap((s) => s.goals),\n            settings: privacySettings,\n            analytics: insights,\n          },\n          fileSize: 0, // Would be calculated\n          downloadUrl: \"\", // Would be generated\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n        logger.info(\"Personal data export created\", {\n          exportId: exportData.exportId,\n        });\n        return exportData;\n      } catch (error) {\n        logger.error(\"Failed to export personal data\", { error });\n        throw error;\n      }\n    }, [sessions, privacySettings, insights, userId]);\n\n  const deleteHistoricalData = useCallback(\n    async (before: Date): Promise<void> => {\n      try {\n        logger.debug(\"Deleting historical data\", { before, userId });\n\n        const sessionsToKeep = sessions.filter(\n          (session) => session.startTime >= before,\n        );\n        const deletedCount = sessions.length - sessionsToKeep.length;\n\n        setSessions(sessionsToKeep);\n\n        // Recalculate insights and trends\n        await Promise.all([calculateInsights(), calculateTrends()]);\n\n        logger.info(\"Historical data deleted\", { deletedCount });\n      } catch (error) {\n        logger.error(\"Failed to delete historical data\", { error });\n        throw error;\n      }\n    },\n    [sessions, calculateInsights, calculateTrends, userId],\n  );\n\n  // ==================== KEYHOLDER ACCESS ====================\n\n  const getKeyholderView = useCallback(\n    (): KeyholderHistoryView =>\n      getKeyholderViewUtil(\n        sessions,\n        keyholderAccess,\n        privacySettings,\n        averageSessionLength,\n        goalCompletionRate,\n      ),\n    [\n      keyholderAccess,\n      sessions,\n      privacySettings,\n      averageSessionLength,\n      goalCompletionRate,\n    ],\n  );\n\n  const shareHistoryWithKeyholder = useCallback(\n    async (sessionIds: string[]): Promise<void> => {\n      try {\n        logger.debug(\"Sharing specific sessions with keyholder\", {\n          sessionIds,\n        });\n\n        // This would create a special sharing link or send specific data\n        // For now, just log the action\n        logger.info(\"History shared with keyholder\", {\n          sessionCount: sessionIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to share history with keyholder\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getPerformanceTrends = useCallback(\n    (): PerformanceTrends =>\n      getPerformanceTrendsUtil(\n        averageSessionLength,\n        trends,\n        goalCompletionRate,\n        insights.consistencyScore,\n        longestStreak,\n      ),\n    [\n      averageSessionLength,\n      trends,\n      goalCompletionRate,\n      insights.consistencyScore,\n      longestStreak,\n    ],\n  );\n\n  const getGoalProgressHistory = useCallback(\n    (): GoalProgressHistory[] => getGoalProgressHistoryUtil(sessions),\n    [sessions],\n  );\n\n  const getComparisonMetrics = useCallback(\n    (): ComparisonMetrics => getComparisonMetricsUtil(sessions),\n    [sessions],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // History data\n    sessions,\n    insights,\n    trends,\n    privacySettings,\n\n    // Data retrieval\n    getSessionsByDateRange,\n    getSessionsByGoal,\n    searchSessions,\n\n    // Privacy management\n    updatePrivacySettings,\n    exportPersonalData,\n    deleteHistoricalData,\n\n    // Keyholder access\n    getKeyholderView,\n    shareHistoryWithKeyholder,\n\n    // Analytics\n    getPerformanceTrends,\n    getGoalProgressHistory,\n    getComparisonMetrics,\n\n    // Computed values\n    totalSessions,\n    averageSessionLength,\n    goalCompletionRate,\n    longestStreak,\n    hasPrivacyRestrictions,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistoryQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useHealthCheck.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (271). Maximum allowed is 150.",
        "line": 79,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 425,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useHealthCheck Hook - System Health Monitoring\n *\n * Monitor overall system health, service availability, and provide early warning\n * for potential issues.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { HealthCheckStorageService } from \"../../services/healthCheckStorage\";\n\n// Health status enum\nexport enum HealthStatus {\n  HEALTHY = \"healthy\",\n  WARNING = \"warning\",\n  CRITICAL = \"critical\",\n  UNKNOWN = \"unknown\",\n}\n\n// Service status\nexport interface ServiceStatus {\n  name: string;\n  status: HealthStatus;\n  responseTime: number;\n  lastChecked: Date;\n  error?: string;\n  uptime: number;\n}\n\n// System metrics\nexport interface SystemMetrics {\n  memoryUsage: number;\n  cpuUsage: number;\n  storageUsage: number;\n  networkLatency: number;\n  errorRate: number;\n  activeConnections: number;\n}\n\n// Health check result\nexport interface HealthCheckResult {\n  overall: HealthStatus;\n  services: ServiceStatus[];\n  metrics: SystemMetrics;\n  alerts: HealthAlert[];\n  lastUpdated: Date;\n  checkDuration: number;\n}\n\n// Health alert\nexport interface HealthAlert {\n  id: string;\n  type: \"warning\" | \"error\" | \"info\";\n  message: string;\n  service?: string;\n  timestamp: Date;\n  acknowledged: boolean;\n}\n\n// Health check configuration\ninterface HealthCheckConfig {\n  checkInterval: number;\n  timeout: number;\n  retryAttempts: number;\n  services: string[];\n}\n\nconst DEFAULT_CONFIG: HealthCheckConfig = {\n  checkInterval: 30000, // 30 seconds\n  timeout: 5000, // 5 seconds\n  retryAttempts: 3,\n  services: [\"firebase\", \"storage\", \"network\"],\n};\n\n/**\n * System Health Check Hook\n */\nexport const useHealthCheck = (config: Partial<HealthCheckConfig> = {}) => {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const [alerts, setAlerts] = useState<HealthAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Check service health\n  const checkServiceHealth = useCallback(\n    async (serviceName: string): Promise<ServiceStatus> => {\n      const startTime = Date.now();\n      let status: HealthStatus = HealthStatus.UNKNOWN;\n      let error: string | undefined;\n      let responseTime = 0;\n\n      try {\n        switch (serviceName) {\n          case \"firebase\":\n            // Check Firebase connectivity\n            status = await checkFirebaseHealth();\n            break;\n          case \"storage\":\n            status = await checkStorageHealth();\n            break;\n          case \"network\":\n            status = await checkNetworkHealth();\n            break;\n          default:\n            status = HealthStatus.UNKNOWN;\n        }\n\n        responseTime = Date.now() - startTime;\n      } catch (err) {\n        status = HealthStatus.CRITICAL;\n        error = err instanceof Error ? err.message : \"Unknown error\";\n        responseTime = Date.now() - startTime;\n        logger.error(`Health check failed for ${serviceName}`, { error: err });\n      }\n\n      return {\n        name: serviceName,\n        status,\n        responseTime,\n        lastChecked: new Date(),\n        error,\n        uptime: calculateUptime(serviceName),\n      };\n    },\n    [],\n  );\n\n  // Check Firebase health\n  const checkFirebaseHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Simple connectivity test - try to access Firebase\n      if (\n        typeof window !== \"undefined\" &&\n        (window as Window & { firebase?: unknown }).firebase\n      ) {\n        return HealthStatus.HEALTHY;\n      }\n      return HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check storage health\n  const checkStorageHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Test localStorage availability using the service\n      const isHealthy = HealthCheckStorageService.testLocalStorage();\n      return isHealthy ? HealthStatus.HEALTHY : HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check network health\n  const checkNetworkHealth = async (): Promise<HealthStatus> => {\n    if (!navigator.onLine) {\n      return HealthStatus.CRITICAL;\n    }\n\n    try {\n      const startTime = Date.now();\n      const response = await fetch(\"/favicon.ico\", {\n        method: \"HEAD\",\n        cache: \"no-cache\",\n      });\n      const responseTime = Date.now() - startTime;\n\n      if (response.ok && responseTime < 2000) {\n        return HealthStatus.HEALTHY;\n      } else if (response.ok && responseTime < 5000) {\n        return HealthStatus.WARNING;\n      }\n      return HealthStatus.CRITICAL;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Calculate service uptime (simplified)\n  const calculateUptime = (_serviceName: string): number => {\n    // In a real implementation, this would track actual uptime\n    // For now, return a mock value\n    return Math.random() * 100;\n  };\n\n  // Get system metrics\n  const getSystemMetrics = useCallback(async (): Promise<SystemMetrics> => {\n    const metrics: SystemMetrics = {\n      memoryUsage: 0,\n      cpuUsage: 0,\n      storageUsage: 0,\n      networkLatency: 0,\n      errorRate: 0,\n      activeConnections: 1,\n    };\n\n    try {\n      // Memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: { usedJSHeapSize: number; totalJSHeapSize: number };\n          }\n        ).memory;\n        if (memory) {\n          metrics.memoryUsage =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Storage usage\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        if (estimate.usage && estimate.quota) {\n          metrics.storageUsage = (estimate.usage / estimate.quota) * 100;\n        }\n      }\n\n      // Network latency (simplified)\n      const startTime = Date.now();\n      await fetch(\"/favicon.ico\", { method: \"HEAD\", cache: \"no-cache\" });\n      metrics.networkLatency = Date.now() - startTime;\n    } catch (error) {\n      logger.warn(\"Failed to get some system metrics\", error);\n    }\n\n    return metrics;\n  }, []);\n\n  // Determine overall health status\n  const calculateOverallHealth = useCallback(\n    (services: ServiceStatus[]): HealthStatus => {\n      const statuses = services.map((s) => s.status);\n\n      if (statuses.includes(HealthStatus.CRITICAL)) {\n        return HealthStatus.CRITICAL;\n      }\n\n      if (statuses.includes(HealthStatus.WARNING)) {\n        return HealthStatus.WARNING;\n      }\n\n      if (statuses.every((s) => s === HealthStatus.HEALTHY)) {\n        return HealthStatus.HEALTHY;\n      }\n\n      return HealthStatus.UNKNOWN;\n    },\n    [],\n  );\n\n  // Generate alerts based on health status\n  const generateAlerts = useCallback(\n    (services: ServiceStatus[], metrics: SystemMetrics): HealthAlert[] => {\n      const newAlerts: HealthAlert[] = [];\n\n      // Service alerts\n      services.forEach((service) => {\n        if (service.status === HealthStatus.CRITICAL) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"error\",\n            message: `Service ${service.name} is critical: ${service.error || \"Unknown error\"}`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        } else if (service.status === HealthStatus.WARNING) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"warning\",\n            message: `Service ${service.name} is experiencing issues`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        }\n      });\n\n      // Metrics alerts\n      if (metrics.memoryUsage > 90) {\n        newAlerts.push({\n          id: `memory-${Date.now()}`,\n          type: \"warning\",\n          message: `High memory usage: ${metrics.memoryUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.storageUsage > 90) {\n        newAlerts.push({\n          id: `storage-${Date.now()}`,\n          type: \"warning\",\n          message: `High storage usage: ${metrics.storageUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.networkLatency > 5000) {\n        newAlerts.push({\n          id: `network-${Date.now()}`,\n          type: \"warning\",\n          message: `High network latency: ${metrics.networkLatency}ms`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      return newAlerts;\n    },\n    [],\n  );\n\n  // Main health check query\n  const {\n    data: healthStatus,\n    isLoading,\n    error,\n    refetch,\n  } = useQuery<HealthCheckResult>({\n    queryKey: [\"system\", \"health\"],\n    queryFn: async () => {\n      const startTime = Date.now();\n\n      // Check all services\n      const serviceChecks = await Promise.all(\n        fullConfig.services.map((service) => checkServiceHealth(service)),\n      );\n\n      // Get system metrics\n      const metrics = await getSystemMetrics();\n\n      // Calculate overall health\n      const overall = calculateOverallHealth(serviceChecks);\n\n      // Generate alerts\n      const newAlerts = generateAlerts(serviceChecks, metrics);\n\n      const result: HealthCheckResult = {\n        overall,\n        services: serviceChecks,\n        metrics,\n        alerts: newAlerts,\n        lastUpdated: new Date(),\n        checkDuration: Date.now() - startTime,\n      };\n\n      // Update alerts state\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n\n      return result;\n    },\n    refetchInterval: isMonitoring ? fullConfig.checkInterval : false,\n    retry: fullConfig.retryAttempts,\n    staleTime: fullConfig.checkInterval / 2,\n  });\n\n  // Acknowledge alert\n  const acknowledgeAlert = useCallback((alertId: string) => {\n    setAlerts((prev) =>\n      prev.map((alert) =>\n        alert.id === alertId ? { ...alert, acknowledged: true } : alert,\n      ),\n    );\n    logger.info(\"Health alert acknowledged\", { alertId });\n  }, []);\n\n  // Clear acknowledged alerts\n  const clearAcknowledgedAlerts = useCallback(() => {\n    setAlerts((prev) => prev.filter((alert) => !alert.acknowledged));\n    logger.info(\"Acknowledged alerts cleared\");\n  }, []);\n\n  // Start/stop monitoring\n  const toggleMonitoring = useCallback((enabled: boolean) => {\n    setIsMonitoring(enabled);\n    logger.info(`Health monitoring ${enabled ? \"started\" : \"stopped\"}`);\n  }, []);\n\n  // Force health check\n  const forceCheck = useCallback(() => {\n    refetch();\n    logger.info(\"Manual health check triggered\");\n  }, [refetch]);\n\n  return {\n    // Health status\n    healthStatus,\n    isLoading,\n    error,\n\n    // Alerts\n    alerts: alerts.filter((alert) => !alert.acknowledged),\n    acknowledgedAlerts: alerts.filter((alert) => alert.acknowledged),\n    allAlerts: alerts,\n\n    // Controls\n    acknowledgeAlert,\n    clearAcknowledgedAlerts,\n    toggleMonitoring,\n    forceCheck,\n\n    // State\n    isMonitoring,\n\n    // Computed properties\n    isHealthy: healthStatus?.overall === HealthStatus.HEALTHY,\n    hasWarnings: healthStatus?.overall === HealthStatus.WARNING,\n    isCritical: healthStatus?.overall === HealthStatus.CRITICAL,\n    hasUnacknowledgedAlerts: alerts.some((alert) => !alert.acknowledged),\n    uptime:\n      healthStatus?.services.reduce((acc, service) => acc + service.uptime, 0) /\n      (healthStatus?.services.length || 1),\n    averageResponseTime:\n      healthStatus?.services.reduce(\n        (acc, service) => acc + service.responseTime,\n        0,\n      ) / (healthStatus?.services.length || 1),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useMigration.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (282). Maximum allowed is 150.",
        "line": 87,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 443,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useMigration Hook - Data Migration Management\n *\n * Handle data migrations, schema updates, and legacy data conversion with\n * progress tracking and rollback capabilities.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { MigrationStorageService } from \"../../services/migrationStorage\";\n\n// Migration status\nexport enum MigrationStatus {\n  PENDING = \"pending\",\n  RUNNING = \"running\",\n  COMPLETED = \"completed\",\n  FAILED = \"failed\",\n  ROLLED_BACK = \"rolled_back\",\n}\n\n// Migration definition\nexport interface Migration {\n  id: string;\n  version: string;\n  name: string;\n  description: string;\n  status: MigrationStatus;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  progress: number;\n  error?: string;\n  rollbackAvailable: boolean;\n}\n\n// Migration batch\nexport interface MigrationBatch {\n  id: string;\n  migrations: Migration[];\n  status: MigrationStatus;\n  totalProgress: number;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\n// Migration result\nexport interface MigrationResult {\n  success: boolean;\n  migrationsRun: number;\n  errors: string[];\n  warnings: string[];\n  duration: number;\n}\n\n// Sample migrations (in a real app, these would be defined elsewhere)\nconst AVAILABLE_MIGRATIONS: Omit<\n  Migration,\n  \"status\" | \"progress\" | \"createdAt\"\n>[] = [\n  {\n    id: \"v4.0.0-theme-system\",\n    version: \"4.0.0\",\n    name: \"Theme System Migration\",\n    description: \"Migrate existing theme preferences to new theme system\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-enhanced-goals\",\n    version: \"4.0.0\",\n    name: \"Enhanced Goals Migration\",\n    description: \"Convert legacy goals to enhanced goal format\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-gamification\",\n    version: \"4.0.0\",\n    name: \"Gamification System Migration\",\n    description: \"Initialize gamification data from existing achievements\",\n    rollbackAvailable: false,\n  },\n];\n\n/**\n * Data Migration Hook\n */\nexport const useMigration = () => {\n  const queryClient = useQueryClient();\n  const [isRunning, setIsRunning] = useState(false);\n\n  // Get migration state\n  const { data: migrationState } = useQuery({\n    queryKey: [\"migration\", \"state\"],\n    queryFn: () => {\n      const stored = MigrationStorageService.getMigrationState();\n      if (stored) {\n        return stored;\n      }\n\n      // Initialize migration state\n      const initialMigrations: Migration[] = AVAILABLE_MIGRATIONS.map(\n        (migration) => ({\n          ...migration,\n          status: MigrationStatus.PENDING,\n          progress: 0,\n          createdAt: new Date(),\n        }),\n      );\n\n      return {\n        migrations: initialMigrations,\n        lastRun: null,\n        currentVersion: \"3.0.0\",\n      };\n    },\n    staleTime: Infinity,\n  });\n\n  // Get pending migrations\n  const pendingMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.PENDING,\n    ) || [];\n\n  // Get completed migrations\n  const completedMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.COMPLETED,\n    ) || [];\n\n  // Create backup before migration\n  const createBackup = useCallback(\n    async (migrationId: string) => {\n      try {\n        const backup = {\n          id: `backup-${migrationId}-${Date.now()}`,\n          migrationId,\n          timestamp: new Date(),\n          data: {\n            // Backup all localStorage via service\n            localStorage: MigrationStorageService.getAllLocalStorage(),\n            version: migrationState?.currentVersion,\n          },\n        };\n\n        const existingBackups =\n          MigrationStorageService.getMigrationBackups<typeof backup>();\n\n        const updatedBackups = [...existingBackups, backup];\n        MigrationStorageService.setMigrationBackups(updatedBackups);\n\n        logger.info(\"Migration backup created\", {\n          migrationId,\n          backupId: backup.id,\n        });\n        return backup.id;\n      } catch (error) {\n        logger.error(\"Failed to create migration backup\", {\n          migrationId,\n          error,\n        });\n        throw error;\n      }\n    },\n    [migrationState],\n  );\n\n  // Migration implementations\n  const migrateThemeSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(25);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      // Convert old theme settings\n      const oldTheme = MigrationStorageService.getLegacyItem(\"theme\");\n      if (oldTheme) {\n        MigrationStorageService.setLegacyItem(\n          \"chastity-theme-current\",\n          JSON.stringify(\n            oldTheme === \"dark\" ? \"default-dark\" : \"default-light\",\n          ),\n        );\n      }\n\n      onProgress(75);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateEnhancedGoals = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(30);\n      await new Promise((resolve) => setTimeout(resolve, 300));\n\n      // Convert legacy goals (simplified)\n      const legacyGoals =\n        MigrationStorageService.getLegacyItem(\"personal-goals\");\n      if (legacyGoals) {\n        // Transform format here\n        onProgress(70);\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      }\n\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateGamificationSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(20);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n\n      // Initialize gamification data\n      onProgress(60);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n      onProgress(100);\n    },\n    [],\n  );\n\n  // Execute migration logic\n  const executeMigrationLogic = useCallback(\n    async (migrationId: string, onProgress: (progress: number) => void) => {\n      switch (migrationId) {\n        case \"v4.0.0-theme-system\":\n          await migrateThemeSystem(onProgress);\n          break;\n        case \"v4.0.0-enhanced-goals\":\n          await migrateEnhancedGoals(onProgress);\n          break;\n        case \"v4.0.0-gamification\":\n          await migrateGamificationSystem(onProgress);\n          break;\n        default:\n          throw new Error(`Unknown migration: ${migrationId}`);\n      }\n    },\n    [migrateThemeSystem, migrateEnhancedGoals, migrateGamificationSystem],\n  );\n\n  // Execute single migration\n  const executeMigration = useCallback(\n    async (migration: Migration): Promise<void> => {\n      logger.info(\"Starting migration\", { migrationId: migration.id });\n\n      // Update migration status\n      const updatedMigrations = migrationState.migrations.map((m: Migration) =>\n        m.id === migration.id\n          ? {\n              ...m,\n              status: MigrationStatus.RUNNING,\n              startedAt: new Date(),\n              progress: 0,\n            }\n          : m,\n      );\n\n      const newState = { ...migrationState, migrations: updatedMigrations };\n      MigrationStorageService.setMigrationState(newState);\n      queryClient.setQueryData([\"migration\", \"state\"], newState);\n\n      try {\n        // Create backup if rollback is available\n        if (migration.rollbackAvailable) {\n          await createBackup(migration.id);\n        }\n\n        // Execute migration logic based on ID\n        await executeMigrationLogic(migration.id, (progress: number) => {\n          // Update progress\n          const progressUpdatedMigrations = migrationState.migrations.map(\n            (m: Migration) => (m.id === migration.id ? { ...m, progress } : m),\n          );\n\n          const progressState = {\n            ...migrationState,\n            migrations: progressUpdatedMigrations,\n          };\n          MigrationStorageService.setMigrationState(progressState);\n          queryClient.setQueryData([\"migration\", \"state\"], progressState);\n        });\n\n        // Mark as completed\n        const completedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.COMPLETED,\n                  completedAt: new Date(),\n                  progress: 100,\n                }\n              : m,\n        );\n\n        const completedState = {\n          ...migrationState,\n          migrations: completedMigrations,\n        };\n        MigrationStorageService.setMigrationState(completedState);\n        queryClient.setQueryData([\"migration\", \"state\"], completedState);\n\n        logger.info(\"Migration completed\", { migrationId: migration.id });\n      } catch (error) {\n        // Mark as failed\n        const failedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.FAILED,\n                  error:\n                    error instanceof Error ? error.message : \"Unknown error\",\n                }\n              : m,\n        );\n\n        const failedState = { ...migrationState, migrations: failedMigrations };\n        MigrationStorageService.setMigrationState(failedState);\n        queryClient.setQueryData([\"migration\", \"state\"], failedState);\n\n        logger.error(\"Migration failed\", { migrationId: migration.id, error });\n        throw error;\n      }\n    },\n    [migrationState, queryClient, createBackup, executeMigrationLogic],\n  );\n\n  // Run migrations mutation\n  const runMigrationsMutation = useMutation({\n    mutationFn: async (migrationIds?: string[]) => {\n      setIsRunning(true);\n      const startTime = Date.now();\n      const result: MigrationResult = {\n        success: true,\n        migrationsRun: 0,\n        errors: [],\n        warnings: [],\n        duration: 0,\n      };\n\n      try {\n        const migrationsToRun = migrationIds\n          ? migrationState.migrations.filter((m: Migration) =>\n              migrationIds.includes(m.id),\n            )\n          : pendingMigrations;\n\n        for (const migration of migrationsToRun) {\n          try {\n            await executeMigration(migration);\n            result.migrationsRun++;\n          } catch (error) {\n            result.success = false;\n            result.errors.push(\n              `${migration.name}: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n            );\n          }\n        }\n\n        result.duration = Date.now() - startTime;\n        return result;\n      } finally {\n        setIsRunning(false);\n      }\n    },\n  });\n\n  // Rollback migration mutation\n  const rollbackMigrationMutation = useMutation({\n    mutationFn: async (migrationId: string) => {\n      const migration = migrationState.migrations.find(\n        (m: Migration) => m.id === migrationId,\n      );\n      if (!migration) throw new Error(\"Migration not found\");\n      if (!migration.rollbackAvailable)\n        throw new Error(\"Rollback not available for this migration\");\n\n      logger.info(\"Rolling back migration\", { migrationId });\n\n      // Find and restore backup\n      const backups = MigrationStorageService.getMigrationBackups<{\n        migrationId: string;\n        data: { localStorage: Record<string, string> };\n      }>();\n      const backup = backups.find((b) => b.migrationId === migrationId);\n\n      if (!backup) throw new Error(\"Backup not found\");\n\n      // Restore data from backup\n      Object.entries(backup.data.localStorage).forEach(([key, value]) => {\n        MigrationStorageService.setLegacyItem(key, value);\n      });\n\n      // Update migration status\n      const rolledBackMigrations = migrationState.migrations.map(\n        (m: Migration) =>\n          m.id === migrationId\n            ? { ...m, status: MigrationStatus.ROLLED_BACK }\n            : m,\n      );\n\n      const rolledBackState = {\n        ...migrationState,\n        migrations: rolledBackMigrations,\n      };\n      MigrationStorageService.setMigrationState(rolledBackState);\n      queryClient.setQueryData([\"migration\", \"state\"], rolledBackState);\n\n      logger.info(\"Migration rolled back\", { migrationId });\n    },\n  });\n\n  return {\n    // Migration state\n    migrations: migrationState?.migrations || [],\n    pendingMigrations,\n    completedMigrations,\n    isRunning,\n\n    // Actions\n    runMigrations: runMigrationsMutation.mutate,\n    rollbackMigration: rollbackMigrationMutation.mutate,\n\n    // Status\n    hasPendingMigrations: pendingMigrations.length > 0,\n    hasFailedMigrations:\n      migrationState?.migrations?.some(\n        (m: Migration) => m.status === MigrationStatus.FAILED,\n      ) || false,\n\n    // Loading states\n    isRunningMigrations: runMigrationsMutation.isPending,\n    isRollingBack: rollbackMigrationMutation.isPending,\n\n    // Results\n    lastResult: runMigrationsMutation.data,\n    error: runMigrationsMutation.error || rollbackMigrationMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useOfflineStatus.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (280). Maximum allowed is 150.",
        "line": 64,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 407,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'addNetworkEvent', 'getNetworkInfo', and 'getNetworkQuality'. Either include them or remove the dependency array.",
        "line": 377,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 377,
        "endColumn": 75,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]",
            "fix": {
              "range": [10907, 10976],
              "text": "[handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useOfflineStatus Hook - Network Status Monitoring\n *\n * Monitor network connectivity and provide offline capabilities with intelligent\n * sync when connection is restored.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Network quality enum\nexport enum NetworkQuality {\n  EXCELLENT = \"excellent\",\n  GOOD = \"good\",\n  FAIR = \"fair\",\n  POOR = \"poor\",\n  OFFLINE = \"offline\",\n}\n\n// Connection type\nexport enum ConnectionType {\n  WIFI = \"wifi\",\n  CELLULAR = \"cellular\",\n  ETHERNET = \"ethernet\",\n  BLUETOOTH = \"bluetooth\",\n  UNKNOWN = \"unknown\",\n}\n\n// Offline status interface\nexport interface OfflineStatus {\n  isOnline: boolean;\n  isOffline: boolean;\n  networkQuality: NetworkQuality;\n  connectionType: ConnectionType;\n  downlink: number;\n  rtt: number;\n  effectiveType: string;\n  lastOnline: Date | null;\n  offlineDuration: number;\n  hasPendingSync: boolean;\n  syncQueueSize: number;\n}\n\n// Offline capabilities\nexport interface OfflineCapabilities {\n  canReadCache: boolean;\n  canWriteCache: boolean;\n  canQueueOperations: boolean;\n  estimatedStorageUsage: number;\n  maxStorageLimit: number;\n}\n\n// Network event\nexport interface NetworkEvent {\n  type: \"online\" | \"offline\" | \"quality-change\";\n  timestamp: Date;\n  details?: Record<string, string | number | boolean>;\n}\n\n/**\n * Network Status Hook\n */\nexport const useOfflineStatus = () => {\n  const queryClient = useQueryClient();\n  const [networkEvents, setNetworkEvents] = useState<NetworkEvent[]>([]);\n  const [syncQueue, setSyncQueue] = useState<Record<string, unknown>[]>([]);\n  const [lastOnline, setLastOnline] = useState<Date | null>(null);\n\n  // Get network information if available\n  const getNetworkInfo = useCallback(() => {\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n\n    return {\n      downlink: connection?.downlink || 0,\n      rtt: connection?.rtt || 0,\n      effectiveType: connection?.effectiveType || \"unknown\",\n      type: connection?.type || ConnectionType.UNKNOWN,\n    };\n  }, []);\n\n  // Determine network quality\n  const getNetworkQuality = useCallback(\n    (downlink: number, rtt: number): NetworkQuality => {\n      if (!navigator.onLine) return NetworkQuality.OFFLINE;\n\n      if (downlink >= 10 && rtt < 100) return NetworkQuality.EXCELLENT;\n      if (downlink >= 5 && rtt < 200) return NetworkQuality.GOOD;\n      if (downlink >= 1.5 && rtt < 500) return NetworkQuality.FAIR;\n      return NetworkQuality.POOR;\n    },\n    [],\n  );\n\n  // Current offline status query\n  const { data: offlineStatus } = useQuery<OfflineStatus>({\n    queryKey: [\"network\", \"status\"],\n    queryFn: () => {\n      const networkInfo = getNetworkInfo();\n      const quality = getNetworkQuality(networkInfo.downlink, networkInfo.rtt);\n      const now = new Date();\n\n      const offlineDuration =\n        lastOnline && !navigator.onLine\n          ? now.getTime() - lastOnline.getTime()\n          : 0;\n\n      return {\n        isOnline: navigator.onLine,\n        isOffline: !navigator.onLine,\n        networkQuality: quality,\n        connectionType: networkInfo.type,\n        downlink: networkInfo.downlink,\n        rtt: networkInfo.rtt,\n        effectiveType: networkInfo.effectiveType,\n        lastOnline,\n        offlineDuration,\n        hasPendingSync: syncQueue.length > 0,\n        syncQueueSize: syncQueue.length,\n      };\n    },\n    refetchInterval: 5000, // Check every 5 seconds\n    staleTime: 1000,\n  });\n\n  // Offline capabilities query\n  const { data: capabilities } = useQuery<OfflineCapabilities>({\n    queryKey: [\"network\", \"capabilities\"],\n    queryFn: async () => {\n      let storageUsage = 0;\n      let storageLimit = 0;\n\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        try {\n          const estimate = await navigator.storage.estimate();\n          storageUsage = estimate.usage || 0;\n          storageLimit = estimate.quota || 0;\n        } catch (error) {\n          logger.warn(\"Could not estimate storage\", error);\n        }\n      }\n\n      return {\n        canReadCache: \"caches\" in window,\n        canWriteCache: \"caches\" in window && navigator.onLine,\n        canQueueOperations: true,\n        estimatedStorageUsage: storageUsage,\n        maxStorageLimit: storageLimit,\n      };\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Add network event\n  const addNetworkEvent = useCallback(\n    (\n      type: NetworkEvent[\"type\"],\n      details?: Record<string, string | number | boolean>,\n    ) => {\n      const event: NetworkEvent = {\n        type,\n        timestamp: new Date(),\n        details,\n      };\n\n      setNetworkEvents((prev) => [...prev.slice(-49), event]); // Keep last 50 events\n      logger.info(`Network event: ${type}`, details);\n    },\n    [],\n  );\n\n  // Handle online event\n  const handleOnline = useCallback(() => {\n    setLastOnline(new Date());\n    addNetworkEvent(\"online\", {\n      wasOffline: !navigator.onLine,\n      syncQueueSize: syncQueue.length,\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n\n    // Process sync queue when back online\n    if (syncQueue.length > 0) {\n      processSyncQueue();\n    }\n  }, [syncQueue, addNetworkEvent, queryClient, processSyncQueue]);\n\n  // Handle offline event\n  const handleOffline = useCallback(() => {\n    addNetworkEvent(\"offline\", {\n      lastOnline: lastOnline?.toISOString(),\n      networkInfo: getNetworkInfo(),\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n  }, [lastOnline, addNetworkEvent, getNetworkInfo, queryClient]);\n\n  // Process sync queue\n  const processSyncQueue = useCallback(async () => {\n    if (!navigator.onLine || syncQueue.length === 0) return;\n\n    logger.info(\"Processing sync queue\", { queueSize: syncQueue.length });\n\n    const processedItems: Record<string, unknown>[] = [];\n\n    for (const item of syncQueue) {\n      try {\n        // Here you would implement actual sync logic\n        // For now, we'll just simulate processing\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        processedItems.push(item);\n        logger.debug(\"Sync item processed\", { item });\n      } catch (error) {\n        logger.error(\"Failed to sync item\", { item, error });\n        break; // Stop processing on error\n      }\n    }\n\n    // Remove processed items from queue\n    setSyncQueue((prev) =>\n      prev.filter((item) => !processedItems.includes(item)),\n    );\n\n    if (processedItems.length > 0) {\n      queryClient.invalidateQueries({ queryKey: [\"network\"] });\n      logger.info(\"Sync queue processed\", {\n        processedCount: processedItems.length,\n        remainingCount: syncQueue.length - processedItems.length,\n      });\n    }\n  }, [syncQueue, queryClient]);\n\n  // Add item to sync queue\n  const queueForSync = useCallback((item: Record<string, unknown>) => {\n    setSyncQueue((prev) => [...prev, { ...item, queuedAt: new Date() }]);\n    logger.debug(\"Item queued for sync\", { item });\n  }, []);\n\n  // Clear sync queue\n  const clearSyncQueue = useCallback(() => {\n    setSyncQueue([]);\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n    logger.info(\"Sync queue cleared\");\n  }, [queryClient]);\n\n  // Retry sync\n  const retrySync = useCallback(() => {\n    if (navigator.onLine) {\n      processSyncQueue();\n    } else {\n      logger.warn(\"Cannot retry sync while offline\");\n    }\n  }, [processSyncQueue]);\n\n  // Monitor connection changes\n  useEffect(() => {\n    const handleConnectionChange = () => {\n      const networkInfo = getNetworkInfo();\n      const newQuality = getNetworkQuality(\n        networkInfo.downlink,\n        networkInfo.rtt,\n      );\n\n      if (offlineStatus && newQuality !== offlineStatus.networkQuality) {\n        addNetworkEvent(\"quality-change\", {\n          oldQuality: offlineStatus.networkQuality,\n          newQuality,\n          networkInfo,\n        });\n      }\n\n      queryClient.invalidateQueries({ queryKey: [\"network\", \"status\"] });\n    };\n\n    // Listen for online/offline events\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes if supported\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n    if (connection) {\n      connection.addEventListener(\"change\", handleConnectionChange);\n    }\n\n    // Set initial online status\n    if (navigator.onLine && !lastOnline) {\n      setLastOnline(new Date());\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      if (connection) {\n        connection.removeEventListener(\"change\", handleConnectionChange);\n      }\n    };\n    // addNetworkEvent, getNetworkInfo, getNetworkQuality are stable (no/stable deps)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline]);\n\n  return {\n    // Status\n    ...offlineStatus,\n    capabilities,\n\n    // Events\n    networkEvents,\n\n    // Sync management\n    queueForSync,\n    clearSyncQueue,\n    retrySync,\n    processSyncQueue,\n\n    // Computed properties\n    connectionStrength: offlineStatus?.networkQuality || NetworkQuality.OFFLINE,\n    canPerformOperations: offlineStatus?.isOnline || false,\n    needsSync: (offlineStatus?.syncQueueSize || 0) > 0,\n\n    // Helper methods\n    isGoodConnection:\n      offlineStatus?.networkQuality === NetworkQuality.EXCELLENT ||\n      offlineStatus?.networkQuality === NetworkQuality.GOOD,\n    isPoorConnection: offlineStatus?.networkQuality === NetworkQuality.POOR,\n    hasRecentEvents:\n      networkEvents.filter((e) => Date.now() - e.timestamp.getTime() < 60000)\n        .length > 0,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/usePerformance.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (248). Maximum allowed is 150.",
        "line": 78,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 382,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * usePerformance Hook - Performance Monitoring\n *\n * Monitor application performance metrics, identify bottlenecks, and provide\n * optimization recommendations.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Performance metric types\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  lcp: number; // Largest Contentful Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout Shift\n\n  // Loading performance\n  domContentLoaded: number;\n  loadComplete: number;\n  firstPaint: number;\n  firstContentfulPaint: number;\n\n  // Memory usage\n  memoryUsed: number;\n  memoryTotal: number;\n  memoryUsagePercent: number;\n\n  // Network\n  networkType: string;\n  effectiveType: string;\n  downlink: number;\n  rtt: number;\n\n  // Custom metrics\n  componentRenderTime: number;\n  apiResponseTime: number;\n\n  timestamp: Date;\n}\n\n// Performance alert\nexport interface PerformanceAlert {\n  id: string;\n  type: \"warning\" | \"critical\";\n  metric: keyof PerformanceMetrics;\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: Date;\n}\n\n// Performance recommendation\nexport interface PerformanceRecommendation {\n  id: string;\n  category: \"loading\" | \"runtime\" | \"memory\" | \"network\";\n  priority: \"low\" | \"medium\" | \"high\";\n  title: string;\n  description: string;\n  impact: string;\n  effort: string;\n}\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  lcp: { good: 2500, poor: 4000 },\n  fid: { good: 100, poor: 300 },\n  cls: { good: 0.1, poor: 0.25 },\n  memoryUsagePercent: { good: 70, poor: 90 },\n  loadComplete: { good: 3000, poor: 6000 },\n  apiResponseTime: { good: 500, poor: 2000 },\n};\n\n/**\n * Performance Monitoring Hook\n */\nexport const usePerformance = () => {\n  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Get current performance metrics\n  const { data: metrics, isLoading } = useQuery<PerformanceMetrics>({\n    queryKey: [\"performance\", \"metrics\"],\n    queryFn: async () => {\n      const perfMetrics: PerformanceMetrics = {\n        lcp: 0,\n        fid: 0,\n        cls: 0,\n        domContentLoaded: 0,\n        loadComplete: 0,\n        firstPaint: 0,\n        firstContentfulPaint: 0,\n        memoryUsed: 0,\n        memoryTotal: 0,\n        memoryUsagePercent: 0,\n        networkType: \"unknown\",\n        effectiveType: \"unknown\",\n        downlink: 0,\n        rtt: 0,\n        componentRenderTime: 0,\n        apiResponseTime: 0,\n        timestamp: new Date(),\n      };\n\n      // Get performance timing\n      if (performance.timing) {\n        const timing = performance.timing;\n        perfMetrics.domContentLoaded =\n          timing.domContentLoadedEventEnd - timing.navigationStart;\n        perfMetrics.loadComplete = timing.loadEventEnd - timing.navigationStart;\n      }\n\n      // Get paint timing\n      const paintEntries = performance.getEntriesByType(\"paint\");\n      paintEntries.forEach((entry) => {\n        if (entry.name === \"first-paint\") {\n          perfMetrics.firstPaint = entry.startTime;\n        } else if (entry.name === \"first-contentful-paint\") {\n          perfMetrics.firstContentfulPaint = entry.startTime;\n        }\n      });\n\n      // Get memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: {\n              usedJSHeapSize: number;\n              totalJSHeapSize: number;\n            };\n          }\n        ).memory;\n        if (memory) {\n          perfMetrics.memoryUsed = memory.usedJSHeapSize;\n          perfMetrics.memoryTotal = memory.totalJSHeapSize;\n          perfMetrics.memoryUsagePercent =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Get network information\n      const nav = navigator as Navigator & {\n        connection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        mozConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        webkitConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n      };\n      const connection =\n        nav.connection || nav.mozConnection || nav.webkitConnection;\n      if (connection) {\n        perfMetrics.networkType = connection.type || \"unknown\";\n        perfMetrics.effectiveType = connection.effectiveType || \"unknown\";\n        perfMetrics.downlink = connection.downlink || 0;\n        perfMetrics.rtt = connection.rtt || 0;\n      }\n\n      return perfMetrics;\n    },\n    refetchInterval: isMonitoring ? 10000 : false, // Every 10 seconds\n    staleTime: 5000,\n  });\n\n  // Generate performance recommendations\n  const { data: recommendations = [] } = useQuery<PerformanceRecommendation[]>({\n    queryKey: [\"performance\", \"recommendations\", metrics],\n    queryFn: () => {\n      if (!metrics) return [];\n\n      const recs: PerformanceRecommendation[] = [];\n\n      // Loading performance recommendations\n      if (metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.poor) {\n        recs.push({\n          id: \"slow-loading\",\n          category: \"loading\",\n          priority: \"high\",\n          title: \"Slow Page Loading\",\n          description: \"Page load time exceeds recommended thresholds\",\n          impact: \"High - affects user experience and engagement\",\n          effort: \"Medium - requires code splitting and optimization\",\n        });\n      }\n\n      // Memory usage recommendations\n      if (\n        metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.poor\n      ) {\n        recs.push({\n          id: \"high-memory\",\n          category: \"memory\",\n          priority: \"high\",\n          title: \"High Memory Usage\",\n          description: \"Application is using excessive memory\",\n          impact: \"High - can cause crashes and slowdowns\",\n          effort: \"High - requires memory leak investigation\",\n        });\n      }\n\n      // Network recommendations\n      if (metrics.rtt > 500) {\n        recs.push({\n          id: \"high-latency\",\n          category: \"network\",\n          priority: \"medium\",\n          title: \"High Network Latency\",\n          description: \"Network requests are slow\",\n          impact: \"Medium - affects data loading\",\n          effort: \"Low - implement caching strategies\",\n        });\n      }\n\n      return recs;\n    },\n    enabled: Boolean(metrics),\n    staleTime: 60000, // 1 minute\n  });\n\n  // Check for performance issues and generate alerts\n  const checkPerformanceAlerts = useCallback(\n    (currentMetrics: PerformanceMetrics) => {\n      const newAlerts: PerformanceAlert[] = [];\n\n      // Check each threshold\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          newAlerts.push({\n            id: `${key}-critical-${Date.now()}`,\n            type: \"critical\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.poor,\n            message: `${key.toUpperCase()} is critically high: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        } else if (value > thresholds.good) {\n          newAlerts.push({\n            id: `${key}-warning-${Date.now()}`,\n            type: \"warning\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.good,\n            message: `${key.toUpperCase()} exceeds good threshold: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        }\n      });\n\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n    },\n    [],\n  );\n\n  // Monitor performance changes\n  useEffect(() => {\n    if (metrics && isMonitoring) {\n      checkPerformanceAlerts(metrics);\n    }\n  }, [metrics, isMonitoring, checkPerformanceAlerts]);\n\n  // Measure component render time\n  const measureRenderTime = useCallback(\n    (componentName: string, renderFn: () => void) => {\n      const startTime = performance.now();\n      renderFn();\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      logger.debug(\n        `Component ${componentName} render time: ${renderTime.toFixed(2)}ms`,\n      );\n      return renderTime;\n    },\n    [],\n  );\n\n  // Measure API response time\n  const measureApiTime = useCallback(\n    async <T>(apiCall: () => Promise<T>): Promise<T> => {\n      const startTime = performance.now();\n      try {\n        const result = await apiCall();\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.debug(`API response time: ${responseTime.toFixed(2)}ms`);\n        return { result, responseTime };\n      } catch (error) {\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.warn(`API error after ${responseTime.toFixed(2)}ms`, error);\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // Clear old alerts\n  const clearOldAlerts = useCallback(() => {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    setAlerts((prev) => prev.filter((alert) => alert.timestamp > oneHourAgo));\n  }, []);\n\n  // Performance score calculation\n  const performanceScore = useCallback(\n    (currentMetrics: PerformanceMetrics): number => {\n      if (!currentMetrics) return 0;\n\n      let score = 100;\n\n      // Deduct points for poor metrics\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          score -= 30;\n        } else if (value > thresholds.good) {\n          score -= 15;\n        }\n      });\n\n      return Math.max(0, score);\n    },\n    [],\n  );\n\n  return {\n    // Current metrics\n    metrics,\n    isLoading,\n\n    // Performance insights\n    performanceScore: metrics ? performanceScore(metrics) : 0,\n    recommendations,\n    alerts,\n\n    // Controls\n    isMonitoring,\n    setIsMonitoring,\n    clearOldAlerts,\n\n    // Measurement tools\n    measureRenderTime,\n    measureApiTime,\n\n    // Computed properties\n    isPerformant: metrics ? performanceScore(metrics) > 80 : false,\n    hasIssues: alerts.length > 0,\n    criticalIssues: alerts.filter((a) => a.type === \"critical\").length,\n    warningIssues: alerts.filter((a) => a.type === \"warning\").length,\n\n    // Quick checks\n    isSlowLoading: metrics?.loadComplete\n      ? metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.good\n      : false,\n    isHighMemory: metrics?.memoryUsagePercent\n      ? metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.good\n      : false,\n    isSlowNetwork: metrics?.rtt ? metrics.rtt > 500 : false,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/task-filter-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/task-sort-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useCountdownTimer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskAssignment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskCRUD.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useEmergencyUnlockModal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/usePauseResumeControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useTrackerStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/useTheme.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 369,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 369,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [10161, 10191],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 396,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 396,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [11075, 11105],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievementGallery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievements.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (225). Maximum allowed is 150.",
        "line": 25,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 345,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useAchievements Hook\n * React hook for managing achievements and progress\n */\n\nimport { useEffect, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService, achievementEngine } from \"../services\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  AchievementCategory,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<AchievementCategory, number>;\n  recentAchievements: DBUserAchievement[];\n}\n\nexport const useAchievements = (userId?: string) => {\n  const queryClient = useQueryClient();\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get all available achievements\n   */\n  const { data: allAchievements = [], isLoading: isLoadingAchievements } =\n    useQuery({\n      queryKey: [\"achievements\"],\n      queryFn: () => achievementDBService.getAllAchievements(),\n      enabled: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n\n  /**\n   * Get user's earned achievements\n   */\n  const { data: userAchievements = [], isLoading: isLoadingUserAchievements } =\n    useQuery({\n      queryKey: [\"achievements\", \"user\", userId],\n      queryFn: () => achievementDBService.getUserAchievements(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  const { data: visibleAchievements = [] } = useQuery({\n    queryKey: [\"achievements\", \"visible\", userId],\n    queryFn: () => achievementDBService.getUserVisibleAchievements(userId!),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's achievement progress\n   */\n  const { data: achievementProgress = [], isLoading: isLoadingProgress } =\n    useQuery({\n      queryKey: [\"achievements\", \"progress\", userId],\n      queryFn: () => achievementDBService.getUserAchievementProgress(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get unread notifications\n   */\n  const { data: unreadNotifications = [], isLoading: isLoadingNotifications } =\n    useQuery({\n      queryKey: [\"achievements\", \"notifications\", userId],\n      queryFn: () => achievementDBService.getUserUnreadNotifications(userId!),\n      enabled: Boolean(userId),\n      refetchInterval: 30 * 1000, // Check every 30 seconds\n    });\n\n  /**\n   * Get achievement statistics\n   */\n  const { data: achievementStats, isLoading: isLoadingStats } = useQuery({\n    queryKey: [\"achievements\", \"stats\", userId],\n    queryFn: async (): Promise<AchievementStats> => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const [stats, achievements] = await Promise.all([\n        achievementDBService.getUserAchievementStats(userId),\n        achievementDBService.getUserAchievements(userId),\n      ]);\n\n      // Get recent achievements (last 5)\n      const recentAchievements = achievements\n        .sort(\n          (a: DBUserAchievement, b: DBUserAchievement) =>\n            b.earnedAt.getTime() - a.earnedAt.getTime(),\n        )\n        .slice(0, 5);\n\n      return {\n        ...stats,\n        recentAchievements,\n      };\n    },\n    enabled: Boolean(userId),\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Toggle achievement visibility\n   */\n  const toggleVisibilityMutation = useMutation({\n    mutationFn: ({ achievementId }: { achievementId: string }) =>\n      achievementDBService.toggleAchievementVisibility(userId!, achievementId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"visible\", userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"user\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Mark notification as read\n   */\n  const markNotificationReadMutation = useMutation({\n    mutationFn: (notificationId: string) =>\n      achievementDBService.markNotificationRead(notificationId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"notifications\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Perform full achievement check\n   */\n  const performFullCheckMutation = useMutation({\n    mutationFn: () => achievementEngine.performFullCheck(userId!),\n    onSuccess: () => {\n      // Invalidate all achievement-related queries\n      queryClient.invalidateQueries({ queryKey: [\"achievements\"] });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  // ==================== HELPER FUNCTIONS ====================\n\n  /**\n   * Get achievement by ID\n   */\n  const getAchievementById = useCallback(\n    (achievementId: string): DBAchievement | undefined => {\n      return allAchievements.find((a: DBAchievement) => a.id === achievementId);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Check if user has specific achievement\n   */\n  const hasAchievement = useCallback(\n    (achievementId: string): boolean => {\n      return userAchievements.some(\n        (ua: DBUserAchievement) => ua.achievementId === achievementId,\n      );\n    },\n    [userAchievements],\n  );\n\n  /**\n   * Get progress for specific achievement\n   */\n  const getProgressForAchievement = useCallback(\n    (achievementId: string): DBAchievementProgress | undefined => {\n      return achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievementId,\n      );\n    },\n    [achievementProgress],\n  );\n\n  /**\n   * Get achievements by category\n   */\n  const getAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBAchievement[] => {\n      return allAchievements.filter(\n        (a: DBAchievement) => a.category === category,\n      );\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Get user's achievements by category\n   */\n  const getUserAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBUserAchievement[] => {\n      const categoryAchievementIds = allAchievements\n        .filter((a: DBAchievement) => a.category === category)\n        .map((a: DBAchievement) => a.id);\n\n      return userAchievements.filter((ua: DBUserAchievement) =>\n        categoryAchievementIds.includes(ua.achievementId),\n      );\n    },\n    [allAchievements, userAchievements],\n  );\n\n  /**\n   * Get achievements with progress information\n   */\n  const getAchievementsWithProgress = useCallback(() => {\n    return allAchievements.map((achievement: DBAchievement) => {\n      const userAchievement = userAchievements.find(\n        (ua: DBUserAchievement) => ua.achievementId === achievement.id,\n      );\n      const progress = achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievement.id,\n      );\n\n      return {\n        achievement,\n        userAchievement,\n        progress: progress\n          ? {\n              currentValue: progress.currentValue,\n              targetValue: progress.targetValue,\n              percentage: Math.min(\n                (progress.currentValue / progress.targetValue) * 100,\n                100,\n              ),\n              isCompleted: progress.isCompleted,\n            }\n          : null,\n        isEarned: Boolean(userAchievement),\n        isVisible: userAchievement?.isVisible ?? true,\n      };\n    });\n  }, [allAchievements, userAchievements, achievementProgress]);\n\n  // ==================== ACTIONS ====================\n\n  const toggleAchievementVisibility = useCallback(\n    (achievementId: string) => {\n      if (!userId) return;\n      toggleVisibilityMutation.mutate({ achievementId });\n    },\n    [userId, toggleVisibilityMutation],\n  );\n\n  const markNotificationRead = useCallback(\n    (notificationId: string) => {\n      markNotificationReadMutation.mutate(notificationId);\n    },\n    [markNotificationReadMutation],\n  );\n\n  const performFullCheck = useCallback(() => {\n    if (!userId) return;\n    performFullCheckMutation.mutate();\n  }, [userId, performFullCheckMutation]);\n\n  // ==================== EFFECTS ====================\n\n  /**\n   * Initialize achievement engine on mount\n   */\n  useEffect(() => {\n    achievementEngine.initialize().catch((error) => {\n      logger.error(\n        \"Failed to initialize achievement engine\",\n        error,\n        \"useAchievements\",\n      );\n    });\n  }, []);\n\n  // ==================== RETURN ====================\n\n  return {\n    // Data\n    allAchievements,\n    userAchievements,\n    visibleAchievements,\n    achievementProgress,\n    unreadNotifications,\n    achievementStats,\n\n    // Loading states\n    isLoading: isLoadingAchievements || isLoadingUserAchievements,\n    isLoadingProgress,\n    isLoadingNotifications,\n    isLoadingStats,\n\n    // Helper functions\n    getAchievementById,\n    hasAchievement,\n    getProgressForAchievement,\n    getAchievementsByCategory,\n    getUserAchievementsByCategory,\n    getAchievementsWithProgress,\n\n    // Actions\n    toggleAchievementVisibility,\n    markNotificationRead,\n    performFullCheck,\n\n    // Mutation states\n    isTogglingVisibility: toggleVisibilityMutation.isPending,\n    isMarkingRead: markNotificationReadMutation.isPending,\n    isPerformingCheck: performFullCheckMutation.isPending,\n  };\n};\n\n/**\n * Hook for achievement notifications (can be used globally)\n */\nexport const useAchievementNotifications = (userId?: string) => {\n  const { unreadNotifications, markNotificationRead, isLoadingNotifications } =\n    useAchievements(userId);\n\n  return {\n    notifications: unreadNotifications,\n    isLoading: isLoadingNotifications,\n    markAsRead: markNotificationRead,\n    hasUnread: unreadNotifications.length > 0,\n    unreadCount: unreadNotifications.length,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useKeyholderRelationships.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 35,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 52,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 77,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useLeaderboards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/usePauseState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRelationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRulesPage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionPersistence.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionTimer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSpecialChallenges.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (195). Maximum allowed is 150.",
        "line": 27,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 267,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport { goalDBService } from \"@/services/database/GoalDBService\";\nimport type { DBGoal } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { useAchievementIntegration } from \"@/constants/challengeAchievements\";\n\nconst logger = serviceLogger(\"useSpecialChallenges\");\n\nexport interface SpecialChallengeStatus {\n  locktober: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n  noNutNovember: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n}\n\n/**\n * Hook for managing special challenge goals (Locktober, No Nut November)\n */\nexport const useSpecialChallenges = (userId: string | null) => {\n  const [challengeStatus, setChallengeStatus] =\n    useState<SpecialChallengeStatus>({\n      locktober: { available: false, active: false, completed: false },\n      noNutNovember: { available: false, active: false, completed: false },\n    });\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const { checkForChallengeAchievements } = useAchievementIntegration();\n\n  /**\n   * Check if challenges are available based on current date\n   */\n  const checkChallengeAvailability = useCallback(() => {\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth(); // 0-based\n\n    return {\n      locktober: currentMonth === 9, // October\n      noNutNovember: currentMonth === 10, // November\n    };\n  }, []);\n\n  /**\n   * Load challenge status for the user\n   */\n  const loadChallengeStatus = useCallback(async () => {\n    if (!userId) {\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const availability = checkChallengeAvailability();\n      const specialGoals = await goalDBService.getSpecialChallengeGoals(userId);\n      const currentYear = new Date().getFullYear();\n\n      // Find current year's goals\n      const locktoberGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"locktober\" &&\n          goal.challengeYear === currentYear,\n      );\n      const noNutGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"no_nut_november\" &&\n          goal.challengeYear === currentYear,\n      );\n\n      setChallengeStatus({\n        locktober: {\n          available: availability.locktober,\n          active: !!locktoberGoal && !locktoberGoal.isCompleted,\n          completed: !!locktoberGoal?.isCompleted,\n          goal: locktoberGoal,\n        },\n        noNutNovember: {\n          available: availability.noNutNovember,\n          active: !!noNutGoal && !noNutGoal.isCompleted,\n          completed: !!noNutGoal?.isCompleted,\n          goal: noNutGoal,\n        },\n      });\n\n      logger.debug(\"Loaded challenge status\", {\n        userId,\n        hasLocktober: !!locktoberGoal,\n        hasNoNut: !!noNutGoal,\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Unknown error\";\n      setError(errorMessage);\n      logger.error(\"Failed to load challenge status\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, checkChallengeAvailability]);\n\n  /**\n   * Join a special challenge\n   */\n  const joinChallenge = useCallback(\n    async (challengeType: \"locktober\" | \"no_nut_november\") => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        setError(null);\n        const goal = await goalDBService.getOrCreateChallengeGoal(\n          userId,\n          challengeType,\n        );\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"User joined challenge\", {\n          userId,\n          challengeType,\n          goalId: goal.id,\n        });\n        return goal;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to join challenge\";\n        setError(errorMessage);\n        logger.error(\"Failed to join challenge\", {\n          error: err,\n          userId,\n          challengeType,\n        });\n        throw err;\n      }\n    },\n    [userId, loadChallengeStatus],\n  );\n\n  /**\n   * Update challenge progress\n   */\n  const updateChallengeProgress = useCallback(\n    async (\n      challengeType: \"locktober\" | \"no_nut_november\",\n      progressValue: number,\n    ) => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        const challengeMap = {\n          locktober: challengeStatus.locktober,\n          no_nut_november: challengeStatus.noNutNovember,\n        };\n        const challenge =\n          challengeMap[challengeType as keyof typeof challengeMap];\n        if (!challenge.goal) {\n          throw new Error(\"Challenge goal not found\");\n        }\n\n        await goalDBService.updateGoalProgress(\n          challenge.goal.id,\n          progressValue,\n        );\n\n        // Check if challenge was completed and trigger achievements\n        const updatedGoal = await goalDBService.findById(challenge.goal.id);\n        if (updatedGoal?.isCompleted) {\n          await checkForChallengeAchievements({\n            challengeType: updatedGoal.challengeType,\n            challengeYear: updatedGoal.challengeYear,\n            isCompleted: updatedGoal.isCompleted,\n          });\n        }\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"Updated challenge progress\", {\n          userId,\n          challengeType,\n          progressValue,\n          goalId: challenge.goal.id,\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to update progress\";\n        setError(errorMessage);\n        logger.error(\"Failed to update challenge progress\", {\n          error: err,\n          userId,\n          challengeType,\n          progressValue,\n        });\n        throw err;\n      }\n    },\n    [\n      userId,\n      challengeStatus,\n      loadChallengeStatus,\n      checkForChallengeAchievements,\n    ],\n  );\n\n  /**\n   * Get progress percentage for a challenge\n   */\n  const getChallengeProgress = useCallback(\n    (challengeType: \"locktober\" | \"no_nut_november\") => {\n      const challenge = challengeStatus[challengeType];\n      if (!challenge.goal) return 0;\n\n      return Math.min(\n        100,\n        (challenge.goal.currentValue / challenge.goal.targetValue) * 100,\n      );\n    },\n    [challengeStatus],\n  );\n\n  // Load challenge status on mount and when userId changes\n  useEffect(() => {\n    loadChallengeStatus();\n  }, [userId, checkChallengeAvailability, loadChallengeStatus]);\n\n  // Refresh status every hour to check for date changes\n  useEffect(() => {\n    const interval = setInterval(\n      () => {\n        const availability = checkChallengeAvailability();\n        setChallengeStatus((prev) => ({\n          ...prev,\n          locktober: { ...prev.locktober, available: availability.locktober },\n          noNutNovember: {\n            ...prev.noNutNovember,\n            available: availability.noNutNovember,\n          },\n        }));\n      },\n      60 * 60 * 1000,\n    ); // Check every hour\n\n    return () => clearInterval(interval);\n  }, [checkChallengeAvailability]);\n\n  return {\n    challengeStatus,\n    isLoading,\n    error,\n    joinChallenge,\n    updateChallengeProgress,\n    getChallengeProgress,\n    refreshStatus: loadChallengeStatus,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSync.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useTrackerHandlers.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setCurrentSession'. Either include it or remove the dependency array. If 'setCurrentSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 77,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 77,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setCurrentSession]",
            "fix": { "range": [2443, 2445], "text": "[setCurrentSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'backupSession'. Either include it or remove the dependency array. If 'backupSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 88,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 88,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [backupSession, currentSession, isSessionInitialized]",
            "fix": {
              "range": [2846, 2884],
              "text": "[backupSession, currentSession, isSessionInitialized]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/AchievementPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/ChastityTracking.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (162). Maximum allowed is 150.",
        "line": 226,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 414,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from \"react\";\nimport { RestoreSessionPrompt } from \"../components/tracker/RestoreSessionPrompt\";\nimport { SessionLoader } from \"../components/tracker/SessionLoader\";\nimport { SessionRecoveryModal } from \"../components/tracker/SessionRecoveryModal\";\nimport { TrackerStats } from \"../components/tracker/TrackerStats\";\nimport { ActionButtons } from \"../components/tracker/ActionButtons\";\nimport { PauseResumeButtons } from \"../components/tracker/PauseResumeButtons\";\n// TODO: CooldownTimer temporarily disabled due to service import restrictions\n// import { CooldownTimer } from \"../components/tracker/CooldownTimer\";\nimport { ReasonModals } from \"../components/tracker/ReasonModals\";\nimport { TrackerHeader } from \"../components/tracker/TrackerHeader\";\nimport { useSessionPersistence } from \"../hooks/useSessionPersistence\";\nimport { useAuth } from \"../hooks/api/useAuth\";\nimport { useTrackerHandlers } from \"../hooks/useTrackerHandlers\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession } from \"../types/database\";\nimport type { SessionRestorationResult } from \"../services/SessionPersistenceService\";\nimport type { User } from \"../types/auth\";\n\n// Helper function to handle session restoration\nconst createSessionRestorationHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    startHeartbeat: (sessionId: string) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n  ) =>\n  (result: SessionRestorationResult) => {\n    logger.info(\"Session restoration completed\", {\n      wasRestored: result.wasRestored,\n      sessionId: result.session?.id,\n    });\n\n    if (result.session) {\n      setCurrentSession(result.session);\n      startHeartbeat(result.session.id);\n\n      // If session had validation issues but was recovered, show recovery modal\n      if (result.error && result.session) {\n        setCorruptedSession(result.session);\n        setShowSessionRecovery(true);\n      }\n    }\n  };\n\n// Helper function to handle session recovery\nconst createSessionRecoveryHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    backupSession: (session: DBSession) => Promise<void>,\n    startHeartbeat: (sessionId: string) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n  ) =>\n  async (session: DBSession) => {\n    logger.info(\"Session recovery initiated\", { sessionId: session.id });\n    try {\n      await backupSession(session);\n      setCurrentSession(session);\n      startHeartbeat(session.id);\n      setShowSessionRecovery(false);\n      setCorruptedSession(null);\n      logger.info(\"Session recovery completed\", { sessionId: session.id });\n    } catch (error) {\n      logger.error(\"Session recovery failed\", { error: error as Error });\n    }\n  };\n\n// Helper function to handle session discard\nconst createSessionDiscardHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    stopHeartbeat: () => void,\n  ) =>\n  () => {\n    setCurrentSession(null);\n    setShowSessionRecovery(false);\n    setCorruptedSession(null);\n    stopHeartbeat();\n    logger.info(\"Corrupted session discarded\");\n  };\n\n// Session Persistence Error Component\nconst SessionPersistenceError: React.FC<{ error: string }> = ({ error }) => (\n  <div className=\"mx-4 mb-4 p-3 bg-red-900/50 border border-red-500 rounded-lg\">\n    <p className=\"text-sm text-red-200\">\n      <strong>Session Error:</strong> {error}\n    </p>\n  </div>\n);\n\n// Cooldown Display Component\nconst CooldownDisplay: React.FC<{\n  pauseState: { cooldownRemaining?: number } | null;\n}> = ({ pauseState }) => {\n  if (!pauseState?.cooldownRemaining) return null;\n\n  return (\n    <div className=\"mx-4 text-center\">\n      <div className=\"text-yellow-600\">\n        Cooldown: {pauseState.cooldownRemaining}s remaining\n      </div>\n    </div>\n  );\n};\n\n// Debug Panel Component\ninterface PauseState {\n  canPause: boolean;\n  cooldownRemaining?: number;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n}\n\nconst DebugPanel: React.FC<{\n  pauseState: PauseState | null;\n  pauseStateLoading: boolean;\n  pauseStateError: string | null;\n}> = ({ pauseState, pauseStateLoading, pauseStateError }) => {\n  if (process.env.NODE_ENV !== \"development\") return null;\n\n  return (\n    <div className=\"mt-8 p-4 bg-gray-800 rounded-lg text-xs\">\n      <h4 className=\"text-yellow-400 font-bold mb-2\">Debug: Pause State</h4>\n      <pre className=\"text-gray-300\">\n        {JSON.stringify(\n          {\n            canPause: pauseState?.canPause,\n            cooldownRemaining: pauseState?.cooldownRemaining,\n            lastPauseTime: pauseState?.lastPauseTime,\n            nextPauseAvailable: pauseState?.nextPauseAvailable,\n            isLoading: pauseStateLoading,\n            error: pauseStateError,\n          },\n          null,\n          2,\n        )}\n      </pre>\n    </div>\n  );\n};\n\n// Custom hook for session state management\nconst useSessionState = () => {\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [showSessionRecovery, setShowSessionRecovery] = useState(false);\n  const [isSessionInitialized, setIsSessionInitialized] = useState(false);\n  const [corruptedSession, setCorruptedSession] = useState<DBSession | null>(\n    null,\n  );\n\n  return {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  };\n};\n\n// Custom hook for mock data (temporary until real implementation)\nconst useMockData = (user: User | null) => {\n  // Mock pause state data for now\n  const pauseState: PauseState = {\n    canPause: true,\n    cooldownRemaining: undefined,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n  };\n  const pauseStateLoading = false;\n  const pauseStateError = null;\n  const refreshPauseState = () => {};\n\n  // Mock session data - replace with real session management\n  const mockSessionData = {\n    isCageOn: true,\n    isPaused: false,\n    remainingGoalTime: 3600,\n    keyholderName: \"Keyholder\",\n    savedSubmissivesName: \"Submissive\",\n    requiredKeyholderDurationSeconds: 7200,\n    mainChastityDisplayTime: 3600,\n    topBoxLabel: \"Total Locked Time\",\n    topBoxTime: \"1d 2h 3m\",\n    livePauseDuration: 0,\n    accumulatedPauseTimeThisSession: 0,\n    timeCageOff: 0,\n    totalChastityTime: 86400,\n    totalTimeCageOff: 0,\n    showRestoreSessionPrompt: false,\n    pauseCooldownMessage: null,\n    denialCooldownActive: false,\n    hasPendingReleaseRequest: false,\n    isGoalActive: true,\n    isHardcoreGoal: false,\n    showReasonModal: false,\n    showPauseReasonModal: false,\n    useRealTimeTimer: false, // Feature flag for real-time timer\n    sessionId: \"mock-session-123\",\n    userId: user?.uid || \"mock-user-123\",\n  };\n\n  // Override pause state for demo - show that pause is available\n  const mockPauseState = {\n    canPause: true,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n    cooldownRemaining: undefined,\n  };\n\n  return {\n    pauseState,\n    pauseStateLoading,\n    pauseStateError,\n    refreshPauseState,\n    ...mockSessionData,\n    mockPauseState,\n  };\n};\n\nconst TrackerPage: React.FC = () => {\n  // Authentication state\n  const { user, isLoading: authLoading } = useAuth();\n\n  // Session persistence state\n  const {\n    isInitializing,\n    error: persistenceError,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n  } = useSessionPersistence({\n    userId: user?.uid,\n    autoInitialize: true,\n  });\n\n  // Session state management\n  const {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  } = useSessionState();\n\n  // Mock data (replace with real hooks)\n  const mockData = useMockData(user);\n\n  // Use tracker handlers hook for event handlers and effects\n  const {\n    handleSessionInitialized,\n    handleEmergencyUnlock,\n    handlePause,\n    handleResume,\n  } = useTrackerHandlers({\n    setCurrentSession,\n    setIsSessionInitialized,\n    startHeartbeat,\n    stopHeartbeat,\n    backupSession,\n    mockData: {\n      sessionId: mockData.sessionId,\n      userId: mockData.userId,\n      refreshPauseState: mockData.refreshPauseState,\n    },\n    currentSession,\n    isSessionInitialized,\n  });\n\n  // Create handlers using helper functions\n  const handleSessionRestored = createSessionRestorationHandler(\n    setCurrentSession,\n    startHeartbeat,\n    setCorruptedSession,\n    setShowSessionRecovery,\n  );\n\n  const handleRecoverSession = createSessionRecoveryHandler(\n    setCurrentSession,\n    backupSession,\n    startHeartbeat,\n    setShowSessionRecovery,\n    setCorruptedSession,\n  );\n\n  const handleDiscardSession = createSessionDiscardHandler(\n    setCurrentSession,\n    setShowSessionRecovery,\n    setCorruptedSession,\n    stopHeartbeat,\n  );\n\n  // Helper to compute TrackerStats props based on timer mode\n  const getTrackerStatsProps = () => {\n    const baseProps = {\n      topBoxLabel: mockData.topBoxLabel,\n      timeCageOff: mockData.timeCageOff,\n      isCageOn: mockData.isCageOn,\n      totalChastityTime: mockData.totalChastityTime,\n      totalTimeCageOff: mockData.totalTimeCageOff,\n      isPaused: mockData.isPaused,\n    };\n\n    if (mockData.useRealTimeTimer) {\n      return {\n        ...baseProps,\n        currentSession,\n        mainChastityDisplayTime: undefined,\n        topBoxTime: undefined,\n        livePauseDuration: undefined,\n        accumulatedPauseTimeThisSession: undefined,\n      };\n    }\n\n    return {\n      ...baseProps,\n      currentSession: undefined,\n      mainChastityDisplayTime: mockData.mainChastityDisplayTime,\n      topBoxTime: mockData.topBoxTime,\n      livePauseDuration: mockData.livePauseDuration,\n      accumulatedPauseTimeThisSession: mockData.accumulatedPauseTimeThisSession,\n    };\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Session Persistence Loading */}\n      {(authLoading || isInitializing) && user?.uid && (\n        <SessionLoader\n          userId={user.uid}\n          onSessionRestored={handleSessionRestored}\n          onInitialized={handleSessionInitialized}\n        />\n      )}\n\n      {/* Session Recovery Modal */}\n      {showSessionRecovery && corruptedSession && (\n        <SessionRecoveryModal\n          corruptedSession={corruptedSession}\n          onRecover={handleRecoverSession}\n          onDiscard={handleDiscardSession}\n        />\n      )}\n\n      {/* Session Persistence Error */}\n      {persistenceError && <SessionPersistenceError error={persistenceError} />}\n\n      {mockData.showRestoreSessionPrompt && (\n        <RestoreSessionPrompt onConfirm={() => {}} onDiscard={() => {}} />\n      )}\n\n      <TrackerHeader\n        remainingGoalTime={mockData.remainingGoalTime}\n        keyholderName={mockData.keyholderName}\n        savedSubmissivesName={mockData.savedSubmissivesName}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        isCageOn={mockData.isCageOn}\n        denialCooldownActive={mockData.denialCooldownActive}\n        pauseCooldownMessage={mockData.pauseCooldownMessage}\n      />\n\n      <TrackerStats {...getTrackerStatsProps()} />\n\n      {/* Enhanced Pause Controls with 4-hour cooldown */}\n      {mockData.isCageOn && currentSession && (\n        <>\n          <CooldownDisplay pauseState={mockData.pauseState} />\n          <PauseResumeButtons\n            sessionId={currentSession.id}\n            userId={user?.uid || \"\"}\n            isPaused={mockData.isPaused}\n            pauseState={mockData.mockPauseState} // Use mock state to show functionality\n            onPause={handlePause}\n            onResume={handleResume}\n          />\n        </>\n      )}\n\n      <ActionButtons\n        isCageOn={mockData.isCageOn}\n        isGoalActive={mockData.isGoalActive}\n        isHardcoreGoal={mockData.isHardcoreGoal}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        hasPendingReleaseRequest={mockData.hasPendingReleaseRequest}\n        sessionId={mockData.sessionId}\n        userId={mockData.userId}\n        onEmergencyUnlock={handleEmergencyUnlock}\n      />\n\n      <ReasonModals\n        showReasonModal={mockData.showReasonModal}\n        showPauseReasonModal={mockData.showPauseReasonModal}\n      />\n\n      <DebugPanel\n        pauseState={mockData.pauseState}\n        pauseStateLoading={mockData.pauseStateLoading}\n        pauseStateError={mockData.pauseStateError}\n      />\n    </div>\n  );\n};\n\nexport default TrackerPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/Dashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/FullReportPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/LogEventPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/MobileShowcase.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/PublicProfilePage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RelationshipsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RewardsPunishmentsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RulesPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsMainPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/TasksPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ButtonVariantsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/HapticFeedbackDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/InputExamplesDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/PullToRefreshDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ShowcaseHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/SwipeableCardDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ToastDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/TouchTargetsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/EffectiveTimeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/KeyholderRelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseCooldownService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/SessionPersistenceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/TimerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/api/session-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/auth-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/cache-config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/AchievementDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/BaseDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EmergencyService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EventDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/GoalDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/KeyholderRelationshipDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/MigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/PerformanceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/RelationshipChastityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SessionDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SettingsDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/TaskDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementBadgeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementLeaderboardService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementNotificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 86,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 86,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2887, 2890], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2887, 2890], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 90,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 90,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3075, 3078], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3075, 3078], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3262, 3265], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3262, 3265], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityEventService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastitySessionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityTaskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipCoreService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipPermissionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipInviteService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipRoleService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipSearchService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatusService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipValidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/feedbackService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/firebase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/gamificationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/goalStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/healthCheckStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migration/DataMigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migrationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/reportStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/ChastityDB.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/dexie.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/AchievementDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/ConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/EventDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseListeners.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSyncCore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/OfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/RelationshipDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SessionDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SyncConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/TaskDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/UserSettingsSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/connectionStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/themeStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/formStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/keyholderStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/modalStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/navigationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/notificationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/themeStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/uiPreferencesStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test/setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test/utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/database.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/events.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/feedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/pauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/realtime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/relationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/security.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/theme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/dataSyncHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/date.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/time.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goalsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/hash.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/string.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/iconImport.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/logging.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseAnalytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseResumeHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/realtime/notification-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/audit-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/security-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/session-history-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/sessionHistoryHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/calculations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/keyholder.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statistics/predictions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statisticsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/systemInfo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/toastBridge.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 72,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 72,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [2678, 2732], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 92,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 92,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [3186, 3229], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 120,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 120,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [3880, 3944], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 132,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 132,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4245, 4311], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 144,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 144,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [4606, 4671], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 156,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 156,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4972, 5038], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 168,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 168,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [5330, 5393], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "info" },
            "desc": "Remove the console.info()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 180,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 180,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [5691, 5757], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 189,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 189,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [5982, 6048], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 198,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 198,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [6256, 6316], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/vite-env.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/vitest.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
