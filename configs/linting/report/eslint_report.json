[{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/deployment/vercel.build.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/linting/commitlint.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/linting/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/Root.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/Navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementGallery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementGallerySubComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementNotification.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementPageStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementPrivacySettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementViewToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/LeaderboardView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/ConflictResolutionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/DexieDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/SyncStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/DashboardHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/DashboardLayouts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/DashboardMain.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/FeatureCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/database/DatabaseDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/demo/SessionPersistenceDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/examples/IntegratedTaskManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/FeedbackFAB.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/FeedbackModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/full_report/CurrentStatusSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/full_report/SessionHistorySection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/full_report/StatisticsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/full_report/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/goals/SpecialChallengeSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AcceptInviteCodeSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinking.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingDemoComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHelp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/ActiveInviteCodesDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/ActiveKeyholderDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AdminDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/InviteCodeCreationSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/KeyholderPasswordUnlock.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/LinkingMessageDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/RelationshipSummary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/SessionControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/SubmissiveRelationshipsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/TaskManagement.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/TypedKeyholderDemo.tsx","messages":[{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":29,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { \n  useAdminSession, \n  useKeyholderRewards, \n  useKeyholderSession, \n  useMultiWearer \n} from '../../hooks/keyholder';\nimport { KeyholderReward, KeyholderPunishment } from '../../types';\n\nimport { TaskData } from '../../types';\n\ninterface TypedKeyholderDemoProps {\n  userId: string;\n  isAuthReady: boolean;\n  addTask: (taskData: TaskData) => Promise<void>;\n  saveDataToFirestore: (data: Record<string, unknown>) => Promise<void>;\n  requiredKeyholderDurationSeconds: number;\n}\n\n/**\n * Demo component showing how the new TypeScript keyholder hooks work\n * This replaces the need for 'any' types with proper TypeScript interfaces\n */\nexport function TypedKeyholderDemo({\n  userId,\n  isAuthReady,\n  addTask,\n  saveDataToFirestore,\n  requiredKeyholderDurationSeconds,\n}: TypedKeyholderDemoProps): React.JSX.Element {\n  // Admin session management with proper typing\n  const {\n    isAdmin,\n    permissions: adminPermissions,\n  } = useAdminSession({ userId, isAuthReady });\n\n  // Keyholder session management with proper typing\n  const {\n    keyholderSession,\n    isActive: isKeyholderActive,\n  } = useKeyholderSession({ userId, isAuthReady, keyholderName: 'Demo Keyholder' });\n\n  // Rewards and punishments with proper typing\n  const {\n    addReward,\n    addPunishment,\n  } = useKeyholderRewards({\n    userId,\n    addTask,\n    saveDataToFirestore,\n    requiredKeyholderDurationSeconds,\n  });\n\n  // Multi-wearer functionality with proper typing\n  const {\n    session: multiWearerSession,\n    wearers,\n  } = useMultiWearer({ keyholderUserId: userId, isAuthReady });\n\n  // Example of properly typed reward\n  const handleAddTypedReward = async (): Promise<void> => {\n    const reward: KeyholderReward = {\n      type: 'time',\n      timeSeconds: 3600, // 1 hour\n      note: 'Good behavior reward',\n    };\n    \n    try {\n      await addReward(reward);\n    } catch (error) {\n      console.error('Error adding reward:', error);\n    }\n  };\n\n  // Example of properly typed punishment\n  const handleAddTypedPunishment = async (): Promise<void> => {\n    const punishment: KeyholderPunishment = {\n      type: 'time',\n      timeSeconds: 1800, // 30 minutes\n      note: 'Minor infraction',\n    };\n    \n    try {\n      await addPunishment(punishment);\n    } catch (error) {\n      console.error('Error adding punishment:', error);\n    }\n  };\n\n  return (\n    <div className=\"typed-keyholder-demo p-4 bg-gray-800 rounded-lg\">\n      <h3 className=\"text-lg font-semibold mb-4\">TypeScript Keyholder Demo</h3>\n      \n      <div className=\"space-y-4\">\n        {/* Admin Session Status */}\n        <div className=\"admin-status\">\n          <h4 className=\"font-medium\">Admin Session</h4>\n          <p>Status: {isAdmin ? 'Active' : 'Inactive'}</p>\n          {adminPermissions && (\n            <p>Permissions: {Object.keys(adminPermissions).filter(\n              key => adminPermissions[key as keyof typeof adminPermissions]\n            ).join(', ')}</p>\n          )}\n        </div>\n\n        {/* Keyholder Session Status */}\n        <div className=\"keyholder-status\">\n          <h4 className=\"font-medium\">Keyholder Session</h4>\n          <p>Status: {isKeyholderActive ? 'Active' : 'Inactive'}</p>\n          {keyholderSession && (\n            <p>Keyholder: {keyholderSession.keyholderName}</p>\n          )}\n        </div>\n\n        {/* Multi-Wearer Status */}\n        <div className=\"multi-wearer-status\">\n          <h4 className=\"font-medium\">Multi-Wearer Session</h4>\n          <p>Active: {multiWearerSession?.isActive ? 'Yes' : 'No'}</p>\n          <p>Wearers: {wearers.length}</p>\n        </div>\n\n        {/* Demo Actions */}\n        <div className=\"demo-actions space-x-2\">\n          <button \n            onClick={handleAddTypedReward}\n            className=\"px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700\"\n          >\n            Add Typed Reward\n          </button>\n          \n          <button \n            onClick={handleAddTypedPunishment}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Add Typed Punishment\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/AchievementNotifications.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/AppLayout.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setPageTitle'. Either include it or remove the dependency array. Outer scope values like 'navItems' aren't valid dependencies because mutating them doesn't re-render the component.","line":66,"column":6,"nodeType":"ArrayExpression","endLine":66,"endColumn":35,"suggestions":[{"desc":"Update the dependencies array to be: [location.pathname, setPageTitle]","fix":{"range":[2108,2137],"text":"[location.pathname, setPageTitle]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'closeMobileMenu'. Either include it or remove the dependency array.","line":72,"column":6,"nodeType":"ArrayExpression","endLine":72,"endColumn":25,"suggestions":[{"desc":"Update the dependencies array to be: [closeMobileMenu, location.pathname]","fix":{"range":[2350,2369],"text":"[closeMobileMenu, location.pathname]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/MobileMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/NavigationData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/EventList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/LogEventForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/BottomNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/BottomSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/MobileButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/MobileCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/MobileInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/PullToRefresh.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/SwipeableCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/TouchTarget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/VirtualList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/mobile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/modals/PrivacyPolicyModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/modals/privacy/PrivacyPolicyContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/notifications/NotificationToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileAchievements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileErrorStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileRecentAchievements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileStatistics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/PublicProfileHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/ErrorDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/MigrationBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/PendingRequestsList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/RelationshipManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/RelationshipRequestForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/RelationshipsHelp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/RelationshipsList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/LogItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/ManualEntryForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/RewardPunishmentStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/RewardsPunishmentsContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/RewardsPunishmentsControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RuleCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RuleEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RulesPageComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RulesPageControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/AccountSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/DataControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/DisplaySettingsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/PersonalGoalSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/PublicProfileSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/ResetModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/SecuritySettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/SessionEditSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/ToggleSwitch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/system/OfflineStatus.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (81). Maximum allowed is 75.","line":11,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":101,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Offline Status Component\n * Shows the status of the offline queue and sync operations\n * Demonstrates the complete Firebase ‚Üî Dexie ‚Üî TanStack Query architecture\n */\nimport React, { useState } from \"react\";\nimport { useOfflineQueueStats } from \"../../hooks/api\";\nimport { useNotificationActions } from \"../../stores\";\nimport { FaWifi, FaWifiSlash, FaSync } from \"../../utils/iconImport\";\n\nexport const OfflineStatus: React.FC = () => {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const { data: queueStats } = useOfflineQueueStats();\n  const { showInfo } = useNotificationActions();\n\n  // Listen for online/offline events\n  React.useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      showInfo(\n        \"Back online! Syncing pending changes...\",\n        \"Connection Restored\",\n      );\n    };\n\n    const handleOffline = () => {\n      setIsOnline(false);\n      showInfo(\n        \"You're offline. Changes will sync when connection is restored.\",\n        \"Offline Mode\",\n      );\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n    };\n  }, [showInfo]);\n\n  const statusColor = isOnline\n    ? (queueStats?.pending || 0) > 0\n      ? \"bg-yellow-500\"\n      : \"bg-green-500\"\n    : \"bg-red-500\";\n\n  const statusIcon = isOnline ? (\n    queueStats?.pending ? (\n      <FaSync className=\"animate-spin\" />\n    ) : (\n      <FaWifi />\n    )\n  ) : (\n    <FaWifiSlash />\n  );\n\n  return (\n    <div className=\"fixed bottom-4 right-4 bg-white/10 backdrop-blur-sm border border-white/20 rounded-lg shadow-lg p-4 max-w-sm\">\n      {/* Status Header */}\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"flex items-center gap-2\">\n          <div className={`w-3 h-3 rounded-full ${statusColor}`} />\n          <span className=\"text-sm font-medium text-white\">\n            {isOnline ? \"Online\" : \"Offline\"}\n          </span>\n          {statusIcon}\n        </div>\n      </div>\n\n      {/* Architecture Flow Indicator */}\n      <div className=\"mt-3 pt-3 border-t border-white/10\">\n        <div className=\"text-xs font-medium text-white mb-2\">\n          üéØ Migration Complete\n        </div>\n        <div className=\"flex items-center justify-between text-xs\">\n          <span className=\"text-blue-400\">Firebase</span>\n          <span className=\"text-gray-400\">‚Üî</span>\n          <span className=\"text-green-400\">Dexie</span>\n          <span className=\"text-gray-400\">‚Üî</span>\n          <span className=\"text-purple-400\">TanStack</span>\n          <span className=\"text-gray-400\">‚Üî</span>\n          <span className=\"text-yellow-400\">UI</span>\n        </div>\n        <div className=\"text-center mt-1\">\n          <span className=\"text-xs text-gray-400\">‚Üë</span>\n        </div>\n        <div className=\"text-center\">\n          <span className=\"text-xs text-orange-400\">Zustand</span>\n        </div>\n      </div>\n\n      {/* Implementation Status */}\n      <div className=\"mt-3 p-2 bg-green-500/20 rounded text-xs text-green-200\">\n        <strong>‚úÖ Architecture Ready:</strong> Firebase to TanStack Query\n        migration is complete and functional.\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/CountdownTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/TaskItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/ActionButtons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/CooldownTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/DenialCooldown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/EmergencyUnlockButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/EmergencyUnlockModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (250). Maximum allowed is 75.","line":23,"column":74,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":288,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (92). Maximum allowed is 75.","line":100,"column":23,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":195,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport {\n  FaTimes,\n  FaExclamationTriangle,\n  FaArrowLeft,\n  FaArrowRight,\n} from \"react-icons/fa\";\nimport type { EmergencyUnlockReason } from \"../../types/events\";\nimport { EMERGENCY_UNLOCK_REASONS } from \"../../types/events\";\nimport { useEmergencyUnlockModal } from \"../../hooks/tracker/useEmergencyUnlockModal\";\n\ninterface EmergencyUnlockModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onEmergencyUnlock: (\n    reason: EmergencyUnlockReason,\n    additionalNotes?: string,\n  ) => Promise<void>;\n  sessionId: string;\n  isProcessing?: boolean;\n}\n\nexport const EmergencyUnlockModal: React.FC<EmergencyUnlockModalProps> = ({\n  isOpen,\n  onClose,\n  onEmergencyUnlock,\n  sessionId,\n  isProcessing: _isProcessing = false,\n}) => {\n  const {\n    stage,\n    reason,\n    customReason,\n    confirmText,\n    isSubmitting,\n    setStage,\n    setReason,\n    setCustomReason,\n    setConfirmText,\n    handleEmergencyUnlock,\n    canProceedFromReason,\n    canConfirm,\n    requiredText,\n    confirmInputRef,\n  } = useEmergencyUnlockModal({\n    sessionId,\n    onEmergencyUnlock: async (finalReason, additionalNotes) => {\n      await onEmergencyUnlock(finalReason, additionalNotes);\n      onClose();\n    },\n    isOpen,\n  });\n\n  if (!isOpen) return null;\n\n  const WarningStage = () => (\n    <div className=\"text-center\">\n      <FaExclamationTriangle className=\"text-6xl text-red-400 mx-auto mb-6\" />\n      <h3 className=\"text-xl font-bold mb-4 text-red-300\">\n        üö® Emergency Unlock\n      </h3>\n\n      <div className=\"bg-red-900/30 border border-red-600 rounded-lg p-4 mb-6 text-left\">\n        <h4 className=\"font-semibold text-red-300 mb-2\">\n          ‚ö†Ô∏è Warning: Emergency Use Only\n        </h4>\n        <ul className=\"text-sm text-red-200 space-y-1\">\n          <li>‚Ä¢ This will immediately end your current session</li>\n          <li>‚Ä¢ All session goals and restrictions will be bypassed</li>\n          <li>‚Ä¢ This action will be logged for safety and accountability</li>\n          <li>‚Ä¢ Frequent use may trigger cooldown periods</li>\n          <li>‚Ä¢ Use only in genuine emergency situations</li>\n        </ul>\n      </div>\n\n      <p className=\"text-sm text-gray-300 mb-6\">\n        This feature is designed for medical emergencies, safety concerns,\n        equipment malfunctions, or other urgent situations that genuinely\n        require immediate unlock.\n      </p>\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={() => setStage(\"reason\")}\n          className=\"w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition flex items-center justify-center\"\n        >\n          I Understand - Continue\n          <FaArrowRight className=\"ml-2\" />\n        </button>\n        <button\n          onClick={onClose}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Cancel\n        </button>\n      </div>\n    </div>\n  );\n\n  const ReasonStage = () => (\n    <div>\n      <div className=\"flex items-center mb-6\">\n        <button\n          onClick={() => setStage(\"warning\")}\n          className=\"mr-3 p-1 text-gray-400 hover:text-white transition\"\n          aria-label=\"Go back\"\n        >\n          <FaArrowLeft />\n        </button>\n        <h3 className=\"text-xl font-bold text-red-300\">\n          Select Emergency Reason\n        </h3>\n      </div>\n\n      <p className=\"text-sm text-gray-300 mb-4\">\n        Please select the reason for your emergency unlock. This information\n        helps ensure the feature is used appropriately and safely.\n      </p>\n\n      <div className=\"space-y-3 mb-6\">\n        {EMERGENCY_UNLOCK_REASONS.map((emergencyReason) => (\n          <label\n            key={emergencyReason}\n            className={`flex items-start p-3 rounded-lg border cursor-pointer transition ${\n              reason === emergencyReason\n                ? \"border-red-500 bg-red-900/30\"\n                : \"border-gray-600 bg-gray-800/50 hover:bg-gray-700/50\"\n            }`}\n          >\n            <input\n              type=\"radio\"\n              name=\"emergency-reason\"\n              value={emergencyReason}\n              checked={reason === emergencyReason}\n              onChange={(e) =>\n                setReason(e.target.value as EmergencyUnlockReason)\n              }\n              className=\"mt-1 mr-3 text-red-600\"\n            />\n            <div>\n              <div className=\"font-medium text-white\">{emergencyReason}</div>\n              <div className=\"text-xs text-gray-400 mt-1\">\n                {emergencyReason === \"Medical Emergency\" &&\n                  \"Health-related emergencies requiring immediate unlock\"}\n                {emergencyReason === \"Safety Concern\" &&\n                  \"Physical safety or security situations\"}\n                {emergencyReason === \"Equipment Malfunction\" &&\n                  \"Device failure or malfunction\"}\n                {emergencyReason === \"Urgent Situation\" &&\n                  \"Other urgent circumstances requiring unlock\"}\n                {emergencyReason === \"Other\" &&\n                  \"Custom reason with additional details\"}\n              </div>\n            </div>\n          </label>\n        ))}\n      </div>\n\n      {reason === \"Other\" && (\n        <div className=\"mb-6\">\n          <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n            Please specify the emergency reason:\n          </label>\n          <textarea\n            value={customReason}\n            onChange={(e) => setCustomReason(e.target.value)}\n            placeholder=\"Describe your emergency situation...\"\n            rows={3}\n            className=\"w-full p-3 rounded-lg border border-gray-600 bg-gray-800 text-white focus:border-red-500 focus:ring-1 focus:ring-red-500 resize-none\"\n            maxLength={500}\n          />\n          <div className=\"text-xs text-gray-400 mt-1\">\n            {customReason.length}/500 characters\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={() => setStage(\"confirm\")}\n          disabled={!canProceedFromReason}\n          className=\"w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition flex items-center justify-center\"\n        >\n          Continue to Confirmation\n          <FaArrowRight className=\"ml-2\" />\n        </button>\n        <button\n          onClick={() => setStage(\"warning\")}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Back\n        </button>\n      </div>\n    </div>\n  );\n\n  const ConfirmationStage = () => (\n    <div>\n      <div className=\"flex items-center mb-6\">\n        <button\n          onClick={() => setStage(\"reason\")}\n          className=\"mr-3 p-1 text-gray-400 hover:text-white transition\"\n          aria-label=\"Go back\"\n        >\n          <FaArrowLeft />\n        </button>\n        <h3 className=\"text-xl font-bold text-red-300\">Final Confirmation</h3>\n      </div>\n\n      <div className=\"bg-yellow-900/30 border border-yellow-600 rounded-lg p-4 mb-6\">\n        <h4 className=\"font-semibold text-yellow-300 mb-2\">‚ö†Ô∏è Final Warning</h4>\n        <p className=\"text-sm text-yellow-200 mb-3\">\n          You are about to perform an emergency unlock. This action:\n        </p>\n        <ul className=\"text-sm text-yellow-200 space-y-1 mb-3\">\n          <li>‚Ä¢ Will immediately end session #{sessionId.slice(-8)}</li>\n          <li>‚Ä¢ Cannot be undone</li>\n          <li>‚Ä¢ Will be permanently logged</li>\n          <li>\n            ‚Ä¢ Reason: <strong>{reason}</strong>\n          </li>\n        </ul>\n      </div>\n\n      <div className=\"mb-6\">\n        <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n          Type \"{requiredText}\" to confirm:\n        </label>\n        <input\n          ref={confirmInputRef}\n          type=\"text\"\n          value={confirmText}\n          onChange={(e) => setConfirmText(e.target.value.toUpperCase())}\n          placeholder={requiredText}\n          className={`w-full p-3 rounded-lg border bg-gray-800 text-white text-center font-mono text-lg tracking-widest focus:ring-2 transition ${\n            confirmText === requiredText\n              ? \"border-green-500 focus:ring-green-500\"\n              : \"border-gray-600 focus:ring-red-500\"\n          }`}\n          maxLength={requiredText.length}\n        />\n        <div className=\"text-xs text-gray-400 mt-1 text-center\">\n          {confirmText.length}/{requiredText.length} characters\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={handleEmergencyUnlock}\n          disabled={!canConfirm || isSubmitting}\n          className=\"w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          {isSubmitting\n            ? \"Processing Emergency Unlock...\"\n            : \"üö® EMERGENCY UNLOCK üö®\"}\n        </button>\n        <button\n          onClick={() => setStage(\"reason\")}\n          disabled={isSubmitting}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Back to Reason Selection\n        </button>\n      </div>\n    </div>\n  );\n\n  return (\n    <div className=\"fixed inset-0 bg-black/75 backdrop-blur-sm z-50 flex items-center justify-center p-4\">\n      <div className=\"bg-gradient-to-br from-gray-900 to-gray-800 max-w-md w-full rounded-xl border-2 border-red-500 shadow-2xl\">\n        <div className=\"relative p-6\">\n          <button\n            onClick={onClose}\n            disabled={isSubmitting}\n            className=\"absolute top-4 right-4 text-gray-400 hover:text-white transition-colors disabled:cursor-not-allowed\"\n            aria-label=\"Close modal\"\n          >\n            <FaTimes size={20} />\n          </button>\n\n          {stage === \"warning\" && <WarningStage />}\n          {stage === \"reason\" && <ReasonStage />}\n          {stage === \"confirm\" && <ConfirmationStage />}\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/GoalDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/KeyholderRequirement.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/PauseCooldownMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/PauseResumeButtons.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (79). Maximum allowed is 75.","line":89,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":172,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { usePauseResumeControls } from \"../../hooks/tracker/usePauseResumeControls\";\n\n// Temporary types until proper hook pattern is implemented\ntype EnhancedPauseReason = \"Bathroom Break\" | \"Emergency\" | \"Medical\" | \"Other\";\n\ntype PauseState = {\n  canPause: boolean;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n  cooldownRemaining?: number;\n};\n\n// PauseButton sub-component\ninterface PauseButtonProps {\n  canPause: boolean;\n  isLoading: boolean;\n  onPauseClick: () => void;\n  pauseButtonStyling: string;\n  pauseButtonText: string;\n}\n\nconst PauseButton: React.FC<PauseButtonProps> = ({\n  canPause,\n  isLoading,\n  onPauseClick,\n  pauseButtonStyling,\n  pauseButtonText,\n}) => (\n  <div className=\"flex justify-center mb-8\">\n    <button\n      type=\"button\"\n      onClick={onPauseClick}\n      disabled={!canPause || isLoading}\n      className={`glass-button font-bold py-3 px-6 shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 ${pauseButtonStyling}`}\n    >\n      ‚è∏Ô∏è {pauseButtonText}\n    </button>\n  </div>\n);\n\n// ResumeButton sub-component\ninterface ResumeButtonProps {\n  isLoading: boolean;\n  onResumeClick: () => void;\n}\n\nconst ResumeButton: React.FC<ResumeButtonProps> = ({\n  isLoading,\n  onResumeClick,\n}) => (\n  <div className=\"flex justify-center mb-8\">\n    <button\n      type=\"button\"\n      onClick={onResumeClick}\n      disabled={isLoading}\n      className=\"glass-button bg-gradient-to-r from-green-600/80 to-emerald-600/80 hover:from-green-500/90 hover:to-emerald-500/90 text-white font-bold py-3 px-6 shadow-lg hover:shadow-green-500/20 transition-all duration-300 transform hover:scale-105 disabled:opacity-50\"\n    >\n      ‚ñ∂Ô∏è {isLoading ? \"Resuming...\" : \"Resume Session\"}\n    </button>\n  </div>\n);\n\n// CooldownDisplay sub-component\ninterface CooldownDisplayProps {\n  cooldownDisplay: string;\n}\n\nconst CooldownDisplay: React.FC<CooldownDisplayProps> = ({\n  cooldownDisplay,\n}) => (\n  <div className=\"text-sm text-yellow-600 mb-4 text-center\">\n    Next pause available in: {cooldownDisplay}\n  </div>\n);\n\n// PauseModal sub-component\ninterface PauseModalProps {\n  show: boolean;\n  selectedReason: EnhancedPauseReason;\n  customReason: string;\n  isLoading: boolean;\n  onReasonChange: (reason: EnhancedPauseReason) => void;\n  onCustomReasonChange: (reason: string) => void;\n  onConfirm: () => void;\n  onCancel: () => void;\n}\n\nconst PauseModal: React.FC<PauseModalProps> = ({\n  show,\n  selectedReason,\n  customReason,\n  isLoading,\n  onReasonChange,\n  onCustomReasonChange,\n  onConfirm,\n  onCancel,\n}) => {\n  if (!show) return null;\n\n  const reasons: EnhancedPauseReason[] = [\n    \"Bathroom Break\",\n    \"Emergency\",\n    \"Medical\",\n    \"Other\",\n  ];\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4\">\n      <div className=\"glass-morphism p-6 md:p-8 text-center w-full max-w-md text-gray-50 border border-yellow-700/30\">\n        <h3 className=\"text-lg md:text-xl font-bold mb-4 text-yellow-300\">\n          Reason for Pausing Session\n        </h3>\n\n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n            Select reason:\n          </label>\n          <select\n            value={selectedReason}\n            onChange={(e) =>\n              onReasonChange(e.target.value as EnhancedPauseReason)\n            }\n            className=\"w-full p-2 rounded-lg border border-yellow-600/50 bg-gray-900/50 backdrop-blur-sm text-gray-50 focus:outline-none focus:ring-2 focus:ring-yellow-500\"\n          >\n            {reasons.map((reason) => (\n              <option key={reason} value={reason}>\n                {reason}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        {selectedReason === \"Other\" && (\n          <div className=\"mb-4\">\n            <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n              Custom reason:\n            </label>\n            <input\n              type=\"text\"\n              value={customReason}\n              onChange={(e) => onCustomReasonChange(e.target.value)}\n              placeholder=\"Enter custom reason\"\n              className=\"w-full p-2 rounded-lg border border-yellow-600/50 bg-gray-900/50 backdrop-blur-sm text-gray-50 focus:outline-none focus:ring-2 focus:ring-yellow-500\"\n            />\n          </div>\n        )}\n\n        <div className=\"flex flex-col sm:flex-row justify-around space-y-3 sm:space-y-0 sm:space-x-4\">\n          <button\n            type=\"button\"\n            onClick={onConfirm}\n            disabled={\n              isLoading || (selectedReason === \"Other\" && !customReason.trim())\n            }\n            className=\"w-full sm:w-auto glass-button bg-gradient-to-r from-yellow-600/80 to-yellow-700/80 hover:from-yellow-500/90 hover:to-yellow-600/90 text-white font-bold py-2 px-4 transition-all duration-300 disabled:opacity-50\"\n          >\n            {isLoading ? \"Pausing...\" : \"Confirm Pause\"}\n          </button>\n          <button\n            type=\"button\"\n            onClick={onCancel}\n            disabled={isLoading}\n            className=\"w-full sm:w-auto glass-button bg-gradient-to-r from-gray-600/80 to-gray-700/80 hover:from-gray-500/90 hover:to-gray-600/90 text-white font-bold py-2 px-4 transition-all duration-300 disabled:opacity-50\"\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface PauseResumeButtonsProps {\n  sessionId: string;\n  userId: string;\n  isPaused: boolean;\n  pauseState?: PauseState;\n  onPause?: () => void;\n  onResume?: () => void;\n}\n\nexport const PauseResumeButtons: React.FC<PauseResumeButtonsProps> = ({\n  sessionId,\n  userId,\n  isPaused,\n  pauseState,\n  onPause,\n  onResume,\n}) => {\n  const {\n    buttonStates,\n    cooldownDisplay,\n    pauseButtonStyling,\n    pauseButtonText,\n    showPauseModal,\n    selectedReason,\n    customReason,\n    isLoading,\n    handlePauseClick,\n    handleResumeClick,\n    handleConfirmPause,\n    handleModalCancel,\n    setSelectedReason,\n    setCustomReason,\n  } = usePauseResumeControls({\n    sessionId,\n    userId,\n    isPaused,\n    pauseState,\n    onPause,\n    onResume,\n  });\n\n  return (\n    <>\n      {buttonStates.showResume && (\n        <ResumeButton isLoading={isLoading} onResumeClick={handleResumeClick} />\n      )}\n\n      {buttonStates.showPause && (\n        <PauseButton\n          canPause={buttonStates.canPause}\n          isLoading={isLoading}\n          onPauseClick={handlePauseClick}\n          pauseButtonStyling={pauseButtonStyling}\n          pauseButtonText={pauseButtonText}\n        />\n      )}\n\n      {buttonStates.showCooldown && (\n        <CooldownDisplay cooldownDisplay={cooldownDisplay} />\n      )}\n\n      <PauseModal\n        show={showPauseModal}\n        selectedReason={selectedReason}\n        customReason={customReason}\n        isLoading={isLoading}\n        onReasonChange={setSelectedReason}\n        onCustomReasonChange={setCustomReason}\n        onConfirm={handleConfirmPause}\n        onCancel={handleModalCancel}\n      />\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/ReasonModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/RestoreSessionPrompt.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/SessionLoader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/SessionRecoveryModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (104). Maximum allowed is 75.","line":12,"column":74,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":127,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { FaExclamationTriangle, FaClock, FaCalendarAlt } from \"react-icons/fa\";\nimport type { DBSession } from \"../../types/database\";\n\ninterface SessionRecoveryModalProps {\n  corruptedSession: DBSession;\n  onRecover: (session: DBSession) => void;\n  onDiscard: () => void;\n  isRecovering?: boolean;\n}\n\nexport const SessionRecoveryModal: React.FC<SessionRecoveryModalProps> = ({\n  corruptedSession,\n  onRecover,\n  onDiscard,\n  isRecovering = false,\n}) => {\n  const formatDuration = (seconds: number): string => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  };\n\n  const calculateEstimatedDuration = (session: DBSession): number => {\n    const now = new Date();\n    const startTime = new Date(session.startTime);\n    const totalMs = now.getTime() - startTime.getTime();\n    const totalSeconds = Math.floor(totalMs / 1000);\n    return Math.max(0, totalSeconds - session.accumulatedPauseTime);\n  };\n\n  const estimatedDuration = calculateEstimatedDuration(corruptedSession);\n\n  return (\n    <div className=\"fixed inset-0 bg-black/75 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-gray-800 rounded-xl shadow-2xl p-6 max-w-md w-full border border-yellow-500\">\n        <div className=\"text-center mb-6\">\n          <FaExclamationTriangle className=\"text-yellow-400 text-4xl mx-auto mb-3\" />\n          <h3 className=\"text-xl font-bold text-yellow-300 mb-2\">\n            Session Recovery Required\n          </h3>\n          <p className=\"text-sm text-gray-300\">\n            We detected an interrupted session that may have corrupted data.\n            Would you like to attempt recovery?\n          </p>\n        </div>\n\n        <div className=\"bg-gray-700/50 rounded-lg p-4 mb-6 space-y-3\">\n          <div className=\"flex items-center text-sm text-gray-300\">\n            <FaCalendarAlt className=\"text-blue-400 mr-2\" />\n            <span className=\"font-medium\">Session Started:</span>\n            <span className=\"ml-2\">\n              {new Date(corruptedSession.startTime).toLocaleString()}\n            </span>\n          </div>\n\n          <div className=\"flex items-center text-sm text-gray-300\">\n            <FaClock className=\"text-green-400 mr-2\" />\n            <span className=\"font-medium\">Estimated Duration:</span>\n            <span className=\"ml-2\">{formatDuration(estimatedDuration)}</span>\n          </div>\n\n          {corruptedSession.isPaused && (\n            <div className=\"flex items-center text-sm text-yellow-300\">\n              <FaExclamationTriangle className=\"text-yellow-400 mr-2\" />\n              <span className=\"font-medium\">Status:</span>\n              <span className=\"ml-2\">Session was paused</span>\n            </div>\n          )}\n\n          {corruptedSession.accumulatedPauseTime > 0 && (\n            <div className=\"flex items-center text-sm text-gray-300\">\n              <FaClock className=\"text-orange-400 mr-2\" />\n              <span className=\"font-medium\">Total Pause Time:</span>\n              <span className=\"ml-2\">\n                {formatDuration(corruptedSession.accumulatedPauseTime)}\n              </span>\n            </div>\n          )}\n        </div>\n\n        <div className=\"bg-yellow-900/30 border border-yellow-600 rounded-lg p-3 mb-6\">\n          <p className=\"text-xs text-yellow-200\">\n            <strong>Recovery Process:</strong> We'll attempt to fix any data\n            inconsistencies while preserving your session progress. Your session\n            timing and pause history will be validated and corrected if\n            necessary.\n          </p>\n        </div>\n\n        <div className=\"flex flex-col sm:flex-row gap-3\">\n          <button\n            onClick={() => onRecover(corruptedSession)}\n            disabled={isRecovering}\n            className=\"flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-blue-800 disabled:opacity-50 text-white font-semibold py-3 px-4 rounded-lg transition flex items-center justify-center\"\n          >\n            {isRecovering ? (\n              <>\n                <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2\" />\n                Recovering...\n              </>\n            ) : (\n              \"Recover Session\"\n            )}\n          </button>\n\n          <button\n            onClick={onDiscard}\n            disabled={isRecovering}\n            className=\"flex-1 bg-gray-600 hover:bg-gray-500 disabled:bg-gray-700 disabled:opacity-50 text-white font-semibold py-3 px-4 rounded-lg transition\"\n          >\n            Discard Session\n          </button>\n        </div>\n\n        <p className=\"text-xs text-gray-500 text-center mt-4\">\n          If recovery fails, you can always start a new session. Your session\n          history will be preserved.\n        </p>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/TrackerHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/TrackerStats.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (99). Maximum allowed is 75.","line":22,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":124,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { formatElapsedTime } from \"../../utils\";\nimport type { DBSession } from \"../../types/database\";\nimport { useTrackerStats } from \"../../hooks/tracker/useTrackerStats\";\n\ninterface TrackerStatsProps {\n  // New props for real-time timer\n  currentSession?: DBSession | null;\n  // Legacy props for backward compatibility\n  topBoxLabel?: string;\n  topBoxTime?: string;\n  mainChastityDisplayTime?: number;\n  isPaused?: boolean;\n  livePauseDuration?: number;\n  accumulatedPauseTimeThisSession?: number;\n  isCageOn?: boolean;\n  timeCageOff?: number;\n  totalChastityTime?: number;\n  totalTimeCageOff?: number;\n}\n\nexport const TrackerStats: React.FC<TrackerStatsProps> = (props) => {\n  const { displayData, stats } = useTrackerStats(props);\n\n  return (\n    <div className=\"space-y-6 mb-8\">\n      {/* Top stat card with enhanced glass effect */}\n      <div className=\"glass-card-primary text-center glass-float\">\n        <p className=\"text-blue-200 text-sm md:text-lg font-medium mb-2\">\n          {stats.topBoxLabel}\n        </p>\n        <p className=\"text-3xl md:text-5xl font-bold bg-gradient-to-r from-blue-200 to-white bg-clip-text text-transparent\">\n          {stats.totalElapsedFormatted}\n        </p>\n      </div>\n\n      {/* Stats grid with enhanced glass cards */}\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-6\">\n        <div\n          className={`glass-card transition-all duration-500 ${\n            displayData.isActive\n              ? displayData.isPaused\n                ? \"glass-card-accent border-yellow-400/30 shadow-yellow-400/20\"\n                : \"border-green-400/30 shadow-green-400/20\"\n              : \"glass-card-primary\"\n          }`}\n        >\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Current Session In Chastity {displayData.isPaused ? \"(Paused)\" : \"\"}\n            :\n          </p>\n          <p\n            className={`text-2xl md:text-4xl font-bold mb-2 ${\n              displayData.isActive\n                ? displayData.isPaused\n                  ? \"text-yellow-300\"\n                  : \"text-green-300\"\n                : \"text-white\"\n            }`}\n          >\n            {stats.currentSessionFormatted}\n          </p>\n          {displayData.isPaused && (\n            <p className=\"text-xs text-yellow-200 bg-yellow-400/10 px-2 py-1 rounded-md\">\n              Currently paused for: {displayData.currentPauseDuration}\n            </p>\n          )}\n          {displayData.isActive &&\n            (props.currentSession\n              ? props.currentSession.accumulatedPauseTime > 0\n              : props.accumulatedPauseTimeThisSession! > 0) && (\n              <p className=\"text-xs text-yellow-200 bg-yellow-400/10 px-2 py-1 rounded-md mt-2\">\n                Total time paused this session:{\" \"}\n                {props.currentSession\n                  ? formatElapsedTime(props.currentSession.accumulatedPauseTime)\n                  : displayData.accumulatedPause}\n              </p>\n            )}\n        </div>\n\n        <div\n          className={`glass-card transition-all duration-500 ${\n            !displayData.isActive && props.timeCageOff! > 0\n              ? \"border-red-400/30 shadow-red-400/20\"\n              : \"glass-card-primary\"\n          }`}\n        >\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Current Session Cage Off:\n          </p>\n          <p\n            className={`text-2xl md:text-4xl font-bold ${\n              !displayData.isActive && props.timeCageOff! > 0\n                ? \"text-red-300\"\n                : \"text-white\"\n            }`}\n          >\n            {stats.cageOffTimeFormatted}\n          </p>\n        </div>\n      </div>\n\n      {/* Total stats with subtle glass cards */}\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-6\">\n        <div className=\"glass-card glass-hover\">\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Total Time In Chastity:\n          </p>\n          <p className=\"text-2xl md:text-4xl font-bold text-white\">\n            {stats.totalChastityTimeFormatted}\n          </p>\n        </div>\n        <div className=\"glass-card glass-hover\">\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Total Time Cage Off:\n          </p>\n          <p className=\"text-2xl md:text-4xl font-bold text-white\">\n            {stats.totalCageOffTimeFormatted}\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/ui/NotificationContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/consistency-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/goal-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/milestone-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/special-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/streak-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/task-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/challengeAchievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/AppContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (152). Maximum allowed is 75.","line":59,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":256,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Application Context\n * Manages global app-level state (non-auth, non-UI)\n * Context layer - App state like connection status, sync status, etc.\n */\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n} from \"react\";\nimport { firebaseSync } from \"../services/sync\";\nimport { preloadCriticalServices } from \"../services/firebase\";\nimport { achievementIntegration } from \"../services/AchievementIntegration\";\nimport { serviceLogger } from \"../utils/logging\";\nimport { db } from \"../services/database\";\nimport type { SyncStatus } from \"../types/database\";\n\n// Extend Navigator interface for connection API\ninterface NavigatorWithConnection extends Navigator {\n  connection?: {\n    effectiveType: string;\n    addEventListener: (event: string, callback: () => void) => void;\n    removeEventListener: (event: string, callback: () => void) => void;\n  };\n}\n\nconst logger = serviceLogger(\"AppContext\");\n\nexport interface AppState {\n  isInitialized: boolean;\n  isOnline: boolean;\n  syncStatus: SyncStatus | null;\n  lastSyncTime: Date | null;\n  hasUnreadNotifications: boolean;\n  connectionType: string | null;\n  sessionPersistenceReady: boolean;\n}\n\nexport interface AppActions {\n  initializeApp: () => Promise<void>;\n  triggerSync: (userId: string) => Promise<void>;\n  markNotificationsRead: () => void;\n  updateConnectionStatus: (isOnline: boolean) => void;\n}\n\nexport interface AppContextType {\n  state: AppState;\n  actions: AppActions;\n}\n\nconst AppContext = createContext<AppContextType | null>(null);\n\ninterface AppProviderProps {\n  children: ReactNode;\n}\n\nexport const AppProvider: React.FC<AppProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    isInitialized: false,\n    isOnline: navigator.onLine,\n    syncStatus: null,\n    lastSyncTime: null,\n    hasUnreadNotifications: false,\n    connectionType: null,\n    sessionPersistenceReady: false,\n  });\n\n  // Initialize app on mount\n  useEffect(() => {\n    const initializeApp = async () => {\n      try {\n        logger.info(\"Initializing application\");\n\n        // Initialize Dexie database first\n        await db.initialize();\n        logger.info(\"Dexie database initialized\");\n\n        // Preload critical Firebase services\n        await preloadCriticalServices();\n\n        // Initialize achievement system\n        await achievementIntegration.initialize();\n\n        // Initialize session persistence service\n        // The service initializes automatically as a singleton\n        logger.info(\"Session persistence service ready\");\n        setState((prev) => ({ ...prev, sessionPersistenceReady: true }));\n\n        // Initialize sync service\n        // FirebaseSync initializes automatically\n\n        // Set initial sync status\n        const syncStatus = \"synced\" as SyncStatus;\n\n        // Detect connection type\n        const connection = (navigator as NavigatorWithConnection).connection;\n        const connectionType = connection?.effectiveType || \"unknown\";\n\n        setState((prev) => ({\n          ...prev,\n          isInitialized: true,\n          syncStatus,\n          connectionType,\n        }));\n\n        logger.info(\"Application initialized successfully\", { connectionType });\n      } catch (error) {\n        logger.error(\"Failed to initialize application\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          isInitialized: false,\n        }));\n      }\n    };\n\n    initializeApp();\n\n    // Listen for online/offline events\n    const handleOnline = () => {\n      setState((prev) => ({ ...prev, isOnline: true }));\n      logger.debug(\"App went online\");\n    };\n\n    const handleOffline = () => {\n      setState((prev) => ({ ...prev, isOnline: false }));\n      logger.debug(\"App went offline\");\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes\n    const handleConnectionChange = () => {\n      const connection = (navigator as NavigatorWithConnection).connection;\n      if (connection) {\n        setState((prev) => ({\n          ...prev,\n          connectionType: connection.effectiveType || \"unknown\",\n        }));\n        logger.debug(\"Connection type changed\", {\n          type: connection.effectiveType,\n        });\n      }\n    };\n\n    if (\"connection\" in navigator) {\n      (navigator as NavigatorWithConnection).connection?.addEventListener(\n        \"change\",\n        handleConnectionChange,\n      );\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n\n      if (\"connection\" in navigator) {\n        (navigator as NavigatorWithConnection).connection?.removeEventListener(\n          \"change\",\n          handleConnectionChange,\n        );\n      }\n    };\n  }, []);\n\n  const actions: AppActions = {\n    initializeApp: async () => {\n      if (state.isInitialized) {\n        logger.debug(\"App already initialized, skipping\");\n        return;\n      }\n\n      setState((prev) => ({ ...prev, isInitialized: false }));\n\n      try {\n        // Initialize Dexie database first\n        await db.initialize();\n        logger.info(\"Dexie database re-initialized\");\n\n        await preloadCriticalServices();\n        // FirebaseSync initializes automatically\n\n        const syncStatus = \"synced\" as SyncStatus;\n\n        setState((prev) => ({\n          ...prev,\n          isInitialized: true,\n          syncStatus,\n        }));\n\n        logger.info(\"App re-initialized successfully\");\n      } catch (error) {\n        logger.error(\"Failed to re-initialize app\", { error: error as Error });\n      }\n    },\n\n    triggerSync: async (userId: string) => {\n      logger.debug(\"Triggering manual sync\", { userId });\n\n      try {\n        await firebaseSync.sync();\n        const result = {\n          success: true,\n          data: {\n            syncStatus: \"synced\" as SyncStatus,\n            lastSyncTime: new Date(),\n          },\n        };\n\n        if (result.success && result.data) {\n          setState((prev) => ({\n            ...prev,\n            syncStatus: result.data.syncStatus,\n            lastSyncTime: result.data.lastSyncTime,\n          }));\n          logger.info(\"Manual sync completed\", { userId });\n        }\n      } catch (error) {\n        const result = {\n          success: false,\n          error: error instanceof Error ? error.message : \"Sync failed\",\n        };\n        logger.warn(\"Manual sync failed\", { userId, error: result.error });\n      }\n    },\n\n    markNotificationsRead: () => {\n      setState((prev) => ({\n        ...prev,\n        hasUnreadNotifications: false,\n      }));\n      logger.debug(\"Notifications marked as read\");\n    },\n\n    updateConnectionStatus: (isOnline: boolean) => {\n      setState((prev) => ({\n        ...prev,\n        isOnline,\n      }));\n      logger.debug(\"Connection status updated\", { isOnline });\n    },\n  };\n\n  const contextValue: AppContextType = {\n    state,\n    actions,\n  };\n\n  return (\n    <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>\n  );\n};\n\nexport const useApp = (): AppContextType => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error(\"useApp must be used within an AppProvider\");\n  }\n  return context;\n};\n\n// Convenience hooks for common use cases\nexport const useAppState = () => {\n  const { state } = useApp();\n  return state;\n};\n\nexport const useAppActions = () => {\n  const { actions } = useApp();\n  return actions;\n};\n\nexport const useConnectionStatus = () => {\n  const { state } = useApp();\n  return {\n    isOnline: state.isOnline,\n    connectionType: state.connectionType,\n  };\n};\n\nexport const useSyncStatus = () => {\n  const { state, actions } = useApp();\n  return {\n    syncStatus: state.syncStatus,\n    lastSyncTime: state.lastSyncTime,\n    triggerSync: actions.triggerSync,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/AuthContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (214). Maximum allowed is 75.","line":52,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":307,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Authentication Context\n * Manages auth state using the AuthService\n * Context layer - React state management for authentication\n */\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n} from \"react\";\nimport { AuthService } from \"@/services/auth/auth-service\";\nimport { getFirebaseAuth } from \"@/services/firebase\";\nimport { User, LoginForm, RegisterForm, ApiResponse } from \"@/types\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"AuthContext\");\n\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface AuthActions {\n  signIn: (credentials: LoginForm) => Promise<ApiResponse<User>>;\n  register: (userData: RegisterForm) => Promise<ApiResponse<User>>;\n  signOut: () => Promise<ApiResponse<void>>;\n  resetPassword: (email: string) => Promise<ApiResponse<void>>;\n  updatePassword: (newPassword: string) => Promise<ApiResponse<void>>;\n  updateProfile: (updates: Partial<User>) => Promise<ApiResponse<User>>;\n  clearError: () => void;\n}\n\nexport interface AuthContextType {\n  state: AuthState;\n  actions: AuthActions;\n  // Direct access properties for backwards compatibility\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AuthState>({\n    user: null,\n    isAuthenticated: false,\n    isLoading: true,\n    error: null,\n  });\n\n  // Initialize auth state on mount\n  useEffect(() => {\n    const initializeAuth = async () => {\n      try {\n        logger.debug(\"Initializing auth state\");\n\n        const auth = await getFirebaseAuth();\n\n        // Check if user is already authenticated\n        const currentUser = await AuthService.getCurrentUser();\n\n        if (currentUser) {\n          setState({\n            user: currentUser,\n            isAuthenticated: true,\n            isLoading: false,\n            error: null,\n          });\n          logger.info(\"User already authenticated\", { uid: currentUser.uid });\n        } else {\n          setState((prev) => ({\n            ...prev,\n            isLoading: false,\n          }));\n          logger.debug(\"No authenticated user found\");\n        }\n\n        // Listen for auth state changes\n        const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {\n          if (firebaseUser) {\n            logger.debug(\"Firebase auth state changed: user signed in\", {\n              uid: firebaseUser.uid,\n            });\n\n            // Get full user profile from our service\n            const user = await AuthService.getCurrentUser();\n            if (user) {\n              setState({\n                user,\n                isAuthenticated: true,\n                isLoading: false,\n                error: null,\n              });\n            }\n          } else {\n            logger.debug(\"Firebase auth state changed: user signed out\");\n            setState({\n              user: null,\n              isAuthenticated: false,\n              isLoading: false,\n              error: null,\n            });\n          }\n        });\n\n        return unsubscribe;\n      } catch (error) {\n        logger.error(\"Failed to initialize auth\", { error: error as Error });\n        setState({\n          user: null,\n          isAuthenticated: false,\n          isLoading: false,\n          error: \"Failed to initialize authentication\",\n        });\n        return undefined;\n      }\n    };\n\n    const unsubscribePromise = initializeAuth();\n\n    return () => {\n      unsubscribePromise.then((unsubscribe) => {\n        if (unsubscribe) {\n          unsubscribe();\n        }\n      });\n    };\n  }, []);\n\n  const actions: AuthActions = {\n    signIn: async (credentials: LoginForm) => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.signIn(credentials);\n\n      if (result.success && result.data) {\n        setState({\n          user: result.data,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User signed in via context\", { uid: result.data.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Sign in failed\",\n        }));\n        logger.warn(\"Sign in failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    register: async (userData: RegisterForm) => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.register(userData);\n\n      if (result.success && result.data) {\n        setState({\n          user: result.data,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User registered via context\", { uid: result.data.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Registration failed\",\n        }));\n        logger.warn(\"Registration failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    signOut: async () => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.signOut();\n\n      if (result.success) {\n        setState({\n          user: null,\n          isAuthenticated: false,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User signed out via context\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Sign out failed\",\n        }));\n        logger.warn(\"Sign out failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    resetPassword: async (email: string) => {\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.resetPassword(email);\n\n      if (!result.success) {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Password reset failed\",\n        }));\n        logger.warn(\"Password reset failed via context\", {\n          error: result.error,\n          email,\n        });\n      } else {\n        logger.info(\"Password reset sent via context\", { email });\n      }\n\n      return result;\n    },\n\n    updatePassword: async (newPassword: string) => {\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.updatePassword(newPassword);\n\n      if (!result.success) {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Password update failed\",\n        }));\n        logger.warn(\"Password update failed via context\", {\n          error: result.error,\n        });\n      } else {\n        logger.info(\"Password updated via context\");\n      }\n\n      return result;\n    },\n\n    updateProfile: async (updates: Partial<User>) => {\n      if (!state.user) {\n        const error = \"No authenticated user found\";\n        setState((prev) => ({ ...prev, error }));\n        return { success: false, error };\n      }\n\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.updateUserProfile(\n        state.user.uid,\n        updates,\n      );\n\n      if (result.success && result.data) {\n        setState((prev) => ({\n          ...prev,\n          user: result.data!,\n        }));\n        logger.info(\"Profile updated via context\", { uid: state.user.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Profile update failed\",\n        }));\n        logger.warn(\"Profile update failed via context\", {\n          error: result.error,\n          uid: state.user.uid,\n        });\n      }\n\n      return result;\n    },\n\n    clearError: () => {\n      setState((prev) => ({ ...prev, error: null }));\n    },\n  };\n\n  const contextValue: AuthContextType = {\n    state,\n    actions,\n    // Direct access properties for backwards compatibility\n    user: state.user,\n    isAuthenticated: state.isAuthenticated,\n    isLoading: state.isLoading,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>\n  );\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n};\n\n// Convenience hooks for common use cases\nexport const useAuthState = () => {\n  const { state } = useAuth();\n  return state;\n};\n\nexport const useAuthActions = () => {\n  const { actions } = useAuth();\n  return actions;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/SyncContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (87). Maximum allowed is 75.","line":37,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":147,"endColumn":2}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":81,"column":15,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":81,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sync Context\n * Provides sync state and conflict resolution across the app\n */\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\nimport { useSync } from \"@/hooks/useSync\";\nimport { useAuth } from \"@/hooks/api/useAuth\";\nimport { ConflictResolutionModal } from \"@/components/common/ConflictResolutionModal\";\nimport type { ConflictInfo } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"SyncContext\");\n\ninterface SyncContextType {\n  isSyncing: boolean;\n  lastSyncTime: Date | null;\n  syncStatus: \"synced\" | \"pending\" | \"conflict\" | \"error\";\n  pendingConflicts: ConflictInfo[];\n  triggerSync: () => Promise<void>;\n  hasConflicts: boolean;\n}\n\nconst SyncContext = createContext<SyncContextType | undefined>(undefined);\n\nexport const useSyncContext = (): SyncContextType => {\n  const context = useContext(SyncContext);\n  if (!context) {\n    throw new Error(\"useSyncContext must be used within SyncProvider\");\n  }\n  return context;\n};\n\ninterface SyncProviderProps {\n  children: React.ReactNode;\n}\n\nexport const SyncProvider: React.FC<SyncProviderProps> = ({ children }) => {\n  const { data: user } = useAuth();\n  const userId = user?.uid;\n  const {\n    isSyncing,\n    lastSyncResult: _lastSyncResult,\n    pendingConflicts,\n    sync,\n    resolveConflicts,\n    error,\n  } = useSync();\n\n  const [showConflictModal, setShowConflictModal] = useState(false);\n  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\n\n  // Determine sync status\n  const getSyncStatus = (): SyncContextType[\"syncStatus\"] => {\n    if (error) return \"error\";\n    if (pendingConflicts.length > 0) return \"conflict\";\n    if (isSyncing) return \"pending\";\n    return \"synced\";\n  };\n\n  // Auto-sync on user change and periodically\n  useEffect(() => {\n    if (!userId) return;\n\n    const performSync = async () => {\n      try {\n        await sync(userId, { conflictResolution: \"auto\" });\n        setLastSyncTime(new Date());\n      } catch (error) {\n        logger.error(\"Auto-sync failed\", { error: error as Error });\n      }\n    };\n\n    // Initial sync\n    performSync();\n\n    // Periodic sync every 5 minutes\n    const interval = setInterval(performSync, 5 * 60 * 1000);\n\n    return () => clearInterval(interval);\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [userId, sync]);\n\n  // Show conflict modal when conflicts are detected\n  useEffect(() => {\n    if (pendingConflicts.length > 0 && !showConflictModal) {\n      setShowConflictModal(true);\n    }\n  }, [pendingConflicts.length, showConflictModal]);\n\n  const triggerSync = async (): Promise<void> => {\n    if (!userId) {\n      throw new Error(\"No user authenticated\");\n    }\n\n    try {\n      await sync(userId, { force: true });\n      setLastSyncTime(new Date());\n    } catch (error) {\n      logger.error(\"Manual sync failed\", { error: error as Error });\n      throw error;\n    }\n  };\n\n  const handleResolveConflicts = async (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => {\n    try {\n      await resolveConflicts(resolutions);\n      setShowConflictModal(false);\n\n      // Trigger a sync after resolving conflicts\n      if (userId) {\n        await sync(userId);\n        setLastSyncTime(new Date());\n      }\n    } catch (error) {\n      logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n    }\n  };\n\n  const handleCancelConflictResolution = () => {\n    setShowConflictModal(false);\n    // Conflicts remain pending - user can resolve them later\n  };\n\n  const contextValue: SyncContextType = {\n    isSyncing,\n    lastSyncTime,\n    syncStatus: getSyncStatus(),\n    pendingConflicts,\n    triggerSync,\n    hasConflicts: pendingConflicts.length > 0,\n  };\n\n  return (\n    <SyncContext.Provider value={contextValue}>\n      {children}\n\n      <ConflictResolutionModal\n        conflicts={pendingConflicts}\n        onResolve={handleResolveConflicts}\n        onCancel={handleCancelConflictResolution}\n        isOpen={showConflictModal}\n      />\n    </SyncContext.Provider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/ToastProvider.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (118). Maximum allowed is 75.","line":56,"column":60,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":194,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ToastProvider - React Context for global toast notifications\n * Provides unified toast API with priority support and accessibility\n */\nimport React, { createContext, useContext, useCallback, useEffect, useMemo, ReactNode } from \"react\";\nimport { useNotificationStore, Notification, NotificationPriority } from \"../stores/notificationStore\";\nimport { toastBridge } from \"../utils/toastBridge\";\n\nexport interface ToastOptions {\n  title?: string;\n  priority?: NotificationPriority;\n  duration?: number;\n  dismissible?: boolean;\n  requireInteraction?: boolean;\n  position?: Notification[\"position\"];\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  icon?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface ToastContextValue {\n  // Core toast methods\n  showToast: (\n    message: string,\n    type: Notification[\"type\"],\n    options?: ToastOptions\n  ) => string;\n  dismissToast: (id: string) => void;\n  clearAllToasts: () => void;\n\n  // Convenience methods with priority defaults\n  showSuccess: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showError: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showWarning: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showInfo: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  \n  // Priority-specific methods\n  showUrgent: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showHigh: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showMedium: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n  showLow: (message: string, options?: Omit<ToastOptions, \"priority\">) => string;\n\n  // State access\n  toasts: Notification[];\n}\n\nconst ToastContext = createContext<ToastContextValue | undefined>(undefined);\n\ninterface ToastProviderProps {\n  children: ReactNode;\n}\n\nexport const ToastProvider: React.FC<ToastProviderProps> = ({ children }) => {\n  // Use selective subscription for better performance\n  const addNotification = useNotificationStore((state) => state.addNotification);\n  const removeNotification = useNotificationStore((state) => state.removeNotification);\n  const clearAllNotifications = useNotificationStore((state) => state.clearAllNotifications);\n  const notifications = useNotificationStore((state) => state.notifications);\n\n  // Core toast method\n  const showToast = useCallback(\n    (\n      message: string,\n      type: Notification[\"type\"],\n      options: ToastOptions = {}\n    ): string => {\n      return addNotification({\n        type,\n        message,\n        title: options.title,\n        priority: options.priority || \"medium\",\n        duration: options.duration,\n        dismissible: options.dismissible,\n        requireInteraction: options.requireInteraction,\n        position: options.position,\n        action: options.action,\n        icon: options.icon,\n        metadata: options.metadata,\n      });\n    },\n    [addNotification]\n  );\n\n  // Dismiss toast\n  const dismissToast = useCallback(\n    (id: string) => {\n      removeNotification(id);\n    },\n    [removeNotification]\n  );\n\n  // Clear all toasts\n  const clearAllToasts = useCallback(() => {\n    clearAllNotifications();\n  }, [clearAllNotifications]);\n\n  // Convenience methods by type with smart priority defaults\n  const showSuccess = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"success\", { priority: \"low\", ...options });\n    },\n    [showToast]\n  );\n\n  const showError = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"error\", { priority: \"high\", ...options });\n    },\n    [showToast]\n  );\n\n  const showWarning = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"warning\", { priority: \"medium\", ...options });\n    },\n    [showToast]\n  );\n\n  const showInfo = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"info\", { priority: \"low\", ...options });\n    },\n    [showToast]\n  );\n\n  // Priority-specific methods\n  const showUrgent = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"error\", { \n        priority: \"urgent\", \n        requireInteraction: true,\n        ...options \n      });\n    },\n    [showToast]\n  );\n\n  const showHigh = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"warning\", { priority: \"high\", ...options });\n    },\n    [showToast]\n  );\n\n  const showMedium = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"info\", { priority: \"medium\", ...options });\n    },\n    [showToast]\n  );\n\n  const showLow = useCallback(\n    (message: string, options: Omit<ToastOptions, \"priority\"> = {}) => {\n      return showToast(message, \"info\", { priority: \"low\", ...options });\n    },\n    [showToast]\n  );\n\n  const contextValue: ToastContextValue = useMemo(() => ({\n    showToast,\n    dismissToast,\n    clearAllToasts,\n    showSuccess,\n    showError,\n    showWarning,\n    showInfo,\n    showUrgent,\n    showHigh,\n    showMedium,\n    showLow,\n    toasts: notifications,\n  }), [\n    showToast, dismissToast, clearAllToasts, showSuccess, showError, \n    showWarning, showInfo, showUrgent, showHigh, showMedium, \n    showLow, notifications\n  ]);\n\n  // Register with the bridge for non-React services\n  useEffect(() => {\n    toastBridge.registerShowToast(contextValue);\n    return () => {\n      toastBridge.unregisterShowToast();\n    };\n  }, [contextValue]);\n\n  return (\n    <ToastContext.Provider value={contextValue}>\n      {children}\n    </ToastContext.Provider>\n  );\n};\n\n/**\n * useToast Hook - Primary interface for toast notifications\n * \n * @example\n * const { showSuccess, showError, showUrgent } = useToast();\n * \n * // Simple usage\n * showSuccess(\"Data saved successfully!\");\n * \n * // With options\n * showError(\"Failed to save\", { \n *   title: \"Save Error\",\n *   action: { label: \"Retry\", onClick: handleRetry }\n * });\n * \n * // Urgent notification\n * showUrgent(\"Critical system error!\", {\n *   title: \"System Alert\",\n *   action: { label: \"Contact Support\", onClick: openSupport }\n * });\n */\nexport const useToast = (): ToastContextValue => {\n  const context = useContext(ToastContext);\n  if (context === undefined) {\n    throw new Error(\"useToast must be used within a ToastProvider\");\n  }\n  return context;\n};\n\nexport default ToastProvider;","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/firebase.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/account-linking/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/account-linking/useAccountLinking.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (270). Maximum allowed is 75.","line":30,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":349,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Linking Hook\n * React hook for managing keyholder-wearer account linking\n */\nimport { useState, useCallback, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AccountLinkingService } from \"../../services/auth/account-linking\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  AccountLinkingState,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useAccountLinking\");\n\n// Query keys\nconst QUERY_KEYS = {\n  relationships: (userId: string) => [\"adminRelationships\", userId],\n  validation: (code: string) => [\"linkCodeValidation\", code],\n  adminSession: (relationshipId: string) => [\"adminSession\", relationshipId],\n} as const;\n\nexport const useAccountLinking = () => {\n  const { user } = useAuthState();\n  const queryClient = useQueryClient();\n\n  // Local state\n  const [state, setState] = useState<AccountLinkingState>({\n    isGeneratingCode: false,\n    currentLinkCode: null,\n    linkCodeError: null,\n    isUsingCode: false,\n    codeUsageError: null,\n    adminRelationships: [],\n    selectedWearerId: null,\n    currentAdminSession: null,\n    isAdminSessionActive: false,\n    showQRCode: false,\n    showDisconnectionDialog: false,\n    showPermissionEditor: false,\n  });\n\n  // ==================== QUERIES ====================\n\n  // Get admin relationships for current user\n  const {\n    data: relationships = [],\n    isLoading: isLoadingRelationships,\n    error: relationshipsError,\n  } = useQuery({\n    queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n    queryFn: () => AccountLinkingService.getAdminRelationships(user!.uid),\n    enabled: !!user,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Update local state when relationships change\n  useEffect(() => {\n    setState((prev) => ({ ...prev, adminRelationships: relationships }));\n  }, [relationships]);\n\n  // ==================== MUTATIONS ====================\n\n  // Generate link code\n  const generateLinkCodeMutation = useMutation({\n    mutationFn: (request: GenerateLinkCodeRequest) =>\n      AccountLinkingService.generateLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isGeneratingCode: true,\n        linkCodeError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<LinkCodeResponse>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentLinkCode: response.data!,\n          isGeneratingCode: false,\n        }));\n        logger.info(\"Link code generated successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: response.error || \"Failed to generate link code\",\n          isGeneratingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        linkCodeError: error.message,\n        isGeneratingCode: false,\n      }));\n      logger.error(\"Failed to generate link code\", { error });\n    },\n  });\n\n  // Use link code\n  const useLinkCodeMutation = useMutation({\n    mutationFn: (request: UseLinkCodeRequest) =>\n      AccountLinkingService.redeemLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isUsingCode: true,\n        codeUsageError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          isUsingCode: false,\n        }));\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Link code used successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: response.error || \"Failed to use link code\",\n          isUsingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        codeUsageError: error.message,\n        isUsingCode: false,\n      }));\n      logger.error(\"Failed to use link code\", { error });\n    },\n  });\n\n  // Update relationship\n  const updateRelationshipMutation = useMutation({\n    mutationFn: (request: UpdateRelationshipRequest) =>\n      AccountLinkingService.updateRelationship(request),\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success) {\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Relationship updated successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to update relationship\", { error });\n    },\n  });\n\n  // Start admin session\n  const startAdminSessionMutation = useMutation({\n    mutationFn: (relationshipId: string) =>\n      AccountLinkingService.startAdminSession(relationshipId),\n    onSuccess: (response: ApiResponse<AdminSession>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentAdminSession: response.data!,\n          isAdminSessionActive: true,\n        }));\n        logger.info(\"Admin session started successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to start admin session\", { error });\n    },\n  });\n\n  // ==================== CALLBACK FUNCTIONS ====================\n\n  const generateLinkCode = useCallback(\n    (request: GenerateLinkCodeRequest = {}) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: \"Authentication required\",\n        }));\n        return;\n      }\n      generateLinkCodeMutation.mutate(request);\n    },\n    [user, generateLinkCodeMutation],\n  );\n\n  const redeemLinkCode = useCallback(\n    (request: UseLinkCodeRequest) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: \"Authentication required\",\n        }));\n        return;\n      }\n      useLinkCodeMutation.mutate(request);\n    },\n    [user, useLinkCodeMutation],\n  );\n\n  const updateRelationship = useCallback(\n    (request: UpdateRelationshipRequest) => {\n      updateRelationshipMutation.mutate(request);\n    },\n    [updateRelationshipMutation],\n  );\n\n  const startAdminSession = useCallback(\n    (relationshipId: string) => {\n      startAdminSessionMutation.mutate(relationshipId);\n    },\n    [startAdminSessionMutation],\n  );\n\n  const disconnectKeyholder = useCallback(\n    (relationshipId: string, reason?: string) => {\n      updateRelationship({\n        relationshipId,\n        status: \"terminated\",\n        terminationReason: reason,\n      });\n    },\n    [updateRelationship],\n  );\n\n  const clearLinkCode = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n    }));\n  }, []);\n\n  const clearAllErrors = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n      codeUsageError: null,\n    }));\n  }, []);\n\n  const setSelectedWearer = useCallback((wearerId: string | null) => {\n    setState((prev) => ({ ...prev, selectedWearerId: wearerId }));\n  }, []);\n\n  // Combined toggle function for boolean state properties\n  const toggleStateProperty = useCallback(\n    (\n      property: keyof Pick<\n        AccountLinkingState,\n        \"showQRCode\" | \"showDisconnectionDialog\" | \"showPermissionEditor\"\n      >,\n    ) => {\n      setState((prev) => ({ ...prev, [property]: !prev[property] }));\n    },\n    [],\n  );\n\n  const toggleQRCode = useCallback(\n    () => toggleStateProperty(\"showQRCode\"),\n    [toggleStateProperty],\n  );\n  const toggleDisconnectionDialog = useCallback(\n    () => toggleStateProperty(\"showDisconnectionDialog\"),\n    [toggleStateProperty],\n  );\n  const togglePermissionEditor = useCallback(\n    () => toggleStateProperty(\"showPermissionEditor\"),\n    [toggleStateProperty],\n  );\n\n  // ==================== DERIVED STATE ====================\n\n  // User role calculations\n  const userRoles = useMemo(\n    () => ({\n      isKeyholder: relationships.some((r) => r.keyholderId === user?.uid),\n      isWearer: relationships.some((r) => r.wearerId === user?.uid),\n      hasActiveRelationships: relationships.some((r) => r.status === \"active\"),\n    }),\n    [relationships, user?.uid],\n  );\n\n  // Relationship filtering\n  const relationshipsByRole = useMemo(\n    () => ({\n      keyholderRelationships: relationships.filter(\n        (r) => r.keyholderId === user?.uid,\n      ),\n      wearerRelationships: relationships.filter(\n        (r) => r.wearerId === user?.uid,\n      ),\n    }),\n    [relationships, user?.uid],\n  );\n\n  const selectedRelationship = state.selectedWearerId\n    ? relationships.find((r) => r.wearerId === state.selectedWearerId)\n    : null;\n\n  // ==================== RETURN OBJECT ====================\n\n  return {\n    // State\n    ...state,\n    relationships,\n    isLoadingRelationships,\n    relationshipsError,\n\n    // Derived state\n    ...userRoles,\n    selectedRelationship,\n    ...relationshipsByRole,\n\n    // Actions\n    generateLinkCode,\n    redeemLinkCode,\n    updateRelationship,\n    startAdminSession,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearAllErrors,\n    setSelectedWearer,\n    toggleQRCode,\n    toggleDisconnectionDialog,\n    togglePermissionEditor,\n\n    // Loading states\n    isGeneratingCode: generateLinkCodeMutation.isPending,\n    isUsingCode: useLinkCodeMutation.isPending,\n    isUpdatingRelationship: updateRelationshipMutation.isPending,\n    isStartingSession: startAdminSessionMutation.isPending,\n  };\n};\n\n// ==================== ADDITIONAL HOOKS ====================\n\n/**\n * Hook for validating link codes\n */\nexport const useLinkCodeValidation = (code: string) => {\n  return useQuery({\n    queryKey: QUERY_KEYS.validation(code),\n    queryFn: () => AccountLinkingService.validateLinkCode(code),\n    enabled: code.length > 0,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n};\n\n/**\n * Hook for admin access validation\n */\nexport const useAdminAccess = (wearerId: string) => {\n  const { user } = useAuthState();\n  const { relationships } = useAccountLinking();\n\n  const adminRelationship = relationships.find(\n    (r) =>\n      r.keyholderId === user?.uid &&\n      r.wearerId === wearerId &&\n      r.status === \"active\",\n  );\n\n  const hasAccess = !!adminRelationship;\n  const permissions = adminRelationship?.permissions || null;\n  const security = adminRelationship?.security || null;\n\n  const canPerformAction = useCallback(\n    (action: keyof typeof permissions) => {\n      return hasAccess && permissions?.[action] === true;\n    },\n    [hasAccess, permissions],\n  );\n\n  return {\n    hasAccess,\n    adminRelationship,\n    permissions,\n    security,\n    canPerformAction,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/achievement-gallery-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/achievements/useLeaderboardActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/achievements/usePrivacySettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/auth-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/emergency-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/events-utils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventType' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Event, EventType } from \"../../types/events\";\nimport { DBEvent, EventFilters } from \"../../types/database\";\n\n/**\n * Event Management Utilities\n * Query keys and helper functions for event hooks\n */\n\n// Utility function to convert Event to DBEvent format\nexport const eventToDBEvent = (\n  event: Event,\n): Omit<DBEvent, \"lastModified\" | \"syncStatus\"> => {\n  return {\n    id: event.id,\n    userId: event.userId,\n    type: event.type,\n    timestamp: event.timestamp,\n    details: event.details,\n    isPrivate: false, // Default value, can be overridden\n    sessionId: undefined, // Can be set if available\n  };\n};\n\n// Query Keys\nexport const eventKeys = {\n  all: [\"events\"] as const,\n  lists: () => [...eventKeys.all, \"list\"] as const,\n  list: (userId: string, filters?: EventFilters) =>\n    [...eventKeys.lists(), userId, filters] as const,\n  infinite: (userId: string, filters?: EventFilters) =>\n    [...eventKeys.all, \"infinite\", userId, filters] as const,\n  detail: (eventId: string) => [...eventKeys.all, \"detail\", eventId] as const,\n  recent: (userId: string, limit?: number) =>\n    [...eventKeys.all, \"recent\", userId, limit] as const,\n} as const;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/queryClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/settings-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/tasks-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEmergency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEventsQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useEventMutations' has too many lines (184). Maximum allowed is 75.","line":89,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":307,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Events TanStack Query Hooks\n * Manages event log data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { eventDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBEvent, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useEventsQuery\");\n\n/**\n * Query for getting all events for a user\n */\nexport function useEventsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"events\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const events = await eventDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(userId).catch((error) => {\n          logger.warn(\"Background events sync failed\", { error });\n        });\n      }\n\n      return events;\n    },\n    ...cacheConfig.events, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting recent events (last 30 days)\n */\nexport function useRecentEventsQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"recent\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents\n        .filter((event) => event.timestamp >= thirtyDaysAgo)\n        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Query for getting events by type\n */\nexport function useEventsByTypeQuery(\n  userId: string | undefined,\n  eventType: EventType,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"type\", userId, eventType],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents.filter((event) => event.type === eventType);\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for event operations\n */\nexport function useEventMutations() {\n  const queryClient = useQueryClient();\n\n  const createEvent = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      type: EventType;\n      timestamp: Date;\n      notes?: string;\n      duration?: number;\n      isPrivate?: boolean;\n      sessionId?: string;\n      metadata?: Record<string, unknown>;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const { notes, duration, ...restParams } = params;\n      const eventData = {\n        ...restParams,\n        isPrivate: restParams.isPrivate ?? false, // Ensure isPrivate is always defined\n        details: {\n          notes,\n          duration,\n        },\n      };\n      const event = await eventDBService.createEvent(eventData);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event creation sync failed\", { error });\n        });\n      }\n\n      return event;\n    },\n    onSuccess: (data, variables) => {\n      // Add event to the cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return [data];\n          return [data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create event\", { error });\n    },\n  });\n\n  const updateEvent = useMutation({\n    mutationFn: async (params: {\n      eventId: string;\n      userId: string;\n      updates: Partial<DBEvent>;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedEvent = await eventDBService.updateEvent(\n        params.eventId,\n        params.updates,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event update sync failed\", { error });\n        });\n      }\n\n      return updatedEvent;\n    },\n    onSuccess: (data, variables) => {\n      // Update event in cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.map((event) =>\n            event.id === variables.eventId\n              ? { ...event, ...(data as Partial<DBEvent>) }\n              : event,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update event\", { error });\n    },\n  });\n\n  const deleteEvent = useMutation({\n    mutationFn: async (params: { eventId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await eventDBService.deleteEvent(params.eventId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event deletion sync failed\", { error });\n        });\n      }\n\n      return params.eventId;\n    },\n    onSuccess: (eventId, variables) => {\n      // Remove event from cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.filter((event) => event.id !== eventId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete event\", { error });\n    },\n  });\n\n  const bulkCreateEvents = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      events: Array<{\n        type: EventType;\n        timestamp: Date;\n        notes?: string;\n        duration?: number;\n        isPrivate?: boolean;\n        sessionId?: string;\n        metadata?: Record<string, unknown>;\n      }>;\n    }) => {\n      // 1. Create all events in local Dexie\n      const createdEvents = await Promise.all(\n        params.events.map((eventData) => {\n          const { notes, duration, ...restEventData } = eventData;\n          return eventDBService.createEvent({\n            ...restEventData,\n            userId: params.userId,\n            isPrivate: restEventData.isPrivate ?? false, // Ensure isPrivate is always defined\n            details: {\n              notes,\n              duration,\n            },\n          });\n        }),\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Bulk event creation sync failed\", { error });\n        });\n      }\n\n      return createdEvents;\n    },\n    onSuccess: (data, variables) => {\n      // Add all events to cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return data;\n          return [...data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to bulk create events\", { error });\n    },\n  });\n\n  return {\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    bulkCreateEvents,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useOfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSessionQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionMutations' has too many lines (113). Maximum allowed is 75.","line":69,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":215,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session TanStack Query Hooks\n * Manages chastity session data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { sessionDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSessionQuery\");\n\n/**\n * Query for getting current active session\n */\nexport function useCurrentSession(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"session\", \"current\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      const session = await sessionDBService.getCurrentSession(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    ...cacheConfig.currentSession, // Apply specific cache settings\n    enabled: !!userId, // The query will not run until the userId is available\n  });\n}\n\n/**\n * Query for getting session history\n */\nexport function useSessionHistory(userId: string | undefined, enabled = true) {\n  return useQuery({\n    queryKey: [\"sessions\", \"history\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const sessions = await sessionDBService.findByUserId(userId);\n\n      // Trigger background sync if online\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session history sync failed:\", { error });\n        });\n      }\n\n      return sessions.sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n    },\n    ...cacheConfig.sessionHistory,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for session operations\n */\nexport function useSessionMutations() {\n  const queryClient = useQueryClient();\n\n  const startSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      startTime?: Date;\n      requiredDuration?: number;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const sessionId = await sessionDBService.startSession(params.userId, {\n        goalDuration: params.requiredDuration,\n        notes: `Session started at ${params.startTime || new Date()}`,\n      });\n\n      // Get the created session\n      const session = await sessionDBService.findById(sessionId);\n      if (!session) {\n        throw new Error(\"Failed to create session\");\n      }\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session start sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    onSuccess: (data, variables) => {\n      // Update the current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n\n      // Invalidate session history to include new session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to start session:\", { error });\n    },\n  });\n\n  const endSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      endTime?: Date;\n      reason?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.endSession(\n        params.userId,\n        params.endTime || new Date(),\n        params.reason,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session end sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Clear current session since it's ended\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], null);\n\n      // Invalidate session history to reflect ended session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to end session:\", { error });\n    },\n  });\n\n  const pauseSession = useMutation({\n    mutationFn: async (params: { userId: string; reason?: string }) => {\n      // 1. Get current session first\n      const currentSession = await sessionDBService.getCurrentSession(\n        params.userId,\n      );\n      if (!currentSession) {\n        throw new Error(\"No active session to pause\");\n      }\n\n      // 2. Update local Dexie immediately\n      await sessionDBService.pauseSession(currentSession.id, new Date());\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session pause sync failed:\", { error });\n        });\n      }\n\n      // Return the updated session\n      const updatedSession = await sessionDBService.getCurrentSession(\n        params.userId,\n      );\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to pause session:\", { error });\n    },\n  });\n\n  const resumeSession = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.resumeSession(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session resume sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to resume session:\", { error });\n    },\n  });\n\n  return {\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSettingsQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSettingsMutations' has too many lines (91). Maximum allowed is 75.","line":49,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":164,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings TanStack Query Hooks\n * Manages user settings with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { settingsDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBSettings } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSettingsQuery\");\n\n/**\n * Query for getting user settings\n */\nexport function useSettingsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"settings\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      let settings = await settingsDBService.getSettings(userId);\n\n      // If no settings exist, create default settings\n      if (!settings) {\n        await settingsDBService.createDefaultSettings(userId);\n        settings = await settingsDBService.getSettings(userId);\n      }\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(userId).catch((error) => {\n          logger.warn(\"Background settings sync failed:\", { error });\n        });\n      }\n\n      return settings;\n    },\n    ...cacheConfig.userSettings, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Mutations for settings operations\n */\nexport function useSettingsMutations() {\n  const queryClient = useQueryClient();\n\n  const updateSettings = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      settings: Partial<DBSettings>;\n    }) => {\n      // 1. Update local Dexie immediately for optimistic update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        params.settings,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache immediately\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update settings:\", { error });\n\n      // Invalidate cache to refetch from server in case of error\n      queryClient.invalidateQueries({\n        queryKey: [\"settings\", \"user\"],\n      });\n    },\n  });\n\n  const resetSettings = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Reset to defaults in local Dexie\n      const defaultSettings = await settingsDBService.createDefaultSettings(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings reset sync failed:\", { error });\n        });\n      }\n\n      return defaultSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache with default values\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to reset settings:\", { error });\n    },\n  });\n\n  const updateTheme = useMutation({\n    mutationFn: async (params: { userId: string; theme: \"light\" | \"dark\" }) => {\n      // Quick theme update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { theme: params.theme },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Theme update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update settings cache\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  const updateEventDisplayMode = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      eventDisplayMode: \"kinky\" | \"vanilla\";\n    }) => {\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { eventDisplayMode: params.eventDisplayMode },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Event display mode sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  return {\n    updateSettings,\n    resetSettings,\n    updateTheme,\n    updateEventDisplayMode,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useTaskQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useTaskMutations' has too many lines (149). Maximum allowed is 75.","line":65,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":244,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task TanStack Query Hooks\n * Manages server state for tasks with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBTask, TaskStatus } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useTaskQuery\");\n\n/**\n * Query for getting all tasks for a user\n */\nexport function useTasksQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"tasks\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const tasks = await taskDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(userId).catch((error) => {\n          logger.warn(\"Background task sync failed\", { error });\n        });\n      }\n\n      return tasks;\n    },\n    ...cacheConfig.tasks, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting pending tasks that need keyholder attention\n */\nexport function usePendingTasksQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"tasks\", \"pending\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allTasks = await taskDBService.findByUserId(userId);\n      return allTasks.filter((task) =>\n        [\"pending\", \"submitted\"].includes(task.status),\n      );\n    },\n    ...cacheConfig.tasks,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for task operations\n */\nexport function useTaskMutations() {\n  const queryClient = useQueryClient();\n\n  const createTask = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      title: string;\n      description?: string;\n      deadline?: Date;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const task = await taskDBService.createTask({\n        ...params,\n        status: \"pending\" as TaskStatus,\n        text: params.description || params.title, // Use description or title as text\n        priority: \"medium\" as const, // Default priority\n        assignedBy: \"submissive\" as const, // Default assignment source\n      });\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task creation sync failed\", { error });\n        });\n      }\n\n      return task;\n    },\n    onSuccess: (data, variables) => {\n      // Invalidate and refetch tasks queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"user\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create task\", { error });\n    },\n  });\n\n  const updateTaskStatus = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      feedback?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        params.status,\n        {\n          keyholderFeedback: params.feedback,\n        },\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task status update sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update specific task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId\n              ? { ...task, ...(data as Partial<DBTask>) }\n              : task,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update task status\", { error });\n    },\n  });\n\n  const deleteTask = useMutation({\n    mutationFn: async (params: { taskId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await taskDBService.deleteTask(params.taskId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task deletion sync failed\", { error });\n        });\n      }\n\n      return params.taskId;\n    },\n    onSuccess: (taskId, variables) => {\n      // Remove task from cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.filter((task) => task.id !== taskId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete task\", { error });\n    },\n  });\n\n  const submitTaskForReview = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      note?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        \"submitted\",\n        {\n          submissiveNote: params.note,\n        },\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task submission sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId\n              ? { ...task, ...(data as Partial<DBTask>) }\n              : task,\n          );\n        },\n      );\n\n      // Invalidate pending tasks since this affects that query\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to submit task for review\", { error });\n    },\n  });\n\n  return {\n    createTask,\n    updateTaskStatus,\n    deleteTask,\n    submitTaskForReview,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useTasks.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useTasks' has too many lines (81). Maximum allowed is 75.","line":45,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":146,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useUpdateTaskStatus' has too many lines (95). Maximum allowed is 75.","line":282,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":396,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"../../services/database/TaskDBService\";\nimport { Task, TaskStatus, DBTask, TaskFilters } from \"../../types/database\";\nimport { logger } from \"../../utils/logging\";\nimport { taskKeys } from \"./tasks-utils\";\n\n/**\n * Task Management Hooks - TanStack Query Integration\n *\n * Integrates with:\n * - taskDBService ‚Üí Dexie ‚Üí Firebase sync\n * - TasksPage.tsx, TaskManagement.tsx (critical fixes needed)\n *\n * Fixes:\n * - TasksPage.tsx:20 (taskDBService.findByUserId)\n * - TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n *\n * Strategy: Optimistic update + background sync\n */\n\n// Types\ninterface CreateTaskData {\n  title: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  assignedBy?: string; // keyholder UID\n  metadata?: Record<string, unknown>;\n}\n\ninterface UpdateTaskData {\n  title?: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Get tasks for a user with optional filtering\n * Fixes: TasksPage.tsx:20 (taskDBService.findByUserId)\n */\nexport function useTasks(userId: string, filters?: TaskFilters) {\n  return useQuery({\n    queryKey: taskKeys.list(userId, filters),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks\", { userId, filters });\n\n      try {\n        const tasks = await taskDBService.findByUserId(userId);\n\n        // Apply filters\n        let filteredTasks = tasks;\n\n        if (filters?.status) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.status === filters.status,\n          );\n        }\n\n        if (filters?.priority) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.priority === filters.priority,\n          );\n        }\n\n        if (filters?.category) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.category === filters.category,\n          );\n        }\n\n        if (filters?.assignedBy) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.assignedBy === filters.assignedBy,\n          );\n        }\n\n        if (filters?.dueDate) {\n          filteredTasks = filteredTasks.filter((task) => {\n            if (!task.dueDate) return false;\n            const taskDue = new Date(task.dueDate);\n\n            if (filters.dueDate?.start && taskDue < filters.dueDate.start)\n              return false;\n            if (filters.dueDate?.end && taskDue > filters.dueDate.end)\n              return false;\n\n            return true;\n          });\n        }\n\n        // Sort by priority and due date\n        filteredTasks.sort((a, b) => {\n          // Priority sorting (urgent > high > medium > low)\n          const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };\n          const aPriority =\n            priorityOrder[a.priority as keyof typeof priorityOrder] ||\n            priorityOrder.medium;\n          const bPriority =\n            priorityOrder[b.priority as keyof typeof priorityOrder] ||\n            priorityOrder.medium;\n\n          if (aPriority !== bPriority) {\n            return bPriority - aPriority;\n          }\n\n          // Due date sorting (sooner first)\n          if (a.dueDate && b.dueDate) {\n            return (\n              new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()\n            );\n          }\n\n          if (a.dueDate && !b.dueDate) return -1;\n          if (!a.dueDate && b.dueDate) return 1;\n\n          // Created date sorting (newest first)\n          return (\n            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n          );\n        });\n\n        logger.info(\"Tasks retrieved successfully\", {\n          userId,\n          totalTasks: tasks.length,\n          filteredTasks: filteredTasks.length,\n        });\n\n        return filteredTasks;\n      } catch (error) {\n        logger.error(\"Failed to fetch tasks\", {\n          error: error instanceof Error ? error.message : String(error),\n          userId,\n          filters,\n        });\n        throw error;\n      }\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes - active data\n    gcTime: 30 * 60 * 1000, // 30 minutes garbage collection\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get tasks by status (useful for kanban boards)\n */\nexport function useTasksByStatus(userId: string, status: TaskStatus) {\n  return useQuery({\n    queryKey: taskKeys.byStatus(userId, status),\n    queryFn: async (): Promise<Task[]> => {\n      const tasks = await taskDBService.findByUserId(userId);\n      return tasks.filter((task) => task.status === status);\n    },\n    staleTime: 2 * 60 * 1000,\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get single task by ID\n */\nexport function useTask(taskId: string) {\n  return useQuery({\n    queryKey: taskKeys.detail(taskId),\n    queryFn: async (): Promise<Task | null> => {\n      logger.info(\"Fetching task detail\", { taskId });\n      const task = await taskDBService.findById(taskId);\n      return task ?? null;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes - task details are stable\n    enabled: !!taskId,\n  });\n}\n\n/**\n * Get tasks assigned by a specific keyholder\n */\nexport function useTasksAssignedBy(keyholderUid: string) {\n  return useQuery({\n    queryKey: taskKeys.assignedBy(keyholderUid),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks assigned by keyholder\", { keyholderUid });\n\n      // Note: This would require a different query method in the future\n      // For now, we'll need to scan all tasks (inefficient but works)\n      const allTasks = await taskDBService.getAll();\n      return allTasks.filter((task: Task) => task.assignedBy === keyholderUid);\n    },\n    staleTime: 5 * 60 * 1000,\n    enabled: !!keyholderUid,\n  });\n}\n\n/**\n * Create new task\n */\nexport function useCreateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      taskData,\n    }: {\n      userId: string;\n      taskData: CreateTaskData;\n    }): Promise<DBTask> => {\n      logger.info(\"Creating new task\", { userId, title: taskData.title });\n\n      // Generate task ID\n      const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      const newTask: DBTask = {\n        id: taskId,\n        userId,\n        text: taskData.title, // DBTask uses 'text' field\n        title: taskData.title,\n        description: taskData.description || \"\",\n        status: \"pending\",\n        priority: taskData.priority || \"medium\",\n        category: taskData.category,\n        dueDate: taskData.dueDate,\n        assignedBy:\n          (taskData.assignedBy as \"submissive\" | \"keyholder\") || \"submissive\",\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      // Dexie-first write for immediate UI response\n      await taskDBService.create(newTask);\n\n      logger.info(\"Task created successfully\", {\n        taskId,\n        userId,\n        title: taskData.title,\n      });\n\n      return newTask;\n    },\n    onSuccess: (\n      newTask: Task,\n      { userId }: { userId: string; taskData: CreateTaskData },\n    ) => {\n      logger.info(\"Task creation successful\", { taskId: newTask.id, userId });\n\n      // Invalidate task lists to trigger refetch\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n\n      // Optimistically add to cache if we have existing data\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return [newTask, ...oldData];\n        },\n      );\n    },\n    onError: (error, { userId, taskData }) => {\n      logger.error(\"Task creation failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        userId,\n        title: taskData.title,\n      });\n    },\n  });\n}\n\n/**\n * Update task status (most common operation)\n * Fixes: TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n * Strategy: Optimistic update + background sync\n */\nexport function useUpdateTaskStatus() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      status,\n      completedAt,\n    }: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      completedAt?: Date;\n    }): Promise<Task> => {\n      logger.info(\"Updating task status\", { taskId, userId, status });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        status,\n        completedAt:\n          status === \"completed\" ? completedAt || new Date() : undefined,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.updateTaskStatus(taskId, status);\n\n      logger.info(\"Task status updated successfully\", {\n        taskId,\n        userId,\n        status,\n      });\n\n      return updatedTask;\n    },\n    onMutate: async ({ taskId, userId, status }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: taskKeys.detail(taskId) });\n      await queryClient.cancelQueries({ queryKey: taskKeys.list(userId) });\n\n      // Snapshot previous values\n      const previousTask = queryClient.getQueryData(taskKeys.detail(taskId));\n      const previousTasks = queryClient.getQueryData(taskKeys.list(userId));\n\n      // Optimistically update task detail\n      queryClient.setQueryData(\n        taskKeys.detail(taskId),\n        (old: Task | undefined) => {\n          if (!old) return old;\n          return { ...old, status, updatedAt: new Date() };\n        },\n      );\n\n      // Optimistically update task lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return oldData;\n          return oldData.map((task) =>\n            task.id === taskId\n              ? { ...task, status, updatedAt: new Date() }\n              : task,\n          );\n        },\n      );\n\n      return { previousTask, previousTasks };\n    },\n    onSuccess: (\n      updatedTask: Task,\n      {\n        userId,\n        taskId,\n      }: { userId: string; taskId: string; status: TaskStatus },\n    ) => {\n      logger.info(\"Task status update successful\", {\n        taskId,\n        userId,\n        status: updatedTask.status,\n      });\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n\n      // If task was completed, invalidate pending tasks\n      if (updatedTask.status === \"completed\") {\n        queryClient.invalidateQueries({\n          queryKey: taskKeys.byStatus(userId, \"pending\"),\n        });\n      }\n    },\n    onError: (error, { taskId, userId }, context) => {\n      logger.error(\"Task status update failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n\n      // Rollback optimistic updates\n      if (context?.previousTask) {\n        queryClient.setQueryData(taskKeys.detail(taskId), context.previousTask);\n      }\n      if (context?.previousTasks) {\n        queryClient.setQueryData(taskKeys.list(userId), context.previousTasks);\n      }\n    },\n  });\n}\n\n/**\n * Update full task details\n */\nexport function useUpdateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      updates,\n    }: {\n      taskId: string;\n      userId: string;\n      updates: UpdateTaskData;\n    }): Promise<Task> => {\n      logger.info(\"Updating task\", { taskId, userId });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.update(taskId, updatedTask);\n\n      logger.info(\"Task updated successfully\", { taskId, userId });\n\n      return updatedTask;\n    },\n    onSuccess: (\n      updatedTask: Task,\n      {\n        userId,\n        taskId,\n      }: { userId: string; taskId: string; updates: UpdateTaskData },\n    ) => {\n      logger.info(\"Task update successful\", { taskId, userId });\n\n      // Update detail cache\n      queryClient.setQueryData(taskKeys.detail(taskId), updatedTask);\n\n      // Invalidate list queries to reflect changes\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task update failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n    },\n  });\n}\n\n/**\n * Delete task\n */\nexport function useDeleteTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n    }: {\n      taskId: string;\n      userId: string;\n    }): Promise<void> => {\n      logger.info(\"Deleting task\", { taskId, userId });\n\n      await taskDBService.delete(taskId);\n\n      logger.info(\"Task deleted successfully\", { taskId, userId });\n    },\n    onSuccess: (\n      _: void,\n      { taskId, userId }: { taskId: string; userId: string },\n    ) => {\n      logger.info(\"Task deletion successful\", { taskId, userId });\n\n      // Remove from detail cache\n      queryClient.removeQueries({ queryKey: taskKeys.detail(taskId) });\n\n      // Invalidate list queries\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"completed\"),\n      });\n\n      // Optimistically remove from cached lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return oldData.filter((task) => task.id !== taskId);\n        },\n      );\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task deletion failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n    },\n  });\n}\n\n/**\n * Get task statistics for dashboard\n */\nexport function useTaskStats(userId: string) {\n  return useQuery({\n    queryKey: [...taskKeys.all, \"stats\", userId],\n    queryFn: async () => {\n      logger.info(\"Calculating task statistics\", { userId });\n\n      const tasks = await taskDBService.findByUserId(userId);\n\n      const stats = {\n        total: tasks.length,\n        pending: tasks.filter((t) => t.status === \"pending\").length,\n        inProgress: tasks.filter((t) => t.status === \"submitted\").length, // Use submitted instead of in_progress\n        completed: tasks.filter((t) => t.status === \"completed\").length,\n        overdue: tasks.filter((t) => {\n          if (!t.dueDate || t.status === \"completed\") return false;\n          return new Date(t.dueDate) < new Date();\n        }).length,\n        byPriority: {\n          high: tasks.filter((t) => t.priority === \"high\").length,\n          medium: tasks.filter((t) => t.priority === \"medium\").length,\n          low: tasks.filter((t) => t.priority === \"low\").length,\n        },\n        completionRate:\n          tasks.length > 0\n            ? Math.round(\n                (tasks.filter((t) => t.status === \"completed\").length /\n                  tasks.length) *\n                  100,\n              )\n            : 0,\n      };\n\n      return stats;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    enabled: !!userId,\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/types/dataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/types/statistics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useConflictResolution.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (110). Maximum allowed is 75.","line":26,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":152,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for handling data sync conflict resolution\n */\nimport { useCallback, Dispatch, SetStateAction } from \"react\";\nimport type {\n  DataConflict,\n  ConflictResolution,\n  GlobalResolutionStrategy,\n  ConflictResolutionResult,\n  SyncMetrics,\n} from \"./types/dataSync\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  intelligentMerge,\n  getLatestTimestampVersion,\n} from \"../../utils/dataSyncHelpers\";\n\nconst logger = serviceLogger(\"useConflictResolution\");\n\ninterface UseConflictResolutionProps {\n  conflicts: DataConflict[];\n  setConflicts: Dispatch<SetStateAction<DataConflict[]>>;\n  setSyncMetrics: Dispatch<SetStateAction<SyncMetrics>>;\n}\n\nexport const useConflictResolution = ({\n  conflicts,\n  setConflicts,\n  setSyncMetrics,\n}: UseConflictResolutionProps) => {\n  const resolveConflict = useCallback(\n    async (\n      conflictId: string,\n      resolution: ConflictResolution,\n    ): Promise<void> => {\n      try {\n        logger.debug(\"Resolving conflict\", { conflictId, resolution });\n\n        const conflict = conflicts.find((c) => c.id === conflictId);\n        if (!conflict) {\n          throw new Error(\"Conflict not found\");\n        }\n\n        // Apply resolution strategy\n        let _resolvedData: Record<string, unknown>;\n\n        switch (resolution.strategy) {\n          case \"local_wins\":\n            _resolvedData = conflict.localVersion;\n            break;\n          case \"remote_wins\":\n            _resolvedData = conflict.remoteVersion;\n            break;\n          case \"keyholder_wins\":\n            _resolvedData = conflict.keyholderVersion || conflict.remoteVersion;\n            break;\n          case \"merge_intelligent\":\n            _resolvedData = intelligentMerge(\n              conflict.localVersion,\n              conflict.remoteVersion,\n            );\n            break;\n          case \"latest_timestamp\":\n            _resolvedData = getLatestTimestampVersion(conflict);\n            break;\n          default:\n            throw new Error(\n              `Unsupported resolution strategy: ${resolution.strategy}`,\n            );\n        }\n\n        // Remove resolved conflict\n        setConflicts((prev) => prev.filter((c) => c.id !== conflictId));\n\n        // Update metrics\n        setSyncMetrics((prev) => ({\n          ...prev,\n          conflictsResolved: prev.conflictsResolved + 1,\n        }));\n\n        logger.info(\"Conflict resolved successfully\", {\n          conflictId,\n          strategy: resolution.strategy,\n        });\n      } catch (error) {\n        logger.error(\"Failed to resolve conflict\", { error, conflictId });\n        throw error;\n      }\n    },\n    [conflicts, setConflicts, setSyncMetrics],\n  );\n\n  const resolveAllConflicts = useCallback(\n    async (\n      strategy: GlobalResolutionStrategy,\n    ): Promise<ConflictResolutionResult[]> => {\n      try {\n        logger.debug(\"Resolving all conflicts\", {\n          strategy,\n          conflictCount: conflicts.length,\n        });\n\n        const results: ConflictResolutionResult[] = [];\n\n        for (const conflict of conflicts) {\n          try {\n            const resolutionStrategy =\n              strategy.strategyByType[conflict.type] ||\n              strategy.defaultStrategy;\n\n            await resolveConflict(conflict.id, {\n              conflictId: conflict.id,\n              strategy: resolutionStrategy,\n              preserveHistory: true,\n            });\n\n            results.push({\n              conflictId: conflict.id,\n              success: true,\n              appliedStrategy: resolutionStrategy,\n              resultingData: {},\n            });\n          } catch (error) {\n            results.push({\n              conflictId: conflict.id,\n              success: false,\n              appliedStrategy: strategy.defaultStrategy,\n              resultingData: {},\n              error: error instanceof Error ? error.message : \"Unknown error\",\n            });\n          }\n        }\n\n        logger.info(\"Batch conflict resolution completed\", {\n          total: conflicts.length,\n          successful: results.filter((r) => r.success).length,\n        });\n\n        return results;\n      } catch (error) {\n        logger.error(\"Failed to resolve all conflicts\", { error });\n        throw error;\n      }\n    },\n    [conflicts, resolveConflict],\n  );\n\n  return {\n    resolveConflict,\n    resolveAllConflicts,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useDataSync.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useDataSync.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (333). Maximum allowed is 75.","line":35,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":479,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (31). Maximum allowed is 25.","line":35,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":479,"endColumn":2},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'performBackgroundSync'. Either include it or remove the dependency array.","line":165,"column":6,"nodeType":"ArrayExpression","endLine":165,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [performBackgroundSync, realTimeSyncEnabled, syncPermissions]","fix":{"range":[4713,4751],"text":"[performBackgroundSync, realTimeSyncEnabled, syncPermissions]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'initializeRealTimeSync', 'loadPendingConflicts', 'loadRelationshipSyncStatus', 'loadSyncHistory', and 'loadSyncPermissions'. Either include them or remove the dependency array.","line":149,"column":6,"nodeType":"ArrayExpression","endLine":149,"endColumn":49,"suggestions":[{"desc":"Update the dependencies array to be: [userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]","fix":{"range":[4061,4104],"text":"[userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":165,"column":28,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":165,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Data Synchronization Hook\n * Handles multi-user data sync, relationship data, and conflict resolution\n * with proper privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { SyncResult } from \"../../types/database\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateOverallSyncQuality,\n  getLastSuccessfulSync,\n  getSyncInterval,\n} from \"../../utils/dataSyncHelpers\";\nimport { useConflictResolution } from \"./useConflictResolution\";\nimport { useSyncBackup } from \"./useSyncBackup\";\nimport { useSyncMonitoring } from \"./useSyncMonitoring\";\n\nconst logger = serviceLogger(\"useDataSync\");\n\n// ==================== INTERFACES ====================\n\nimport type {\n  SyncStatus,\n  RelationshipSyncStatus,\n  DataConflict,\n  SyncPermissions,\n  SyncMetrics,\n  SyncScope,\n  DataEntityType,\n  RelationshipSyncResult,\n} from \"./types/dataSync\";\nimport type * as _Types from \"./types/dataSync\";\nexport type * from \"./types/dataSync\";\n\nexport const useDataSync = (userId: string) => {\n  // ==================== STATE ====================\n\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    state: \"idle\",\n    lastSync: null,\n    progress: 0,\n    message: \"Ready to sync\",\n    error: null,\n  });\n\n  const [relationshipSync, setRelationshipSync] = useState<\n    RelationshipSyncStatus[]\n  >([]);\n\n  const [conflicts, setConflicts] = useState<DataConflict[]>([]);\n\n  const [syncPermissions, setSyncPermissions] = useState<SyncPermissions>({\n    allowDataSharing: true,\n    shareSessionData: true,\n    shareGoalData: true,\n    shareTaskData: true,\n    shareEventData: false,\n    allowRealTimeSync: false,\n    syncFrequency: \"moderate\",\n    privacyLevel: \"relationship_only\",\n  });\n\n  const [syncMetrics, setSyncMetrics] = useState<SyncMetrics>({\n    totalSyncs: 0,\n    successfulSyncs: 0,\n    failedSyncs: 0,\n    averageSyncTime: 0,\n    dataTransferred: 0,\n    conflictsResolved: 0,\n    lastSuccessfulSync: null,\n    reliabilityScore: 100,\n  });\n\n  const [realTimeSyncEnabled, setRealTimeSyncEnabled] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== SUB-HOOKS ====================\n\n  const conflictResolution = useConflictResolution({\n    conflicts,\n    setConflicts,\n    setSyncMetrics,\n  });\n\n  const syncBackup = useSyncBackup({ userId });\n\n  const syncMonitoring = useSyncMonitoring({ conflicts, syncMetrics });\n\n  // ==================== COMPUTED VALUES ====================\n\n  const isSyncing = useMemo(\n    () => syncStatus.state === \"syncing\",\n    [syncStatus.state],\n  );\n\n  const hasConflicts = useMemo(() => conflicts.length > 0, [conflicts.length]);\n\n  const syncQuality = useMemo(\n    () => calculateOverallSyncQuality(relationshipSync),\n    [relationshipSync],\n  );\n\n  const lastSuccessfulSync = useMemo(\n    () => getLastSuccessfulSync(syncMetrics),\n    [syncMetrics],\n  );\n\n  const needsAttention = useMemo(\n    () =>\n      conflicts.some((c) => c.priority === \"high\" || c.priority === \"critical\"),\n    [conflicts],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSync = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load sync state and configuration\n        await Promise.all([\n          loadSyncPermissions(),\n          loadSyncHistory(),\n          loadPendingConflicts(),\n          loadRelationshipSyncStatus(),\n        ]);\n\n        // Initialize real-time sync if enabled\n        if (syncPermissions.allowRealTimeSync) {\n          await initializeRealTimeSync();\n        }\n      } catch (err) {\n        logger.error(\"Failed to initialize data sync\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize sync\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSync();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, syncPermissions.allowRealTimeSync]);\n\n  // ==================== REAL-TIME SYNC ====================\n\n  useEffect(() => {\n    if (!realTimeSyncEnabled || !syncPermissions.allowRealTimeSync) return;\n\n    const syncInterval = getSyncInterval(syncPermissions.syncFrequency);\n    const interval = setInterval(() => {\n      performBackgroundSync();\n    }, syncInterval);\n\n    return () => clearInterval(interval);\n    // performBackgroundSync is stable (no deps), syncPermissions used for getSyncInterval\n    // syncPermissions is state, not a store action\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [realTimeSyncEnabled, syncPermissions]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSyncPermissions = useCallback(async () => {\n    try {\n      // Load user's sync preferences from database\n      logger.debug(\"Loading sync permissions\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync permissions\", { error });\n    }\n  }, [userId]);\n\n  const loadSyncHistory = useCallback(async () => {\n    try {\n      // Load sync metrics and history\n      logger.debug(\"Loading sync history\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync history\", { error });\n    }\n  }, [userId]);\n\n  const loadPendingConflicts = useCallback(async () => {\n    try {\n      // Load unresolved conflicts\n      setConflicts([]);\n      logger.debug(\"Loading pending conflicts\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load pending conflicts\", { error });\n    }\n  }, [userId]);\n\n  const loadRelationshipSyncStatus = useCallback(async () => {\n    try {\n      // Load sync status for all relationships\n      setRelationshipSync([]);\n      logger.debug(\"Loading relationship sync status\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load relationship sync status\", { error });\n    }\n  }, [userId]);\n\n  // ==================== MANUAL SYNC OPERATIONS ====================\n\n  const forceSyncAll = useCallback(async (): Promise<SyncResult> => {\n    try {\n      logger.debug(\"Starting force sync all\", { userId });\n\n      setSyncStatus({\n        state: \"syncing\",\n        lastSync: null,\n        progress: 0,\n        message: \"Starting synchronization...\",\n        error: null,\n      });\n\n      // Simulate sync process\n      for (let i = 0; i <= 100; i += 20) {\n        setSyncStatus((prev) => ({\n          ...prev,\n          progress: i,\n          message: `Syncing... ${i}%`,\n        }));\n        await new Promise((resolve) => setTimeout(resolve, 200));\n      }\n\n      const result: SyncResult = {\n        success: true,\n        operations: {\n          uploaded: 15,\n          downloaded: 8,\n          conflicts: 2,\n        },\n        conflicts: [],\n        timestamp: new Date(),\n      };\n\n      setSyncStatus({\n        state: \"completed\",\n        lastSync: new Date(),\n        progress: 100,\n        message: \"Sync completed successfully\",\n        error: null,\n      });\n\n      // Update metrics\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        successfulSyncs: prev.successfulSyncs + 1,\n        lastSuccessfulSync: new Date(),\n      }));\n\n      logger.info(\"Force sync completed successfully\", { result });\n      return result;\n    } catch (error) {\n      logger.error(\"Force sync failed\", { error });\n\n      setSyncStatus({\n        state: \"error\",\n        lastSync: null,\n        progress: 0,\n        message: \"Sync failed\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        failedSyncs: prev.failedSyncs + 1,\n      }));\n\n      throw error;\n    }\n  }, [userId]);\n\n  const syncRelationshipData = useCallback(\n    async (relationshipId: string): Promise<RelationshipSyncResult> => {\n      try {\n        logger.debug(\"Syncing relationship data\", { relationshipId });\n\n        const startTime = Date.now();\n\n        // Find relationship sync status\n        const relationshipStatus = relationshipSync.find(\n          (rs) => rs.relationshipId === relationshipId,\n        );\n        if (!relationshipStatus) {\n          throw new Error(\"Relationship not found\");\n        }\n\n        // Perform relationship-specific sync\n        const result: RelationshipSyncResult = {\n          relationshipId,\n          success: true,\n          syncedCollections: [\"sessions\", \"goals\", \"tasks\"],\n          conflictsFound: 1,\n          conflictsResolved: 0,\n          metrics: {\n            duration: Date.now() - startTime,\n            itemsSynced: 12,\n            bytesTransferred: 4096,\n          },\n        };\n\n        // Update relationship sync status\n        setRelationshipSync((prev) =>\n          prev.map((rs) =>\n            rs.relationshipId === relationshipId\n              ? { ...rs, lastSync: new Date() }\n              : rs,\n          ),\n        );\n\n        logger.info(\"Relationship sync completed\", { relationshipId, result });\n        return result;\n      } catch (error) {\n        logger.error(\"Relationship sync failed\", { error, relationshipId });\n\n        return {\n          relationshipId,\n          success: false,\n          syncedCollections: [],\n          conflictsFound: 0,\n          conflictsResolved: 0,\n          error: error instanceof Error ? error.message : \"Unknown error\",\n          metrics: {\n            duration: 0,\n            itemsSynced: 0,\n            bytesTransferred: 0,\n          },\n        };\n      }\n    },\n    [relationshipSync],\n  );\n\n  // ==================== PRIVACY AND PERMISSIONS ====================\n\n  const updateSyncPermissions = useCallback(\n    async (permissions: Partial<SyncPermissions>): Promise<void> => {\n      try {\n        logger.debug(\"Updating sync permissions\", { permissions });\n\n        const updatedPermissions = { ...syncPermissions, ...permissions };\n        setSyncPermissions(updatedPermissions);\n\n        // Update real-time sync based on new permissions\n        if (\n          updatedPermissions.allowRealTimeSync !==\n          syncPermissions.allowRealTimeSync\n        ) {\n          if (updatedPermissions.allowRealTimeSync) {\n            await initializeRealTimeSync();\n          } else {\n            setRealTimeSyncEnabled(false);\n          }\n        }\n\n        logger.info(\"Sync permissions updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update sync permissions\", { error });\n        throw error;\n      }\n    },\n    [syncPermissions, initializeRealTimeSync],\n  );\n\n  const configureSyncScope = useCallback(\n    async (scope: SyncScope): Promise<void> => {\n      try {\n        logger.debug(\"Configuring sync scope\", { scope });\n        // Configure what data gets synced\n        logger.info(\"Sync scope configured successfully\");\n      } catch (error) {\n        logger.error(\"Failed to configure sync scope\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== REAL-TIME SYNC ====================\n\n  const enableRealtimeSync = useCallback(\n    (entityTypes: DataEntityType[]): void => {\n      try {\n        logger.debug(\"Enabling realtime sync\", { entityTypes });\n        setRealTimeSyncEnabled(true);\n        // Set up WebSocket connections or other real-time mechanisms\n        logger.info(\"Realtime sync enabled successfully\");\n      } catch (error) {\n        logger.error(\"Failed to enable realtime sync\", { error });\n      }\n    },\n    [],\n  );\n\n  const disableRealtimeSync = useCallback((): void => {\n    try {\n      logger.debug(\"Disabling realtime sync\");\n      setRealTimeSyncEnabled(false);\n      // Clean up real-time connections\n      logger.info(\"Realtime sync disabled successfully\");\n    } catch (error) {\n      logger.error(\"Failed to disable realtime sync\", { error });\n    }\n  }, []);\n\n  // ==================== PRIVATE HELPER FUNCTIONS ====================\n\n  const initializeRealTimeSync = useCallback(async (): Promise<void> => {\n    try {\n      logger.debug(\"Initializing real-time sync\");\n      setRealTimeSyncEnabled(true);\n      // Set up WebSocket connections, event listeners, etc.\n    } catch (error) {\n      logger.error(\"Failed to initialize real-time sync\", { error });\n    }\n  }, []);\n\n  const performBackgroundSync = useCallback(async (): Promise<void> => {\n    try {\n      // Perform lightweight background sync\n      logger.debug(\"Performing background sync\");\n    } catch (error) {\n      logger.error(\"Background sync failed\", { error });\n    }\n  }, []);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Sync state\n    syncStatus,\n    relationshipSync,\n    conflicts,\n    syncMetrics,\n\n    // Manual sync operations\n    forceSyncAll,\n    syncRelationshipData,\n\n    // Conflict resolution (from useConflictResolution hook)\n    resolveConflict: conflictResolution.resolveConflict,\n    resolveAllConflicts: conflictResolution.resolveAllConflicts,\n\n    // Privacy and permissions\n    updateSyncPermissions,\n    configureSyncScope,\n\n    // Real-time sync\n    enableRealtimeSync,\n    disableRealtimeSync,\n\n    // Backup and recovery (from useSyncBackup hook)\n    createBackup: syncBackup.createBackup,\n    restoreFromBackup: syncBackup.restoreFromBackup,\n\n    // Monitoring (from useSyncMonitoring hook)\n    getSyncHealth: syncMonitoring.getSyncHealth,\n    getSyncHistory: syncMonitoring.getSyncHistory,\n\n    // Computed values\n    isSyncing,\n    hasConflicts,\n    syncQuality,\n    lastSuccessfulSync,\n    needsAttention,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useStatistics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useStatistics.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (496). Maximum allowed is 75.","line":46,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":634,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (33). Maximum allowed is 25.","line":46,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":634,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'KeyholderStatisticsView' is not defined.","line":319,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":319,"endColumn":51},{"ruleId":"no-undef","severity":1,"message":"'StatisticType' is not defined.","line":571,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":571,"endColumn":36},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (527). Maximum allowed is 500.","line":590,"column":1,"nodeType":null,"messageId":"exceed","endLine":635,"endColumn":1}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadAchievementStatistics', 'loadComparativeStatistics', 'loadGoalStatistics', 'loadPredictiveAnalytics', 'loadRecommendations', 'loadSessionStatistics', and 'loadSharedStatistics'. Either include them or remove the dependency array.","line":226,"column":6,"nodeType":"ArrayExpression","endLine":226,"endColumn":30,"suggestions":[{"desc":"Update the dependencies array to be: [userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]","fix":{"range":[5810,5834],"text":"[userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive Statistics Hook\n * Provides analytics and insights for both users and keyholders\n * with appropriate privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateImprovementScore,\n  calculateConsistencyRating,\n  calculateOverallProgress,\n  calculateKeyholderSatisfaction,\n} from \"../../utils/statisticsHelpers\";\n\nconst logger = serviceLogger(\"useStatistics\");\n\n// ==================== INTERFACES ====================\n\n// Re-export all types from the types file\nexport type * from \"./types/statistics\";\n\nimport type {\n  SessionStatistics,\n  GoalStatistics,\n  AchievementStatistics,\n  ComparativeStatistics,\n  SharedStatistics,\n  PredictiveAnalytics,\n  RecommendationEngine,\n  TimePeriod,\n  PeriodStatistics,\n  MonthlyTrends,\n  WeeklyBreakdown,\n  ComparisonResult,\n  BenchmarkData,\n  KeyholderDashboardStats,\n  RelationshipComparisonStats,\n  PredictiveInsights,\n  Recommendation,\n  StatisticsExport,\n  ExportFormat,\n} from \"./types/statistics\";\n\n// ==================== HOOK IMPLEMENTATION ====================\n\nexport const useStatistics = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessionStats, setSessionStats] = useState<SessionStatistics>({\n    totalSessionTime: 0,\n    averageSessionLength: 0,\n    longestSession: 0,\n    shortestSession: 0,\n    sessionsThisWeek: 0,\n    sessionsThisMonth: 0,\n    sessionFrequency: {\n      daily: 0,\n      weekly: 0,\n      monthly: 0,\n      trend: \"stable\",\n    },\n    completionRate: 0,\n    goalAchievementRate: 0,\n    satisfactionRating: 0,\n    trends: [],\n    streaks: {\n      current: 0,\n      longest: 0,\n      type: \"session_consistency\",\n    },\n  });\n\n  const [goalStats, setGoalStats] = useState<GoalStatistics>({\n    totalGoals: 0,\n    completedGoals: 0,\n    activeGoals: 0,\n    completionRate: 0,\n    averageCompletionTime: 0,\n    mostCommonGoalTypes: [],\n    hardestGoalTypes: [],\n    goalStreaks: {\n      current: 0,\n      longest: 0,\n      type: \"goal_completion\",\n    },\n  });\n\n  const [achievementStats, setAchievementStats] =\n    useState<AchievementStatistics>({\n      totalAchievements: 0,\n      recentAchievements: [],\n      achievementsByCategory: [],\n      rareAchievements: [],\n      achievementPoints: 0,\n      percentileRank: 0,\n    });\n\n  const [comparativeStats, setComparativeStats] =\n    useState<ComparativeStatistics>({\n      userPercentile: 50,\n      averageUserStats: sessionStats,\n      personalBest: {\n        longestSession: 0,\n        mostGoalsInSession: 0,\n        longestStreak: 0,\n        highestSatisfactionRating: 0,\n        bestMonth: {\n          month: \"\",\n          year: 0,\n          totalTime: 0,\n          sessionCount: 0,\n        },\n      },\n      improvements: {\n        sessionLength: { improvement: 0, timeframe: \"month\" },\n        consistency: { improvement: 0, timeframe: \"month\" },\n        goalCompletion: { improvement: 0, timeframe: \"month\" },\n      },\n    });\n\n  const [sharedStats, setSharedStats] = useState<SharedStatistics>({\n    allowedMetrics: [],\n    keyholderView: {\n      sessionOverview: {\n        totalSessions: 0,\n        averageDuration: 0,\n        lastSessionDate: new Date(),\n      },\n      goalProgress: {\n        activeGoals: 0,\n        completionRate: 0,\n      },\n      behaviorPatterns: {\n        consistency: 0,\n        pauseFrequency: 0,\n        improvementTrend: \"stable\",\n      },\n      allowedInsights: [],\n    },\n    lastSharedAt: new Date(),\n    sharingLevel: \"basic\",\n  });\n\n  const [_predictiveAnalytics, setPredictiveAnalytics] =\n    useState<PredictiveAnalytics>({\n      nextSessionPrediction: {\n        suggestedDuration: 0,\n        successProbability: 0,\n        optimalStartTime: new Date(),\n        riskFactors: [],\n      },\n      goalRecommendations: [],\n      improvementOpportunities: [],\n      trendPredictions: [],\n    });\n\n  const [_recommendations, setRecommendations] = useState<RecommendationEngine>(\n    {\n      sessionRecommendations: [],\n      goalRecommendations: [],\n      behaviorInsights: [],\n      personalizedTips: [],\n    },\n  );\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const improvementScore = useMemo(\n    () => calculateImprovementScore(sessionStats.trends),\n    [sessionStats.trends],\n  );\n\n  const consistencyRating = useMemo(\n    () => calculateConsistencyRating(sessionStats),\n    [sessionStats],\n  );\n\n  const overallProgress = useMemo(\n    () => calculateOverallProgress(goalStats),\n    [goalStats],\n  );\n\n  const keyholderSatisfaction = useMemo(\n    () => calculateKeyholderSatisfaction(sharedStats),\n    [sharedStats],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeStatistics = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load all statistics data\n        await Promise.all([\n          loadSessionStatistics(),\n          loadGoalStatistics(),\n          loadAchievementStatistics(),\n          loadComparativeStatistics(),\n          loadSharedStatistics(),\n          loadPredictiveAnalytics(),\n          loadRecommendations(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize statistics\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize statistics\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeStatistics();\n    // Callback functions are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessionStatistics = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Calculate session statistics from historical data\n      const mockStats: SessionStatistics = {\n        totalSessionTime: 7200, // 2 hours\n        averageSessionLength: 3600, // 1 hour\n        longestSession: 7200,\n        shortestSession: 1800,\n        sessionsThisWeek: 3,\n        sessionsThisMonth: 12,\n        sessionFrequency: {\n          daily: 0.4,\n          weekly: 3,\n          monthly: 12,\n          trend: \"stable\",\n        },\n        completionRate: 85,\n        goalAchievementRate: 75,\n        satisfactionRating: 4.2,\n        trends: [],\n        streaks: {\n          current: 5,\n          longest: 12,\n          type: \"session_consistency\",\n        },\n      };\n\n      setSessionStats(mockStats);\n    } catch (error) {\n      logger.error(\"Failed to load session statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadGoalStatistics = useCallback(async () => {\n    try {\n      // Calculate goal statistics from historical goal data\n      setGoalStats({\n        totalGoals: 25,\n        completedGoals: 20,\n        activeGoals: 3,\n        completionRate: 80,\n        averageCompletionTime: 48, // hours\n        mostCommonGoalTypes: [],\n        hardestGoalTypes: [],\n        goalStreaks: {\n          current: 3,\n          longest: 8,\n          type: \"goal_completion\",\n        },\n      });\n    } catch (error) {\n      logger.error(\"Failed to load goal statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadAchievementStatistics = useCallback(async () => {\n    try {\n      // Load achievement data\n      setAchievementStats({\n        totalAchievements: 15,\n        recentAchievements: [],\n        achievementsByCategory: [],\n        rareAchievements: [],\n        achievementPoints: 1500,\n        percentileRank: 75,\n      });\n    } catch (error) {\n      logger.error(\"Failed to load achievement statistics\", { error });\n    }\n  }, []);\n\n  const loadComparativeStatistics = useCallback(async () => {\n    try {\n      // Load comparative data (anonymized benchmarks)\n      setComparativeStats((prev) => ({\n        ...prev,\n        userPercentile: 72,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load comparative statistics\", { error });\n    }\n  }, []); // sessionStats not actually used for computation\n\n  const loadSharedStatistics = useCallback(async () => {\n    try {\n      if (!relationshipId) return;\n\n      // Load keyholder-specific statistics view\n      const keyholderView: KeyholderStatisticsView = {\n        sessionOverview: {\n          totalSessions: sessionStats.sessionsThisMonth,\n          averageDuration: sessionStats.averageSessionLength,\n          lastSessionDate: new Date(),\n        },\n        goalProgress: {\n          activeGoals: goalStats.activeGoals,\n          completionRate: goalStats.completionRate,\n        },\n        behaviorPatterns: {\n          consistency: consistencyRating,\n          pauseFrequency: 0.2,\n          improvementTrend: \"improving\",\n        },\n        allowedInsights: [\"session_duration\", \"goal_completion\"],\n      };\n\n      setSharedStats((prev) => ({\n        ...prev,\n        keyholderView,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load shared statistics\", { error });\n    }\n  }, [\n    relationshipId,\n    consistencyRating,\n    sessionStats.sessionsThisMonth,\n    sessionStats.averageSessionLength,\n    goalStats.activeGoals,\n    goalStats.completionRate,\n  ]);\n\n  const loadPredictiveAnalytics = useCallback(async () => {\n    try {\n      // Generate predictive insights based on historical data\n      setPredictiveAnalytics({\n        nextSessionPrediction: {\n          suggestedDuration: sessionStats.averageSessionLength * 1.1,\n          successProbability: 85,\n          optimalStartTime: new Date(),\n          riskFactors: [],\n        },\n        goalRecommendations: [],\n        improvementOpportunities: [],\n        trendPredictions: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load predictive analytics\", { error });\n    }\n  }, [sessionStats.averageSessionLength]);\n\n  const loadRecommendations = useCallback(async () => {\n    try {\n      // Generate personalized recommendations\n      setRecommendations({\n        sessionRecommendations: [],\n        goalRecommendations: [],\n        behaviorInsights: [],\n        personalizedTips: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load recommendations\", { error });\n    }\n  }, []); // Static data for recommendations\n\n  // ==================== TIME-BASED QUERIES ====================\n\n  const getStatsForPeriod = useCallback(\n    (period: TimePeriod): PeriodStatistics => {\n      // Filter and calculate statistics for specific time period\n      return {\n        period,\n        sessionCount: 0,\n        totalTime: 0,\n        goalCompletionRate: 0,\n        averageSatisfaction: 0,\n      };\n    },\n    [],\n  );\n\n  const getMonthlyTrends = useCallback((_months: number): MonthlyTrends => {\n    // Calculate monthly trends for specified number of months\n    return {\n      months: [],\n      overallTrend: \"stable\",\n    };\n  }, []);\n\n  const getWeeklyBreakdown = useCallback((): WeeklyBreakdown => {\n    // Analyze sessions by day of week\n    return {\n      weekdays: [],\n      weekendVsWeekday: {\n        weekday: {\n          period: { start: new Date(), end: new Date(), label: \"Weekday\" },\n          sessionCount: 0,\n          totalTime: 0,\n          goalCompletionRate: 0,\n          averageSatisfaction: 0,\n        },\n        weekend: {\n          period: { start: new Date(), end: new Date(), label: \"Weekend\" },\n          sessionCount: 0,\n          totalTime: 0,\n          goalCompletionRate: 0,\n          averageSatisfaction: 0,\n        },\n      },\n    };\n  }, []);\n\n  // ==================== COMPARATIVE ANALYSIS ====================\n\n  const compareWithPrevious = useCallback(\n    (_period: TimePeriod): ComparisonResult => {\n      // Compare current metrics with previous period\n      return {\n        metric: \"session_duration\",\n        currentValue: sessionStats.averageSessionLength,\n        previousValue: sessionStats.averageSessionLength * 0.9,\n        change: sessionStats.averageSessionLength * 0.1,\n        changePercentage: 10,\n        trend: \"improving\",\n      };\n    },\n    [sessionStats],\n  );\n\n  const getBenchmarkComparisons = useCallback((): BenchmarkData[] => {\n    // Compare user metrics with anonymized community benchmarks\n    return [\n      {\n        userValue: sessionStats.averageSessionLength,\n        averageValue: 3000, // 50 minutes average\n        percentile: 75,\n        category: \"session_duration\",\n      },\n    ];\n  }, [sessionStats]);\n\n  // ==================== KEYHOLDER FEATURES ====================\n\n  const getKeyholderDashboard = useCallback((): KeyholderDashboardStats => {\n    return {\n      submissiveOverview: {\n        name: \"Submissive\",\n        consistencyScore: consistencyRating,\n        improvementTrend: \"improving\",\n        lastActiveDate: new Date(),\n      },\n      sessionSummary: {\n        thisWeek: sessionStats.sessionsThisWeek,\n        thisMonth: sessionStats.sessionsThisMonth,\n        averageDuration: sessionStats.averageSessionLength,\n        completionRate: sessionStats.completionRate,\n      },\n      goalTracking: {\n        activeGoals: [],\n        completionRate: goalStats.completionRate,\n        upcomingDeadlines: [],\n      },\n      behaviorInsights: {\n        strengths: [],\n        areasForImprovement: [],\n        recommendations: [],\n      },\n    };\n  }, [\n    consistencyRating,\n    sessionStats.sessionsThisWeek,\n    sessionStats.sessionsThisMonth,\n    sessionStats.averageSessionLength,\n    sessionStats.completionRate,\n    goalStats.completionRate,\n  ]);\n\n  const getRelationshipComparison =\n    useCallback((): RelationshipComparisonStats => {\n      return {\n        relationshipDuration: 90, // days\n        sharedSessions: sessionStats.sessionsThisMonth,\n        collaborationScore: 85,\n        satisfactionTrend: \"improving\",\n        milestones: [],\n      };\n    }, [sessionStats.sessionsThisMonth]);\n\n  // ==================== PREDICTIVE ANALYTICS ====================\n\n  const getPredictiveInsights = useCallback((): PredictiveInsights => {\n    return {\n      nextSessionSuccess: {\n        probability: 85,\n        factors: [\"consistent schedule\", \"appropriate goal setting\"],\n      },\n      goalAchievementLikelihood: [],\n      riskAssessment: {\n        burnoutRisk: \"low\",\n        consistencyRisk: \"low\",\n        factors: [],\n      },\n    };\n  }, []);\n\n  const getRecommendations = useCallback((): Recommendation[] => {\n    return [\n      {\n        id: \"rec1\",\n        type: \"session\",\n        title: \"Optimize Session Timing\",\n        description:\n          \"Consider starting sessions earlier in the day for better completion rates\",\n        priority: \"medium\",\n        expectedImpact: \"Improved session completion rate\",\n        actionRequired: \"Adjust session start time\",\n      },\n    ];\n  }, []);\n\n  // ==================== EXPORT AND SHARING ====================\n\n  const exportStatistics = useCallback(\n    async (format: ExportFormat): Promise<StatisticsExport> => {\n      try {\n        logger.debug(\"Exporting statistics\", { format, userId });\n\n        const exportData = {\n          sessionStats,\n          goalStats,\n          achievementStats,\n          exportedAt: new Date(),\n        };\n\n        return {\n          format,\n          data: exportData,\n          generatedAt: new Date(),\n          fileSize: JSON.stringify(exportData).length,\n          downloadUrl: \"https://example.com/download/stats\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to export statistics\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionStats, goalStats, achievementStats],\n  );\n\n  const shareWithKeyholder = useCallback(\n    async (statTypes: StatisticType[]): Promise<void> => {\n      try {\n        if (!relationshipId) {\n          throw new Error(\"No keyholder relationship found\");\n        }\n\n        logger.debug(\"Sharing statistics with keyholder\", { statTypes });\n\n        setSharedStats((prev) => ({\n          ...prev,\n          allowedMetrics: statTypes,\n          lastSharedAt: new Date(),\n        }));\n\n        logger.info(\"Statistics shared with keyholder successfully\");\n      } catch (error) {\n        logger.error(\"Failed to share statistics with keyholder\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Statistics\n    sessionStats,\n    goalStats,\n    achievementStats,\n    comparativeStats,\n\n    // Time-based queries\n    getStatsForPeriod,\n    getMonthlyTrends,\n    getWeeklyBreakdown,\n\n    // Comparative analysis\n    compareWithPrevious,\n    getBenchmarkComparisons,\n\n    // Keyholder features\n    getKeyholderDashboard,\n    getRelationshipComparison,\n\n    // Predictive analytics\n    getPredictiveInsights,\n    getRecommendations,\n\n    // Export and sharing\n    exportStatistics,\n    shareWithKeyholder,\n\n    // Computed values\n    improvementScore,\n    consistencyRating,\n    overallProgress,\n    keyholderSatisfaction,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useSyncBackup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/data/useSyncMonitoring.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/types/Goals.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'EnhancedGoal' is not defined.","line":7,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":30},{"ruleId":"no-undef","severity":1,"message":"'CollaborativeGoal' is not defined.","line":8,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":40},{"ruleId":"no-undef","severity":1,"message":"'GoalRecommendation' is not defined.","line":9,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":39},{"ruleId":"no-undef","severity":1,"message":"'GoalAnalytics' is not defined.","line":10,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":31},{"ruleId":"no-undef","severity":1,"message":"'GoalTemplate' is not defined.","line":11,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":30},{"ruleId":"no-undef","severity":1,"message":"'GoalTemplate' is not defined.","line":23,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":39},{"ruleId":"no-undef","severity":1,"message":"'GoalCategory' is not defined.","line":28,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":27},{"ruleId":"no-undef","severity":1,"message":"'GoalDifficulty' is not defined.","line":29,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":31},{"ruleId":"no-undef","severity":1,"message":"'GoalType' is not defined.","line":31,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":31,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'GoalCategory' is not defined.","line":69,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":27},{"ruleId":"no-undef","severity":1,"message":"'GoalDifficulty' is not defined.","line":70,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":31},{"ruleId":"no-undef","severity":1,"message":"'GoalType' is not defined.","line":72,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Type Definitions for useGoals\n * Extracted for better code organization\n */\n\nexport interface EnhancedGoalState {\n  personalGoals: EnhancedGoal[];\n  collaborativeGoals: CollaborativeGoal[];\n  recommendedGoals: GoalRecommendation[];\n  goalAnalytics: GoalAnalytics;\n  goalTemplates: GoalTemplate[];\n}\n\n// Storage keys\nconst _STORAGE_KEYS = {\n  PERSONAL_GOALS: \"chastity-goals-personal\",\n  COLLABORATIVE_GOALS: \"chastity-goals-collaborative\",\n  GOAL_ANALYTICS: \"chastity-goals-analytics\",\n  GOAL_TEMPLATES: \"chastity-goals-templates\",\n};\n\n// Sample templates\nconst _DEFAULT_TEMPLATES: GoalTemplate[] = [\n  {\n    id: \"chastity-duration-30\",\n    name: \"30-Day Chastity Challenge\",\n    description: \"Complete 30 consecutive days in chastity\",\n    category: GoalCategory.CHASTITY,\n    difficulty: GoalDifficulty.MEDIUM,\n    template: {\n      type: GoalType.DURATION,\n      target: {\n        type: \"duration\",\n        value: 30,\n        unit: \"days\",\n        description: \"30 consecutive days\",\n      },\n      milestones: [\n        {\n          id: \"milestone-1\",\n          name: \"First Week\",\n          description: \"Complete 7 days\",\n          target: 7,\n          achieved: false,\n        },\n        {\n          id: \"milestone-2\",\n          name: \"Two Weeks\",\n          description: \"Complete 14 days\",\n          target: 14,\n          achieved: false,\n        },\n        {\n          id: \"milestone-3\",\n          name: \"Final Week\",\n          description: \"Complete 30 days\",\n          target: 30,\n          achieved: false,\n        },\n      ],\n    },\n    popularity: 85,\n    successRate: 68,\n  },\n  {\n    id: \"behavior-improvement\",\n    name: \"Behavioral Improvement\",\n    description: \"Reduce unwanted behaviors through positive reinforcement\",\n    category: GoalCategory.BEHAVIOR,\n    difficulty: GoalDifficulty.HARD,\n    template: {\n      type: GoalType.BEHAVIORAL,\n      target: {\n        type: \"count\",\n        value: 0,\n        unit: \"incidents\",\n        description: \"Zero incidents per week\",\n      },\n    },\n    popularity: 72,\n    successRate: 54,\n  },\n];\n\n/**\n * Enhanced Goals Hook\n */\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useAccountSettings.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useAccountSettings' has too many lines (111). Maximum allowed is 75.","line":27,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":144,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Settings Hook - Extracts account management from AccountSection component\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface AccountData {\n  email: string;\n  has2FA: boolean;\n}\n\nexport interface UseAccountSettingsReturn {\n  account: AccountData;\n  isLoading: boolean;\n  updateEmail: (email: string) => Promise<void>;\n  updatePassword: (oldPassword: string, newPassword: string) => Promise<void>;\n  enable2FA: () => Promise<string>;\n  disable2FA: (code: string) => Promise<void>;\n  deleteAccount: (password: string) => Promise<void>;\n  isUpdating: boolean;\n  isDeleting: boolean;\n  error: Error | null;\n  has2FA: boolean;\n  qrCode: string | null;\n}\n\nexport function useAccountSettings(): UseAccountSettingsReturn {\n  const [account, setAccount] = useState<AccountData>({\n    email: \"\",\n    has2FA: false,\n  });\n  const [isLoading, setIsLoading] = useState(true);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [qrCode, setQrCode] = useState<string | null>(null);\n\n  const updateEmail = useCallback(async (email: string): Promise<void> => {\n    setIsUpdating(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      setAccount((prev) => ({ ...prev, email }));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to update email\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsUpdating(false);\n    }\n  }, []);\n\n  const updatePassword = useCallback(\n    async (_oldPassword: string, _newPassword: string): Promise<void> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update password\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const enable2FA = useCallback(async (): Promise<string> => {\n    setIsUpdating(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      const mockQR = \"data:image/png;base64,mock-qr-code\";\n      setQrCode(mockQR);\n      setAccount((prev) => ({ ...prev, has2FA: true }));\n      return mockQR;\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to enable 2FA\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsUpdating(false);\n    }\n  }, []);\n\n  const disable2FA = useCallback(async (_code: string): Promise<void> => {\n    setIsUpdating(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      setAccount((prev) => ({ ...prev, has2FA: false }));\n      setQrCode(null);\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to disable 2FA\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsUpdating(false);\n    }\n  }, []);\n\n  const deleteAccount = useCallback(\n    async (_password: string): Promise<void> => {\n      setIsDeleting(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to delete account\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsDeleting(false);\n      }\n    },\n    [],\n  );\n\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    account,\n    isLoading,\n    updateEmail,\n    updatePassword,\n    enable2FA,\n    disable2FA,\n    deleteAccount,\n    isUpdating,\n    isDeleting,\n    error,\n    has2FA: account.has2FA,\n    qrCode,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useDisplaySettings.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useDisplaySettings' has too many lines (122). Maximum allowed is 75.","line":35,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":165,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'setPreviewedSettings' is not defined.","line":141,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":25},{"ruleId":"no-undef","severity":1,"message":"'setPreviewedSettings' is not defined.","line":145,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Display Settings Hook - Extracts settings persistence from DisplaySettingsSection\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface DisplaySettings {\n  theme: \"light\" | \"dark\" | \"auto\";\n  language: string;\n  dateFormat: string;\n  timeFormat: \"12h\" | \"24h\";\n}\n\nexport interface UseDisplaySettingsReturn {\n  displaySettings: DisplaySettings;\n  isLoading: boolean;\n  updateTheme: (theme: \"light\" | \"dark\" | \"auto\") => Promise<void>;\n  updateLanguage: (language: string) => Promise<void>;\n  updateDateFormat: (format: string) => Promise<void>;\n  updateTimeFormat: (format: \"12h\" | \"24h\") => Promise<void>;\n  resetToDefaults: () => Promise<void>;\n  isUpdating: boolean;\n  error: Error | null;\n  previewSettings: (settings: Partial<DisplaySettings>) => void;\n  clearPreview: () => void;\n}\n\nconst defaultSettings: DisplaySettings = {\n  theme: \"auto\",\n  language: \"en\",\n  dateFormat: \"MM/DD/YYYY\",\n  timeFormat: \"12h\",\n};\n\nexport function useDisplaySettings(): UseDisplaySettingsReturn {\n  const [displaySettings, setDisplaySettings] =\n    useState<DisplaySettings>(defaultSettings);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [_previewedSettings, _setPreviewedSettings] =\n    useState<Partial<DisplaySettings> | null>(null);\n\n  const updateTheme = useCallback(\n    async (theme: \"light\" | \"dark\" | \"auto\"): Promise<void> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        setDisplaySettings((prev) => ({ ...prev, theme }));\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update theme\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const updateLanguage = useCallback(\n    async (language: string): Promise<void> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        setDisplaySettings((prev) => ({ ...prev, language }));\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update language\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const updateDateFormat = useCallback(\n    async (dateFormat: string): Promise<void> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        setDisplaySettings((prev) => ({ ...prev, dateFormat }));\n      } catch (err) {\n        const error =\n          err instanceof Error\n            ? err\n            : new Error(\"Failed to update date format\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const updateTimeFormat = useCallback(\n    async (timeFormat: \"12h\" | \"24h\"): Promise<void> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        setDisplaySettings((prev) => ({ ...prev, timeFormat }));\n      } catch (err) {\n        const error =\n          err instanceof Error\n            ? err\n            : new Error(\"Failed to update time format\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const resetToDefaults = useCallback(async (): Promise<void> => {\n    setIsUpdating(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      setDisplaySettings(defaultSettings);\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to reset settings\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsUpdating(false);\n    }\n  }, []);\n\n  const previewSettings = useCallback((settings: Partial<DisplaySettings>) => {\n    setPreviewedSettings(settings);\n  }, []);\n\n  const clearPreview = useCallback(() => {\n    setPreviewedSettings(null);\n  }, []);\n\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    displaySettings,\n    isLoading,\n    updateTheme,\n    updateLanguage,\n    updateDateFormat,\n    updateTimeFormat,\n    resetToDefaults,\n    isUpdating,\n    error,\n    previewSettings,\n    clearPreview,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useGameification.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (457). Maximum allowed is 75.","line":152,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":711,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (30). Maximum allowed is 25.","line":152,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":711,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 16. Maximum allowed is 15.","line":152,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":711,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'ChallengeReward' is not defined.","line":582,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":582,"endColumn":57},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (587). Maximum allowed is 500.","line":596,"column":1,"nodeType":null,"messageId":"exceed","endLine":712,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useGameification Hook - Enhanced Gamification System\n *\n * Comprehensive gamification system beyond basic achievements, including challenges,\n * leaderboards, seasons, and social features.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  PlayerProfile,\n  Challenge,\n  Leaderboard,\n  Season,\n  SocialGameFeatures,\n  Badge,\n  ExperienceSource,\n  LevelResult,\n  LevelUpResult,\n  ChallengeCompletion,\n  LeaderboardRank,\n  FriendComparison,\n  SeasonalReward,\n  PlayerTitle,\n  ChallengeDifficulty,\n  ChallengeType,\n  LeaderboardCategory,\n  LeaderboardPeriod,\n  BadgeCategory,\n  ExperienceEvent,\n} from \"../../types/gamification\";\nimport { logger } from \"../../utils/logging\";\n\n// Storage keys\nconst STORAGE_KEYS = {\n  PLAYER_PROFILE: \"chastity-gamification-profile\",\n  CHALLENGES: \"chastity-gamification-challenges\",\n  LEADERBOARDS: \"chastity-gamification-leaderboards\",\n  SOCIAL_FEATURES: \"chastity-gamification-social\",\n  EXPERIENCE_HISTORY: \"chastity-gamification-experience\",\n};\n\n// Experience values by source\nconst _EXPERIENCE_VALUES = {\n  [ExperienceSource.SESSION_COMPLETE]: 100,\n  [ExperienceSource.CHALLENGE_COMPLETE]: 250,\n  [ExperienceSource.MILESTONE_REACHED]: 150,\n  [ExperienceSource.BEHAVIOR_IMPROVEMENT]: 75,\n  [ExperienceSource.DAILY_CHECK_IN]: 25,\n  [ExperienceSource.SOCIAL_INTERACTION]: 50,\n  [ExperienceSource.GOAL_ACHIEVEMENT]: 200,\n};\n\n// Level thresholds\nconst LEVEL_THRESHOLDS = [\n  0, 100, 250, 500, 1000, 1750, 2750, 4000, 5500, 7500, 10000, 13000, 16500,\n  20500, 25000, 30000, 35500, 41500, 48000, 55000, 62500,\n];\n\n// Default player profile\nconst DEFAULT_PLAYER_PROFILE: PlayerProfile = {\n  level: 1,\n  experience: 0,\n  experienceToNext: 100,\n  title: PlayerTitle.NOVICE,\n  badges: [],\n  stats: {\n    totalExperience: 0,\n    challengesCompleted: 0,\n    currentStreak: 0,\n    longestStreak: 0,\n    totalDuration: 0,\n    badgesEarned: 0,\n    leaderboardRank: {\n      [LeaderboardCategory.EXPERIENCE]: 0,\n      [LeaderboardCategory.DURATION]: 0,\n      [LeaderboardCategory.CHALLENGES]: 0,\n      [LeaderboardCategory.STREAKS]: 0,\n      [LeaderboardCategory.SOCIAL]: 0,\n    },\n    socialConnections: 0,\n    achievementPoints: 0,\n  },\n  preferences: {\n    showLevel: true,\n    showBadges: true,\n    participateInLeaderboards: true,\n    allowSocialFeatures: true,\n    notificationSettings: {\n      levelUp: true,\n      badgeEarned: true,\n      challengeComplete: true,\n      leaderboardUpdate: false,\n      socialActivity: true,\n      seasonalEvents: true,\n    },\n  },\n  joinedAt: new Date(),\n  lastActive: new Date(),\n};\n\n// Sample challenges\nconst SAMPLE_CHALLENGES: Challenge[] = [\n  {\n    id: \"challenge-streak-7\",\n    type: ChallengeType.DURATION,\n    name: \"7-Day Streak\",\n    description: \"Maintain a 7-day consecutive streak\",\n    difficulty: ChallengeDifficulty.BEGINNER,\n    requirements: [\n      {\n        id: \"req-1\",\n        type: \"duration\",\n        description: \"Complete 7 consecutive days\",\n        targetValue: 7,\n        currentValue: 0,\n        completed: false,\n      },\n    ],\n    rewards: [\n      {\n        type: \"experience\",\n        value: 500,\n        description: \"500 XP\",\n        claimed: false,\n      },\n      {\n        type: \"badge\",\n        value: 1,\n        description: \"Streak Master Badge\",\n        claimed: false,\n      },\n    ],\n    startDate: new Date(),\n    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    progress: {\n      percentage: 0,\n      requirementsCompleted: 0,\n      totalRequirements: 1,\n      lastUpdated: new Date(),\n      milestones: [],\n    },\n    isCompleted: false,\n    participants: 247,\n    isPublic: true,\n  },\n];\n\n/**\n * Enhanced Gamification Hook\n */\nexport const useGameification = (userId: string) => {\n  const queryClient = useQueryClient();\n\n  // Get player profile\n  const { data: playerProfile = DEFAULT_PLAYER_PROFILE } =\n    useQuery<PlayerProfile>({\n      queryKey: [\"gamification\", \"profile\", userId],\n      queryFn: () => {\n        const stored = localStorage.getItem(STORAGE_KEYS.PLAYER_PROFILE);\n        return stored\n          ? { ...DEFAULT_PLAYER_PROFILE, ...JSON.parse(stored) }\n          : DEFAULT_PLAYER_PROFILE;\n      },\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000,\n    });\n\n  // Get active challenges\n  const { data: activeChallenges = [] } = useQuery<Challenge[]>({\n    queryKey: [\"gamification\", \"challenges\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.CHALLENGES);\n      const userChallenges = stored ? JSON.parse(stored) : [];\n      return [...SAMPLE_CHALLENGES, ...userChallenges].filter(\n        (c) => !c.isCompleted,\n      );\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get leaderboards\n  const { data: leaderboards = [] } = useQuery<Leaderboard[]>({\n    queryKey: [\"gamification\", \"leaderboards\"],\n    queryFn: async () => {\n      // Simulate leaderboard data\n      return generateSampleLeaderboards();\n    },\n    staleTime: 5 * 60 * 1000,\n    refetchInterval: 10 * 60 * 1000,\n  });\n\n  // Get current season\n  const { data: currentSeason } = useQuery<Season | null>({\n    queryKey: [\"gamification\", \"season\"],\n    queryFn: () => {\n      return {\n        id: \"season-winter-2024\",\n        name: \"Winter Challenge 2024\",\n        description:\n          \"Embrace the cold season with special winter-themed challenges\",\n        theme: \"winter\",\n        startDate: new Date(\"2024-12-01\"),\n        endDate: new Date(\"2024-02-28\"),\n        rewards: generateSeasonalRewards(),\n        challenges: [\"winter-endurance\", \"cold-discipline\"],\n        leaderboards: [\"winter-champions\"],\n        isActive: true,\n      };\n    },\n    staleTime: 60 * 60 * 1000, // 1 hour\n  });\n\n  // Get social features\n  const { data: socialFeatures } = useQuery<SocialGameFeatures>({\n    queryKey: [\"gamification\", \"social\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.SOCIAL_FEATURES);\n      return stored\n        ? JSON.parse(stored)\n        : {\n            friends: [],\n            pendingRequests: [],\n            recentActivity: [],\n            groups: [],\n            comparisons: [],\n          };\n    },\n    enabled: Boolean(userId) && playerProfile.preferences.allowSocialFeatures,\n    staleTime: 2 * 60 * 1000,\n  });\n\n  // Get experience history\n  const { data: experienceHistory = [] } = useQuery<ExperienceEvent[]>({\n    queryKey: [\"gamification\", \"experience\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.EXPERIENCE_HISTORY);\n      return stored ? JSON.parse(stored) : [];\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Accept challenge mutation\n  const acceptChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge accepted\", { challengeId, userId });\n\n      // In a real implementation, this would register the user for the challenge\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Complete challenge mutation\n  const completeChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string): Promise<ChallengeCompletion> => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge completed\", { challengeId, userId });\n\n      // Mark challenge as completed\n      const updatedChallenges = activeChallenges.map((c) =>\n        c.id === challengeId\n          ? {\n              ...c,\n              isCompleted: true,\n              progress: { ...c.progress, percentage: 100 },\n            }\n          : c,\n      );\n      localStorage.setItem(\n        STORAGE_KEYS.CHALLENGES,\n        JSON.stringify(updatedChallenges),\n      );\n\n      // Calculate rewards\n      const experienceGained = challenge.rewards.reduce(\n        (total, reward) =>\n          reward.type === \"experience\" ? total + reward.value : total,\n        0,\n      );\n\n      // Add experience\n      const levelResult = await addExperienceInternal(\n        experienceGained,\n        ExperienceSource.CHALLENGE_COMPLETE,\n      );\n\n      // Create completion result\n      const completion: ChallengeCompletion = {\n        challengeId,\n        completedAt: new Date(),\n        rewards: challenge.rewards,\n        experience: experienceGained,\n        newBadges: challenge.rewards\n          .filter((r) => r.type === \"badge\")\n          .map((r) => createBadgeFromReward(r)),\n        levelUp: levelResult.leveledUp\n          ? {\n              newLevel: levelResult.newLevel,\n              rewards: [],\n              unlockedFeatures: [],\n            }\n          : undefined,\n      };\n\n      // Update stats\n      const updatedProfile = {\n        ...playerProfile,\n        stats: {\n          ...playerProfile.stats,\n          challengesCompleted: playerProfile.stats.challengesCompleted + 1,\n          totalExperience:\n            playerProfile.stats.totalExperience + experienceGained,\n        },\n      };\n      localStorage.setItem(\n        STORAGE_KEYS.PLAYER_PROFILE,\n        JSON.stringify(updatedProfile),\n      );\n      queryClient.setQueryData(\n        [\"gamification\", \"profile\", userId],\n        updatedProfile,\n      );\n\n      return completion;\n    },\n  });\n\n  // Add experience mutation\n  const addExperienceMutation = useMutation({\n    mutationFn: async ({\n      amount,\n      source,\n    }: {\n      amount: number;\n      source: ExperienceSource;\n    }): Promise<LevelResult> => {\n      return addExperienceInternal(amount, source);\n    },\n  });\n\n  // Internal add experience function\n  const addExperienceInternal = async (\n    amount: number,\n    source: ExperienceSource,\n  ): Promise<LevelResult> => {\n    const oldLevel = playerProfile.level;\n    const newExperience = playerProfile.experience + amount;\n\n    // Calculate new level\n    let newLevel = oldLevel;\n    for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {\n      if (newExperience >= LEVEL_THRESHOLDS[i]) {\n        newLevel = i + 1;\n      } else {\n        break;\n      }\n    }\n\n    const experienceToNext =\n      newLevel < LEVEL_THRESHOLDS.length\n        ? LEVEL_THRESHOLDS[newLevel] - newExperience\n        : 0;\n\n    // Create experience event\n    const experienceEvent: ExperienceEvent = {\n      id: `exp-${Date.now()}`,\n      source,\n      amount,\n      description: `Gained ${amount} XP from ${source}`,\n      timestamp: new Date(),\n    };\n\n    // Update experience history\n    const updatedHistory = [experienceEvent, ...experienceHistory].slice(\n      0,\n      100,\n    );\n    localStorage.setItem(\n      STORAGE_KEYS.EXPERIENCE_HISTORY,\n      JSON.stringify(updatedHistory),\n    );\n    queryClient.setQueryData(\n      [\"gamification\", \"experience\", userId],\n      updatedHistory,\n    );\n\n    // Update profile\n    const updatedProfile = {\n      ...playerProfile,\n      level: newLevel,\n      experience: newExperience,\n      experienceToNext,\n      stats: {\n        ...playerProfile.stats,\n        totalExperience: playerProfile.stats.totalExperience + amount,\n      },\n      lastActive: new Date(),\n    };\n\n    localStorage.setItem(\n      STORAGE_KEYS.PLAYER_PROFILE,\n      JSON.stringify(updatedProfile),\n    );\n    queryClient.setQueryData(\n      [\"gamification\", \"profile\", userId],\n      updatedProfile,\n    );\n\n    logger.info(\"Experience added\", {\n      amount,\n      source,\n      oldLevel,\n      newLevel,\n      userId,\n    });\n\n    return {\n      leveledUp: newLevel > oldLevel,\n      oldLevel,\n      newLevel,\n      experience: amount,\n    };\n  };\n\n  // Check level up\n  const checkLevelUp = useCallback(async (): Promise<LevelUpResult | null> => {\n    const _currentLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level - 1] || 0;\n    const nextLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level] || Infinity;\n\n    if (playerProfile.experience >= nextLevelThreshold) {\n      const newLevel = playerProfile.level + 1;\n      const rewards = generateLevelRewards(newLevel);\n\n      return {\n        newLevel,\n        rewards,\n        newTitle: getPlayerTitle(newLevel),\n        unlockedFeatures: getUnlockedFeatures(newLevel),\n      };\n    }\n\n    return null;\n  }, [playerProfile]);\n\n  // Get leaderboard rank\n  const getLeaderboardRank = useCallback(\n    async (leaderboardId: string): Promise<LeaderboardRank> => {\n      const leaderboard = leaderboards.find((l) => l.id === leaderboardId);\n      if (!leaderboard) throw new Error(\"Leaderboard not found\");\n\n      // Find user's rank (simulated)\n      const userRank =\n        Math.floor(Math.random() * leaderboard.totalParticipants) + 1;\n      const percentile =\n        ((leaderboard.totalParticipants - userRank) /\n          leaderboard.totalParticipants) *\n        100;\n\n      return {\n        category: leaderboard.category,\n        period: leaderboard.period,\n        rank: userRank,\n        totalParticipants: leaderboard.totalParticipants,\n        percentile,\n        value: playerProfile.stats.totalExperience,\n      };\n    },\n    [leaderboards, playerProfile],\n  );\n\n  // Compare with friends\n  const compareWithFriends = useCallback(async (): Promise<\n    FriendComparison[]\n  > => {\n    if (!socialFeatures?.friends) return [];\n\n    return socialFeatures.friends.map((friend) => ({\n      friendId: friend.userId,\n      friendName: friend.displayName,\n      categories: [\n        {\n          category: \"Level\",\n          playerValue: playerProfile.level,\n          friendValue: friend.level,\n          difference: playerProfile.level - friend.level,\n          status:\n            playerProfile.level > friend.level\n              ? \"ahead\"\n              : playerProfile.level < friend.level\n                ? \"behind\"\n                : \"tied\",\n        },\n        {\n          category: \"Experience\",\n          playerValue: playerProfile.experience,\n          friendValue: Math.floor(Math.random() * 10000),\n          difference: 0,\n          status: \"tied\",\n        },\n      ],\n      overallComparison: \"ahead\",\n    }));\n  }, [socialFeatures, playerProfile]);\n\n  // Send challenge to friend\n  const sendChallenge = useCallback(\n    async (friendId: string, challengeId: string) => {\n      logger.info(\"Challenge sent to friend\", {\n        friendId,\n        challengeId,\n        userId,\n      });\n      // In a real implementation, this would create a challenge invitation\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Get seasonal rewards\n  const getSeasonalRewards = useCallback(async (): Promise<\n    SeasonalReward[]\n  > => {\n    return currentSeason?.rewards || [];\n  }, [currentSeason]);\n\n  // Claim seasonal reward\n  const claimSeasonalReward = useCallback(\n    async (rewardId: string) => {\n      logger.info(\"Seasonal reward claimed\", { rewardId, userId });\n      // In a real implementation, this would claim the reward and update user data\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Helper functions\n  const generateSampleLeaderboards = (): Leaderboard[] => [\n    {\n      id: \"exp-weekly\",\n      category: LeaderboardCategory.EXPERIENCE,\n      period: LeaderboardPeriod.WEEKLY,\n      name: \"Weekly Experience Leaders\",\n      description: \"Top experience earners this week\",\n      entries: Array.from({ length: 10 }, (_, i) => ({\n        rank: i + 1,\n        userId: `user-${i}`,\n        displayName: `Player ${i + 1}`,\n        value: Math.floor(Math.random() * 5000),\n        change: Math.floor(Math.random() * 10) - 5,\n        badge: i < 3 ? [\"gold\", \"silver\", \"bronze\"][i] : undefined,\n      })),\n      lastUpdated: new Date(),\n      totalParticipants: 1247,\n    },\n  ];\n\n  const generateSeasonalRewards = (): SeasonalReward[] => [\n    {\n      id: \"winter-badge\",\n      name: \"Winter Warrior\",\n      description: \"Complete 10 challenges during winter season\",\n      type: \"badge\",\n      requirement: {\n        type: \"challenges\",\n        value: 10,\n        description: \"Complete 10 challenges\",\n      },\n      claimed: false,\n      exclusive: true,\n    },\n  ];\n\n  const createBadgeFromReward = (reward: ChallengeReward): Badge => ({\n    id: `badge-${reward.value}`,\n    name: reward.description,\n    description: reward.description,\n    category: BadgeCategory.ACHIEVEMENT,\n    iconUrl: \"/badges/achievement.png\",\n    rarity: \"common\",\n    earnedAt: new Date(),\n    requirements: [],\n    hidden: false,\n  });\n\n  const generateLevelRewards = (level: number) => [\n    {\n      type: \"badge\" as const,\n      value: `level-${level}`,\n      description: `Level ${level} Achievement Badge`,\n    },\n  ];\n\n  const getPlayerTitle = (level: number): PlayerTitle => {\n    if (level >= 20) return PlayerTitle.LEGEND;\n    if (level >= 15) return PlayerTitle.GRANDMASTER;\n    if (level >= 12) return PlayerTitle.MASTER;\n    if (level >= 10) return PlayerTitle.EXPERT;\n    if (level >= 8) return PlayerTitle.ADEPT;\n    if (level >= 6) return PlayerTitle.PRACTITIONER;\n    if (level >= 4) return PlayerTitle.APPRENTICE;\n    return PlayerTitle.NOVICE;\n  };\n\n  const getUnlockedFeatures = (level: number): string[] => {\n    const features = [];\n    if (level >= 3) features.push(\"Custom Challenges\");\n    if (level >= 5) features.push(\"Friend System\");\n    if (level >= 8) features.push(\"Group Challenges\");\n    if (level >= 10) features.push(\"Advanced Analytics\");\n    return features;\n  };\n\n  // Computed properties\n  const currentLevel = playerProfile.level;\n  const progressToNext =\n    playerProfile.experienceToNext > 0\n      ? ((playerProfile.experience -\n          (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0)) /\n          ((LEVEL_THRESHOLDS[playerProfile.level] ||\n            playerProfile.experienceToNext) -\n            (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0))) *\n        100\n      : 100;\n\n  const activeChallengeCount = activeChallenges.length;\n  const completedChallengesThisWeek = playerProfile.stats.challengesCompleted; // Simplified\n\n  const rank =\n    leaderboards.length > 0\n      ? leaderboards[0].entries.findIndex((e) => e.userId === userId) + 1 || 0\n      : 0;\n\n  const hasUnclaimedRewards =\n    currentSeason?.rewards.some((r) => !r.claimed) || false;\n\n  return {\n    // Player state\n    playerProfile,\n    activeChallenges,\n    leaderboards,\n    currentSeason,\n    socialFeatures,\n    experienceHistory,\n\n    // Challenge management\n    acceptChallenge: acceptChallengeMutation.mutate,\n    completeChallenge: completeChallengeMutation.mutate,\n    getChallengeProgress: (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      return challenge?.progress;\n    },\n\n    // Experience and leveling\n    addExperience: addExperienceMutation.mutate,\n    checkLevelUp,\n\n    // Leaderboard features\n    getLeaderboardRank,\n    joinLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Joined leaderboard\", { leaderboardId, userId });\n    },\n    leaveLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Left leaderboard\", { leaderboardId, userId });\n    },\n\n    // Social features\n    compareWithFriends,\n    sendChallenge,\n\n    // Seasonal events\n    getSeasonalRewards,\n    claimSeasonalReward,\n\n    // Loading states\n    isAcceptingChallenge: acceptChallengeMutation.isPending,\n    isCompletingChallenge: completeChallengeMutation.isPending,\n    isAddingExperience: addExperienceMutation.isPending,\n\n    // Results\n    lastChallengeCompletion: completeChallengeMutation.data,\n    lastLevelResult: addExperienceMutation.data,\n\n    // Computed properties\n    currentLevel,\n    progressToNext,\n    activeChallengeCount,\n    completedChallengesThisWeek,\n    rank,\n    hasUnclaimedRewards,\n\n    // Quick stats\n    totalExperience: playerProfile.stats.totalExperience,\n    totalBadges: playerProfile.badges.length,\n    currentStreak: playerProfile.stats.currentStreak,\n\n    // Errors\n    error:\n      acceptChallengeMutation.error ||\n      completeChallengeMutation.error ||\n      addExperienceMutation.error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useGoals.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (462). Maximum allowed is 75.","line":40,"column":25,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":593,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (26). Maximum allowed is 25.","line":40,"column":25,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":593,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":47,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":55},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":58,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":55},{"ruleId":"no-undef","severity":1,"message":"'DEFAULT_TEMPLATES' is not defined.","line":66,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":50},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":69,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":55},{"ruleId":"no-undef","severity":1,"message":"'DEFAULT_TEMPLATES' is not defined.","line":71,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":71,"endColumn":32},{"ruleId":"no-undef","severity":1,"message":"'DEFAULT_TEMPLATES' is not defined.","line":72,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":72,"endColumn":28},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":145,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":145,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":175,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":175,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'STORAGE_KEYS' is not defined.","line":190,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":190,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useGoals Hook - Enhanced Goal System\n *\n * Advanced goal system with AI recommendations, collaborative goals, and\n * comprehensive progress analytics.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  EnhancedGoal,\n  CollaborativeGoal,\n  GoalRecommendation,\n  GoalAnalytics,\n  GoalTemplate,\n  CreateGoalRequest,\n  GoalUpdate,\n  OptimizedGoalPlan,\n  CollaborationInvite,\n  GoalInsights,\n  GoalPredictions,\n  CompletionTrends,\n  GoalType,\n  GoalCategory,\n  GoalDifficulty,\n  GoalStatus,\n} from \"../../types/goals\";\nimport { logger } from \"../../utils/logging\";\nimport {\n  getGoalInsights,\n  getPredictiveAnalytics as getPredictiveAnalyticsHelper,\n  getCompletionTrends as getCompletionTrendsHelper,\n} from \"../../utils/goalsHelpers\";\n\n// Enhanced goal state\n\nimport type * as _Types from \"./types/Goals\";\nexport type * from \"./types/Goals\";\n\nexport const useGoals = (userId?: string, relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get personal goals\n  const { data: personalGoals = [] } = useQuery<EnhancedGoal[]>({\n    queryKey: [\"goals\", \"personal\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.PERSONAL_GOALS);\n      return stored ? JSON.parse(stored) : [];\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get collaborative goals\n  const { data: collaborativeGoals = [] } = useQuery<CollaborativeGoal[]>({\n    queryKey: [\"goals\", \"collaborative\", userId, relationshipId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.COLLABORATIVE_GOALS);\n      return stored ? JSON.parse(stored) : [];\n    },\n    enabled: Boolean(userId) && Boolean(relationshipId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get goal templates\n  const { data: goalTemplates = DEFAULT_TEMPLATES } = useQuery<GoalTemplate[]>({\n    queryKey: [\"goals\", \"templates\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.GOAL_TEMPLATES);\n      return stored\n        ? [...DEFAULT_TEMPLATES, ...JSON.parse(stored)]\n        : DEFAULT_TEMPLATES;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get AI recommendations\n  const { data: recommendedGoals = [] } = useQuery<GoalRecommendation[]>({\n    queryKey: [\"goals\", \"recommendations\", userId],\n    queryFn: async () => {\n      // Simulate AI recommendation generation\n      await new Promise((resolve) => setTimeout(resolve, 800));\n\n      return generateSmartRecommendations(personalGoals, collaborativeGoals);\n    },\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    refetchInterval: 30 * 60 * 1000, // 30 minutes\n  });\n\n  // Get goal analytics\n  const { data: goalAnalytics } = useQuery<GoalAnalytics>({\n    queryKey: [\"goals\", \"analytics\", userId],\n    queryFn: () => calculateGoalAnalytics(personalGoals, collaborativeGoals),\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Create goal mutation\n  const createGoalMutation = useMutation({\n    mutationFn: async (request: CreateGoalRequest) => {\n      const newGoal: EnhancedGoal = {\n        id: `goal-${Date.now()}`,\n        type: request.type,\n        category: request.category,\n        title: request.title,\n        description: request.description,\n        target: request.target,\n        progress: {\n          current: 0,\n          target: request.target.value,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones:\n            request.milestones?.map((m) => ({\n              ...m,\n              id: `milestone-${Date.now()}-${Math.random()}`,\n              achieved: false,\n            })) || [],\n          lastUpdated: new Date(),\n        },\n        milestones:\n          request.milestones?.map((m) => ({\n            ...m,\n            id: `milestone-${Date.now()}-${Math.random()}`,\n            achieved: false,\n          })) || [],\n        aiGenerated: false,\n        difficulty: request.difficulty,\n        estimatedCompletion: calculateEstimatedCompletion(\n          request.difficulty,\n          request.target,\n        ),\n        createdAt: new Date(),\n        tags: request.tags || [],\n        isPublic: request.isPublic || false,\n      };\n\n      const updated = [...personalGoals, newGoal];\n      localStorage.setItem(\n        STORAGE_KEYS.PERSONAL_GOALS,\n        JSON.stringify(updated),\n      );\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal created\", { goalId: newGoal.id, title: newGoal.title });\n      return newGoal;\n    },\n  });\n\n  // Update goal mutation\n  const updateGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      updates,\n    }: {\n      goalId: string;\n      updates: GoalUpdate;\n    }) => {\n      const goalIndex = personalGoals.findIndex((g) => g.id === goalId);\n      if (goalIndex === -1) throw new Error(\"Goal not found\");\n\n      const updatedGoal: EnhancedGoal = {\n        ...personalGoals[goalIndex],\n        ...updates,\n      };\n      const updated = [...personalGoals];\n      updated[goalIndex] = updatedGoal;\n\n      localStorage.setItem(\n        STORAGE_KEYS.PERSONAL_GOALS,\n        JSON.stringify(updated),\n      );\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal updated\", { goalId, updates });\n      return updatedGoal;\n    },\n  });\n\n  // Delete goal mutation\n  const deleteGoalMutation = useMutation({\n    mutationFn: async (goalId: string) => {\n      const updated = personalGoals.filter((g) => g.id !== goalId);\n      localStorage.setItem(\n        STORAGE_KEYS.PERSONAL_GOALS,\n        JSON.stringify(updated),\n      );\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal deleted\", { goalId });\n    },\n  });\n\n  // Generate goal from prompt mutation\n  const generateGoalFromPromptMutation = useMutation({\n    mutationFn: async (prompt: string) => {\n      logger.info(\"Generating goal from prompt\", { prompt });\n\n      // Simulate AI processing\n      await new Promise((resolve) => setTimeout(resolve, 1500));\n\n      const aiGoal: EnhancedGoal = {\n        id: `ai-goal-${Date.now()}`,\n        type: GoalType.DURATION,\n        category: GoalCategory.CHASTITY,\n        title: \"AI-Generated Chastity Goal\",\n        description: `Generated from: \"${prompt}\"`,\n        target: {\n          type: \"duration\",\n          value: 14,\n          unit: \"days\",\n          description: \"14 days of commitment\",\n        },\n        progress: {\n          current: 0,\n          target: 14,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones: [],\n          lastUpdated: new Date(),\n        },\n        milestones: [\n          {\n            id: \"ai-milestone-1\",\n            name: \"First Week\",\n            description: \"Complete 7 days\",\n            target: 7,\n            achieved: false,\n          },\n          {\n            id: \"ai-milestone-2\",\n            name: \"Final Goal\",\n            description: \"Complete 14 days\",\n            target: 14,\n            achieved: false,\n          },\n        ],\n        aiGenerated: true,\n        difficulty: GoalDifficulty.MEDIUM,\n        estimatedCompletion: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n        createdAt: new Date(),\n        tags: [\"ai-generated\"],\n        isPublic: false,\n      };\n\n      return aiGoal;\n    },\n  });\n\n  // Optimize goal plan mutation\n  const optimizeGoalPlanMutation = useMutation({\n    mutationFn: async (goalIds: string[]) => {\n      const goalsToOptimize = personalGoals.filter((g) =>\n        goalIds.includes(g.id),\n      );\n\n      // Simulate optimization processing\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      const optimizedPlan: OptimizedGoalPlan = {\n        goals: goalsToOptimize,\n        timeline: generateTimeline(goalsToOptimize),\n        conflicts: detectConflicts(goalsToOptimize),\n        recommendations: generatePlanRecommendations(goalsToOptimize),\n        estimatedCompletion: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days\n      };\n\n      return optimizedPlan;\n    },\n  });\n\n  // Share goal mutation\n  const shareGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      logger.info(\"Sharing goal\", { goalId, targetUserId });\n      // In a real implementation, this would create a sharing record\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Invite collaborator mutation\n  const inviteCollaboratorMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      const invite: CollaborationInvite = {\n        id: `invite-${Date.now()}`,\n        goalId,\n        inviterId: userId!,\n        inviteeId: targetUserId,\n        permissions: {\n          canEdit: false,\n          canDelete: false,\n          canInviteOthers: false,\n          canViewProgress: true,\n          canAddMilestones: false,\n        },\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        status: \"pending\",\n      };\n\n      logger.info(\"Collaboration invite sent\", {\n        inviteId: invite.id,\n        goalId,\n        targetUserId,\n      });\n      return invite;\n    },\n  });\n\n  // Helper functions\n  const generateSmartRecommendations = (\n    personal: EnhancedGoal[],\n    _collaborative: CollaborativeGoal[],\n  ): GoalRecommendation[] => {\n    const recommendations: GoalRecommendation[] = [];\n\n    // Analyze completed goals to suggest similar ones\n    const completedGoals = personal.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const activeCategories = new Set(personal.map((g) => g.category));\n\n    // Suggest goals in successful categories\n    completedGoals.forEach((goal) => {\n      if (Math.random() > 0.7) {\n        // 30% chance to recommend\n        recommendations.push({\n          id: `rec-${Date.now()}-${Math.random()}`,\n          type: goal.type,\n          category: goal.category,\n          title: `Advanced ${goal.category} Challenge`,\n          description: `Based on your success with \"${goal.title}\"`,\n          difficulty:\n            goal.difficulty === GoalDifficulty.EASY\n              ? GoalDifficulty.MEDIUM\n              : GoalDifficulty.HARD,\n          estimatedDuration: 30,\n          reasoning: `You successfully completed similar goals in the ${goal.category} category`,\n          confidence: 0.8,\n          similarGoals: [goal.id],\n          successRate: 0.75,\n        });\n      }\n    });\n\n    // Suggest unexplored categories\n    const allCategories = Object.values(GoalCategory);\n    const unexploredCategories = allCategories.filter(\n      (cat) => !activeCategories.has(cat),\n    );\n\n    unexploredCategories.forEach((category) => {\n      if (Math.random() > 0.8) {\n        // 20% chance\n        recommendations.push({\n          id: `exp-${Date.now()}-${Math.random()}`,\n          type: GoalType.MILESTONE,\n          category,\n          title: `Explore ${category}`,\n          description: `Try something new in the ${category} category`,\n          difficulty: GoalDifficulty.EASY,\n          estimatedDuration: 14,\n          reasoning: `Diversifying goal categories can improve overall success`,\n          confidence: 0.6,\n          similarGoals: [],\n          successRate: 0.65,\n        });\n      }\n    });\n\n    return recommendations.slice(0, 5); // Limit to 5 recommendations\n  };\n\n  const calculateGoalAnalytics = (\n    personal: EnhancedGoal[],\n    collaborative: CollaborativeGoal[],\n  ): GoalAnalytics => {\n    const allGoals = [...personal, ...collaborative];\n    const completed = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const active = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    );\n\n    const categoryDistribution = Object.values(GoalCategory).reduce(\n      (acc, cat) => {\n        acc[cat] = allGoals.filter((g) => g.category === cat).length;\n        return acc;\n      },\n      {} as Record<GoalCategory, number>,\n    );\n\n    const difficultyDistribution = Object.values(GoalDifficulty).reduce(\n      (acc, diff) => {\n        acc[diff] = allGoals.filter((g) => g.difficulty === diff).length;\n        return acc;\n      },\n      {} as Record<GoalDifficulty, number>,\n    );\n\n    return {\n      totalGoals: allGoals.length,\n      completedGoals: completed.length,\n      activeGoals: active.length,\n      completionRate:\n        allGoals.length > 0 ? (completed.length / allGoals.length) * 100 : 0,\n      averageCompletionTime: calculateAverageCompletionTime(completed),\n      categoryDistribution,\n      difficultyDistribution,\n      monthlyProgress: generateMonthlyProgress(allGoals),\n      streaks: calculateStreaks(completed),\n    };\n  };\n\n  const calculateEstimatedCompletion = (\n    difficulty: GoalDifficulty,\n    target: { value?: number; unit?: string },\n  ): Date => {\n    const baseDays = target.value || 30;\n    const multiplier = {\n      [GoalDifficulty.EASY]: 1,\n      [GoalDifficulty.MEDIUM]: 1.5,\n      [GoalDifficulty.HARD]: 2,\n      [GoalDifficulty.EXTREME]: 3,\n    };\n\n    return new Date(\n      Date.now() + baseDays * multiplier[difficulty] * 24 * 60 * 60 * 1000,\n    );\n  };\n\n  const calculateAverageCompletionTime = (\n    completed: EnhancedGoal[],\n  ): number => {\n    if (completed.length === 0) return 0;\n\n    const totalDays = completed.reduce((acc, goal) => {\n      if (goal.completedAt && goal.startedAt) {\n        return (\n          acc +\n          (goal.completedAt.getTime() - goal.startedAt.getTime()) /\n            (24 * 60 * 60 * 1000)\n        );\n      }\n      return acc;\n    }, 0);\n\n    return totalDays / completed.length;\n  };\n\n  const generateMonthlyProgress = (_goals: EnhancedGoal[]) => {\n    // Simplified monthly progress calculation\n    return Array.from({ length: 6 }, (_, i) => ({\n      month: new Date(\n        Date.now() - i * 30 * 24 * 60 * 60 * 1000,\n      ).toLocaleDateString(\"en-US\", { month: \"short\" }),\n      goalsStarted: Math.floor(Math.random() * 5),\n      goalsCompleted: Math.floor(Math.random() * 3),\n      totalProgress: Math.floor(Math.random() * 100),\n    }));\n  };\n\n  const calculateStreaks = (_completed: EnhancedGoal[]) => {\n    return Object.values(GoalCategory).map((category) => ({\n      category,\n      currentStreak: Math.floor(Math.random() * 10),\n      longestStreak: Math.floor(Math.random() * 20),\n      lastGoalCompleted: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n    }));\n  };\n\n  const generateTimeline = (goals: EnhancedGoal[]) => {\n    return goals.map((goal) => ({\n      date: goal.estimatedCompletion,\n      goals: [goal.id],\n      milestones: goal.milestones.map((m) => m.id),\n      estimatedEffort: 4, // hours\n    }));\n  };\n\n  const detectConflicts = (_goals: EnhancedGoal[]) => {\n    // Simplified conflict detection\n    return [];\n  };\n\n  const generatePlanRecommendations = (_goals: EnhancedGoal[]) => {\n    return [\n      {\n        type: \"reorder\" as const,\n        description: \"Consider starting easier goals first to build momentum\",\n        impact: \"Improved success rate\",\n        effort: \"Low\",\n      },\n    ];\n  };\n\n  // Analytics functions using helpers\n  const getGoalInsightsCallback = useCallback(\n    (): GoalInsights => getGoalInsights(),\n    [],\n  );\n\n  const getPredictiveAnalyticsCallback = useCallback(\n    (): GoalPredictions => getPredictiveAnalyticsHelper(personalGoals),\n    [personalGoals],\n  );\n\n  const getCompletionTrendsCallback = useCallback(\n    (): CompletionTrends => getCompletionTrendsHelper(),\n    [],\n  );\n\n  return {\n    // Goal state\n    personalGoals,\n    collaborativeGoals,\n    recommendedGoals,\n    goalAnalytics,\n    goalTemplates,\n\n    // Goal management\n    createGoal: createGoalMutation.mutate,\n    updateGoal: updateGoalMutation.mutate,\n    deleteGoal: deleteGoalMutation.mutate,\n\n    // AI features\n    getSmartRecommendations: () => recommendedGoals,\n    generateGoalFromPrompt: generateGoalFromPromptMutation.mutate,\n    optimizeGoalPlan: optimizeGoalPlanMutation.mutate,\n\n    // Collaboration\n    shareGoal: shareGoalMutation.mutate,\n    inviteCollaborator: inviteCollaboratorMutation.mutate,\n    acceptCollaboration: async (inviteId: string) => {\n      logger.info(\"Collaboration accepted\", { inviteId });\n    },\n\n    // Analytics\n    getGoalInsights: getGoalInsightsCallback,\n    getPredictiveAnalytics: getPredictiveAnalyticsCallback,\n    getCompletionTrends: getCompletionTrendsCallback,\n\n    // Loading states\n    isCreating: createGoalMutation.isPending,\n    isUpdating: updateGoalMutation.isPending,\n    isDeleting: deleteGoalMutation.isPending,\n    isGenerating: generateGoalFromPromptMutation.isPending,\n    isOptimizing: optimizeGoalPlanMutation.isPending,\n\n    // Computed properties\n    activeGoalsCount: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    ).length,\n    completionRate: goalAnalytics ? goalAnalytics.completionRate : 0,\n    averageCompletionTime: goalAnalytics\n      ? goalAnalytics.averageCompletionTime\n      : 0,\n    hasCollaborativeGoals: collaborativeGoals.length > 0,\n    needsAttention: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.BEHIND,\n    ).length,\n\n    // Results\n    lastOptimization: optimizeGoalPlanMutation.data,\n    lastGeneratedGoal: generateGoalFromPromptMutation.data,\n\n    // Errors\n    error:\n      createGoalMutation.error ||\n      updateGoalMutation.error ||\n      deleteGoalMutation.error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useLogEventForm.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useLogEventForm' has too many lines (76). Maximum allowed is 75.","line":41,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":129,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Log Event Form Hook\n *\n * Extracts form submission logic from LogEventForm component.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { Event } from \"../../types/events\";\n\nexport interface EventFormData {\n  type: string;\n  notes?: string;\n  timestamp?: Date;\n  category?: string;\n}\n\nexport interface UseLogEventFormReturn {\n  formData: EventFormData;\n  setFormData: (data: Partial<EventFormData>) => void;\n  resetForm: () => void;\n  errors: Record<string, string>;\n  isValid: boolean;\n  validate: () => boolean;\n  submitEvent: () => Promise<void>;\n  isSubmitting: boolean;\n  submitError: Error | null;\n  saveDraft: () => void;\n  loadDraft: () => void;\n  hasDraft: boolean;\n  clearDraft: () => void;\n  categorySuggestions: string[];\n  recentEvents: Event[];\n}\n\nconst defaultFormData: EventFormData = {\n  type: \"\",\n  notes: \"\",\n  timestamp: new Date(),\n};\n\nexport function useLogEventForm(\n  initialData?: Partial<EventFormData>,\n): UseLogEventFormReturn {\n  const [formData, setFormDataState] = useState<EventFormData>({\n    ...defaultFormData,\n    ...initialData,\n  });\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [submitError, setSubmitError] = useState<Error | null>(null);\n  const [hasDraft, setHasDraft] = useState(false);\n\n  const setFormData = useCallback((data: Partial<EventFormData>) => {\n    setFormDataState((prev) => ({ ...prev, ...data }));\n  }, []);\n\n  const resetForm = useCallback(() => {\n    setFormDataState(defaultFormData);\n    setErrors({});\n  }, []);\n\n  const validate = useCallback((): boolean => {\n    const newErrors: Record<string, string> = {};\n\n    if (!formData.type) {\n      newErrors.type = \"Event type is required\";\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  }, [formData]);\n\n  const submitEvent = useCallback(async (): Promise<void> => {\n    setIsSubmitting(true);\n    setSubmitError(null);\n\n    try {\n      if (!validate()) {\n        throw new Error(\"Validation failed\");\n      }\n\n      // Mock submission\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      resetForm();\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to submit event\");\n      setSubmitError(error);\n      throw error;\n    } finally {\n      setIsSubmitting(false);\n    }\n  }, [validate, resetForm]);\n\n  const saveDraft = useCallback(() => {\n    localStorage.setItem(\"eventDraft\", JSON.stringify(formData));\n    setHasDraft(true);\n  }, [formData]);\n\n  const loadDraft = useCallback(() => {\n    const draft = localStorage.getItem(\"eventDraft\");\n    if (draft) {\n      setFormDataState(JSON.parse(draft));\n    }\n  }, []);\n\n  const clearDraft = useCallback(() => {\n    localStorage.removeItem(\"eventDraft\");\n    setHasDraft(false);\n  }, []);\n\n  return {\n    formData,\n    setFormData,\n    resetForm,\n    errors,\n    isValid: Object.keys(errors).length === 0,\n    validate,\n    submitEvent,\n    isSubmitting,\n    submitError,\n    saveDraft,\n    loadDraft,\n    hasDraft,\n    clearDraft,\n    categorySuggestions: [\"Orgasm\", \"Edge\", \"Release\", \"Lock\"],\n    recentEvents: [],\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useManualEntry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/usePersonalGoals.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'usePersonalGoals' has too many lines (141). Maximum allowed is 75.","line":50,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":203,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Personal Goals Hook - Extracts goal management from PersonalGoalSection component\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface PersonalGoal {\n  id: string;\n  title: string;\n  description?: string;\n  targetDuration: number; // in seconds\n  currentProgress: number; // in seconds\n  isCompleted: boolean;\n  createdAt: Date;\n  completedAt?: Date;\n  reward?: string;\n}\n\nexport interface CreateGoalInput {\n  title: string;\n  description?: string;\n  targetDuration: number;\n  reward?: string;\n}\n\nexport interface UpdateGoalInput {\n  title?: string;\n  description?: string;\n  targetDuration?: number;\n  reward?: string;\n}\n\nexport interface UsePersonalGoalsReturn {\n  goals: PersonalGoal[];\n  activeGoals: PersonalGoal[];\n  completedGoals: PersonalGoal[];\n  isLoading: boolean;\n  createGoal: (goal: CreateGoalInput) => Promise<PersonalGoal>;\n  updateGoal: (id: string, updates: UpdateGoalInput) => Promise<PersonalGoal>;\n  deleteGoal: (id: string) => Promise<void>;\n  completeGoal: (id: string) => Promise<void>;\n  isCreating: boolean;\n  isUpdating: boolean;\n  isDeleting: boolean;\n  error: Error | null;\n  getGoalProgress: (goalId: string) => number;\n  getGoalProjection: (goalId: string) => Date | null;\n}\n\nexport function usePersonalGoals(): UsePersonalGoalsReturn {\n  const [goals, setGoals] = useState<PersonalGoal[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isCreating, setIsCreating] = useState(false);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const activeGoals = goals.filter((g) => !g.isCompleted);\n  const completedGoals = goals.filter((g) => g.isCompleted);\n\n  const createGoal = useCallback(\n    async (goal: CreateGoalInput): Promise<PersonalGoal> => {\n      setIsCreating(true);\n      setError(null);\n      try {\n        const newGoal: PersonalGoal = {\n          id: `goal-${Date.now()}`,\n          title: goal.title,\n          description: goal.description,\n          targetDuration: goal.targetDuration,\n          currentProgress: 0,\n          isCompleted: false,\n          createdAt: new Date(),\n          reward: goal.reward,\n        };\n        setGoals((prev) => [...prev, newGoal]);\n        return newGoal;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to create goal\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsCreating(false);\n      }\n    },\n    [],\n  );\n\n  const updateGoal = useCallback(\n    async (id: string, updates: UpdateGoalInput): Promise<PersonalGoal> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        let updatedGoal: PersonalGoal | null = null;\n        setGoals((prev) =>\n          prev.map((g) => {\n            if (g.id === id) {\n              updatedGoal = { ...g, ...updates };\n              return updatedGoal;\n            }\n            return g;\n          }),\n        );\n        if (!updatedGoal) throw new Error(\"Goal not found\");\n        return updatedGoal;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update goal\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const deleteGoal = useCallback(async (id: string): Promise<void> => {\n    setIsDeleting(true);\n    setError(null);\n    try {\n      setGoals((prev) => prev.filter((g) => g.id !== id));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to delete goal\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsDeleting(false);\n    }\n  }, []);\n\n  const completeGoal = useCallback(async (id: string): Promise<void> => {\n    setError(null);\n    try {\n      setGoals((prev) =>\n        prev.map((g) =>\n          g.id === id\n            ? { ...g, isCompleted: true, completedAt: new Date() }\n            : g,\n        ),\n      );\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to complete goal\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  const getGoalProgress = useCallback(\n    (goalId: string): number => {\n      const goal = goals.find((g) => g.id === goalId);\n      if (!goal || goal.targetDuration === 0) return 0;\n      return (goal.currentProgress / goal.targetDuration) * 100;\n    },\n    [goals],\n  );\n\n  const getGoalProjection = useCallback(\n    (goalId: string): Date | null => {\n      const goal = goals.find((g) => g.id === goalId);\n      if (!goal || goal.currentProgress === 0) return null;\n\n      const remainingDuration = goal.targetDuration - goal.currentProgress;\n      const daysPassed = Math.floor(\n        (Date.now() - goal.createdAt.getTime()) / (1000 * 60 * 60 * 24),\n      );\n      const progressPerDay = goal.currentProgress / daysPassed;\n\n      if (progressPerDay === 0) return null;\n\n      const daysRemaining = Math.ceil(remainingDuration / progressPerDay);\n      const projectedDate = new Date();\n      projectedDate.setDate(projectedDate.getDate() + daysRemaining);\n\n      return projectedDate;\n    },\n    [goals],\n  );\n\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    goals,\n    activeGoals,\n    completedGoals,\n    isLoading,\n    createGoal,\n    updateGoal,\n    deleteGoal,\n    completeGoal,\n    isCreating,\n    isUpdating,\n    isDeleting,\n    error,\n    getGoalProgress,\n    getGoalProjection,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useReporting.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (280). Maximum allowed is 75.","line":220,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":561,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useReporting Hook - Advanced Reporting & Analytics\n *\n * Comprehensive reporting system with custom reports, data visualization,\n * and export capabilities for detailed analysis.\n */\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Report types\nexport enum ReportType {\n  SUMMARY = \"summary\",\n  DETAILED = \"detailed\",\n  ANALYTICS = \"analytics\",\n  CUSTOM = \"custom\",\n}\n\n// Export formats\nexport enum ExportFormat {\n  JSON = \"json\",\n  CSV = \"csv\",\n  PDF = \"pdf\",\n  XLSX = \"xlsx\",\n}\n\n// Report template\nexport interface ReportTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: ReportType;\n  parameters: ReportParameter[];\n  defaultParameters: Record<string, string | number | boolean | Date>;\n}\n\n// Report parameter\nexport interface ReportParameter {\n  name: string;\n  type: \"string\" | \"number\" | \"date\" | \"boolean\" | \"select\";\n  required: boolean;\n  options?: string[];\n  default?: string | number | boolean | Date;\n}\n\n// Report parameters\nexport interface ReportParameters {\n  dateRange: {\n    start: Date;\n    end: Date;\n  };\n  includeDetails: boolean;\n  groupBy?: string;\n  filters: Record<string, string | number | boolean | Date>;\n}\n\n// Generated report\nexport interface GeneratedReport {\n  id: string;\n  templateId: string;\n  name: string;\n  parameters: ReportParameters;\n  data: Record<string, unknown> | unknown[];\n  generatedAt: Date;\n  generatedBy: string;\n  size: number;\n}\n\n// Custom report definition\nexport interface CustomReportDefinition {\n  name: string;\n  description: string;\n  dataSource: string;\n  fields: string[];\n  filters: ReportFilter[];\n  grouping?: string[];\n  sorting?: ReportSort[];\n}\n\n// Report filter\nexport interface ReportFilter {\n  field: string;\n  operator: \"equals\" | \"contains\" | \"greater\" | \"less\" | \"between\";\n  value: string | number | boolean | Date;\n}\n\n// Report sort\nexport interface ReportSort {\n  field: string;\n  direction: \"asc\" | \"desc\";\n}\n\n// Custom report\nexport interface CustomReport {\n  id: string;\n  definition: CustomReportDefinition;\n  createdAt: Date;\n  lastRun?: Date;\n}\n\n// Report schedule\nexport interface ReportSchedule {\n  frequency: \"daily\" | \"weekly\" | \"monthly\";\n  time: string;\n  recipients: string[];\n  format: ExportFormat;\n  enabled: boolean;\n}\n\n// Scheduled report\nexport interface ScheduledReport {\n  id: string;\n  reportId: string;\n  schedule: ReportSchedule;\n  nextRun: Date;\n  lastRun?: Date;\n}\n\n// Report export\nexport interface ReportExport {\n  id: string;\n  reportId: string;\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data export\nexport interface DataExport {\n  id: string;\n  dataType: string;\n  filters: DataFilter[];\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data filter\nexport interface DataFilter {\n  field: string;\n  value: string | number | boolean | Date;\n}\n\n// Reporting preferences\nexport interface ReportingPreferences {\n  defaultFormat: ExportFormat;\n  autoRefresh: boolean;\n  refreshInterval: number;\n  maxReports: number;\n}\n\n// Default templates\nconst DEFAULT_TEMPLATES: ReportTemplate[] = [\n  {\n    id: \"session-summary\",\n    name: \"Session Summary\",\n    description: \"Summary of chastity sessions over time\",\n    type: ReportType.SUMMARY,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"includeDetails\",\n        type: \"boolean\",\n        required: false,\n        default: false,\n      },\n    ],\n    defaultParameters: {\n      includeDetails: false,\n    },\n  },\n  {\n    id: \"achievement-progress\",\n    name: \"Achievement Progress\",\n    description: \"Progress on achievements and goals\",\n    type: ReportType.ANALYTICS,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"category\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"duration\", \"behavior\", \"goals\"],\n      },\n    ],\n    defaultParameters: {\n      category: \"all\",\n    },\n  },\n  {\n    id: \"behavioral-analysis\",\n    name: \"Behavioral Analysis\",\n    description: \"Analysis of behavioral patterns and events\",\n    type: ReportType.DETAILED,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"eventTypes\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"sessions\", \"events\", \"tasks\"],\n      },\n    ],\n    defaultParameters: {\n      eventTypes: \"all\",\n    },\n  },\n];\n\n// Storage keys\nconst STORAGE_KEYS = {\n  CUSTOM_REPORTS: \"chastity-reports-custom\",\n  RECENT_REPORTS: \"chastity-reports-recent\",\n  PREFERENCES: \"chastity-reports-preferences\",\n};\n\n/**\n * Advanced Reporting Hook\n */\nexport const useReporting = (userId?: string, _relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get available templates\n  const { data: availableReports = DEFAULT_TEMPLATES } = useQuery<\n    ReportTemplate[]\n  >({\n    queryKey: [\"reports\", \"templates\"],\n    queryFn: () => DEFAULT_TEMPLATES,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get custom reports\n  const { data: customReports = [] } = useQuery<CustomReport[]>({\n    queryKey: [\"reports\", \"custom\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.CUSTOM_REPORTS);\n      return stored ? JSON.parse(stored) : [];\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get recent reports\n  const { data: recentReports = [] } = useQuery<GeneratedReport[]>({\n    queryKey: [\"reports\", \"recent\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.RECENT_REPORTS);\n      return stored ? JSON.parse(stored) : [];\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get preferences\n  const { data: preferences } = useQuery<ReportingPreferences>({\n    queryKey: [\"reports\", \"preferences\", userId],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.PREFERENCES);\n      return stored\n        ? JSON.parse(stored)\n        : {\n            defaultFormat: ExportFormat.JSON,\n            autoRefresh: false,\n            refreshInterval: 300000, // 5 minutes\n            maxReports: 50,\n          };\n    },\n    enabled: Boolean(userId),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Generate report mutation\n  const generateReportMutation = useMutation({\n    mutationFn: async ({\n      templateId,\n      parameters,\n    }: {\n      templateId: string;\n      parameters: ReportParameters;\n    }) => {\n      const template = availableReports.find((t) => t.id === templateId);\n      if (!template) throw new Error(\"Template not found\");\n\n      logger.info(\"Generating report\", { templateId, parameters });\n\n      // Simulate report generation\n      const reportData = await generateReportData(templateId, parameters);\n\n      const report: GeneratedReport = {\n        id: `report-${Date.now()}`,\n        templateId,\n        name: template.name,\n        parameters,\n        data: reportData,\n        generatedAt: new Date(),\n        generatedBy: userId || \"anonymous\",\n        size: JSON.stringify(reportData).length,\n      };\n\n      // Store in recent reports\n      const updated = [report, ...recentReports].slice(\n        0,\n        preferences?.maxReports || 50,\n      );\n      localStorage.setItem(\n        STORAGE_KEYS.RECENT_REPORTS,\n        JSON.stringify(updated),\n      );\n      queryClient.setQueryData([\"reports\", \"recent\", userId], updated);\n\n      return report;\n    },\n  });\n\n  // Create custom report mutation\n  const createCustomReportMutation = useMutation({\n    mutationFn: async (definition: CustomReportDefinition) => {\n      const customReport: CustomReport = {\n        id: `custom-${Date.now()}`,\n        definition,\n        createdAt: new Date(),\n      };\n\n      const updated = [...customReports, customReport];\n      localStorage.setItem(\n        STORAGE_KEYS.CUSTOM_REPORTS,\n        JSON.stringify(updated),\n      );\n      queryClient.setQueryData([\"reports\", \"custom\", userId], updated);\n\n      logger.info(\"Custom report created\", { reportId: customReport.id });\n      return customReport;\n    },\n  });\n\n  // Schedule report mutation\n  const scheduleReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      schedule,\n    }: {\n      reportId: string;\n      schedule: ReportSchedule;\n    }) => {\n      const scheduledReport: ScheduledReport = {\n        id: `schedule-${Date.now()}`,\n        reportId,\n        schedule,\n        nextRun: calculateNextRun(schedule),\n      };\n\n      logger.info(\"Report scheduled\", {\n        reportId,\n        schedule: scheduledReport.id,\n      });\n      return scheduledReport;\n    },\n  });\n\n  // Export report mutation\n  const exportReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      format,\n    }: {\n      reportId: string;\n      format: ExportFormat;\n    }) => {\n      const report = recentReports.find((r) => r.id === reportId);\n      if (!report) throw new Error(\"Report not found\");\n\n      const exportData = await exportReportData(report, format);\n\n      const exportResult: ReportExport = {\n        id: `export-${Date.now()}`,\n        reportId,\n        format,\n        url: exportData.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n      };\n\n      logger.info(\"Report exported\", {\n        reportId,\n        format,\n        exportId: exportResult.id,\n      });\n      return exportResult;\n    },\n  });\n\n  // Export raw data mutation\n  const exportRawDataMutation = useMutation({\n    mutationFn: async ({\n      dataType,\n      filters,\n      format,\n    }: {\n      dataType: string;\n      filters: DataFilter[];\n      format: ExportFormat;\n    }) => {\n      const rawData = await getRawData(dataType, filters);\n      const exportResult = await exportData(rawData, format);\n\n      const dataExport: DataExport = {\n        id: `data-export-${Date.now()}`,\n        dataType,\n        filters,\n        format,\n        url: exportResult.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\n      };\n\n      logger.info(\"Raw data exported\", {\n        dataType,\n        format,\n        exportId: dataExport.id,\n      });\n      return dataExport;\n    },\n  });\n\n  // Helper functions\n  const generateReportData = async (\n    templateId: string,\n    parameters: ReportParameters,\n  ) => {\n    // In a real implementation, this would query actual data\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    return {\n      summary: {\n        totalSessions: Math.floor(Math.random() * 100),\n        averageDuration: Math.floor(Math.random() * 72),\n        longestSession: Math.floor(Math.random() * 168),\n      },\n      details: parameters.includeDetails ? generateDetailedData() : null,\n      generatedAt: new Date().toISOString(),\n    };\n  };\n\n  const generateDetailedData = () => ({\n    sessions: Array.from({ length: 10 }, (_, i) => ({\n      id: i + 1,\n      startDate: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n      duration: Math.floor(Math.random() * 72),\n      events: Math.floor(Math.random() * 5),\n    })),\n  });\n\n  const calculateNextRun = (schedule: ReportSchedule): Date => {\n    const now = new Date();\n    const [hours, minutes] = schedule.time.split(\":\").map(Number);\n\n    const nextRun = new Date(now);\n    nextRun.setHours(hours, minutes, 0, 0);\n\n    if (nextRun <= now) {\n      switch (schedule.frequency) {\n        case \"daily\":\n          nextRun.setDate(nextRun.getDate() + 1);\n          break;\n        case \"weekly\":\n          nextRun.setDate(nextRun.getDate() + 7);\n          break;\n        case \"monthly\":\n          nextRun.setMonth(nextRun.getMonth() + 1);\n          break;\n      }\n    }\n\n    return nextRun;\n  };\n\n  const exportReportData = async (\n    report: GeneratedReport,\n    format: ExportFormat,\n  ) => {\n    // Simulate export processing\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    const blob = new Blob([JSON.stringify(report.data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n\n    return { url };\n  };\n\n  const getRawData = async (dataType: string, filters: DataFilter[]) => {\n    // Simulate data retrieval\n    await new Promise((resolve) => setTimeout(resolve, 800));\n    return { dataType, filters, records: [] };\n  };\n\n  const exportData = async (data: Record<string, unknown> | unknown[], format: ExportFormat) => {\n    const blob = new Blob([JSON.stringify(data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n    return { url };\n  };\n\n  const getContentType = (format: ExportFormat): string => {\n    switch (format) {\n      case ExportFormat.JSON:\n        return \"application/json\";\n      case ExportFormat.CSV:\n        return \"text/csv\";\n      case ExportFormat.PDF:\n        return \"application/pdf\";\n      case ExportFormat.XLSX:\n        return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      default:\n        return \"application/octet-stream\";\n    }\n  };\n\n  return {\n    // Available reports and templates\n    availableReports,\n    customReports,\n    recentReports,\n    preferences,\n\n    // Actions\n    generateReport: generateReportMutation.mutate,\n    createCustomReport: createCustomReportMutation.mutate,\n    scheduleReport: scheduleReportMutation.mutate,\n    exportReport: exportReportMutation.mutate,\n    exportRawData: exportRawDataMutation.mutate,\n\n    // Loading states\n    isGenerating: generateReportMutation.isPending,\n    isCreatingCustom: createCustomReportMutation.isPending,\n    isScheduling: scheduleReportMutation.isPending,\n    isExporting:\n      exportReportMutation.isPending || exportRawDataMutation.isPending,\n\n    // Results\n    lastGeneratedReport: generateReportMutation.data,\n    lastExport: exportReportMutation.data || exportRawDataMutation.data,\n\n    // Computed properties\n    totalReports: recentReports.length,\n    hasScheduledReports: false, // Would check actual scheduled reports\n    lastReportDate:\n      recentReports.length > 0 ? recentReports[0].generatedAt : null,\n    hasCustomReports: customReports.length > 0,\n\n    // Errors\n    error:\n      generateReportMutation.error ||\n      createCustomReportMutation.error ||\n      scheduleReportMutation.error ||\n      exportReportMutation.error ||\n      exportRawDataMutation.error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/features/useRuleEditor.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRuleEditor' has too many lines (172). Maximum allowed is 75.","line":75,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":262,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Rule Editor Hook\n *\n * Extracts rule management logic from RuleEditor component.\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface Rule {\n  id: string;\n  title: string;\n  description: string;\n  enabled: boolean;\n  conditions: Condition[];\n  actions: RuleAction[];\n}\n\nexport interface Condition {\n  type: string;\n  value: unknown;\n}\n\nexport interface RuleAction {\n  type: string;\n  value: unknown;\n}\n\nexport interface CreateRuleInput {\n  title: string;\n  description?: string;\n}\n\nexport interface UpdateRuleInput {\n  title?: string;\n  description?: string;\n  enabled?: boolean;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  message: string;\n}\n\nexport interface UseRuleEditorReturn {\n  rules: Rule[];\n  currentRule: Rule | null;\n  isLoading: boolean;\n  createRule: (rule: CreateRuleInput) => Promise<Rule>;\n  updateRule: (id: string, updates: UpdateRuleInput) => Promise<Rule>;\n  deleteRule: (id: string) => Promise<void>;\n  toggleRule: (id: string, enabled: boolean) => Promise<void>;\n  setCurrentRule: (rule: Rule | null) => void;\n  resetEditor: () => void;\n  validateRule: (rule: Rule) => ValidationResult;\n  isRuleValid: boolean;\n  validationErrors: string[];\n  testRule: (\n    rule: Rule,\n    testData: Record<string, unknown>,\n  ) => Promise<TestResult>;\n  isTesting: boolean;\n  addCondition: (condition: Condition) => void;\n  removeCondition: (index: number) => void;\n  updateCondition: (index: number, condition: Condition) => void;\n  addAction: (action: RuleAction) => void;\n  removeAction: (index: number) => void;\n  updateAction: (index: number, action: RuleAction) => void;\n}\n\nexport function useRuleEditor(): UseRuleEditorReturn {\n  const [rules, setRules] = useState<Rule[]>([]);\n  const [currentRule, setCurrentRule] = useState<Rule | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isTesting, setIsTesting] = useState(false);\n  const [validationErrors, setValidationErrors] = useState<string[]>([]);\n\n  const createRule = useCallback(\n    async (rule: CreateRuleInput): Promise<Rule> => {\n      const newRule: Rule = {\n        id: `rule-${Date.now()}`,\n        title: rule.title,\n        description: rule.description || \"\",\n        enabled: true,\n        conditions: [],\n        actions: [],\n      };\n      setRules((prev) => [...prev, newRule]);\n      return newRule;\n    },\n    [],\n  );\n\n  const updateRule = useCallback(\n    async (id: string, updates: UpdateRuleInput): Promise<Rule> => {\n      let updatedRule: Rule | null = null;\n      setRules((prev) =>\n        prev.map((r) => {\n          if (r.id === id) {\n            updatedRule = { ...r, ...updates };\n            return updatedRule;\n          }\n          return r;\n        }),\n      );\n      if (!updatedRule) throw new Error(\"Rule not found\");\n      return updatedRule;\n    },\n    [],\n  );\n\n  const deleteRule = useCallback(async (id: string): Promise<void> => {\n    setRules((prev) => prev.filter((r) => r.id !== id));\n  }, []);\n\n  const toggleRule = useCallback(\n    async (id: string, enabled: boolean): Promise<void> => {\n      await updateRule(id, { enabled });\n    },\n    [updateRule],\n  );\n\n  const resetEditor = useCallback(() => {\n    setCurrentRule(null);\n    setValidationErrors([]);\n  }, []);\n\n  const validateRule = useCallback((rule: Rule): ValidationResult => {\n    const errors: string[] = [];\n    if (!rule.title) errors.push(\"Title is required\");\n    if (rule.conditions.length === 0)\n      errors.push(\"At least one condition is required\");\n    if (rule.actions.length === 0)\n      errors.push(\"At least one action is required\");\n    setValidationErrors(errors);\n    return { valid: errors.length === 0, errors };\n  }, []);\n\n  const testRule = useCallback(\n    async (\n      _rule: Rule,\n      _testData: Record<string, unknown>,\n    ): Promise<TestResult> => {\n      setIsTesting(true);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        return { passed: true, message: \"Rule test passed\" };\n      } finally {\n        setIsTesting(false);\n      }\n    },\n    [],\n  );\n\n  const addCondition = useCallback(\n    (condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: [...currentRule.conditions, condition],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeCondition = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateCondition = useCallback(\n    (index: number, condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.map((c, i) =>\n            i === index ? condition : c,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const addAction = useCallback(\n    (action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: [...currentRule.actions, action],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeAction = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateAction = useCallback(\n    (index: number, action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.map((a, i) =>\n            i === index ? action : a,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    rules,\n    currentRule,\n    isLoading,\n    createRule,\n    updateRule,\n    deleteRule,\n    toggleRule,\n    setCurrentRule,\n    resetEditor,\n    validateRule,\n    isRuleValid: validationErrors.length === 0,\n    validationErrors,\n    testRule,\n    isTesting,\n    addCondition,\n    removeCondition,\n    updateCondition,\n    addAction,\n    removeAction,\n    updateAction,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/multi-wearer-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useAdminDashboard.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useAdminDashboard' has too many lines (149). Maximum allowed is 75.","line":81,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":261,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Admin Dashboard Hook\n *\n * Extracts admin session logic and wearer management from AdminDashboard component.\n * Provides aggregated statistics and multi-wearer operations.\n */\n\nimport { useState, useCallback, useMemo } from \"react\";\nimport { logger } from \"../../utils/logging\";\n\n// Types for admin dashboard\nexport interface WearerWithSession {\n  id: string;\n  name: string;\n  email?: string;\n  isActive: boolean;\n  sessionStartTime?: Date;\n  sessionDuration: number; // in seconds\n  isPaused: boolean;\n  taskCount: number;\n}\n\nexport interface AdminStatistics {\n  totalWearers: number;\n  activeWearers: number;\n  activeSessions: number;\n  totalSessionTime: number; // in seconds\n  averageSessionLength: number; // in seconds\n  tasksCompleted: number;\n  tasksPending: number;\n}\n\nexport interface Activity {\n  id: string;\n  type: \"session_start\" | \"session_end\" | \"task_completed\" | \"task_assigned\";\n  wearerId: string;\n  wearerName: string;\n  timestamp: Date;\n  description: string;\n}\n\nexport interface AdminFilter {\n  showActive?: boolean;\n  showInactive?: boolean;\n  searchText?: string;\n}\n\nexport interface UseAdminDashboardReturn {\n  // Data\n  wearers: WearerWithSession[];\n  statistics: AdminStatistics;\n  recentActivity: Activity[];\n  isLoading: boolean;\n  error: Error | null;\n\n  // Actions\n  pauseAllSessions: () => Promise<void>;\n  resumeAllSessions: () => Promise<void>;\n  endSession: (wearerId: string) => Promise<void>;\n  sendBulkNotification: (message: string, wearerIds: string[]) => Promise<void>;\n\n  // Metrics\n  activeSessions: number;\n  totalWearers: number;\n  averageSessionLength: number;\n\n  // Filtering\n  filterBy: (filter: AdminFilter) => void;\n  currentFilter: AdminFilter;\n\n  // Real-time\n  refreshData: () => Promise<void>;\n  lastUpdate: Date | null;\n}\n\n/**\n * Admin Dashboard Hook\n *\n * @returns Admin dashboard interface with wearer management and statistics\n */\nexport function useAdminDashboard(): UseAdminDashboardReturn {\n  // State\n  const [wearers, setWearers] = useState<WearerWithSession[]>([]);\n  const [recentActivity, setRecentActivity] = useState<Activity[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [currentFilter, setCurrentFilter] = useState<AdminFilter>({});\n  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n\n  // Calculate statistics\n  const statistics = useMemo((): AdminStatistics => {\n    const activeWearers = wearers.filter((w) => w.isActive).length;\n    const activeSessions = wearers.filter(\n      (w) => w.isActive && w.sessionStartTime,\n    ).length;\n    const totalSessionTime = wearers.reduce(\n      (sum, w) => sum + w.sessionDuration,\n      0,\n    );\n    const averageSessionLength =\n      activeSessions > 0 ? totalSessionTime / activeSessions : 0;\n\n    return {\n      totalWearers: wearers.length,\n      activeWearers,\n      activeSessions,\n      totalSessionTime,\n      averageSessionLength,\n      tasksCompleted: wearers.reduce((sum, w) => sum + (w.taskCount || 0), 0),\n      tasksPending: 0, // Would be calculated from actual task data\n    };\n  }, [wearers]);\n\n  // Pause all active sessions\n  const pauseAllSessions = useCallback(async (): Promise<void> => {\n    setError(null);\n    try {\n      setWearers((prev) =>\n        prev.map((w) =>\n          w.isActive && !w.isPaused ? { ...w, isPaused: true } : w,\n        ),\n      );\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to pause sessions\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  // Resume all paused sessions\n  const resumeAllSessions = useCallback(async (): Promise<void> => {\n    setError(null);\n    try {\n      setWearers((prev) =>\n        prev.map((w) => (w.isPaused ? { ...w, isPaused: false } : w)),\n      );\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to resume sessions\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  // End a specific wearer's session\n  const endSession = useCallback(\n    async (wearerId: string): Promise<void> => {\n      setError(null);\n      try {\n        setWearers((prev) =>\n          prev.map((w) =>\n            w.id === wearerId\n              ? {\n                  ...w,\n                  isActive: false,\n                  sessionStartTime: undefined,\n                  isPaused: false,\n                }\n              : w,\n          ),\n        );\n\n        // Add activity log\n        const wearer = wearers.find((w) => w.id === wearerId);\n        if (wearer) {\n          setRecentActivity((prev) =>\n            [\n              {\n                id: `activity-${Date.now()}`,\n                type: \"session_end\",\n                wearerId,\n                wearerName: wearer.name,\n                timestamp: new Date(),\n                description: `Session ended for ${wearer.name}`,\n              },\n              ...prev,\n            ].slice(0, 50),\n          ); // Keep last 50 activities\n        }\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to end session\");\n        setError(error);\n        throw error;\n      }\n    },\n    [wearers],\n  );\n\n  // Send bulk notification\n  const sendBulkNotification = useCallback(\n    async (message: string, wearerIds: string[]): Promise<void> => {\n      setError(null);\n      try {\n        // Mock implementation - in production would call notification service\n        logger.info(\n          `Sending notification to ${wearerIds.length} wearers: ${message}`,\n        );\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to send notification\");\n        setError(error);\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // Apply filter\n  const filterBy = useCallback((filter: AdminFilter) => {\n    setCurrentFilter(filter);\n  }, []);\n\n  // Refresh data\n  const refreshData = useCallback(async (): Promise<void> => {\n    setError(null);\n    try {\n      // Mock implementation - in production would fetch from API/Firebase\n      setLastUpdate(new Date());\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to refresh data\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    // Data\n    wearers,\n    statistics,\n    recentActivity,\n    isLoading,\n    error,\n\n    // Actions\n    pauseAllSessions,\n    resumeAllSessions,\n    endSession,\n    sendBulkNotification,\n\n    // Metrics\n    activeSessions: statistics.activeSessions,\n    totalWearers: statistics.totalWearers,\n    averageSessionLength: statistics.averageSessionLength,\n\n    // Filtering\n    filterBy,\n    currentFilter,\n\n    // Real-time\n    refreshData,\n    lastUpdate,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useAdminSession.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useKeyholderRewards.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useKeyholderRewards.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useKeyholderRewards' has too many lines (81). Maximum allowed is 75.","line":22,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":108,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from \"react\";\nimport { serverTimestamp } from \"firebase/firestore\";\nimport { KeyholderReward, KeyholderPunishment, TaskData } from \"../../types\";\n\ninterface UseKeyholderRewardsProps {\n  userId: string;\n  addTask: (taskData: TaskData) => Promise<void>;\n  saveDataToFirestore: (data: Record<string, unknown>) => Promise<void>;\n  requiredKeyholderDurationSeconds: number;\n}\n\ninterface UseKeyholderRewardsReturn {\n  isLoading: boolean;\n  error: string | null;\n  addReward: (reward: KeyholderReward) => Promise<void>;\n  addPunishment: (punishment: KeyholderPunishment) => Promise<void>;\n  updateDuration: (newDurationSeconds: number) => Promise<void>;\n  adjustTimeFromReward: (timeSeconds: number) => Promise<void>;\n  adjustTimeFromPunishment: (timeSeconds: number) => Promise<void>;\n}\n\nexport function useKeyholderRewards({\n  userId,\n  addTask,\n  saveDataToFirestore,\n  requiredKeyholderDurationSeconds,\n}: UseKeyholderRewardsProps): UseKeyholderRewardsReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const addReward = useCallback(\n    async (reward: KeyholderReward) => {\n      await handleAddReward({\n        reward,\n        userId,\n        addTask,\n        saveDataToFirestore,\n        requiredKeyholderDurationSeconds,\n        setIsLoading,\n        setError,\n      });\n    },\n    [userId, addTask, saveDataToFirestore, requiredKeyholderDurationSeconds],\n  );\n\n  const addPunishment = useCallback(\n    async (punishment: KeyholderPunishment) => {\n      await handleAddPunishment({\n        punishment,\n        userId,\n        addTask,\n        saveDataToFirestore,\n        requiredKeyholderDurationSeconds,\n        setIsLoading,\n        setError,\n      });\n    },\n    [userId, addTask, saveDataToFirestore, requiredKeyholderDurationSeconds],\n  );\n\n  const updateDuration = useCallback(\n    async (newDurationSeconds: number) => {\n      await handleUpdateDuration({\n        newDurationSeconds,\n        saveDataToFirestore,\n        setIsLoading,\n        setError,\n      });\n    },\n    [saveDataToFirestore],\n  );\n\n  const adjustTimeFromReward = useCallback(\n    async (timeSeconds: number) => {\n      await handleAdjustTimeFromReward({\n        timeSeconds,\n        requiredKeyholderDurationSeconds,\n        updateDuration,\n        setIsLoading,\n        setError,\n      });\n    },\n    [requiredKeyholderDurationSeconds, updateDuration],\n  );\n\n  const adjustTimeFromPunishment = useCallback(\n    async (timeSeconds: number) => {\n      await handleAdjustTimeFromPunishment({\n        timeSeconds,\n        requiredKeyholderDurationSeconds,\n        updateDuration,\n        setIsLoading,\n        setError,\n      });\n    },\n    [requiredKeyholderDurationSeconds, updateDuration],\n  );\n\n  return {\n    isLoading,\n    error,\n    addReward,\n    addPunishment,\n    updateDuration,\n    adjustTimeFromReward,\n    adjustTimeFromPunishment,\n  };\n}\n\n// Helper functions for useKeyholderRewards\nasync function handleAddReward(params: {\n  reward: KeyholderReward;\n  userId: string;\n  addTask: (taskData: TaskData) => Promise<void>;\n  saveDataToFirestore: (data: Record<string, unknown>) => Promise<void>;\n  requiredKeyholderDurationSeconds: number;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n  setError: React.Dispatch<React.SetStateAction<string | null>>;\n}): Promise<void> {\n  const {\n    reward,\n    userId,\n    addTask,\n    saveDataToFirestore,\n    requiredKeyholderDurationSeconds,\n    setIsLoading,\n    setError,\n  } = params;\n\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    if (!userId || !addTask || !saveDataToFirestore) {\n      throw new Error(\"Missing required dependencies for adding reward\");\n    }\n\n    const timeToRemoveInSeconds = reward.timeSeconds || 0;\n\n    // Update duration if time reward is given\n    if (timeToRemoveInSeconds > 0) {\n      const currentDuration = requiredKeyholderDurationSeconds || 0;\n      const newDuration = Math.max(0, currentDuration - timeToRemoveInSeconds);\n      await saveDataToFirestore({\n        requiredKeyholderDurationSeconds: newDuration,\n      });\n    }\n\n    // Create the standardized log entry\n    const taskData: TaskData = {\n      text: \"Keyholder Reward\",\n      logType: \"reward\",\n      sourceText: \"Manually added by Keyholder\",\n      note: reward.note || reward.other || \"\",\n      timeChangeSeconds: timeToRemoveInSeconds > 0 ? -timeToRemoveInSeconds : 0,\n      createdAt: serverTimestamp(),\n    };\n\n    await addTask(taskData);\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to add reward\");\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}\n\nasync function handleAddPunishment(params: {\n  punishment: KeyholderPunishment;\n  userId: string;\n  addTask: (taskData: TaskData) => Promise<void>;\n  saveDataToFirestore: (data: Record<string, unknown>) => Promise<void>;\n  requiredKeyholderDurationSeconds: number;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n  setError: React.Dispatch<React.SetStateAction<string | null>>;\n}): Promise<void> {\n  const {\n    punishment,\n    userId,\n    addTask,\n    saveDataToFirestore,\n    requiredKeyholderDurationSeconds,\n    setIsLoading,\n    setError,\n  } = params;\n\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    if (!userId || !addTask || !saveDataToFirestore) {\n      throw new Error(\"Missing required dependencies for adding punishment\");\n    }\n\n    const timeToAddInSeconds = punishment.timeSeconds || 0;\n\n    // Update duration if time punishment is given\n    if (timeToAddInSeconds > 0) {\n      const currentDuration = requiredKeyholderDurationSeconds || 0;\n      const newDuration = currentDuration + timeToAddInSeconds;\n      await saveDataToFirestore({\n        requiredKeyholderDurationSeconds: newDuration,\n      });\n    }\n\n    // Create the standardized log entry\n    const taskData: TaskData = {\n      text: \"Keyholder Punishment\",\n      logType: \"punishment\",\n      sourceText: \"Manually added by Keyholder\",\n      note: punishment.note || punishment.other || \"\",\n      timeChangeSeconds: timeToAddInSeconds > 0 ? timeToAddInSeconds : 0,\n      createdAt: serverTimestamp(),\n    };\n\n    await addTask(taskData);\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to add punishment\");\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}\n\nasync function handleUpdateDuration(params: {\n  newDurationSeconds: number;\n  saveDataToFirestore: (data: Record<string, unknown>) => Promise<void>;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n  setError: React.Dispatch<React.SetStateAction<string | null>>;\n}): Promise<void> {\n  const { newDurationSeconds, saveDataToFirestore, setIsLoading, setError } =\n    params;\n\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    if (!saveDataToFirestore) {\n      throw new Error(\"Missing saveDataToFirestore function\");\n    }\n\n    if (newDurationSeconds < 0) {\n      throw new Error(\"Duration cannot be negative\");\n    }\n\n    await saveDataToFirestore({\n      requiredKeyholderDurationSeconds: newDurationSeconds,\n    });\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to update duration\");\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}\n\nasync function handleAdjustTimeFromReward(params: {\n  timeSeconds: number;\n  requiredKeyholderDurationSeconds: number;\n  updateDuration: (newDurationSeconds: number) => Promise<void>;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n  setError: React.Dispatch<React.SetStateAction<string | null>>;\n}): Promise<void> {\n  const {\n    timeSeconds,\n    requiredKeyholderDurationSeconds,\n    updateDuration,\n    setIsLoading,\n    setError,\n  } = params;\n\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    if (timeSeconds <= 0) {\n      throw new Error(\"Reward time must be positive\");\n    }\n\n    const currentDuration = requiredKeyholderDurationSeconds || 0;\n    const newDuration = Math.max(0, currentDuration - timeSeconds);\n\n    await updateDuration(newDuration);\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to adjust time from reward\",\n    );\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}\n\nasync function handleAdjustTimeFromPunishment(params: {\n  timeSeconds: number;\n  requiredKeyholderDurationSeconds: number;\n  updateDuration: (newDurationSeconds: number) => Promise<void>;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n  setError: React.Dispatch<React.SetStateAction<string | null>>;\n}): Promise<void> {\n  const {\n    timeSeconds,\n    requiredKeyholderDurationSeconds,\n    updateDuration,\n    setIsLoading,\n    setError,\n  } = params;\n\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    if (timeSeconds <= 0) {\n      throw new Error(\"Punishment time must be positive\");\n    }\n\n    const currentDuration = requiredKeyholderDurationSeconds || 0;\n    const newDuration = currentDuration + timeSeconds;\n\n    await updateDuration(newDuration);\n  } catch (err) {\n    setError(\n      err instanceof Error\n        ? err.message\n        : \"Failed to adjust time from punishment\",\n    );\n    throw err;\n  } finally {\n    setIsLoading(false);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useKeyholderSession.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (120). Maximum allowed is 75.","line":33,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":167,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { doc, setDoc, onSnapshot } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} KeyholderPermissions\n * @property {boolean} canModifyDuration\n * @property {boolean} canAssignTasks\n * @property {boolean} canViewHistory\n */\n\n/**\n * @typedef {Object} KeyholderSessionState\n * @property {boolean} isActive\n * @property {string|null} keyholderEmail\n * @property {Date|null} sessionStartTime\n * @property {KeyholderPermissions} permissions\n * @property {number} [requiredDuration]\n */\n\n/**\n * @typedef {Object} KeyholderSessionOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {string} [userEmail]\n */\n\n/**\n * Hook for managing keyholder sessions\n * @param {KeyholderSessionOptions} options\n * @returns {Object}\n */\nexport const useKeyholderSession = ({ userId, isAuthReady }) => {\n  const [sessionState, setSessionState] = useState({\n    isActive: false,\n    keyholderEmail: null,\n    sessionStartTime: null,\n    permissions: {\n      canModifyDuration: false,\n      canAssignTasks: false,\n      canViewHistory: false\n    }\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const startKeyholderSession = useCallback(async (keyholderEmail, permissions = {}) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      const newSessionState = {\n        isActive: true,\n        keyholderEmail,\n        sessionStartTime: new Date(),\n        permissions: {\n          canModifyDuration: permissions.canModifyDuration ?? true,\n          canAssignTasks: permissions.canAssignTasks ?? true,\n          canViewHistory: permissions.canViewHistory ?? true\n        }\n      };\n\n      await setDoc(userDocRef, { keyholderSession: newSessionState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to start keyholder session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const endKeyholderSession = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      const endSessionState = {\n        isActive: false,\n        keyholderEmail: null,\n        sessionStartTime: null,\n        permissions: {\n          canModifyDuration: false,\n          canAssignTasks: false,\n          canViewHistory: false\n        }\n      };\n\n      await setDoc(userDocRef, { keyholderSession: endSessionState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to end keyholder session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const updatePermissions = useCallback(async (newPermissions) => {\n    if (!userId || !isAuthReady || !sessionState.isActive) {\n      setError('No active keyholder session');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { \n        keyholderSession: {\n          ...sessionState,\n          permissions: { ...sessionState.permissions, ...newPermissions }\n        }\n      }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to update permissions');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, sessionState]);\n\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.keyholderSession) {\n            setSessionState({\n              ...data.keyholderSession,\n              sessionStartTime: data.keyholderSession.sessionStartTime?.toDate() || null\n            });\n          }\n        }\n        setError(null);\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [userId, isAuthReady]);\n\n  return {\n    sessionState,\n    isLoading,\n    error,\n    startKeyholderSession,\n    endKeyholderSession,\n    updatePermissions,\n    isKeyholderActive: sessionState.isActive && sessionState.keyholderEmail !== null\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useKeyholderSession.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useKeyholderSession' has too many lines (83). Maximum allowed is 75.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":137,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from \"react\";\nimport {\n  doc,\n  setDoc,\n  updateDoc,\n  onSnapshot,\n  DocumentReference,\n} from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\nimport { KeyholderSession, KeyholderPermissions } from \"../../types\";\n\ninterface UseKeyholderSessionProps {\n  userId: string;\n  isAuthReady: boolean;\n  keyholderName?: string;\n}\n\ninterface UseKeyholderSessionReturn {\n  keyholderSession: KeyholderSession | null;\n  isActive: boolean;\n  permissions: KeyholderPermissions | null;\n  isLoading: boolean;\n  error: string | null;\n  startSession: (\n    keyholderName: string,\n    permissions: KeyholderPermissions,\n  ) => Promise<void>;\n  endSession: () => Promise<void>;\n  updatePermissions: (\n    permissions: Partial<KeyholderPermissions>,\n  ) => Promise<void>;\n  updateKeyholderName: (name: string) => Promise<void>;\n}\n\nconst defaultPermissions: KeyholderPermissions = {\n  canApproveTasks: false,\n  canAddPunishments: false,\n  canAddRewards: false,\n  canModifyDuration: false,\n  canLockControls: false,\n};\n\nexport function useKeyholderSession({\n  userId,\n  isAuthReady,\n  keyholderName,\n}: UseKeyholderSessionProps): UseKeyholderSessionReturn {\n  const [keyholderSession, setKeyholderSession] =\n    useState<KeyholderSession | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const getKeyholderDocRef = useCallback(() => {\n    if (!userId) return null;\n    return doc(db, \"users\", userId, \"keyholderSession\", \"current\");\n  }, [userId]);\n\n  // Set up real-time listener for keyholder session\n  useEffect(() => {\n    if (!isAuthReady || !userId) {\n      setIsLoading(false);\n      setKeyholderSession(null);\n      return;\n    }\n\n    const keyholderDocRef = getKeyholderDocRef();\n    if (!keyholderDocRef) {\n      setIsLoading(false);\n      return;\n    }\n\n    setIsLoading(true);\n\n    const unsubscribe = setupSessionListener(\n      keyholderDocRef,\n      keyholderName,\n      setKeyholderSession,\n      setError,\n      setIsLoading,\n    );\n\n    return () => unsubscribe();\n  }, [isAuthReady, userId, keyholderName, getKeyholderDocRef]);\n\n  const startSession = useCallback(\n    async (sessionKeyholderName: string, permissions: KeyholderPermissions) => {\n      await handleStartSession(\n        sessionKeyholderName,\n        permissions,\n        userId,\n        getKeyholderDocRef,\n        setError,\n      );\n    },\n    [userId, getKeyholderDocRef],\n  );\n\n  const endSession = useCallback(async () => {\n    await handleEndSession(getKeyholderDocRef, setError);\n  }, [getKeyholderDocRef]);\n\n  const updatePermissions = useCallback(\n    async (newPermissions: Partial<KeyholderPermissions>) => {\n      await handleUpdatePermissions(\n        keyholderSession,\n        newPermissions,\n        getKeyholderDocRef,\n        setError,\n      );\n    },\n    [keyholderSession, getKeyholderDocRef],\n  );\n\n  const updateKeyholderName = useCallback(\n    async (name: string) => {\n      await handleUpdateKeyholderName(\n        name,\n        userId,\n        getKeyholderDocRef,\n        setError,\n      );\n    },\n    [userId, getKeyholderDocRef],\n  );\n\n  return {\n    keyholderSession,\n    isActive: keyholderSession?.isActive || false,\n    permissions: keyholderSession?.permissions || null,\n    isLoading,\n    error,\n    startSession,\n    endSession,\n    updatePermissions,\n    updateKeyholderName,\n  };\n}\n\n// Helper functions for useKeyholderSession\nfunction setupSessionListener(\n  keyholderDocRef: DocumentReference,\n  keyholderName: string | undefined,\n  setKeyholderSession: React.Dispatch<\n    React.SetStateAction<KeyholderSession | null>\n  >,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>,\n) {\n  return onSnapshot(\n    keyholderDocRef,\n    (docSnapshot) => {\n      try {\n        if (docSnapshot.exists()) {\n          const data = docSnapshot.data();\n          const session: KeyholderSession = {\n            keyholderName: data.keyholderName || keyholderName,\n            isActive: data.isActive || false,\n            startTime: data.startTime?.toDate(),\n            endTime: data.endTime?.toDate(),\n            permissions: { ...defaultPermissions, ...data.permissions },\n          };\n          setKeyholderSession(session);\n        } else {\n          setKeyholderSession(null);\n        }\n        setError(null);\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to process session data\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    (err) => {\n      setError(\n        err instanceof Error\n          ? err.message\n          : \"Failed to listen to session changes\",\n      );\n      setIsLoading(false);\n    },\n  );\n}\n\nasync function handleStartSession(\n  sessionKeyholderName: string,\n  permissions: KeyholderPermissions,\n  userId: string,\n  getKeyholderDocRef: () => DocumentReference | null,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n): Promise<void> {\n  try {\n    setError(null);\n    const keyholderDocRef = getKeyholderDocRef();\n    if (!keyholderDocRef) {\n      throw new Error(\"No keyholder document reference available\");\n    }\n\n    if (!sessionKeyholderName.trim()) {\n      throw new Error(\"Keyholder name is required\");\n    }\n\n    const sessionData = {\n      keyholderName: sessionKeyholderName.trim(),\n      isActive: true,\n      startTime: new Date(),\n      endTime: null,\n      permissions,\n    };\n\n    await setDoc(keyholderDocRef, sessionData);\n\n    // Also update the main user document with keyholder name\n    const userDocRef = doc(db, \"users\", userId);\n    await updateDoc(userDocRef, {\n      keyholderName: sessionKeyholderName.trim(),\n    });\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to start keyholder session\",\n    );\n    throw err;\n  }\n}\n\nasync function handleEndSession(\n  getKeyholderDocRef: () => DocumentReference | null,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n): Promise<void> {\n  try {\n    setError(null);\n    const keyholderDocRef = getKeyholderDocRef();\n    if (!keyholderDocRef) return;\n\n    await updateDoc(keyholderDocRef, {\n      isActive: false,\n      endTime: new Date(),\n    });\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to end keyholder session\",\n    );\n    throw err;\n  }\n}\n\nasync function handleUpdatePermissions(\n  keyholderSession: KeyholderSession | null,\n  newPermissions: Partial<KeyholderPermissions>,\n  getKeyholderDocRef: () => DocumentReference | null,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n): Promise<void> {\n  try {\n    setError(null);\n    if (!keyholderSession || !keyholderSession.isActive) {\n      throw new Error(\"No active keyholder session to update\");\n    }\n\n    const keyholderDocRef = getKeyholderDocRef();\n    if (!keyholderDocRef) return;\n\n    const updatedPermissions = {\n      ...keyholderSession.permissions,\n      ...newPermissions,\n    };\n\n    await updateDoc(keyholderDocRef, {\n      permissions: updatedPermissions,\n    });\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to update permissions\",\n    );\n    throw err;\n  }\n}\n\nasync function handleUpdateKeyholderName(\n  name: string,\n  userId: string,\n  getKeyholderDocRef: () => DocumentReference | null,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n): Promise<void> {\n  try {\n    setError(null);\n    if (!name.trim()) {\n      throw new Error(\"Keyholder name cannot be empty\");\n    }\n\n    const keyholderDocRef = getKeyholderDocRef();\n    if (!keyholderDocRef) return;\n\n    await updateDoc(keyholderDocRef, {\n      keyholderName: name.trim(),\n    });\n\n    // Also update the main user document\n    const userDocRef = doc(db, \"users\", userId);\n    await updateDoc(userDocRef, {\n      keyholderName: name.trim(),\n    });\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to update keyholder name\",\n    );\n    throw err;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useKeyholderSystem.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (265). Maximum allowed is 75.","line":140,"column":35,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":476,"endColumn":2},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'endAdminSession'. Either include it or remove the dependency array.","line":450,"column":6,"nodeType":"ArrayExpression","endLine":450,"endColumn":26,"suggestions":[{"desc":"Update the dependencies array to be: [endAdminSession, state.adminSession]","fix":{"range":[13510,13530],"text":"[endAdminSession, state.adminSession]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'refreshData'. Either include it or remove the dependency array.","line":438,"column":6,"nodeType":"ArrayExpression","endLine":441,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]","fix":{"range":[13081,13185],"text":"[keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useKeyholderSystem Hook\n * Unified management interface for all keyholder functionality\n * Acts as the primary entry point for keyholder operations\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { useAuthState } from \"../../contexts\";\nimport { useKeyholderRelationships } from \"../useKeyholderRelationships\";\nimport {\n  KeyholderRelationship,\n  KeyholderPermissions as _KeyholderPermissions,\n} from \"../../types/core\";\nimport { Task } from \"../../types\";\nimport { InviteCode } from \"../../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderSystem\");\n\n// ==================== TYPES ====================\n\nexport interface KeyholderStats {\n  totalSubmissives: number;\n  activeRelationships: number;\n  totalSessions: number;\n  averageSessionDuration: number;\n  totalRewardsGiven: number;\n  totalPunishmentsGiven: number;\n  lastActivity: Date | null;\n}\n\nexport interface KeyholderStatus {\n  isActiveKeyholder: boolean;\n  hasPermissions: boolean;\n  canCreateInvites: boolean;\n  maxRelationships: number;\n  currentRelationships: number;\n}\n\nexport interface AdminSession {\n  id: string;\n  keyholderId: string;\n  relationshipId: string;\n  startTime: Date;\n  expiresAt: Date;\n  permissions: string[];\n  isActive: boolean;\n  lastActivity: Date;\n}\n\nexport interface KeyholderSystemState {\n  // Active relationships where user is keyholder\n  activeRelationships: KeyholderRelationship[];\n  // Current admin session if active\n  adminSession: AdminSession | null;\n  // Overall keyholder status and permissions\n  keyholderStatus: KeyholderStatus;\n  // Quick stats for dashboard\n  stats: KeyholderStats;\n  // Currently selected relationship for operations\n  selectedRelationship: KeyholderRelationship | null;\n  // Loading states\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n}\n\nexport interface InviteOptions {\n  expirationHours?: number;\n  maxUses?: number;\n  customNote?: string;\n}\n\nexport interface BulkOperations {\n  startSessions: (\n    relationshipIds: string[],\n    options?: { duration?: number; message?: string },\n  ) => Promise<void>;\n  stopSessions: (relationshipIds: string[], reason?: string) => Promise<void>;\n  sendMessages: (relationshipIds: string[], message: string) => Promise<void>;\n  assignTasks: (\n    relationshipIds: string[],\n    task: Omit<Task, \"id\" | \"createdAt\">,\n  ) => Promise<void>;\n}\n\nexport interface KeyholderSystemActions {\n  // Relationship management\n  createInviteCode: (options?: InviteOptions) => Promise<string | null>;\n  acceptSubmissive: (\n    inviteCode: string,\n  ) => Promise<KeyholderRelationship | null>;\n  removeSubmissive: (relationshipId: string) => Promise<void>;\n\n  // Session management\n  startAdminSession: (relationshipId: string) => Promise<AdminSession | null>;\n  endAdminSession: () => Promise<void>;\n\n  // Multi-user operations\n  switchActiveRelationship: (relationshipId: string) => void;\n  getBulkOperations: () => BulkOperations;\n\n  // Data management\n  refreshData: () => Promise<void>;\n  resetError: () => void;\n}\n\n// ==================== INITIAL STATE ====================\n\nconst initialKeyholderStatus: KeyholderStatus = {\n  isActiveKeyholder: false,\n  hasPermissions: false,\n  canCreateInvites: false,\n  maxRelationships: 5, // Default limit\n  currentRelationships: 0,\n};\n\nconst initialStats: KeyholderStats = {\n  totalSubmissives: 0,\n  activeRelationships: 0,\n  totalSessions: 0,\n  averageSessionDuration: 0,\n  totalRewardsGiven: 0,\n  totalPunishmentsGiven: 0,\n  lastActivity: null,\n};\n\nconst initialState: KeyholderSystemState = {\n  activeRelationships: [],\n  adminSession: null,\n  keyholderStatus: initialKeyholderStatus,\n  stats: initialStats,\n  selectedRelationship: null,\n  isLoading: false,\n  isInitialized: false,\n  error: null,\n};\n\n// ==================== MAIN HOOK ====================\n\nexport const useKeyholderSystem = (keyholderId?: string) => {\n  const { user } = useAuthState();\n  const keyholderRelationships = useKeyholderRelationships();\n\n  // Use provided keyholderId or fall back to current user\n  const effectiveKeyholderId = keyholderId || user?.uid;\n\n  const [state, setState] = useState<KeyholderSystemState>(initialState);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const computedValues = useMemo(() => {\n    const { activeRelationships, adminSession, keyholderStatus } = state;\n\n    return {\n      hasActiveRelationships: activeRelationships.length > 0,\n      canStartAdminSession: adminSession === null,\n      activeRelationshipCount: activeRelationships.length,\n      hasMaxRelationships:\n        keyholderStatus.currentRelationships >=\n        keyholderStatus.maxRelationships,\n      selectedRelationshipId: state.selectedRelationship?.id || null,\n    };\n  }, [state]);\n\n  // ==================== ACTIONS ====================\n\n  const refreshData = useCallback(async () => {\n    if (!effectiveKeyholderId) return;\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      logger.debug(\"Refreshing keyholder system data\", {\n        keyholderId: effectiveKeyholderId,\n      });\n\n      // Get relationships from the existing hook\n      await keyholderRelationships.loadRelationships();\n\n      const keyholderRelationshipsList =\n        keyholderRelationships.relationships.asKeyholder;\n\n      // Calculate keyholder status and stats\n      const { keyholderStatus, stats } = calculateKeyholderStatusAndStats(\n        keyholderRelationshipsList,\n        keyholderRelationships,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        activeRelationships: keyholderRelationshipsList,\n        keyholderStatus,\n        stats,\n        isLoading: false,\n        isInitialized: true,\n      }));\n\n      logger.info(\"Keyholder system data refreshed\", {\n        relationshipCount: keyholderRelationshipsList.length,\n        activeCount: stats.activeRelationships,\n      });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : \"Failed to refresh keyholder data\";\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      logger.error(\"Failed to refresh keyholder system data\", {\n        error: error as Error,\n      });\n    }\n  }, [effectiveKeyholderId, keyholderRelationships]);\n\n  const createInviteCode = useCallback(\n    async (options: InviteOptions = {}): Promise<string | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Creating invite code\", {\n          keyholderId: effectiveKeyholderId,\n          options,\n        });\n\n        const inviteCode = await keyholderRelationships.createInviteCode(\n          options.expirationHours,\n        );\n\n        return await handleInviteCodeCreation(inviteCode, refreshData);\n      } catch (error) {\n        return handleInviteCodeError(error, setState);\n      }\n    },\n    [effectiveKeyholderId, keyholderRelationships, refreshData],\n  );\n\n  const acceptSubmissive = useCallback(\n    async (inviteCode: string): Promise<KeyholderRelationship | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Accepting submissive\", {\n          keyholderId: effectiveKeyholderId,\n          inviteCode,\n        });\n\n        const success =\n          await keyholderRelationships.acceptInviteCode(inviteCode);\n\n        return await handleSubmissiveAcceptance(\n          success,\n          refreshData,\n          state.activeRelationships,\n        );\n      } catch (error) {\n        return handleSubmissiveAcceptanceError(error, setState);\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.activeRelationships,\n    ],\n  );\n\n  const removeSubmissive = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      if (!effectiveKeyholderId) return;\n\n      try {\n        logger.debug(\"Removing submissive\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        await keyholderRelationships.endRelationship(relationshipId);\n\n        // Refresh data to update state\n        await refreshData();\n\n        // Clear selected relationship if it was the removed one\n        if (state.selectedRelationship?.id === relationshipId) {\n          setState((prev) => ({ ...prev, selectedRelationship: null }));\n        }\n      } catch (error) {\n        logger.error(\"Failed to remove submissive\", { error: error as Error });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to remove submissive\",\n        }));\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.selectedRelationship,\n    ],\n  );\n\n  const switchActiveRelationship = useCallback(\n    (relationshipId: string) => {\n      const relationship = state.activeRelationships.find(\n        (rel) => rel.id === relationshipId,\n      );\n      if (relationship) {\n        setState((prev) => ({ ...prev, selectedRelationship: relationship }));\n        logger.debug(\"Switched active relationship\", { relationshipId });\n      }\n    },\n    [state.activeRelationships],\n  );\n\n  // Admin session management (placeholder implementation)\n  const startAdminSession = useCallback(\n    async (relationshipId: string): Promise<AdminSession | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Starting admin session\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        // TODO: Implement actual admin session creation\n        const adminSession: AdminSession = {\n          id: `admin_${Date.now()}`,\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n          startTime: new Date(),\n          expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes\n          permissions: [\"session_control\", \"task_management\", \"rewards\"], // Default permissions\n          isActive: true,\n          lastActivity: new Date(),\n        };\n\n        setState((prev) => ({ ...prev, adminSession }));\n\n        logger.info(\"Admin session started\", { sessionId: adminSession.id });\n        return adminSession;\n      } catch (error) {\n        logger.error(\"Failed to start admin session\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to start admin session\",\n        }));\n        return null;\n      }\n    },\n    [effectiveKeyholderId],\n  );\n\n  const endAdminSession = useCallback(async (): Promise<void> => {\n    if (!state.adminSession) return;\n\n    try {\n      logger.debug(\"Ending admin session\", {\n        sessionId: state.adminSession.id,\n      });\n\n      // TODO: Implement actual admin session cleanup\n      setState((prev) => ({ ...prev, adminSession: null }));\n\n      logger.info(\"Admin session ended\");\n    } catch (error) {\n      logger.error(\"Failed to end admin session\", { error: error as Error });\n      setState((prev) => ({\n        ...prev,\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to end admin session\",\n      }));\n    }\n  }, [state.adminSession]);\n\n  const getBulkOperations = useCallback((): BulkOperations => {\n    return {\n      startSessions: async (\n        relationshipIds: string[],\n        options?: { duration?: number; message?: string },\n      ) => {\n        logger.debug(\"Bulk starting sessions\", { relationshipIds, options });\n        // TODO: Implement bulk session start\n      },\n      stopSessions: async (relationshipIds: string[], reason?: string) => {\n        logger.debug(\"Bulk stopping sessions\", { relationshipIds, reason });\n        // TODO: Implement bulk session stop\n      },\n      sendMessages: async (relationshipIds: string[], message: string) => {\n        logger.debug(\"Bulk sending messages\", { relationshipIds, message });\n        // TODO: Implement bulk messaging\n      },\n      assignTasks: async (\n        relationshipIds: string[],\n        task: Omit<Task, \"id\" | \"createdAt\">,\n      ) => {\n        logger.debug(\"Bulk assigning tasks\", { relationshipIds, task });\n        // TODO: Implement bulk task assignment\n      },\n    };\n  }, []);\n\n  const resetError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  // ==================== EFFECTS ====================\n\n  // Initialize data when user changes\n  useEffect(() => {\n    if (effectiveKeyholderId && !state.isInitialized) {\n      refreshData();\n    }\n  }, [effectiveKeyholderId, state.isInitialized, refreshData]);\n\n  // Auto-refresh when relationships data changes\n  useEffect(() => {\n    if (\n      keyholderRelationships.relationships.asKeyholder.length !==\n      state.activeRelationships.length\n    ) {\n      refreshData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    keyholderRelationships.relationships.asKeyholder.length,\n    state.activeRelationships.length,\n  ]);\n\n  // Admin session auto-expiry\n  useEffect(() => {\n    if (state.adminSession && state.adminSession.expiresAt < new Date()) {\n      logger.info(\"Admin session expired, ending session\");\n      endAdminSession();\n    }\n    // endAdminSession is stable as it only depends on state.adminSession which is already in deps\n  }, [state.adminSession]);\n\n  // ==================== RETURN ====================\n\n  const actions: KeyholderSystemActions = {\n    createInviteCode,\n    acceptSubmissive,\n    removeSubmissive,\n    startAdminSession,\n    endAdminSession,\n    switchActiveRelationship,\n    getBulkOperations,\n    refreshData,\n    resetError,\n  };\n\n  return {\n    // State\n    ...state,\n\n    // Computed\n    ...computedValues,\n\n    // Actions\n    ...actions,\n  };\n};\n\nexport type UseKeyholderSystemReturn = ReturnType<typeof useKeyholderSystem>;\n\n// Helper functions for useKeyholderSystem\nfunction calculateKeyholderStatusAndStats(\n  keyholderRelationshipsList: KeyholderRelationship[],\n  keyholderRelationships: Record<string, unknown>,\n): { keyholderStatus: KeyholderStatus; stats: KeyholderStats } {\n  // Calculate keyholder status\n  const keyholderStatus: KeyholderStatus = {\n    isActiveKeyholder: keyholderRelationshipsList.length > 0,\n    hasPermissions: keyholderRelationshipsList.some(\n      (rel) =>\n        rel.permissions && Object.values(rel.permissions).some((perm) => perm),\n    ),\n    canCreateInvites: keyholderRelationships.canCreateInviteCode\n      ? keyholderRelationships.canCreateInviteCode()\n      : false,\n    maxRelationships: 5, // Could be user-specific in the future\n    currentRelationships: keyholderRelationshipsList.length,\n  };\n\n  // Calculate basic stats\n  const stats: KeyholderStats = {\n    totalSubmissives: keyholderRelationshipsList.length,\n    activeRelationships: keyholderRelationshipsList.filter(\n      (rel) => rel.status === \"active\",\n    ).length,\n    totalSessions: 0, // TODO: Calculate from session data\n    averageSessionDuration: 0, // TODO: Calculate from session data\n    totalRewardsGiven: 0, // TODO: Calculate from reward data\n    totalPunishmentsGiven: 0, // TODO: Calculate from punishment data\n    lastActivity: null, // TODO: Calculate from activity data\n  };\n\n  return { keyholderStatus, stats };\n}\n\nasync function handleInviteCodeCreation(\n  inviteCode: InviteCode | null,\n  refreshData: () => Promise<void>,\n): Promise<string | null> {\n  if (inviteCode) {\n    // Refresh data to update state\n    await refreshData();\n    return inviteCode.code;\n  }\n  return null;\n}\n\nfunction handleInviteCodeError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to create invite code\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to create invite code\",\n  }));\n  return null;\n}\n\nasync function handleSubmissiveAcceptance(\n  success: boolean,\n  refreshData: () => Promise<void>,\n  activeRelationships: KeyholderRelationship[],\n): Promise<KeyholderRelationship | null> {\n  if (success) {\n    // Refresh data to get the new relationship\n    await refreshData();\n\n    // Return the newest relationship (should be the one just created)\n    const newestRelationship = activeRelationships.sort(\n      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),\n    )[0];\n\n    return newestRelationship || null;\n  }\n  return null;\n}\n\nfunction handleSubmissiveAcceptanceError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to accept submissive\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to accept submissive\",\n  }));\n  return null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useMultiWearer.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useMultiWearer' has too many lines (196). Maximum allowed is 75.","line":49,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":265,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from \"react\";\nimport { onSnapshot, query, where } from \"firebase/firestore\";\nimport {\n  MultiWearerSession,\n  Wearer,\n  KeyholderPermissions,\n  SessionData,\n} from \"../../types\";\nimport {\n  getMultiWearerCollectionRef,\n  getWearersCollectionRef,\n  createMultiWearerSession,\n  endMultiWearerSession,\n  addWearerToSession,\n  removeWearerFromSession,\n  updateWearerInSession,\n  parseWearerData,\n  parseSessionData,\n} from \"./multiWearerHelpers\";\nimport { logger } from \"../../utils/logging\";\n\ninterface UseMultiWearerProps {\n  keyholderUserId: string;\n  isAuthReady: boolean;\n}\n\ninterface UseMultiWearerReturn {\n  session: MultiWearerSession | null;\n  wearers: Wearer[];\n  isLoading: boolean;\n  error: string | null;\n  createSession: () => Promise<void>;\n  endSession: () => Promise<void>;\n  addWearer: (wearerData: Omit<Wearer, \"id\">) => Promise<void>;\n  removeWearer: (wearerId: string) => Promise<void>;\n  updateWearer: (wearerId: string, updates: Partial<Wearer>) => Promise<void>;\n  updateWearerPermissions: (\n    wearerId: string,\n    permissions: Partial<KeyholderPermissions>,\n  ) => Promise<void>;\n  updateWearerSession: (\n    wearerId: string,\n    sessionData: Partial<SessionData>,\n  ) => Promise<void>;\n  activateWearer: (wearerId: string) => Promise<void>;\n  deactivateWearer: (wearerId: string) => Promise<void>;\n}\n\nexport function useMultiWearer({\n  keyholderUserId,\n  isAuthReady,\n}: UseMultiWearerProps): UseMultiWearerReturn {\n  const [session, setSession] = useState<MultiWearerSession | null>(null);\n  const [wearers, setWearers] = useState<Wearer[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Set up real-time listener for multi-wearer session\n  useEffect(() => {\n    if (!isAuthReady || !keyholderUserId) {\n      setIsLoading(false);\n      setSession(null);\n      setWearers([]);\n      return;\n    }\n\n    const multiWearerCollectionRef = getMultiWearerCollectionRef();\n    const q = query(\n      multiWearerCollectionRef,\n      where(\"keyholderUserId\", \"==\", keyholderUserId),\n      where(\"isActive\", \"==\", true),\n    );\n\n    setIsLoading(true);\n\n    const unsubscribe = onSnapshot(\n      q,\n      (querySnapshot) => {\n        try {\n          if (!querySnapshot.empty) {\n            const docSnapshot = querySnapshot.docs[0];\n            const sessionData = parseSessionData(docSnapshot);\n            setSession({ ...sessionData, wearers: [] });\n\n            // Set up listener for wearers\n            const wearersCollectionRef = getWearersCollectionRef(\n              docSnapshot.id,\n            );\n            const wearersUnsubscribe = onSnapshot(\n              wearersCollectionRef,\n              (wearersSnapshot) => {\n                const wearersData: Wearer[] =\n                  wearersSnapshot.docs.map(parseWearerData);\n                setWearers(wearersData);\n                setSession((prev) =>\n                  prev ? { ...prev, wearers: wearersData } : null,\n                );\n              },\n            );\n\n            return () => wearersUnsubscribe();\n          } else {\n            setSession(null);\n            setWearers([]);\n          }\n          setError(null);\n        } catch (err) {\n          logger.error(\"Error processing multi-wearer session data\", err);\n          setError(\n            err instanceof Error\n              ? err.message\n              : \"Failed to process session data\",\n          );\n        } finally {\n          setIsLoading(false);\n        }\n      },\n      (err) => {\n        logger.error(\"Error listening to multi-wearer session\", err);\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to listen to session changes\",\n        );\n        setIsLoading(false);\n      },\n    );\n\n    return () => unsubscribe();\n  }, [isAuthReady, keyholderUserId]);\n\n  const createSession = useCallback(async () => {\n    try {\n      setError(null);\n      if (!keyholderUserId) {\n        throw new Error(\"Keyholder user ID is required\");\n      }\n      await createMultiWearerSession(keyholderUserId);\n    } catch (err) {\n      logger.error(\"Error creating multi-wearer session\", err);\n      setError(err instanceof Error ? err.message : \"Failed to create session\");\n      throw err;\n    }\n  }, [keyholderUserId]);\n\n  const endSession = useCallback(async () => {\n    try {\n      setError(null);\n      if (!session) return;\n      await endMultiWearerSession(keyholderUserId);\n    } catch (err) {\n      logger.error(\"Error ending multi-wearer session\", err);\n      setError(err instanceof Error ? err.message : \"Failed to end session\");\n      throw err;\n    }\n  }, [session, keyholderUserId]);\n\n  const addWearer = useCallback(\n    async (wearerData: Omit<Wearer, \"id\">) => {\n      try {\n        setError(null);\n        if (!session) {\n          throw new Error(\"No active session to add wearer to\");\n        }\n        await addWearerToSession(keyholderUserId, wearerData);\n      } catch (err) {\n        logger.error(\"Error adding wearer\", err);\n        setError(err instanceof Error ? err.message : \"Failed to add wearer\");\n        throw err;\n      }\n    },\n    [session, keyholderUserId],\n  );\n\n  const removeWearer = useCallback(\n    async (wearerId: string) => {\n      try {\n        setError(null);\n        if (!session) return;\n        await removeWearerFromSession(keyholderUserId, wearerId);\n      } catch (err) {\n        logger.error(\"Error removing wearer\", err);\n        setError(\n          err instanceof Error ? err.message : \"Failed to remove wearer\",\n        );\n        throw err;\n      }\n    },\n    [session, keyholderUserId],\n  );\n\n  const updateWearer = useCallback(\n    async (wearerId: string, updates: Partial<Wearer>) => {\n      try {\n        setError(null);\n        if (!session) return;\n        await updateWearerInSession(keyholderUserId, wearerId, updates);\n      } catch (err) {\n        logger.error(\"Error updating wearer\", err);\n        setError(\n          err instanceof Error ? err.message : \"Failed to update wearer\",\n        );\n        throw err;\n      }\n    },\n    [session, keyholderUserId],\n  );\n\n  const updateWearerPermissions = useCallback(\n    async (wearerId: string, permissions: Partial<KeyholderPermissions>) => {\n      const wearer = wearers.find((w) => w.id === wearerId);\n      if (!wearer) return;\n\n      const updatedPermissions = {\n        ...wearer.keyholderPermissions,\n        ...permissions,\n      };\n      await updateWearer(wearerId, {\n        keyholderPermissions: updatedPermissions,\n      });\n    },\n    [wearers, updateWearer],\n  );\n\n  const updateWearerSession = useCallback(\n    async (wearerId: string, sessionData: Partial<SessionData>) => {\n      const wearer = wearers.find((w) => w.id === wearerId);\n      if (!wearer) return;\n\n      const updatedSessionData = { ...wearer.sessionData, ...sessionData };\n      await updateWearer(wearerId, { sessionData: updatedSessionData });\n    },\n    [wearers, updateWearer],\n  );\n\n  const activateWearer = useCallback(\n    async (wearerId: string) => {\n      await updateWearer(wearerId, { isActive: true });\n    },\n    [updateWearer],\n  );\n\n  const deactivateWearer = useCallback(\n    async (wearerId: string) => {\n      await updateWearer(wearerId, { isActive: false });\n    },\n    [updateWearer],\n  );\n\n  return {\n    session,\n    wearers,\n    isLoading,\n    error,\n    createSession,\n    endSession,\n    addWearer,\n    removeWearer,\n    updateWearer,\n    updateWearerPermissions,\n    updateWearerSession,\n    activateWearer,\n    deactivateWearer,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/keyholder/useSessionControls.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionControls' has too many lines (104). Maximum allowed is 75.","line":39,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":152,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'extendCooldown' is not defined.","line":147,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'lockCooldown' is not defined.","line":148,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Controls Hook\n *\n * Extracts session control UI logic from SessionControls component.\n * Handles session time modifications and control permissions.\n */\n\nimport { useState, useCallback, useMemo as _useMemo } from \"react\";\n\nexport interface UseSessionControlsReturn {\n  // Actions\n  extendSession: (minutes: number) => Promise<void>;\n  reduceSession: (minutes: number) => Promise<void>;\n  lockSession: () => Promise<void>;\n  unlockSession: () => Promise<void>;\n  setLockTimer: (duration: number) => Promise<void>;\n\n  // Permissions\n  canExtend: boolean;\n  canReduce: boolean;\n  canLock: boolean;\n  canUnlock: boolean;\n\n  // State\n  isExtending: boolean;\n  isReducing: boolean;\n  isLocking: boolean;\n  isUnlocking: boolean;\n\n  // Cooldowns\n  extendCooldown: number | null;\n  lockCooldown: number | null;\n\n  // Error handling\n  error: Error | null;\n  clearError: () => void;\n}\n\nexport function useSessionControls(\n  _wearerId?: string,\n): UseSessionControlsReturn {\n  const [isExtending, setIsExtending] = useState(false);\n  const [isReducing, setIsReducing] = useState(false);\n  const [isLocking, setIsLocking] = useState(false);\n  const [isUnlocking, setIsUnlocking] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [_extendCooldown, _setExtendCooldown] = useState<number | null>(null);\n  const [_lockCooldown, _setLockCooldown] = useState<number | null>(null);\n\n  const extendSession = useCallback(async (_minutes: number): Promise<void> => {\n    setIsExtending(true);\n    setError(null);\n    try {\n      // Mock implementation\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to extend session\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsExtending(false);\n    }\n  }, []);\n\n  const reduceSession = useCallback(async (_minutes: number): Promise<void> => {\n    setIsReducing(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to reduce session\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsReducing(false);\n    }\n  }, []);\n\n  const lockSession = useCallback(async (): Promise<void> => {\n    setIsLocking(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to lock session\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsLocking(false);\n    }\n  }, []);\n\n  const unlockSession = useCallback(async (): Promise<void> => {\n    setIsUnlocking(true);\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to unlock session\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsUnlocking(false);\n    }\n  }, []);\n\n  const setLockTimer = useCallback(async (_duration: number): Promise<void> => {\n    setError(null);\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to set lock timer\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Permissions - would be calculated from actual session data\n  const canExtend = true;\n  const canReduce = true;\n  const canLock = true;\n  const canUnlock = true;\n\n  return {\n    extendSession,\n    reduceSession,\n    lockSession,\n    unlockSession,\n    setLockTimer,\n    canExtend,\n    canReduce,\n    canLock,\n    canUnlock,\n    isExtending,\n    isReducing,\n    isLocking,\n    isUnlocking,\n    extendCooldown,\n    lockCooldown,\n    error,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/mobile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/mobile/useHapticFeedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/mobile/usePullToRefresh.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (107). Maximum allowed is 75.","line":28,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":159,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pull to Refresh Hook\n * Provides pull-to-refresh functionality for mobile devices\n */\nimport { useCallback, useRef, useState, useEffect } from \"react\";\nimport type { React } from \"react\";\nimport { useHapticFeedback } from \"./useHapticFeedback\";\nimport { logger } from \"../../utils/logging\";\n\ninterface PullToRefreshOptions {\n  threshold?: number;\n  maxPullDistance?: number;\n  onRefresh: () => Promise<void> | void;\n  disabled?: boolean;\n}\n\ninterface PullToRefreshReturn {\n  isRefreshing: boolean;\n  isPulling: boolean;\n  pullDistance: number;\n  pullPercentage: number;\n  onTouchStart: (e: React.TouchEvent) => void;\n  onTouchMove: (e: React.TouchEvent) => void;\n  onTouchEnd: (e: React.TouchEvent) => void;\n  onScroll: (e: React.UIEvent) => void;\n}\n\nexport const usePullToRefresh = ({\n  threshold = 80,\n  maxPullDistance = 120,\n  onRefresh,\n  disabled = false,\n}: PullToRefreshOptions): PullToRefreshReturn => {\n  const { light: hapticLight, success: hapticSuccess } = useHapticFeedback();\n\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [isPulling, setIsPulling] = useState(false);\n  const [pullDistance, setPullDistance] = useState(0);\n  const [_scrollTop, setScrollTop] = useState(0);\n\n  const startY = useRef<number>(0);\n  const currentY = useRef<number>(0);\n  const isAtTop = useRef<boolean>(true);\n  const hasTriggeredHaptic = useRef<boolean>(false);\n\n  const pullPercentage = Math.min((pullDistance / threshold) * 100, 100);\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      if (disabled || isRefreshing) return;\n\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      startY.current = touch.clientY;\n      currentY.current = touch.clientY;\n      hasTriggeredHaptic.current = false;\n    },\n    [disabled, isRefreshing],\n  );\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent) => {\n      if (disabled || isRefreshing || !isAtTop.current) return;\n\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      currentY.current = touch.clientY;\n      const deltaY = currentY.current - startY.current;\n\n      if (deltaY > 0) {\n        // Pulling down\n        const distance = Math.min(deltaY * 0.5, maxPullDistance); // Apply resistance\n        setPullDistance(distance);\n        setIsPulling(distance > 10);\n\n        // Haptic feedback when threshold is reached\n        if (distance >= threshold && !hasTriggeredHaptic.current) {\n          hapticLight();\n          hasTriggeredHaptic.current = true;\n        }\n\n        // Prevent default scrolling when pulling\n        if (deltaY > 10) {\n          e.preventDefault();\n        }\n      } else {\n        setPullDistance(0);\n        setIsPulling(false);\n      }\n    },\n    [disabled, isRefreshing, threshold, maxPullDistance, hapticLight],\n  );\n\n  const handleTouchEnd = useCallback(async () => {\n    if (disabled || isRefreshing) return;\n\n    if (pullDistance >= threshold) {\n      setIsRefreshing(true);\n      hapticSuccess();\n\n      try {\n        await onRefresh();\n      } catch (error) {\n        logger.error(\"Pull to refresh failed\", { error }, \"usePullToRefresh\");\n      } finally {\n        setIsRefreshing(false);\n      }\n    }\n\n    setPullDistance(0);\n    setIsPulling(false);\n    hasTriggeredHaptic.current = false;\n  }, [\n    disabled,\n    isRefreshing,\n    pullDistance,\n    threshold,\n    onRefresh,\n    hapticSuccess,\n  ]);\n\n  const handleScroll = useCallback(\n    (e: React.UIEvent) => {\n      const target = e.currentTarget as HTMLElement;\n      const scrollTop = target.scrollTop;\n      setScrollTop(scrollTop);\n      isAtTop.current = scrollTop <= 0;\n\n      // Reset pull state when scrolling away from top\n      if (scrollTop > 0 && isPulling) {\n        setPullDistance(0);\n        setIsPulling(false);\n      }\n    },\n    [isPulling],\n  );\n\n  // Reset states when disabled changes\n  useEffect(() => {\n    if (disabled) {\n      setPullDistance(0);\n      setIsPulling(false);\n      setIsRefreshing(false);\n    }\n  }, [disabled]);\n\n  return {\n    isRefreshing,\n    isPulling,\n    pullDistance,\n    pullPercentage,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd,\n    onScroll: handleScroll,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/mobile/useTouchGestures.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (94). Maximum allowed is 75.","line":83,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":205,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Touch Gestures Hook\n * Provides swipe, tap, and other touch interactions for mobile devices\n */\nimport { useCallback, useRef, useState } from \"react\";\nimport type { React } from \"react\";\n\ninterface TouchPoint {\n  x: number;\n  y: number;\n  timestamp: number;\n}\n\ninterface SwipeOptions {\n  minDistance?: number;\n  maxTime?: number;\n  threshold?: number;\n}\n\ninterface UseTouchGesturesReturn {\n  onTouchStart: (e: React.TouchEvent) => void;\n  onTouchMove: (e: React.TouchEvent) => void;\n  onTouchEnd: (e: React.TouchEvent) => void;\n  isSwipeActive: boolean;\n}\n\ninterface TouchGestureHandlers {\n  onSwipeLeft?: () => void;\n  onSwipeRight?: () => void;\n  onSwipeUp?: () => void;\n  onSwipeDown?: () => void;\n  onTap?: () => void;\n  onLongPress?: () => void;\n}\n\n// Helper function to determine if a gesture is a tap\nconst isTapGesture = (\n  deltaX: number,\n  deltaY: number,\n  threshold: number,\n): boolean => {\n  return Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold;\n};\n\n// Helper function to determine swipe direction and trigger handler\nconst handleSwipeGesture = (\n  deltaX: number,\n  deltaY: number,\n  minDistance: number,\n  handlers: TouchGestureHandlers,\n): void => {\n  const absDeltaX = Math.abs(deltaX);\n  const absDeltaY = Math.abs(deltaY);\n\n  if (absDeltaX > absDeltaY && absDeltaX >= minDistance) {\n    // Horizontal swipe\n    if (deltaX > 0) {\n      handlers.onSwipeRight?.();\n    } else {\n      handlers.onSwipeLeft?.();\n    }\n  } else if (absDeltaY >= minDistance) {\n    // Vertical swipe\n    if (deltaY > 0) {\n      handlers.onSwipeDown?.();\n    } else {\n      handlers.onSwipeUp?.();\n    }\n  }\n};\n\n// Helper function to reset touch state\nconst resetTouchState = (\n  touchStart: React.MutableRefObject<TouchPoint | null>,\n  touchCurrent: React.MutableRefObject<TouchPoint | null>,\n  setIsSwipeActive: (active: boolean) => void,\n): void => {\n  touchStart.current = null;\n  touchCurrent.current = null;\n  setIsSwipeActive(false);\n};\n\nexport const useTouchGestures = (\n  handlers: TouchGestureHandlers,\n  options: SwipeOptions = {},\n): UseTouchGesturesReturn => {\n  const { minDistance = 50, maxTime = 1000, threshold = 30 } = options;\n\n  const touchStart = useRef<TouchPoint | null>(null);\n  const touchCurrent = useRef<TouchPoint | null>(null);\n  const longPressTimer = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const [isSwipeActive, setIsSwipeActive] = useState(false);\n\n  const clearLongPressTimer = useCallback(() => {\n    if (longPressTimer.current) {\n      clearTimeout(longPressTimer.current);\n      longPressTimer.current = null;\n    }\n  }, []);\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      const touchPoint: TouchPoint = {\n        x: touch.clientX,\n        y: touch.clientY,\n        timestamp: Date.now(),\n      };\n\n      touchStart.current = touchPoint;\n      touchCurrent.current = touchPoint;\n      setIsSwipeActive(false);\n\n      // Start long press timer\n      if (handlers.onLongPress) {\n        longPressTimer.current = setTimeout(() => {\n          handlers.onLongPress?.();\n        }, 500);\n      }\n\n      // Prevent default to avoid iOS bounce\n      if (e.cancelable) {\n        e.preventDefault();\n      }\n    },\n    [handlers],\n  );\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent) => {\n      const touch = e.touches[0];\n      if (!touch || !touchStart.current) return;\n\n      touchCurrent.current = {\n        x: touch.clientX,\n        y: touch.clientY,\n        timestamp: Date.now(),\n      };\n\n      const deltaX = Math.abs(touch.clientX - touchStart.current.x);\n      const deltaY = Math.abs(touch.clientY - touchStart.current.y);\n\n      // Clear long press if we've moved significantly\n      if (deltaX > threshold || deltaY > threshold) {\n        clearLongPressTimer();\n\n        // Set swipe active if we've moved enough\n        if (deltaX > minDistance || deltaY > minDistance) {\n          setIsSwipeActive(true);\n        }\n      }\n\n      // Prevent scrolling during horizontal swipes\n      if (deltaX > deltaY && deltaX > threshold) {\n        e.preventDefault();\n      }\n    },\n    [minDistance, threshold, clearLongPressTimer],\n  );\n\n  const handleTouchEnd = useCallback(\n    (_e: React.TouchEvent) => {\n      clearLongPressTimer();\n\n      if (!touchStart.current || !touchCurrent.current) {\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      const startPoint = touchStart.current;\n      const endPoint = touchCurrent.current;\n      const deltaTime = endPoint.timestamp - startPoint.timestamp;\n\n      // Check if gesture was too slow\n      if (deltaTime > maxTime) {\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      const deltaX = endPoint.x - startPoint.x;\n      const deltaY = endPoint.y - startPoint.y;\n\n      // Determine if it's a tap (small movement)\n      if (isTapGesture(deltaX, deltaY, threshold)) {\n        handlers.onTap?.();\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      // Handle swipe gestures\n      handleSwipeGesture(deltaX, deltaY, minDistance, handlers);\n      resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n    },\n    [handlers, maxTime, minDistance, threshold, clearLongPressTimer],\n  );\n\n  return {\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd,\n    isSwipeActive,\n  };\n};\n\n/**\n * Simplified swipe hook for common use cases\n */\nexport const useSwipeGestures = (\n  onSwipeLeft?: () => void,\n  onSwipeRight?: () => void,\n  options?: SwipeOptions,\n) => {\n  return useTouchGestures(\n    {\n      onSwipeLeft,\n      onSwipeRight,\n    },\n    options,\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/mobile/useViewport.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (94). Maximum allowed is 75.","line":32,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":146,"endColumn":2}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'updateSafeAreaInsets' and 'updateViewport'. Either include them or remove the dependency array.","line":124,"column":6,"nodeType":"ArrayExpression","endLine":124,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [updateSafeAreaInsets, updateViewport]","fix":{"range":[3158,3160],"text":"[updateSafeAreaInsets, updateViewport]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Viewport Hook\n * Provides viewport dimensions and mobile-specific viewport utilities\n */\nimport { useState, useEffect, useCallback } from \"react\";\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n  innerWidth: number;\n  innerHeight: number;\n}\n\ninterface ViewportInfo extends ViewportSize {\n  isMobile: boolean;\n  isTablet: boolean;\n  isDesktop: boolean;\n  isLandscape: boolean;\n  isPortrait: boolean;\n  safeAreaInsets: {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n  };\n}\n\n// Breakpoints\nconst MOBILE_BREAKPOINT = 768;\nconst TABLET_BREAKPOINT = 1024;\n\nexport const useViewport = (): ViewportInfo => {\n  const [viewport, setViewport] = useState<ViewportSize>(() => {\n    if (typeof window === \"undefined\") {\n      return {\n        width: 0,\n        height: 0,\n        innerWidth: 0,\n        innerHeight: 0,\n      };\n    }\n\n    return {\n      width: window.screen.width,\n      height: window.screen.height,\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight,\n    };\n  });\n\n  const [safeAreaInsets, setSafeAreaInsets] = useState({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  });\n\n  const updateViewport = useCallback(() => {\n    setViewport({\n      width: window.screen.width,\n      height: window.screen.height,\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight,\n    });\n  }, []);\n\n  const updateSafeAreaInsets = useCallback(() => {\n    if (typeof window === \"undefined\" || !window.getComputedStyle) return;\n\n    const computedStyle = window.getComputedStyle(document.documentElement);\n\n    setSafeAreaInsets({\n      top: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-top)\") || \"0\",\n      ),\n      bottom: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-bottom)\") || \"0\",\n      ),\n      left: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-left)\") || \"0\",\n      ),\n      right: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-right)\") || \"0\",\n      ),\n    });\n  }, []);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    updateViewport();\n    updateSafeAreaInsets();\n\n    // Handle resize events with throttling\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        updateViewport();\n        updateSafeAreaInsets();\n      }, 150);\n    };\n\n    // Handle orientation change\n    const handleOrientationChange = () => {\n      // Delay to account for viewport changes after orientation change\n      setTimeout(() => {\n        updateViewport();\n        updateSafeAreaInsets();\n      }, 500);\n    };\n\n    window.addEventListener(\"resize\", handleResize, { passive: true });\n    window.addEventListener(\"orientationchange\", handleOrientationChange, {\n      passive: true,\n    });\n\n    return () => {\n      clearTimeout(timeoutId);\n      window.removeEventListener(\"resize\", handleResize);\n      window.removeEventListener(\"orientationchange\", handleOrientationChange);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Determine device type based on viewport width\n  const isMobile = viewport.innerWidth < MOBILE_BREAKPOINT;\n  const isTablet =\n    viewport.innerWidth >= MOBILE_BREAKPOINT &&\n    viewport.innerWidth < TABLET_BREAKPOINT;\n  const isDesktop = viewport.innerWidth >= TABLET_BREAKPOINT;\n\n  // Determine orientation\n  const isLandscape = viewport.innerWidth > viewport.innerHeight;\n  const isPortrait = viewport.innerHeight >= viewport.innerWidth;\n\n  return {\n    ...viewport,\n    isMobile,\n    isTablet,\n    isDesktop,\n    isLandscape,\n    isPortrait,\n    safeAreaInsets,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/profile-achievements-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileAchievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfilePrivacy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileSharing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/usePublicProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/notification-operations.ts","messages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createNotificationFactory\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":30,"column":10,"nodeType":"Identifier","endLine":30,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createMarkAsReadFunction\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":106,"column":10,"nodeType":"Identifier","endLine":106,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createMarkAllAsReadFunction\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":127,"column":10,"nodeType":"Identifier","endLine":127,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createDismissNotificationFunction\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":153,"column":10,"nodeType":"Identifier","endLine":153,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createUpdatePreferencesFunction\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":175,"column":10,"nodeType":"Identifier","endLine":175,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createConvenienceNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":201,"column":23,"nodeType":"Identifier","endLine":201,"endColumn":34},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createConvenienceNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":213,"column":21,"nodeType":"Identifier","endLine":213,"endColumn":32},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createConvenienceNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":225,"column":23,"nodeType":"Identifier","endLine":225,"endColumn":34},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createConvenienceNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":237,"column":20,"nodeType":"Identifier","endLine":237,"endColumn":31},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":259,"column":30,"nodeType":"Identifier","endLine":259,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":272,"column":30,"nodeType":"Identifier","endLine":272,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":285,"column":32,"nodeType":"Identifier","endLine":285,"endColumn":43},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipNotificationFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":294,"column":37,"nodeType":"Identifier","endLine":294,"endColumn":48}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification operation helper functions\n */\nimport React, { useCallback } from \"react\";\nimport {\n  Notification,\n  NotificationState,\n  NotificationType,\n  NotificationPriority,\n  NotificationChannelType as _NotificationChannelType,\n  NotificationPreferences,\n} from \"../../types/realtime\";\nimport {\n  isInQuietHours,\n  deliverNotification,\n  saveNotification,\n  updateNotificationStatus,\n  updateMultipleNotificationStatus,\n  deleteNotification,\n  saveNotificationPreferences,\n} from \"./notification-utils\";\n\n// Helper function to create a new notification\nexport const createNotificationFactory = (\n  userId: string,\n  notificationState: NotificationState,\n  setNotificationState: React.Dispatch<React.SetStateAction<NotificationState>>,\n  maxNotifications: number,\n) => {\n  return useCallback(\n    async (\n      notification: Omit<\n        Notification,\n        \"id\" | \"timestamp\" | \"isRead\" | \"userId\"\n      >,\n    ): Promise<void> => {\n      const newNotification: Notification = {\n        ...notification,\n        id: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date(),\n        isRead: false,\n        userId,\n      };\n\n      // Check if notifications are enabled globally\n      if (!notificationState.preferences.globalEnabled) {\n        return;\n      }\n\n      // Check category preferences - using manual find for compatibility\n      let categoryPref = null;\n      for (\n        let i = 0;\n        i < notificationState.preferences.categories.length;\n        i++\n      ) {\n        if (\n          notificationState.preferences.categories[i].category ===\n          notification.type\n        ) {\n          categoryPref = notificationState.preferences.categories[i];\n          break;\n        }\n      }\n\n      if (!categoryPref?.enabled) {\n        return;\n      }\n\n      // Check quiet hours\n      if (isInQuietHours(notificationState.preferences.quietHours)) {\n        // Queue for later delivery if not urgent\n        if (notification.priority !== NotificationPriority.URGENT) {\n          return;\n        }\n      }\n\n      // Add to state\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: [\n          newNotification,\n          ...prev.notifications.slice(0, maxNotifications - 1),\n        ],\n      }));\n\n      // Deliver through enabled channels\n      await deliverNotification(newNotification, categoryPref.channels);\n\n      // Save to backend\n      await saveNotification(newNotification);\n    },\n    [\n      userId,\n      notificationState.preferences,\n      maxNotifications,\n      setNotificationState,\n    ],\n  );\n};\n\n// Helper function to create mark as read function\nexport const createMarkAsReadFunction = (\n  setNotificationState: React.Dispatch<React.SetStateAction<NotificationState>>,\n) => {\n  return useCallback(\n    async (notificationId: string): Promise<void> => {\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: prev.notifications.map((notif) =>\n          notif.id === notificationId ? { ...notif, isRead: true } : notif,\n        ),\n      }));\n\n      // Update in backend\n      await updateNotificationStatus(notificationId, { isRead: true });\n    },\n    [setNotificationState],\n  );\n};\n\n// Helper function to create mark all as read function\nexport const createMarkAllAsReadFunction = (\n  notificationState: NotificationState,\n  setNotificationState: React.Dispatch<React.SetStateAction<NotificationState>>,\n) => {\n  return useCallback(async (): Promise<void> => {\n    const unreadIds: string[] = [];\n    for (let i = 0; i < notificationState.notifications.length; i++) {\n      const notif = notificationState.notifications[i];\n      if (!notif.isRead) {\n        unreadIds.push(notif.id);\n      }\n    }\n\n    setNotificationState((prev) => ({\n      ...prev,\n      notifications: prev.notifications.map((notif) => ({\n        ...notif,\n        isRead: true,\n      })),\n    }));\n\n    // Update in backend\n    await updateMultipleNotificationStatus(unreadIds, { isRead: true });\n  }, [notificationState.notifications, setNotificationState]);\n};\n\n// Helper function to create dismiss notification function\nexport const createDismissNotificationFunction = (\n  setNotificationState: React.Dispatch<React.SetStateAction<NotificationState>>,\n) => {\n  return useCallback(\n    async (notificationId: string): Promise<void> => {\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: prev.notifications.filter(\n          (notif) => notif.id !== notificationId,\n        ),\n      }));\n\n      // Remove from backend\n      await deleteNotification(notificationId);\n    },\n    [setNotificationState],\n  );\n};\n\n// Helper function to create preferences update function\nexport const createUpdatePreferencesFunction = (\n  userId: string,\n  notificationState: NotificationState,\n  setNotificationState: React.Dispatch<React.SetStateAction<NotificationState>>,\n) => {\n  return useCallback(\n    async (prefs: Partial<NotificationPreferences>): Promise<void> => {\n      const updatedPreferences = {\n        ...notificationState.preferences,\n        ...prefs,\n      };\n\n      setNotificationState((prev) => ({\n        ...prev,\n        preferences: updatedPreferences,\n        deliveryChannels: updatedPreferences.channels,\n      }));\n\n      // Save to backend\n      await saveNotificationPreferences(userId, updatedPreferences);\n    },\n    [userId, notificationState.preferences, setNotificationState],\n  );\n};\n\n// Helper function to create convenience notification functions\nexport const createConvenienceNotificationFunctions = (\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\" | \"isRead\" | \"userId\">,\n  ) => Promise<void>,\n) => {\n  const showSuccess = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.SUCCESS,\n        title,\n        message,\n        priority: NotificationPriority.LOW,\n      });\n    },\n    [addNotification],\n  );\n\n  const showError = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.ERROR,\n        title,\n        message,\n        priority: NotificationPriority.HIGH,\n      });\n    },\n    [addNotification],\n  );\n\n  const showWarning = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.WARNING,\n        title,\n        message,\n        priority: NotificationPriority.MEDIUM,\n      });\n    },\n    [addNotification],\n  );\n\n  const showInfo = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.INFO,\n        title,\n        message,\n        priority: NotificationPriority.LOW,\n      });\n    },\n    [addNotification],\n  );\n\n  return { showSuccess, showError, showWarning, showInfo };\n};\n\n// Helper function to create relationship-specific notification functions\nexport const createRelationshipNotificationFunctions = (\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\" | \"isRead\" | \"userId\">,\n  ) => Promise<void>,\n  relationshipId?: string,\n) => {\n  const notifyTaskAssigned = useCallback(\n    (taskTitle: string, keyholderName: string) => {\n      return addNotification({\n        type: NotificationType.TASK_ASSIGNED,\n        title: \"New Task Assigned\",\n        message: `${keyholderName} has assigned you: ${taskTitle}`,\n        priority: NotificationPriority.MEDIUM,\n        relationshipId,\n      });\n    },\n    [addNotification, relationshipId],\n  );\n\n  const notifyTaskApproved = useCallback(\n    (taskTitle: string) => {\n      return addNotification({\n        type: NotificationType.TASK_APPROVED,\n        title: \"Task Approved\",\n        message: `Your task \"${taskTitle}\" has been approved`,\n        priority: NotificationPriority.LOW,\n        relationshipId,\n      });\n    },\n    [addNotification, relationshipId],\n  );\n\n  const notifySessionStarted = useCallback(() => {\n    return addNotification({\n      type: NotificationType.SESSION_STARTED,\n      title: \"Chastity Session Started\",\n      message: \"Your chastity session has begun\",\n      priority: NotificationPriority.MEDIUM,\n    });\n  }, [addNotification]);\n\n  const notifyRelationshipRequest = useCallback(\n    (requesterName: string) => {\n      return addNotification({\n        type: NotificationType.RELATIONSHIP_REQUEST,\n        title: \"Relationship Request\",\n        message: `${requesterName} wants to establish a keyholder relationship with you`,\n        priority: NotificationPriority.HIGH,\n        actionUrl: \"/relationships\",\n        actionText: \"View Request\",\n      });\n    },\n    [addNotification],\n  );\n\n  return {\n    notifyTaskAssigned,\n    notifyTaskApproved,\n    notifySessionStarted,\n    notifyRelationshipRequest,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/notification-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/presence-operations.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (93). Maximum allowed is 75.","line":19,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":123,"endColumn":2},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":24,"column":29,"nodeType":"Identifier","endLine":24,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":52,"column":21,"nodeType":"Identifier","endLine":52,"endColumn":32},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":59,"column":22,"nodeType":"Identifier","endLine":59,"endColumn":33},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":66,"column":19,"nodeType":"Identifier","endLine":66,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":73,"column":19,"nodeType":"Identifier","endLine":73,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":80,"column":24,"nodeType":"Identifier","endLine":80,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createPresenceUpdateFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":103,"column":26,"nodeType":"Identifier","endLine":103,"endColumn":37},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createSubscriptionFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":129,"column":31,"nodeType":"Identifier","endLine":129,"endColumn":42},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":185,"column":27,"nodeType":"Identifier","endLine":185,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":192,"column":35,"nodeType":"Identifier","endLine":192,"endColumn":46},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":206,"column":24,"nodeType":"Identifier","endLine":206,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":214,"column":27,"nodeType":"Identifier","endLine":214,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":225,"column":26,"nodeType":"Identifier","endLine":225,"endColumn":37}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Presence operation helper functions\n */\nimport React, { useCallback } from \"react\";\nimport {\n  PresenceState,\n  UserPresence,\n  PresenceStatus,\n  ActivityContext,\n  PresenceSubscription,\n} from \"../../types/realtime\";\nimport {\n  createPresenceUpdate,\n  sendPresenceUpdate,\n  fetchUserPresences,\n} from \"./presence-utils\";\n\n// Helper function to create presence update functions\nexport const createPresenceUpdateFunctions = (\n  userId: string,\n  presenceState: PresenceState,\n  setPresenceState: React.Dispatch<React.SetStateAction<PresenceState>>,\n) => {\n  const updateOwnPresence = useCallback(\n    async (\n      status: PresenceStatus,\n      customMessage?: string,\n      currentActivity?: ActivityContext,\n    ): Promise<void> => {\n      const updatedPresence = createPresenceUpdate(\n        presenceState.ownPresence,\n        status,\n        customMessage,\n        currentActivity,\n      );\n\n      setPresenceState((prev) => ({\n        ...prev,\n        ownPresence: updatedPresence,\n        userPresences: {\n          ...prev.userPresences,\n          [userId]: updatedPresence,\n        },\n      }));\n\n      // Send presence update to backend/WebSocket\n      await sendPresenceUpdate(updatedPresence);\n    },\n    [userId, presenceState.ownPresence, setPresenceState],\n  );\n\n  const setOnline = useCallback(\n    (customMessage?: string) => {\n      return updateOwnPresence(PresenceStatus.ONLINE, customMessage);\n    },\n    [updateOwnPresence],\n  );\n\n  const setOffline = useCallback(\n    (customMessage?: string) => {\n      return updateOwnPresence(PresenceStatus.OFFLINE, customMessage);\n    },\n    [updateOwnPresence],\n  );\n\n  const setAway = useCallback(\n    (customMessage?: string) => {\n      return updateOwnPresence(PresenceStatus.AWAY, customMessage);\n    },\n    [updateOwnPresence],\n  );\n\n  const setBusy = useCallback(\n    (customMessage?: string) => {\n      return updateOwnPresence(PresenceStatus.BUSY, customMessage);\n    },\n    [updateOwnPresence],\n  );\n\n  const setInSession = useCallback(\n    (sessionStartTime?: Date) => {\n      const presence: UserPresence = {\n        ...presenceState.ownPresence,\n        status: PresenceStatus.IN_SESSION,\n        isInChastitySession: true,\n        sessionStartTime: sessionStartTime || new Date(),\n      };\n\n      setPresenceState((prev) => ({\n        ...prev,\n        ownPresence: presence,\n        userPresences: {\n          ...prev.userPresences,\n          [userId]: presence,\n        },\n      }));\n\n      return sendPresenceUpdate(presence);\n    },\n    [userId, presenceState.ownPresence, setPresenceState],\n  );\n\n  const updateActivity = useCallback(\n    (activity: ActivityContext) => {\n      return updateOwnPresence(\n        presenceState.ownPresence.status,\n        presenceState.ownPresence.customMessage,\n        activity,\n      );\n    },\n    [presenceState.ownPresence, updateOwnPresence],\n  );\n\n  return {\n    updateOwnPresence,\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivity,\n  };\n};\n\n// Helper function to create subscription functions\nexport const createSubscriptionFunctions = (\n  setPresenceState: React.Dispatch<React.SetStateAction<PresenceState>>,\n) => {\n  const subscribeToPresence = useCallback(\n    (\n      userIds: string[],\n      callback: (presences: UserPresence[]) => void,\n    ): PresenceSubscription => {\n      const subscription: PresenceSubscription = {\n        userIds,\n        callback,\n        isActive: true,\n      };\n\n      setPresenceState((prev) => ({\n        ...prev,\n        subscriptions: [...prev.subscriptions, subscription],\n      }));\n\n      // Fetch initial presence data\n      fetchUserPresences(userIds).then((presences) => {\n        const presenceMap: Record<string, UserPresence> = {};\n        for (let i = 0; i < presences.length; i++) {\n          const presence = presences[i];\n          presenceMap[presence.userId] = presence;\n        }\n\n        setPresenceState((prev) => ({\n          ...prev,\n          userPresences: {\n            ...prev.userPresences,\n            ...presenceMap,\n          },\n        }));\n\n        callback(presences);\n      });\n\n      // Return unsubscribe function\n      return {\n        ...subscription,\n        unsubscribe: () => {\n          setPresenceState((prev) => ({\n            ...prev,\n            subscriptions: prev.subscriptions.filter(\n              (sub) => sub !== subscription,\n            ),\n          }));\n        },\n      } as PresenceSubscription & { unsubscribe: () => void };\n    },\n    [setPresenceState],\n  );\n\n  return { subscribeToPresence };\n};\n\n// Helper function to create query functions\nexport const createQueryFunctions = (presenceState: PresenceState) => {\n  const getUserPresence = useCallback(\n    (targetUserId: string): UserPresence | null => {\n      return presenceState.userPresences[targetUserId] || null;\n    },\n    [presenceState.userPresences],\n  );\n\n  const getMultipleUserPresence = useCallback(\n    (userIds: string[]): UserPresence[] => {\n      const result: UserPresence[] = [];\n      for (let i = 0; i < userIds.length; i++) {\n        const presence = presenceState.userPresences[userIds[i]];\n        if (presence) {\n          result.push(presence);\n        }\n      }\n      return result;\n    },\n    [presenceState.userPresences],\n  );\n\n  const isUserOnline = useCallback(\n    (targetUserId: string): boolean => {\n      const presence = getUserPresence(targetUserId);\n      return presence?.status === PresenceStatus.ONLINE;\n    },\n    [getUserPresence],\n  );\n\n  const isUserInSession = useCallback(\n    (targetUserId: string): boolean => {\n      const presence = getUserPresence(targetUserId);\n      return (\n        presence?.status === PresenceStatus.IN_SESSION ||\n        presence?.isInChastitySession === true\n      );\n    },\n    [getUserPresence],\n  );\n\n  const getOnlineCount = useCallback(\n    (userIds: string[]): number => {\n      let count = 0;\n      for (let i = 0; i < userIds.length; i++) {\n        const presence = presenceState.userPresences[userIds[i]];\n        if (\n          presence &&\n          [\n            PresenceStatus.ONLINE,\n            PresenceStatus.BUSY,\n            PresenceStatus.IN_SESSION,\n          ].indexOf(presence.status) !== -1\n        ) {\n          count++;\n        }\n      }\n      return count;\n    },\n    [presenceState.userPresences],\n  );\n\n  return {\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n  };\n};\n\n// Helper function to calculate computed values\nexport const calculatePresenceComputedValues = (\n  userPresences: Record<string, UserPresence>,\n  lastActivity: Date,\n  activityTimeout: number,\n) => {\n  const totalUsers = Object.keys(userPresences).length;\n\n  let onlineUsers = 0;\n  let inSessionUsers = 0;\n\n  const userPresenceValues = Object.keys(userPresences).map(\n    (key) => userPresences[key],\n  );\n\n  for (let i = 0; i < userPresenceValues.length; i++) {\n    const p = userPresenceValues[i];\n    if (\n      [\n        PresenceStatus.ONLINE,\n        PresenceStatus.BUSY,\n        PresenceStatus.IN_SESSION,\n      ].indexOf(p.status) !== -1\n    ) {\n      onlineUsers++;\n    }\n\n    if (p.status === PresenceStatus.IN_SESSION || p.isInChastitySession) {\n      inSessionUsers++;\n    }\n  }\n\n  const isActive = Date.now() - lastActivity.getTime() < activityTimeout;\n\n  return {\n    totalUsers,\n    onlineUsers,\n    inSessionUsers,\n    lastActivity,\n    isActive,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/presence-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/realtime-sync-operations.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (210). Maximum allowed is 75.","line":24,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":293,"endColumn":2},{"ruleId":"max-params","severity":1,"message":"Arrow function has too many parameters (11). Maximum allowed is 5.","line":40,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":40,"endColumn":5},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":41,"column":19,"nodeType":"Identifier","endLine":41,"endColumn":30},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":120,"column":22,"nodeType":"Identifier","endLine":120,"endColumn":33},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":136,"column":28,"nodeType":"Identifier","endLine":136,"endColumn":39},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":155,"column":26,"nodeType":"Identifier","endLine":155,"endColumn":37},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":171,"column":25,"nodeType":"Identifier","endLine":171,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":180,"column":23,"nodeType":"Identifier","endLine":180,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'success' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":183,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":183,"endColumn":20},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":195,"column":25,"nodeType":"Identifier","endLine":195,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":227,"column":31,"nodeType":"Identifier","endLine":227,"endColumn":42},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":242,"column":29,"nodeType":"Identifier","endLine":242,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createWebSocketFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":254,"column":32,"nodeType":"Identifier","endLine":254,"endColumn":43},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createChannelFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":300,"column":23,"nodeType":"Identifier","endLine":300,"endColumn":34},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createChannelFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":311,"column":24,"nodeType":"Identifier","endLine":311,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createChannelFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":322,"column":25,"nodeType":"Identifier","endLine":322,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRealtimeSubscriptionFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":348,"column":30,"nodeType":"Identifier","endLine":348,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRealtimeSubscriptionFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":373,"column":25,"nodeType":"Identifier","endLine":373,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipSyncFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":390,"column":29,"nodeType":"Identifier","endLine":390,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createRelationshipSyncFunctions\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":398,"column":27,"nodeType":"Identifier","endLine":398,"endColumn":38}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'attemptReconnect', 'connectionStartTimeRef', 'handleMessage', 'reconnectAttemptsRef', 'setSyncState', 'startHeartbeat', 'stopHeartbeat', and 'wsRef'. Either include them or remove the dependency array. If 'setSyncState' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":118,"column":6,"nodeType":"ArrayExpression","endLine":118,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [wsRef, setSyncState, userId, connectionStartTimeRef, reconnectAttemptsRef, startHeartbeat, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]","fix":{"range":[3421,3451],"text":"[wsRef, setSyncState, userId, connectionStartTimeRef, reconnectAttemptsRef, startHeartbeat, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'reconnectTimeoutRef' and 'wsRef'. Either include them or remove the dependency array.","line":134,"column":6,"nodeType":"ArrayExpression","endLine":134,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [reconnectTimeoutRef, stopHeartbeat, wsRef]","fix":{"range":[3890,3905],"text":"[reconnectTimeoutRef, stopHeartbeat, wsRef]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'reconnectAttemptsRef' and 'reconnectTimeoutRef'. Either include them or remove the dependency array.","line":153,"column":6,"nodeType":"ArrayExpression","endLine":153,"endColumn":70,"suggestions":[{"desc":"Update the dependencies array to be: [connect, maxReconnectAttempts, reconnectAttemptsRef, reconnectInterval, reconnectTimeoutRef, setSyncState]","fix":{"range":[4402,4466],"text":"[connect, maxReconnectAttempts, reconnectAttemptsRef, reconnectInterval, reconnectTimeoutRef, setSyncState]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'heartbeatTimeoutRef' and 'wsRef'. Either include them or remove the dependency array.","line":169,"column":6,"nodeType":"ArrayExpression","endLine":169,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [heartbeatInterval, heartbeatTimeoutRef, sendMessage, wsRef]","fix":{"range":[5016,5048],"text":"[heartbeatInterval, heartbeatTimeoutRef, sendMessage, wsRef]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'heartbeatTimeoutRef'. Either include it or remove the dependency array.","line":178,"column":6,"nodeType":"ArrayExpression","endLine":178,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [heartbeatTimeoutRef]","fix":{"range":[5349,5351],"text":"[heartbeatTimeoutRef]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'wsRef'. Either include it or remove the dependency array.","line":192,"column":5,"nodeType":"ArrayExpression","endLine":192,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [setSyncState, wsRef]","fix":{"range":[5801,5815],"text":"[setSyncState, wsRef]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'subscriptionsRef'. Either include it or remove the dependency array.","line":283,"column":5,"nodeType":"ArrayExpression","endLine":283,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [setSyncState, subscriptionsRef]","fix":{"range":[8239,8253],"text":"[setSyncState, subscriptionsRef]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'subscriptionsRef'. Either include it or remove the dependency array.","line":370,"column":5,"nodeType":"ArrayExpression","endLine":370,"endColumn":7,"suggestions":[{"desc":"Update the dependencies array to be: [subscriptionsRef]","fix":{"range":[10384,10386],"text":"[subscriptionsRef]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":17,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Realtime sync operation helper functions\n */\nimport React, { useCallback } from \"react\";\nimport {\n  RealtimeSyncState,\n  ConnectionStatus,\n  SyncChannel,\n  ChannelType,\n  RealtimeUpdate,\n  Subscription,\n} from \"../../types/realtime\";\nimport {\n  createWebSocketUrl,\n  createSyncChannel,\n  sendWebSocketMessage,\n  updateSyncMetrics,\n  shouldAttemptReconnection,\n  createSubscription,\n  notifySubscribers as _notifySubscribers,\n} from \"./realtimeSyncHelpers\";\n\n// Helper function to create WebSocket connection functions\nexport const createWebSocketFunctions = (\n  userId: string,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n  reconnectAttemptsRef: React.MutableRefObject<number>,\n  reconnectTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  heartbeatTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  connectionStartTimeRef: React.MutableRefObject<Date | null>,\n  maxReconnectAttempts: number,\n  reconnectInterval: number,\n  heartbeatInterval: number,\n) => {\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTING,\n    }));\n\n    try {\n      const wsUrl = createWebSocketUrl(userId);\n      wsRef.current = new WebSocket(wsUrl);\n      connectionStartTimeRef.current = new Date();\n\n      wsRef.current.onopen = () => {\n        // WebSocket connected\n        reconnectAttemptsRef.current = 0;\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.CONNECTED,\n        }));\n\n        // Start heartbeat\n        startHeartbeat();\n\n        // Rejoin previous channels\n        // Implementation would go here\n      };\n\n      wsRef.current.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          handleMessage(message);\n        } catch {\n          // Failed to parse WebSocket message\n        }\n      };\n\n      wsRef.current.onclose = (event) => {\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.DISCONNECTED,\n        }));\n\n        stopHeartbeat();\n\n        if (\n          shouldAttemptReconnection(\n            event,\n            reconnectAttemptsRef.current,\n            maxReconnectAttempts,\n          )\n        ) {\n          attemptReconnect();\n        }\n      };\n\n      wsRef.current.onerror = (_error) => {\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.ERROR,\n          syncMetrics: updateSyncMetrics(prev.syncMetrics, \"error\"),\n        }));\n      };\n    } catch {\n      setSyncState((prev) => ({\n        ...prev,\n        connectionStatus: ConnectionStatus.ERROR,\n      }));\n    }\n    // Refs (wsRef, reconnectAttemptsRef, connectionStartTimeRef, heartbeatTimeoutRef, reconnectTimeoutRef)\n    // are stable and don't trigger re-renders. Functions (attemptReconnect, handleMessage, startHeartbeat,\n    // stopHeartbeat) are defined later and create circular dependencies. All should be wrapped in useCallback\n    // with proper dependencies to avoid stale closures.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, maxReconnectAttempts]);\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Intentional disconnect\");\n      wsRef.current = null;\n    }\n\n    stopHeartbeat();\n\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [stopHeartbeat]);\n\n  const attemptReconnect = useCallback(() => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      return;\n    }\n\n    reconnectAttemptsRef.current++;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.RECONNECTING,\n    }));\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, reconnectInterval);\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [connect, maxReconnectAttempts, reconnectInterval, setSyncState]);\n\n  const startHeartbeat = useCallback(() => {\n    const sendHeartbeat = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({ type: \"heartbeat\", timestamp: new Date().toISOString() });\n        heartbeatTimeoutRef.current = setTimeout(\n          sendHeartbeat,\n          heartbeatInterval,\n        );\n      }\n    };\n\n    heartbeatTimeoutRef.current = setTimeout(sendHeartbeat, heartbeatInterval);\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [heartbeatInterval, sendMessage]);\n\n  const stopHeartbeat = useCallback(() => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const sendMessage = useCallback(\n\n    (message: RealtimeUpdate | Record<string, unknown>) => {\n      const success = sendWebSocketMessage(wsRef.current, message, () => {\n        setSyncState((prev) => ({\n          ...prev,\n          syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageSent\"),\n        }));\n      });\n    },\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [setSyncState],\n  );\n\n  const handleMessage = useCallback(\n    (message: Record<string, unknown>) => {\n      setSyncState((prev) => ({\n        ...prev,\n        syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageReceived\"),\n      }));\n\n      switch (message.type) {\n        case \"channel_joined\":\n          handleChannelJoined(message);\n          break;\n        case \"channel_left\":\n          handleChannelLeft(message);\n          break;\n        case \"realtime_update\":\n          handleRealtimeUpdate(message);\n          break;\n        case \"heartbeat_ack\":\n          // Heartbeat acknowledged\n          break;\n        default:\n        // Unknown message type\n      }\n    },\n    [\n      setSyncState,\n      handleChannelJoined,\n      handleChannelLeft,\n      handleRealtimeUpdate,\n    ],\n  );\n\n  const handleChannelJoined = useCallback(\n    (message: { channel: SyncChannel }) => {\n      const channel: SyncChannel = message.channel;\n\n      setSyncState((prev) => ({\n        ...prev,\n        activeChannels: [\n          ...prev.activeChannels.filter((c) => c.id !== channel.id),\n          channel,\n        ],\n      }));\n    },\n    [setSyncState],\n  );\n\n  const handleChannelLeft = useCallback(\n    (message: { channelId: string }) => {\n      const channelId = message.channelId;\n\n      setSyncState((prev) => ({\n        ...prev,\n        activeChannels: prev.activeChannels.filter((c) => c.id !== channelId),\n      }));\n    },\n    [setSyncState],\n  );\n\n  const handleRealtimeUpdate = useCallback(\n    (message: { update: RealtimeUpdate }) => {\n      const update: RealtimeUpdate = message.update;\n\n      // Update local data\n      setSyncState((prev) => ({\n        ...prev,\n        realtimeData: {\n          ...prev.realtimeData,\n          [update.type]: update.data,\n        },\n      }));\n\n      // Notify subscribers - using object instead of Map\n      const subscriptionKeys = Object.keys(subscriptionsRef.current);\n      for (let i = 0; i < subscriptionKeys.length; i++) {\n        const key = subscriptionKeys[i];\n        const subscription = subscriptionsRef.current[key];\n        if (subscription.dataType === update.type && subscription.isActive) {\n          try {\n            subscription.callback(update);\n          } catch {\n            // Error in subscription callback\n          }\n        }\n      }\n    },\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [setSyncState],\n  );\n\n  return {\n    connect,\n    disconnect,\n    sendMessage,\n    startHeartbeat,\n    stopHeartbeat,\n  };\n};\n\n// Helper function to create channel management functions\nexport const createChannelFunctions = (\n  userId: string,\n  sendMessage: (message: RealtimeUpdate | Record<string, unknown>) => void,\n) => {\n  const joinChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      sendMessage({\n        type: \"join_channel\",\n        channelId,\n        userId,\n      });\n    },\n    [userId, sendMessage],\n  );\n\n  const leaveChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      sendMessage({\n        type: \"leave_channel\",\n        channelId,\n        userId,\n      });\n    },\n    [userId, sendMessage],\n  );\n\n  const createChannel = useCallback(\n    async (type: ChannelType, participants: string[]): Promise<SyncChannel> => {\n      const channel = createSyncChannel(type, userId, participants);\n\n      sendMessage({\n        type: \"create_channel\",\n        channel,\n        userId,\n      });\n\n      return channel;\n    },\n    [userId, sendMessage],\n  );\n\n  return {\n    joinChannel,\n    leaveChannel,\n    createChannel,\n  };\n};\n\n// Helper function to create subscription functions\nexport const createRealtimeSubscriptionFunctions = (\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n) => {\n  const subscribeToUpdates = useCallback(\n    (\n      dataType: string,\n      callback: (update: RealtimeUpdate) => void,\n    ): Subscription => {\n      const subscription = createSubscription(dataType, callback);\n      subscriptionsRef.current[subscription.id] = subscription;\n\n      // Return unsubscribe function\n      return {\n        ...subscription,\n        unsubscribe: () => {\n          const sub = subscriptionsRef.current[subscription.id];\n          if (sub) {\n            sub.isActive = false;\n            delete subscriptionsRef.current[subscription.id];\n          }\n        },\n      } as Subscription & { unsubscribe: () => void };\n    },\n    // Refs are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n\n  const publishUpdate = useCallback(\n    async (_update: RealtimeUpdate): Promise<void> => {\n      // Implementation would send the update via WebSocket\n    },\n    [],\n  );\n\n  return {\n    subscribeToUpdates,\n    publishUpdate,\n  };\n};\n\n// Helper function to create relationship sync functions\nexport const createRelationshipSyncFunctions = (\n  joinChannel: (channelId: string) => Promise<void>,\n) => {\n  const syncWithKeyholder = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      const channelId = `relationship_${relationshipId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  const syncSessionData = useCallback(\n    async (sessionId: string): Promise<void> => {\n      const channelId = `session_${sessionId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  return {\n    syncWithKeyholder,\n    syncSessionData,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/realtime-sync-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/timer-operations.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":58,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":58,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":38},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":59,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":59,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timer operation helper functions\n */\nimport {\n  LiveTimer,\n  TimerStatus,\n  LiveTimerState,\n  TimerSubscription,\n} from \"../../types/realtime\";\n\n// Helper function to validate timer permissions\nexport const validateTimerPermissions = (\n  timer: LiveTimer,\n  userId: string,\n  operation: string,\n): void => {\n  if (timer.isKeyholderControlled && timer.keyholderUserId !== userId) {\n    throw new Error(`Only the keyholder can ${operation} this timer`);\n  }\n};\n\n// Helper function to update timer in state\nexport const updateTimerInState = (\n  timers: LiveTimer[],\n  timerId: string,\n  updates: Partial<LiveTimer>,\n): LiveTimer[] => {\n  return timers.map((t) => (t.id === timerId ? { ...t, ...updates } : t));\n};\n\n// Helper function to calculate timer progress\nexport const calculateTimerProgress = (\n  timer: LiveTimer,\n  now: Date,\n): Partial<LiveTimer> => {\n  if (timer.status !== TimerStatus.RUNNING) {\n    return {};\n  }\n\n  const actualElapsed = Math.floor(\n    (now.getTime() - timer.startTime.getTime() - timer.totalPauseTime) / 1000,\n  );\n  const remaining = Math.max(0, timer.duration - actualElapsed);\n\n  return {\n    currentTime: now,\n    elapsed: actualElapsed,\n    remaining,\n    status: remaining <= 0 ? TimerStatus.COMPLETED : timer.status,\n  };\n};\n\n// Helper function to create timer subscription\nexport const createTimerSubscription = (\n  timerId: string,\n  callback: (timer: LiveTimer) => void,\n  events: string[] = [\"start\", \"pause\", \"resume\", \"stop\", \"update\"],\n  setTimerState: React.Dispatch<React.SetStateAction<LiveTimerState>>,\n  subscriptionsRef: React.MutableRefObject<Map<string, TimerSubscription>>,\n): TimerSubscription => {\n  const subscription: TimerSubscription = {\n    timerId,\n    callback,\n    events,\n    isActive: true,\n  };\n\n  const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  subscriptionsRef.current.set(subscriptionId, subscription);\n\n  setTimerState((prev) => ({\n    ...prev,\n    subscriptions: [...prev.subscriptions, subscription],\n  }));\n\n  return {\n    ...subscription,\n    unsubscribe: () => {\n      subscriptionsRef.current.delete(subscriptionId);\n      setTimerState((prev) => ({\n        ...prev,\n        subscriptions: prev.subscriptions.filter((sub) => sub !== subscription),\n      }));\n    },\n  } as TimerSubscription & { unsubscribe: () => void };\n};\n\n// Helper function to calculate computed values\nexport const calculateComputedValues = (activeTimers: LiveTimer[]) => {\n  const runningCount = activeTimers.filter(\n    (t) => t.status === TimerStatus.RUNNING,\n  ).length;\n  const pausedCount = activeTimers.filter(\n    (t) => t.status === TimerStatus.PAUSED,\n  ).length;\n  const completedCount = activeTimers.filter(\n    (t) => t.status === TimerStatus.COMPLETED,\n  ).length;\n\n  const totalActiveTime = activeTimers\n    .filter((t) => t.status === TimerStatus.RUNNING)\n    .reduce((total, timer) => total + timer.elapsed, 0);\n\n  const longestRunningTimer =\n    activeTimers\n      .filter((t) => t.status === TimerStatus.RUNNING)\n      .sort((a, b) => b.elapsed - a.elapsed)[0] || null;\n\n  return {\n    runningCount,\n    pausedCount,\n    completedCount,\n    totalActiveTime,\n    longestRunningTimer,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/useLiveTimer.ts","messages":[{"ruleId":"max-params","severity":1,"message":"Arrow function has too many parameters (6). Maximum allowed is 5.","line":61,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":61,"endColumn":16},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (357). Maximum allowed is 75.","line":88,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":541,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":105,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":105,"endColumn":42},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":106,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":106,"endColumn":40},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateTimerProgress'. Either include it or remove the dependency array.","line":495,"column":6,"nodeType":"ArrayExpression","endLine":495,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [syncInterval, updateTimerProgress]","fix":{"range":[13199,13213],"text":"[syncInterval, updateTimerProgress]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'syncActiveTimers'. Either include it or remove the dependency array.","line":509,"column":6,"nodeType":"ArrayExpression","endLine":509,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [syncActiveTimers, syncInterval]","fix":{"range":[13674,13688],"text":"[syncActiveTimers, syncInterval]"}}]}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":495,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":495,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":509,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":509,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useLiveTimer - Live Timer Synchronization Hook\n *\n * Synchronized timer updates across all devices and users with real-time progress\n * sharing and keyholder monitoring.\n */\nimport { useState, useEffect, useCallback, useRef, useMemo } from \"react\";\nimport {\n  LiveTimerState,\n  LiveTimer,\n  TimerType,\n  TimerStatus,\n  TimerSync,\n  TimerEvent,\n  TimerSubscription,\n} from \"../../types/realtime\";\nimport {\n  validateTimerPermissions,\n  updateTimerInState,\n  calculateTimerProgress,\n  createTimerSubscription,\n  calculateComputedValues,\n} from \"./timer-operations\";\n\ninterface UseLiveTimerOptions {\n  userId: string;\n  relationshipId?: string;\n  syncInterval?: number; // milliseconds\n  accuracyThreshold?: number; // milliseconds\n}\n\n// Helper function to create timer sync record\nconst createTimerSync = async (timerId: string): Promise<TimerSync> => {\n  const now = new Date();\n  return {\n    timerId,\n    lastSync: now,\n    serverTime: await getServerTime(),\n    clientOffset: 0,\n    syncAccuracy: 1.0,\n  };\n};\n\n// Helper function to create new timer\nconst createNewTimer = (\n  userId: string,\n  relationshipId: string | undefined,\n  type: TimerType,\n  duration: number,\n  title: string,\n  options?: {\n    description?: string;\n    canPause?: boolean;\n    canStop?: boolean;\n    canExtend?: boolean;\n    isKeyholderControlled?: boolean;\n    keyholderUserId?: string;\n    sessionId?: string;\n    taskId?: string;\n  },\n): LiveTimer => {\n  const now = new Date();\n  return {\n    id: `timer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    type,\n    status: TimerStatus.STOPPED,\n    startTime: now,\n    currentTime: now,\n    duration,\n    elapsed: 0,\n    remaining: duration,\n    isPaused: false,\n    totalPauseTime: 0,\n    userId,\n    relationshipId,\n    title,\n    description: options?.description,\n    canPause: options?.canPause ?? true,\n    canStop: options?.canStop ?? true,\n    canExtend: options?.canExtend ?? false,\n    isKeyholderControlled: options?.isKeyholderControlled ?? false,\n    keyholderUserId: options?.keyholderUserId,\n    sessionId: options?.sessionId,\n    taskId: options?.taskId,\n  };\n};\n\nexport const useLiveTimer = (options: UseLiveTimerOptions) => {\n  const {\n    userId,\n    relationshipId,\n    syncInterval = 1000, // 1 second\n    accuracyThreshold = 500, // 500ms\n  } = options;\n\n  // Timer state\n  const [timerState, setTimerState] = useState<LiveTimerState>({\n    activeTimers: [],\n    timerSyncs: [],\n    subscriptions: [],\n    events: [],\n  });\n\n  // Refs for intervals and sync\n  const updateIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const syncIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const subscriptionsRef = useRef<Map<string, TimerSubscription>>(new Map());\n\n  // Create a new timer\n  const createTimer = useCallback(\n    async (\n      type: TimerType,\n      duration: number, // seconds\n      title: string,\n      options?: {\n        description?: string;\n        canPause?: boolean;\n        canStop?: boolean;\n        canExtend?: boolean;\n        isKeyholderControlled?: boolean;\n        keyholderUserId?: string;\n        sessionId?: string;\n        taskId?: string;\n      },\n    ): Promise<LiveTimer> => {\n      const timer = createNewTimer(\n        userId,\n        relationshipId,\n        type,\n        duration,\n        title,\n        options,\n      );\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: [...prev.activeTimers, timer],\n      }));\n\n      // Create sync record\n      const sync = await createTimerSync(timer.id);\n      setTimerState((prev) => ({\n        ...prev,\n        timerSyncs: [...prev.timerSyncs, sync],\n      }));\n\n      // Save to backend\n      await saveTimer(timer);\n\n      return timer;\n    },\n    [userId, relationshipId],\n  );\n\n  // Start a timer\n  const startTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      validateTimerPermissions(timer, userId, \"control\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.RUNNING,\n        startTime: now,\n        currentTime: now,\n        isPaused: false,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      // Log event and sync\n      await logTimerEvent(timerId, \"start\", { startTime: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Pause a timer\n  const pauseTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canPause) {\n        throw new Error(\"Timer cannot be paused\");\n      }\n\n      validateTimerPermissions(timer, userId, \"pause\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.PAUSED,\n        isPaused: true,\n        pausedAt: now,\n        currentTime: now,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"pause\", { pausedAt: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Resume a timer\n  const resumeTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      validateTimerPermissions(timer, userId, \"resume\");\n\n      const now = new Date();\n      const pauseDuration = timer.pausedAt\n        ? now.getTime() - timer.pausedAt.getTime()\n        : 0;\n\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.RUNNING,\n        isPaused: false,\n        pausedAt: undefined,\n        totalPauseTime: timer.totalPauseTime + pauseDuration,\n        currentTime: now,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"resume\", { resumedAt: now, pauseDuration });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Stop a timer\n  const stopTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canStop) {\n        throw new Error(\"Timer cannot be stopped\");\n      }\n\n      validateTimerPermissions(timer, userId, \"stop\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.STOPPED,\n        endTime: now,\n        currentTime: now,\n        isPaused: false,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"stop\", { stoppedAt: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Extend a timer\n  const extendTimer = useCallback(\n    async (timerId: string, additionalSeconds: number): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canExtend) {\n        throw new Error(\"Timer cannot be extended\");\n      }\n\n      validateTimerPermissions(timer, userId, \"extend\");\n\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        duration: timer.duration + additionalSeconds,\n        remaining: timer.remaining + additionalSeconds,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"extend\", { additionalSeconds });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Subscribe to timer updates\n  const subscribeToTimer = useCallback(\n    (\n      timerId: string,\n      callback: (timer: LiveTimer) => void,\n      events: string[] = [\"start\", \"pause\", \"resume\", \"stop\", \"update\"],\n    ): TimerSubscription => {\n      return createTimerSubscription(\n        timerId,\n        callback,\n        events,\n        setTimerState,\n        subscriptionsRef,\n      );\n    },\n    [],\n  );\n\n  // Get timer by ID\n  const getTimer = useCallback(\n    (timerId: string): LiveTimer | null => {\n      return timerState.activeTimers.find((t) => t.id === timerId) || null;\n    },\n    [timerState.activeTimers],\n  );\n\n  // Get timers by type\n  const getTimersByType = useCallback(\n    (type: TimerType): LiveTimer[] => {\n      return timerState.activeTimers.filter((t) => t.type === type);\n    },\n    [timerState.activeTimers],\n  );\n\n  // Get running timers\n  const getRunningTimers = useCallback((): LiveTimer[] => {\n    return timerState.activeTimers.filter(\n      (t) => t.status === TimerStatus.RUNNING,\n    );\n  }, [timerState.activeTimers]);\n\n  // Update timer progress\n  const updateTimerProgress = useCallback(() => {\n    const now = new Date();\n\n    setTimerState((prev) => ({\n      ...prev,\n      activeTimers: prev.activeTimers.map((timer) => {\n        const progress = calculateTimerProgress(timer, now);\n        const updatedTimer = { ...timer, ...progress };\n\n        // Check if timer completed\n        if (progress.remaining === 0 && timer.status === TimerStatus.RUNNING) {\n          logTimerEvent(timer.id, \"complete\", { completedAt: now });\n          notifySubscribers(updatedTimer);\n        }\n\n        return updatedTimer;\n      }),\n    }));\n  }, [notifySubscribers]);\n\n  // Sync timer with server\n  const syncTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      try {\n        const serverTime = await getServerTime();\n        const now = new Date();\n        const clientOffset = now.getTime() - serverTime.getTime();\n\n        setTimerState((prev) => ({\n          ...prev,\n          timerSyncs: prev.timerSyncs.map((sync) =>\n            sync.timerId === timerId\n              ? {\n                  ...sync,\n                  lastSync: now,\n                  serverTime,\n                  clientOffset,\n                  syncAccuracy:\n                    Math.abs(clientOffset) < accuracyThreshold ? 1.0 : 0.5,\n                }\n              : sync,\n          ),\n        }));\n      } catch {\n        // Failed to sync timer\n      }\n    },\n    [accuracyThreshold],\n  );\n\n  // Notify subscribers\n  const notifySubscribers = useCallback((timer: LiveTimer) => {\n    subscriptionsRef.current.forEach((subscription) => {\n      if (subscription.timerId === timer.id && subscription.isActive) {\n        try {\n          subscription.callback(timer);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    });\n  }, []);\n\n  // Helper function to sync active timers with server\n  const syncActiveTimers = useCallback(async () => {\n    const runningTimers = timerState.activeTimers.filter(\n      (t) => t.status === TimerStatus.RUNNING,\n    );\n\n    for (const timer of runningTimers) {\n      try {\n        const serverTime = await getServerTime();\n        const now = new Date();\n        const clientOffset = now.getTime() - serverTime.getTime();\n\n        setTimerState((prev) => ({\n          ...prev,\n          timerSyncs: prev.timerSyncs.map((sync) =>\n            sync.timerId === timer.id\n              ? {\n                  ...sync,\n                  lastSync: now,\n                  serverTime,\n                  clientOffset,\n                  syncAccuracy:\n                    Math.abs(clientOffset) < accuracyThreshold ? 1.0 : 0.5,\n                }\n              : sync,\n          ),\n        }));\n      } catch {\n        // Failed to sync timer\n      }\n    }\n  }, [timerState.activeTimers, accuracyThreshold]);\n\n  // Start update interval\n  useEffect(() => {\n    updateIntervalRef.current = setInterval(updateTimerProgress, syncInterval);\n\n    return () => {\n      if (updateIntervalRef.current) {\n        clearInterval(updateIntervalRef.current);\n      }\n    };\n    // updateTimerProgress is stable (no deps)\n    // syncInterval is a number variable, not a store action\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [syncInterval]);\n\n  // Start sync interval\n  useEffect(() => {\n    syncIntervalRef.current = setInterval(syncActiveTimers, syncInterval * 30); // Sync every 30 seconds\n\n    return () => {\n      if (syncIntervalRef.current) {\n        clearInterval(syncIntervalRef.current);\n      }\n    };\n    // syncActiveTimers is stable\n    // syncInterval is a number variable, not a store action\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [syncInterval]);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    return calculateComputedValues(timerState.activeTimers);\n  }, [timerState.activeTimers]);\n\n  return {\n    // Timer state\n    activeTimers: timerState.activeTimers,\n    timerSyncs: timerState.timerSyncs,\n    events: timerState.events,\n\n    // Timer management\n    createTimer,\n    startTimer,\n    pauseTimer,\n    resumeTimer,\n    stopTimer,\n    extendTimer,\n\n    // Timer queries\n    getTimer,\n    getTimersByType,\n    getRunningTimers,\n\n    // Subscription management\n    subscribeToTimer,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Helper functions\nasync function getServerTime(): Promise<Date> {\n  // In real implementation, fetch server time from API\n  try {\n    // const response = await fetch('/api/time');\n    // const { timestamp } = await response.json();\n    // return new Date(timestamp);\n    return new Date(); // Fallback to client time\n  } catch {\n    // Fallback to client time\n    return new Date();\n  }\n}\n\nasync function saveTimer(_timer: LiveTimer): Promise<void> {\n  // In real implementation, save to backend\n  // In real implementation, save to backend\n}\n\nasync function logTimerEvent(\n  timerId: string,\n  type: string,\n  data?: Record<string, string | number | boolean | Date>,\n): Promise<void> {\n  const _event: TimerEvent = {\n    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timerId,\n    type: type as TimerEvent[\"type\"],\n    timestamp: new Date(),\n    userId: \"\", // Would be filled from context\n    data,\n  };\n\n  // In real implementation, save to backend\n  // In real implementation, save to backend\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/useNotifications.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (309). Maximum allowed is 75.","line":91,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":481,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useNotifications - Comprehensive Notification System Hook\n *\n * Complete notification system for in-app, push, and email notifications\n * with user preferences and relationship context.\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport {\n  NotificationState,\n  Notification,\n  NotificationType,\n  NotificationPriority,\n  NotificationChannelType,\n  NotificationPreferences,\n  NotificationChannelSettings,\n  QuietHours,\n} from \"../../types/realtime\";\n\ninterface UseNotificationsOptions {\n  userId: string;\n  relationshipId?: string;\n  enablePush?: boolean;\n  enableEmail?: boolean;\n  maxNotifications?: number;\n}\n\nconst defaultPreferences: NotificationPreferences = {\n  channels: [\n    {\n      type: NotificationChannelType.IN_APP,\n      enabled: true,\n      settings: {},\n    },\n    {\n      type: NotificationChannelType.PUSH,\n      enabled: false,\n      settings: {},\n    },\n    {\n      type: NotificationChannelType.EMAIL,\n      enabled: false,\n      settings: {},\n    },\n  ],\n  quietHours: {\n    enabled: false,\n    startTime: \"22:00\",\n    endTime: \"08:00\",\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    days: [0, 1, 2, 3, 4, 5, 6], // All days\n  },\n  categories: [\n    {\n      category: NotificationType.TASK_ASSIGNED,\n      enabled: true,\n      channels: [NotificationChannelType.IN_APP, NotificationChannelType.PUSH],\n      priority: NotificationPriority.MEDIUM,\n    },\n    {\n      category: NotificationType.TASK_APPROVED,\n      enabled: true,\n      channels: [NotificationChannelType.IN_APP],\n      priority: NotificationPriority.LOW,\n    },\n    {\n      category: NotificationType.SESSION_STARTED,\n      enabled: true,\n      channels: [NotificationChannelType.IN_APP],\n      priority: NotificationPriority.MEDIUM,\n    },\n    {\n      category: NotificationType.RELATIONSHIP_REQUEST,\n      enabled: true,\n      channels: [NotificationChannelType.IN_APP, NotificationChannelType.EMAIL],\n      priority: NotificationPriority.HIGH,\n    },\n    {\n      category: NotificationType.SYSTEM_ALERT,\n      enabled: true,\n      channels: [\n        NotificationChannelType.IN_APP,\n        NotificationChannelType.PUSH,\n        NotificationChannelType.EMAIL,\n      ],\n      priority: NotificationPriority.URGENT,\n    },\n  ],\n  globalEnabled: true,\n};\n\nexport const useNotifications = (options: UseNotificationsOptions) => {\n  const {\n    userId,\n    relationshipId,\n    enablePush = false,\n    _enableEmail = false,\n    maxNotifications = 100,\n  } = options;\n\n  // Notification state\n  const [notificationState, setNotificationState] = useState<NotificationState>(\n    {\n      notifications: [],\n      preferences: defaultPreferences,\n      deliveryChannels: defaultPreferences.channels,\n      notificationHistory: [],\n    },\n  );\n\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load notifications and preferences on mount\n  useEffect(() => {\n    const loadNotifications = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Load user preferences\n        const preferences = await fetchNotificationPreferences(userId);\n\n        // Load recent notifications\n        const notifications = await fetchRecentNotifications(\n          userId,\n          relationshipId,\n        );\n\n        setNotificationState((prev) => ({\n          ...prev,\n          preferences: { ...defaultPreferences, ...preferences },\n          notifications,\n        }));\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to load notifications\",\n        );\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    if (userId) {\n      loadNotifications();\n    }\n  }, [userId, relationshipId]);\n\n  // Request push notification permission\n  useEffect(() => {\n    if (enablePush && \"Notification\" in window) {\n      const requestPermission = async () => {\n        if (Notification.permission === \"default\") {\n          const _permission = await Notification.requestPermission();\n          // Permission granted or denied\n        }\n      };\n\n      requestPermission();\n    }\n  }, [enablePush]);\n\n  // Add notification\n  const addNotification = useCallback(\n    async (\n      notification: Omit<\n        Notification,\n        \"id\" | \"timestamp\" | \"isRead\" | \"userId\"\n      >,\n    ): Promise<void> => {\n      const newNotification: Notification = {\n        ...notification,\n        id: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date(),\n        isRead: false,\n        userId,\n      };\n\n      // Check if notifications are enabled globally\n      if (!notificationState.preferences.globalEnabled) {\n        return;\n      }\n\n      // Check category preferences\n      const categoryPref = notificationState.preferences.categories.find(\n        (cat) => cat.category === notification.type,\n      );\n\n      if (!categoryPref?.enabled) {\n        return;\n      }\n\n      // Check quiet hours\n      if (isInQuietHours(notificationState.preferences.quietHours)) {\n        // Queue for later delivery if not urgent\n        if (notification.priority !== NotificationPriority.URGENT) {\n          return;\n        }\n      }\n\n      // Add to state\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: [\n          newNotification,\n          ...prev.notifications.slice(0, maxNotifications - 1),\n        ],\n      }));\n\n      // Deliver through enabled channels\n      await deliverNotification(newNotification, categoryPref.channels);\n\n      // Save to backend\n      await saveNotification(newNotification);\n    },\n    [userId, notificationState.preferences, maxNotifications],\n  );\n\n  // Mark notification as read\n  const markAsRead = useCallback(\n    async (notificationId: string): Promise<void> => {\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: prev.notifications.map((notif) =>\n          notif.id === notificationId ? { ...notif, isRead: true } : notif,\n        ),\n      }));\n\n      // Update in backend\n      await updateNotificationStatus(notificationId, { isRead: true });\n    },\n    [],\n  );\n\n  // Mark all notifications as read\n  const markAllAsRead = useCallback(async (): Promise<void> => {\n    const unreadIds = notificationState.notifications\n      .filter((notif) => !notif.isRead)\n      .map((notif) => notif.id);\n\n    setNotificationState((prev) => ({\n      ...prev,\n      notifications: prev.notifications.map((notif) => ({\n        ...notif,\n        isRead: true,\n      })),\n    }));\n\n    // Update in backend\n    await updateMultipleNotificationStatus(unreadIds, { isRead: true });\n  }, [notificationState.notifications]);\n\n  // Dismiss notification\n  const dismissNotification = useCallback(\n    async (notificationId: string): Promise<void> => {\n      setNotificationState((prev) => ({\n        ...prev,\n        notifications: prev.notifications.filter(\n          (notif) => notif.id !== notificationId,\n        ),\n      }));\n\n      // Remove from backend\n      await deleteNotification(notificationId);\n    },\n    [],\n  );\n\n  // Update preferences\n  const updatePreferences = useCallback(\n    async (prefs: Partial<NotificationPreferences>): Promise<void> => {\n      const updatedPreferences = {\n        ...notificationState.preferences,\n        ...prefs,\n      };\n\n      setNotificationState((prev) => ({\n        ...prev,\n        preferences: updatedPreferences,\n        deliveryChannels: updatedPreferences.channels,\n      }));\n\n      // Save to backend\n      await saveNotificationPreferences(userId, updatedPreferences);\n    },\n    [userId, notificationState.preferences],\n  );\n\n  // Enable/disable notification channel\n  const enableChannel = useCallback(\n    async (channel: NotificationChannelType): Promise<void> => {\n      const updatedChannels = notificationState.preferences.channels.map(\n        (ch) => (ch.type === channel ? { ...ch, enabled: true } : ch),\n      );\n\n      await updatePreferences({ channels: updatedChannels });\n    },\n    [notificationState.preferences.channels, updatePreferences],\n  );\n\n  const disableChannel = useCallback(\n    async (channel: NotificationChannelType): Promise<void> => {\n      const updatedChannels = notificationState.preferences.channels.map(\n        (ch) => (ch.type === channel ? { ...ch, enabled: false } : ch),\n      );\n\n      await updatePreferences({ channels: updatedChannels });\n    },\n    [notificationState.preferences.channels, updatePreferences],\n  );\n\n  // Update channel settings\n  const updateChannelSettings = useCallback(\n    async (\n      channel: NotificationChannelType,\n      settings: NotificationChannelSettings,\n    ): Promise<void> => {\n      const updatedChannels = notificationState.preferences.channels.map(\n        (ch) =>\n          ch.type === channel\n            ? { ...ch, settings: { ...ch.settings, ...settings } }\n            : ch,\n      );\n\n      await updatePreferences({ channels: updatedChannels });\n    },\n    [notificationState.preferences.channels, updatePreferences],\n  );\n\n  // Convenience methods for creating notifications\n  const showSuccess = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.SUCCESS,\n        title,\n        message,\n        priority: NotificationPriority.LOW,\n      });\n    },\n    [addNotification],\n  );\n\n  const showError = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.ERROR,\n        title,\n        message,\n        priority: NotificationPriority.HIGH,\n      });\n    },\n    [addNotification],\n  );\n\n  const showWarning = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.WARNING,\n        title,\n        message,\n        priority: NotificationPriority.MEDIUM,\n      });\n    },\n    [addNotification],\n  );\n\n  const showInfo = useCallback(\n    (title: string, message: string) => {\n      return addNotification({\n        type: NotificationType.INFO,\n        title,\n        message,\n        priority: NotificationPriority.LOW,\n      });\n    },\n    [addNotification],\n  );\n\n  // Relationship-specific notifications\n  const notifyTaskAssigned = useCallback(\n    (taskTitle: string, keyholderName: string) => {\n      return addNotification({\n        type: NotificationType.TASK_ASSIGNED,\n        title: \"New Task Assigned\",\n        message: `${keyholderName} has assigned you: ${taskTitle}`,\n        priority: NotificationPriority.MEDIUM,\n        relationshipId,\n      });\n    },\n    [addNotification, relationshipId],\n  );\n\n  const notifyTaskApproved = useCallback(\n    (taskTitle: string) => {\n      return addNotification({\n        type: NotificationType.TASK_APPROVED,\n        title: \"Task Approved\",\n        message: `Your task \"${taskTitle}\" has been approved`,\n        priority: NotificationPriority.LOW,\n        relationshipId,\n      });\n    },\n    [addNotification, relationshipId],\n  );\n\n  const notifySessionStarted = useCallback(() => {\n    return addNotification({\n      type: NotificationType.SESSION_STARTED,\n      title: \"Chastity Session Started\",\n      message: \"Your chastity session has begun\",\n      priority: NotificationPriority.MEDIUM,\n    });\n  }, [addNotification]);\n\n  const notifyRelationshipRequest = useCallback(\n    (requesterName: string) => {\n      return addNotification({\n        type: NotificationType.RELATIONSHIP_REQUEST,\n        title: \"Relationship Request\",\n        message: `${requesterName} wants to establish a keyholder relationship with you`,\n        priority: NotificationPriority.HIGH,\n        actionUrl: \"/relationships\",\n        actionText: \"View Request\",\n      });\n    },\n    [addNotification],\n  );\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    const unreadCount = notificationState.notifications.filter(\n      (n) => !n.isRead,\n    ).length;\n    const hasHighPriority = notificationState.notifications.some(\n      (n) =>\n        n.priority === NotificationPriority.HIGH ||\n        n.priority === NotificationPriority.URGENT,\n    );\n    const recentNotifications = notificationState.notifications.slice(0, 10);\n\n    return {\n      unreadCount,\n      hasHighPriority,\n      recentNotifications,\n    };\n  }, [notificationState.notifications]);\n\n  return {\n    // Notification state\n    notifications: notificationState.notifications,\n    preferences: notificationState.preferences,\n    loading,\n    error,\n\n    // Notification management\n    addNotification,\n    markAsRead,\n    markAllAsRead,\n    dismissNotification,\n\n    // Preferences\n    updatePreferences,\n    enableChannel,\n    disableChannel,\n    updateChannelSettings,\n\n    // Convenience methods\n    showSuccess,\n    showError,\n    showWarning,\n    showInfo,\n\n    // Relationship-specific methods\n    notifyTaskAssigned,\n    notifyTaskApproved,\n    notifySessionStarted,\n    notifyRelationshipRequest,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Helper functions\nfunction isInQuietHours(quietHours: QuietHours): boolean {\n  if (!quietHours.enabled) return false;\n\n  const now = new Date();\n  const currentDay = now.getDay();\n  const currentTime = now.toTimeString().slice(0, 5); // HH:MM format\n\n  // Check if current day is in quiet hours days\n  if (!quietHours.days.includes(currentDay)) {\n    return false;\n  }\n\n  // Simple time comparison (doesn't handle cross-midnight ranges properly)\n  return (\n    currentTime >= quietHours.startTime && currentTime <= quietHours.endTime\n  );\n}\n\nasync function deliverNotification(\n  notification: Notification,\n  channels: NotificationChannelType[],\n): Promise<void> {\n  const deliveryPromises = channels.map(async (channel) => {\n    switch (channel) {\n      case NotificationChannelType.IN_APP:\n        // Already handled by adding to state\n        return;\n\n      case NotificationChannelType.PUSH:\n        return deliverPushNotification(notification);\n\n      case NotificationChannelType.EMAIL:\n        return deliverEmailNotification(notification);\n\n      case NotificationChannelType.SMS:\n        return deliverSMSNotification(notification);\n\n      default:\n      // Unknown notification channel\n    }\n  });\n\n  await Promise.allSettled(deliveryPromises);\n}\n\nasync function deliverPushNotification(\n  notification: Notification,\n): Promise<void> {\n  if (\"Notification\" in window && Notification.permission === \"granted\") {\n    new Notification(notification.title, {\n      body: notification.message,\n      icon: \"/icon-192x192.png\",\n      badge: \"/badge-72x72.png\",\n      tag: notification.id,\n      requireInteraction: notification.priority === NotificationPriority.URGENT,\n    });\n  }\n}\n\nasync function deliverEmailNotification(\n  _notification: Notification,\n): Promise<void> {\n  // In real implementation, send email via backend API\n}\n\nasync function deliverSMSNotification(\n  _notification: Notification,\n): Promise<void> {\n  // In real implementation, send SMS via backend API\n}\n\nasync function fetchNotificationPreferences(\n  _userId: string,\n): Promise<Partial<NotificationPreferences>> {\n  // In real implementation, fetch from backend\n  return {};\n}\n\nasync function fetchRecentNotifications(\n  _userId: string,\n  _relationshipId?: string,\n): Promise<Notification[]> {\n  // In real implementation, fetch from backend\n  return [];\n}\n\nasync function saveNotification(_notification: Notification): Promise<void> {\n  // In real implementation, save to backend\n}\n\nasync function updateNotificationStatus(\n  _notificationId: string,\n  _status: Partial<Pick<Notification, \"isRead\">>,\n): Promise<void> {\n  // In real implementation, update in backend\n}\n\nasync function updateMultipleNotificationStatus(\n  _notificationIds: string[],\n  _status: Partial<Pick<Notification, \"isRead\">>,\n): Promise<void> {\n  // In real implementation, bulk update in backend\n}\n\nasync function deleteNotification(_notificationId: string): Promise<void> {\n  // In real implementation, delete from backend\n}\n\nasync function saveNotificationPreferences(\n  _userId: string,\n  _preferences: NotificationPreferences,\n): Promise<void> {\n  // In real implementation, save to backend\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/usePresence.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (152). Maximum allowed is 75.","line":29,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":241,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":50,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":44},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":51,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":43}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setAway'. Either include it or remove the dependency array.","line":137,"column":6,"nodeType":"ArrayExpression","endLine":137,"endColumn":76,"suggestions":[{"desc":"Update the dependencies array to be: [autoTrackActivity, presenceState.ownPresence.status, activityTimeout, setAway]","fix":{"range":[3664,3734],"text":"[autoTrackActivity, presenceState.ownPresence.status, activityTimeout, setAway]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":161,"column":34,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":161,"endColumn":48,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setAway', 'setOffline', and 'setOnline'. Either include them or remove the dependency array.","line":192,"column":6,"nodeType":"ArrayExpression","endLine":192,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setAway, setOffline, setOnline]","fix":{"range":[5478,5480],"text":"[setAway, setOffline, setOnline]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setOffline' and 'setOnline'. Either include them or remove the dependency array.","line":204,"column":6,"nodeType":"ArrayExpression","endLine":204,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setOffline, setOnline]","fix":{"range":[5807,5809],"text":"[setOffline, setOnline]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * usePresence - Online/Offline Status Hook\n *\n * Track and display online/offline presence for users in relationships\n * with activity indicators and status messages.\n */\nimport { useState, useEffect, useCallback, useMemo, useRef } from \"react\";\nimport {\n  PresenceState,\n  UserPresence as _UserPresence,\n  PresenceStatus,\n  ActivityContext,\n  PresenceSubscription as _PresenceSubscription,\n} from \"../../types/realtime\";\nimport {\n  createPresenceUpdateFunctions,\n  createSubscriptionFunctions,\n  createQueryFunctions,\n  calculatePresenceComputedValues,\n} from \"./presence-operations\";\n\ninterface UsePresenceOptions {\n  userId: string;\n  updateInterval?: number; // milliseconds\n  activityTimeout?: number; // milliseconds\n  autoTrackActivity?: boolean;\n}\n\nexport const usePresence = (options: UsePresenceOptions) => {\n  const {\n    userId,\n    updateInterval = 30000, // 30 seconds\n    activityTimeout = 300000, // 5 minutes\n    autoTrackActivity = true,\n  } = options;\n\n  // Presence state\n  const [presenceState, setPresenceState] = useState<PresenceState>({\n    userPresences: {},\n    subscriptions: [],\n    ownPresence: {\n      userId,\n      status: PresenceStatus.OFFLINE,\n      lastSeen: new Date(),\n    },\n  });\n\n  // Refs for tracking activity\n  const lastActivityRef = useRef<Date>(new Date());\n  const presenceIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const activityTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Create operation functions using helpers\n  const presenceUpdateFunctions = createPresenceUpdateFunctions(\n    userId,\n    presenceState,\n    setPresenceState,\n  );\n\n  const subscriptionFunctions = createSubscriptionFunctions(setPresenceState);\n  const queryFunctions = createQueryFunctions(presenceState);\n\n  // Extract individual functions for easier use\n  const {\n    updateOwnPresence: _updateOwnPresence,\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivity: updateActivityStatus,\n  } = presenceUpdateFunctions;\n\n  const { subscribeToPresence } = subscriptionFunctions;\n  const {\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n  } = queryFunctions;\n\n  // Update activity\n  const updateActivity = useCallback(\n    (activity: ActivityContext) => {\n      lastActivityRef.current = new Date();\n      return updateActivityStatus(activity);\n    },\n    [updateActivityStatus],\n  );\n\n  // Handle activity tracking\n  useEffect(() => {\n    if (!autoTrackActivity) return;\n\n    const trackActivity = () => {\n      lastActivityRef.current = new Date();\n\n      // Reset activity timeout\n      if (activityTimeoutRef.current) {\n        clearTimeout(activityTimeoutRef.current);\n      }\n\n      // Set away status after inactivity\n      activityTimeoutRef.current = setTimeout(() => {\n        if (presenceState.ownPresence.status === PresenceStatus.ONLINE) {\n          setAway(\"Away due to inactivity\");\n        }\n      }, activityTimeout);\n    };\n\n    // Track various activity events\n    const events = [\n      \"mousedown\",\n      \"mousemove\",\n      \"keypress\",\n      \"scroll\",\n      \"touchstart\",\n      \"click\",\n    ];\n\n    events.forEach((event) => {\n      document.addEventListener(event, trackActivity, { passive: true });\n    });\n\n    return () => {\n      events.forEach((event) => {\n        document.removeEventListener(event, trackActivity);\n      });\n\n      if (activityTimeoutRef.current) {\n        clearTimeout(activityTimeoutRef.current);\n      }\n    };\n    // setAway is from presenceUpdateFunctions which is recreated when presenceState changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [autoTrackActivity, presenceState.ownPresence.status, activityTimeout]);\n\n  // Handle presence updates\n  useEffect(() => {\n    const sendPeriodicUpdate = async () => {\n      if (presenceState.ownPresence.status !== PresenceStatus.OFFLINE) {\n        // In real implementation, send to backend/WebSocket\n        // await sendPresenceUpdate(presenceState.ownPresence);\n      }\n    };\n\n    presenceIntervalRef.current = setInterval(\n      sendPeriodicUpdate,\n      updateInterval,\n    );\n\n    return () => {\n      if (presenceIntervalRef.current) {\n        clearInterval(presenceIntervalRef.current);\n      }\n    };\n    // sendPeriodicUpdate uses presenceState.ownPresence which is in deps\n    // updateInterval is a config number, not a store action\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [presenceState.ownPresence, updateInterval]);\n\n  // Handle online/offline events\n  useEffect(() => {\n    const handleOnline = () => {\n      setOnline(\"Back online\");\n    };\n\n    const handleOffline = () => {\n      setOffline(\"Connection lost\");\n    };\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        setAway(\"Tab inactive\");\n      } else {\n        setOnline(\"Tab active\");\n      }\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n    // setOnline, setOffline, setAway are from presenceUpdateFunctions (stable)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Initialize presence as online\n  useEffect(() => {\n    setOnline(\"Connected\");\n\n    // Set offline when component unmounts\n    return () => {\n      setOffline(\"Disconnected\");\n    };\n    // setOnline, setOffline are from presenceUpdateFunctions (stable)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    return calculatePresenceComputedValues(\n      presenceState.userPresences,\n      lastActivityRef.current,\n      activityTimeout,\n    );\n  }, [presenceState.userPresences, activityTimeout]);\n\n  return {\n    // Presence state\n    ownPresence: presenceState.ownPresence,\n    userPresences: presenceState.userPresences,\n\n    // Status management\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivity,\n\n    // Subscription management\n    subscribeToPresence,\n\n    // Presence queries\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/realtime/useRealtimeSync.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (364). Maximum allowed is 75.","line":34,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":507,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (29). Maximum allowed is 25.","line":34,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":507,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":62,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":44},{"ruleId":"no-undef","severity":1,"message":"'NodeJS' is not defined.","line":63,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":63,"endColumn":44}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'attemptReconnect', 'handleMessage', 'sendMessage', 'startHeartbeat', 'stopHeartbeat', and 'syncState.activeChannels'. Either include them or remove the dependency array.","line":157,"column":6,"nodeType":"ArrayExpression","endLine":157,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [userId, startHeartbeat, syncState.activeChannels, sendMessage, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]","fix":{"range":[4158,4188],"text":"[userId, startHeartbeat, syncState.activeChannels, sendMessage, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'stopHeartbeat'. Either include it or remove the dependency array.","line":173,"column":6,"nodeType":"ArrayExpression","endLine":173,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [stopHeartbeat]","fix":{"range":[4601,4603],"text":"[stopHeartbeat]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'sendMessage'. Either include it or remove the dependency array.","line":209,"column":6,"nodeType":"ArrayExpression","endLine":209,"endColumn":25,"suggestions":[{"desc":"Update the dependencies array to be: [heartbeatInterval, sendMessage]","fix":{"range":[5683,5702],"text":"[heartbeatInterval, sendMessage]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'handleChannelJoined', 'handleChannelLeft', and 'handleRealtimeUpdate'. Either include them or remove the dependency array.","line":262,"column":6,"nodeType":"ArrayExpression","endLine":262,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]","fix":{"range":[7133,7135],"text":"[handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useRealtimeSync - Real-time Data Synchronization Hook\n *\n * Real-time data synchronization across devices and users with WebSocket integration\n * and conflict resolution.\n */\nimport { useState, useEffect, useCallback, useRef, useMemo } from \"react\";\nimport {\n  RealtimeSyncState,\n  ConnectionStatus,\n  SyncChannel,\n  ChannelType,\n  RealtimeUpdate,\n  Subscription,\n  UpdateCallback,\n} from \"../../types/realtime\";\n\ninterface WebSocketMessage {\n  type: string;\n  data?: unknown;\n  channelId?: string;\n  userId?: string;\n  timestamp?: Date;\n}\n\ninterface UseRealtimeSyncOptions {\n  userId: string;\n  autoConnect?: boolean;\n  reconnectInterval?: number; // milliseconds\n  heartbeatInterval?: number; // milliseconds\n  maxReconnectAttempts?: number;\n}\n\nexport const useRealtimeSync = (options: UseRealtimeSyncOptions) => {\n  const {\n    userId,\n    autoConnect = true,\n    reconnectInterval = 5000,\n    heartbeatInterval = 30000,\n    maxReconnectAttempts = 5,\n  } = options;\n\n  // Realtime sync state\n  const [syncState, setSyncState] = useState<RealtimeSyncState>({\n    connectionStatus: ConnectionStatus.DISCONNECTED,\n    activeChannels: [],\n    realtimeData: {},\n    syncMetrics: {\n      lastSuccessfulSync: new Date(),\n      syncErrors: 0,\n      messagesReceived: 0,\n      messagesSent: 0,\n      averageLatency: 0,\n      connectionUptime: 0,\n    },\n  });\n\n  // Refs for WebSocket and subscriptions\n  const wsRef = useRef<WebSocket | null>(null);\n  const subscriptionsRef = useRef<Map<string, Subscription>>(new Map());\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const heartbeatTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const connectionStartTimeRef = useRef<Date | null>(null);\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTING,\n    }));\n\n    try {\n      // In real implementation, use your WebSocket server URL\n      const wsUrl =\n        process.env.NODE_ENV === \"development\"\n          ? \"ws://localhost:8080/ws\"\n          : \"wss://api.chastityos.com/ws\";\n\n      wsRef.current = new WebSocket(`${wsUrl}?userId=${userId}`);\n      connectionStartTimeRef.current = new Date();\n\n      wsRef.current.onopen = () => {\n        // WebSocket connected\n        reconnectAttemptsRef.current = 0;\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.CONNECTED,\n        }));\n\n        // Start heartbeat\n        startHeartbeat();\n\n        // Rejoin previous channels\n        syncState.activeChannels.forEach((channel) => {\n          sendMessage({\n            type: \"join_channel\",\n            channelId: channel.id,\n            userId,\n          });\n        });\n      };\n\n      wsRef.current.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          handleMessage(message);\n        } catch {\n          // Failed to parse WebSocket message\n        }\n      };\n\n      wsRef.current.onclose = (event) => {\n        // WebSocket disconnected\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.DISCONNECTED,\n        }));\n\n        stopHeartbeat();\n\n        // Attempt reconnection if not intentional disconnect\n        if (\n          event.code !== 1000 &&\n          reconnectAttemptsRef.current < maxReconnectAttempts\n        ) {\n          attemptReconnect();\n        }\n      };\n\n      wsRef.current.onerror = (_error) => {\n        // WebSocket error\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.ERROR,\n          syncMetrics: {\n            ...prev.syncMetrics,\n            syncErrors: prev.syncMetrics.syncErrors + 1,\n          },\n        }));\n      };\n    } catch {\n      // Failed to create WebSocket connection\n      setSyncState((prev) => ({\n        ...prev,\n        connectionStatus: ConnectionStatus.ERROR,\n      }));\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, maxReconnectAttempts]);\n\n  // Disconnect WebSocket\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Intentional disconnect\");\n      wsRef.current = null;\n    }\n\n    stopHeartbeat();\n\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // stopHeartbeat is stable\n\n  // Attempt reconnection\n  const attemptReconnect = useCallback(() => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      // Max reconnection attempts reached\n      return;\n    }\n\n    reconnectAttemptsRef.current++;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.RECONNECTING,\n    }));\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      // Reconnection attempt\n      connect();\n    }, reconnectInterval);\n  }, [connect, maxReconnectAttempts, reconnectInterval]);\n\n  // Start heartbeat\n  const startHeartbeat = useCallback(() => {\n    const sendHeartbeat = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({ type: \"heartbeat\", timestamp: new Date().toISOString() });\n        heartbeatTimeoutRef.current = setTimeout(\n          sendHeartbeat,\n          heartbeatInterval,\n        );\n      }\n    };\n\n    heartbeatTimeoutRef.current = setTimeout(sendHeartbeat, heartbeatInterval);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [heartbeatInterval]); // sendMessage is stable\n\n  // Stop heartbeat\n  const stopHeartbeat = useCallback(() => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n  }, []);\n\n  // Send message via WebSocket\n  const sendMessage = useCallback((message: WebSocketMessage) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n\n      setSyncState((prev) => ({\n        ...prev,\n        syncMetrics: {\n          ...prev.syncMetrics,\n          messagesSent: prev.syncMetrics.messagesSent + 1,\n        },\n      }));\n    }\n  }, []);\n\n  // Handle incoming messages\n  const handleMessage = useCallback((message: WebSocketMessage) => {\n    setSyncState((prev) => ({\n      ...prev,\n      syncMetrics: {\n        ...prev.syncMetrics,\n        messagesReceived: prev.syncMetrics.messagesReceived + 1,\n        lastSuccessfulSync: new Date(),\n      },\n    }));\n\n    switch (message.type) {\n      case \"channel_joined\":\n        handleChannelJoined(message);\n        break;\n      case \"channel_left\":\n        handleChannelLeft(message);\n        break;\n      case \"realtime_update\":\n        handleRealtimeUpdate(message);\n        break;\n      case \"heartbeat_ack\":\n        // Heartbeat acknowledged\n        break;\n      default:\n      // Unknown message type\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // handler functions are stable\n\n  // Handle channel joined\n  const handleChannelJoined = useCallback((message: WebSocketMessage) => {\n    const channel: SyncChannel = message.data as SyncChannel;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: [\n        ...prev.activeChannels.filter((c) => c.id !== channel.id),\n        channel,\n      ],\n    }));\n  }, []);\n\n  // Handle channel left\n  const handleChannelLeft = useCallback((message: WebSocketMessage) => {\n    const channelId = (message.data as { channelId: string })?.channelId;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: prev.activeChannels.filter((c) => c.id !== channelId),\n    }));\n  }, []);\n\n  // Handle realtime update\n  const handleRealtimeUpdate = useCallback((message: WebSocketMessage) => {\n    const update: RealtimeUpdate = message.data as RealtimeUpdate;\n\n    // Update local data\n    setSyncState((prev) => ({\n      ...prev,\n      realtimeData: {\n        ...prev.realtimeData,\n        [update.type]: update.data,\n      },\n    }));\n\n    // Notify subscribers\n    subscriptionsRef.current.forEach((subscription, _subscriptionId) => {\n      if (subscription.dataType === update.type && subscription.isActive) {\n        try {\n          subscription.callback(update);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    });\n  }, []);\n\n  // Join a sync channel\n  const joinChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"join_channel\",\n          channelId,\n          userId,\n        });\n      } else {\n        throw new Error(\"WebSocket not connected\");\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Leave a sync channel\n  const leaveChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"leave_channel\",\n          channelId,\n          userId,\n        });\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Create a new sync channel\n  const createChannel = useCallback(\n    async (type: ChannelType, participants: string[]): Promise<SyncChannel> => {\n      const channel: SyncChannel = {\n        id: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        type,\n        participants: [userId, ...participants],\n        lastActivity: new Date(),\n        isActive: true,\n        encryptionEnabled: type === ChannelType.RELATIONSHIP,\n      };\n\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"create_channel\",\n          channel,\n          userId,\n        });\n      }\n\n      return channel;\n    },\n    [userId, sendMessage],\n  );\n\n  // Subscribe to realtime updates\n  const subscribeToUpdates = useCallback(\n    (dataType: string, callback: UpdateCallback): Subscription => {\n      const subscription: Subscription = {\n        id: `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        dataType,\n        callback,\n        isActive: true,\n        created: new Date(),\n      };\n\n      subscriptionsRef.current.set(subscription.id, subscription);\n\n      // Return unsubscribe function\n      return {\n        ...subscription,\n        unsubscribe: () => {\n          const sub = subscriptionsRef.current.get(subscription.id);\n          if (sub) {\n            sub.isActive = false;\n            subscriptionsRef.current.delete(subscription.id);\n          }\n        },\n      } as Subscription & { unsubscribe: () => void };\n    },\n    [],\n  );\n\n  // Publish a realtime update\n  const publishUpdate = useCallback(\n    async (update: RealtimeUpdate): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"publish_update\",\n          update: {\n            ...update,\n            userId,\n            timestamp: new Date(),\n          },\n        });\n      } else {\n        throw new Error(\"WebSocket not connected\");\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Sync with keyholder\n  const syncWithKeyholder = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      const channelId = `relationship_${relationshipId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  // Sync session data\n  const syncSessionData = useCallback(\n    async (sessionId: string): Promise<void> => {\n      const channelId = `session_${sessionId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  // Auto-connect on mount\n  useEffect(() => {\n    if (autoConnect && userId) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [userId, autoConnect, connect, disconnect]);\n\n  // Update connection uptime\n  useEffect(() => {\n    if (\n      syncState.connectionStatus === ConnectionStatus.CONNECTED &&\n      connectionStartTimeRef.current\n    ) {\n      const updateUptime = () => {\n        setSyncState((prev) => ({\n          ...prev,\n          syncMetrics: {\n            ...prev.syncMetrics,\n            connectionUptime:\n              Date.now() - connectionStartTimeRef.current!.getTime(),\n          },\n        }));\n      };\n\n      const interval = setInterval(updateUptime, 1000);\n      return () => clearInterval(interval);\n    }\n  }, [syncState.connectionStatus]);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    const isConnected =\n      syncState.connectionStatus === ConnectionStatus.CONNECTED;\n    const channelCount = syncState.activeChannels.length;\n    const lastSyncTime = syncState.syncMetrics.lastSuccessfulSync;\n    const hasActiveSync = syncState.activeChannels.some((c) => c.isActive);\n\n    return {\n      isConnected,\n      channelCount,\n      lastSyncTime,\n      hasActiveSync,\n    };\n  }, [syncState]);\n\n  return {\n    // Connection state\n    connectionStatus: syncState.connectionStatus,\n    activeChannels: syncState.activeChannels,\n    syncMetrics: syncState.syncMetrics,\n\n    // Connection control\n    connect,\n    disconnect,\n\n    // Channel management\n    joinChannel,\n    leaveChannel,\n    createChannel,\n\n    // Real-time data operations\n    subscribeToUpdates,\n    publishUpdate,\n\n    // Relationship-specific sync\n    syncWithKeyholder,\n    syncSessionData,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/relationship-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipInvites.ts","messages":[],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":91,"column":15,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":91,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipList.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadRelationships'. Either include it or remove the dependency array.","line":82,"column":6,"nodeType":"ArrayExpression","endLine":82,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [loadRelationships, userId]","fix":{"range":[2493,2501],"text":"[loadRelationships, userId]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipPermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipStatus.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipStatus' has too many lines (138). Maximum allowed is 75.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":199,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Status Management\n * Handles session management and status updates\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport {\n  RelationshipChastityData,\n  RelationshipSession,\n} from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipStatusState extends BaseHookState {\n  chastityData: RelationshipChastityData | null;\n  sessions: RelationshipSession[];\n}\n\ninterface RelationshipStatusActions extends BaseHookActions {\n  startSession: (\n    relationshipId: string,\n    options?: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    },\n  ) => Promise<void>;\n  endSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  pauseSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  resumeSession: (relationshipId: string, sessionId: string) => Promise<void>;\n  loadRelationshipData: (relationshipId: string) => Promise<void>;\n}\n\nexport function useRelationshipStatus(): RelationshipStatusState &\n  RelationshipStatusActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipStatusState>({\n    chastityData: null,\n    sessions: [],\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadChastityData = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const chastityData =\n          await relationshipChastityService.getChastityData(relationshipId);\n        setState((prev) => ({ ...prev, chastityData }));\n      },\n      \"load chastity data\",\n      setState,\n    );\n  }, []);\n\n  const loadSessions = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const sessions =\n          await relationshipChastityService.getSessionHistory(relationshipId);\n        setState((prev) => ({ ...prev, sessions }));\n      },\n      \"load sessions\",\n      setState,\n    );\n  }, []);\n\n  const loadRelationshipData = useCallback(\n    async (relationshipId: string) => {\n      await Promise.all([\n        loadChastityData(relationshipId),\n        loadSessions(relationshipId),\n      ]);\n    },\n    [loadChastityData, loadSessions],\n  );\n\n  const startSession = useCallback(\n    async (\n      relationshipId: string,\n      options?: {\n        goalDuration?: number;\n        isHardcoreMode?: boolean;\n        notes?: string;\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.startSession(\n            relationshipId,\n            userId,\n            options || {},\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"start session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const endSession = useCallback(\n    async (relationshipId: string, sessionId: string, reason?: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.endSession(\n            relationshipId,\n            sessionId,\n            userId,\n            reason,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"end session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const pauseSession = useCallback(\n    async (relationshipId: string, sessionId: string, reason?: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.pauseSession(\n            relationshipId,\n            sessionId,\n            userId,\n            reason,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"pause session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const resumeSession = useCallback(\n    async (relationshipId: string, sessionId: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.resumeSession(\n            relationshipId,\n            sessionId,\n            userId,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"resume session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Set up real-time listeners for active relationship data\n  useEffect(() => {\n    // This would be called externally when activeRelationship changes\n    // The parent hook will need to manage this subscription\n  }, []);\n\n  return {\n    ...state,\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n    loadRelationshipData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipTasks.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipTasks' has too many lines (132). Maximum allowed is 75.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":192,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Task and Event Management\n * Handles creating, updating tasks and logging events\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport { RelationshipTask, RelationshipEvent } from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipTasksState extends BaseHookState {\n  tasks: RelationshipTask[];\n  events: RelationshipEvent[];\n}\n\ninterface RelationshipTasksActions extends BaseHookActions {\n  createTask: (\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n  ) => Promise<void>;\n  updateTaskStatus: (\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTask[\"status\"],\n    note?: string,\n  ) => Promise<void>;\n  logEvent: (\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n  ) => Promise<void>;\n  loadRelationshipData: (relationshipId: string) => Promise<void>;\n}\n\nexport function useRelationshipTasks(): RelationshipTasksState &\n  RelationshipTasksActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipTasksState>({\n    tasks: [],\n    events: [],\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadTasks = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const tasks =\n          await relationshipChastityService.getTasks(relationshipId);\n        setState((prev) => ({ ...prev, tasks }));\n      },\n      \"load tasks\",\n      setState,\n    );\n  }, []);\n\n  const loadEvents = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const events =\n          await relationshipChastityService.getEvents(relationshipId);\n        setState((prev) => ({ ...prev, events }));\n      },\n      \"load events\",\n      setState,\n    );\n  }, []);\n\n  const loadRelationshipData = useCallback(\n    async (relationshipId: string) => {\n      await Promise.all([\n        loadTasks(relationshipId),\n        loadEvents(relationshipId),\n      ]);\n    },\n    [loadTasks, loadEvents],\n  );\n\n  const createTask = useCallback(\n    async (\n      relationshipId: string,\n      taskData: {\n        text: string;\n        dueDate?: Date;\n        consequence?: RelationshipTask[\"consequence\"];\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.createTask(\n            relationshipId,\n            taskData,\n            userId,\n          );\n          await loadTasks(relationshipId);\n        },\n        \"create task\",\n        setState,\n      );\n    },\n    [userId, loadTasks],\n  );\n\n  const updateTaskStatus = useCallback(\n    async (\n      relationshipId: string,\n      taskId: string,\n      status: RelationshipTask[\"status\"],\n      note?: string,\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.updateTaskStatus(\n            relationshipId,\n            taskId,\n            status,\n            userId,\n            note,\n          );\n          await loadTasks(relationshipId);\n        },\n        \"update task status\",\n        setState,\n      );\n    },\n    [userId, loadTasks],\n  );\n\n  const logEvent = useCallback(\n    async (\n      relationshipId: string,\n      eventData: {\n        type: RelationshipEvent[\"type\"];\n        details: RelationshipEvent[\"details\"];\n        isPrivate?: boolean;\n        tags?: string[];\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.logEvent(\n            relationshipId,\n            eventData,\n            userId,\n          );\n          await loadEvents(relationshipId);\n        },\n        \"log event\",\n        setState,\n      );\n    },\n    [userId, loadEvents],\n  );\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Set up real-time listeners for tasks\n  useEffect(() => {\n    // This would be called externally when activeRelationship changes\n    // The parent hook will need to manage this subscription\n  }, []);\n\n  return {\n    ...state,\n    createTask,\n    updateTaskStatus,\n    logEvent,\n    loadRelationshipData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipValidation.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipValidation' has too many lines (82). Maximum allowed is 75.","line":30,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":132,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Form Validation\n * Handles validation logic for relationship forms and rules\n */\nimport { useState, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { dataMigrationService } from \"@/services/migration/DataMigrationService\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\nimport type { KeyholderPermissions } from \"@/types/core\";\n\ninterface RelationshipValidationState extends BaseHookState {\n  needsMigration: boolean;\n}\n\ninterface RelationshipValidationActions extends BaseHookActions {\n  migrateSingleUserData: () => Promise<void>;\n  checkMigrationStatus: () => Promise<void>;\n  validateRequestForm: (formData: {\n    email: string;\n    role: \"submissive\" | \"keyholder\";\n    message?: string;\n  }) => { isValid: boolean; errors: string[] };\n  validatePermissionsForm: (permissions: KeyholderPermissions) => {\n    isValid: boolean;\n    errors: string[];\n  };\n}\n\nexport function useRelationshipValidation(): RelationshipValidationState &\n  RelationshipValidationActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipValidationState>({\n    needsMigration: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const checkMigrationStatus = useCallback(async () => {\n    if (!userId) return;\n\n    try {\n      const needsMigration = await dataMigrationService.needsMigration(userId);\n      setState((prev) => ({ ...prev, needsMigration }));\n    } catch {\n      // Silent fail for migration check - using logger instead of console\n      // logger.warn(\"Failed to check migration status\", error);\n    }\n  }, [userId]);\n\n  const migrateSingleUserData = useCallback(async () => {\n    if (!userId) throw new Error(\"User not authenticated\");\n\n    return withErrorHandling(\n      async () => {\n        const result = await dataMigrationService.migrateSingleUserData(userId);\n        if (!result.success) {\n          throw new Error(result.errors.join(\", \"));\n        }\n        setState((prev) => ({ ...prev, needsMigration: false }));\n      },\n      \"migrate single user data\",\n      setState,\n    );\n  }, [userId]);\n\n  const validateRequestForm = useCallback(\n    (formData: {\n      email: string;\n      role: \"submissive\" | \"keyholder\";\n      message?: string;\n    }) => {\n      const errors: string[] = [];\n\n      if (!formData.email.trim()) {\n        errors.push(\"Email is required\");\n      } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n        errors.push(\"Email format is invalid\");\n      }\n\n      if (!formData.role) {\n        errors.push(\"Role is required\");\n      }\n\n      if (formData.message && formData.message.length > 500) {\n        errors.push(\"Message cannot exceed 500 characters\");\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n      };\n    },\n    [],\n  );\n\n  const validatePermissionsForm = useCallback(\n    (permissions: KeyholderPermissions) => {\n      const errors: string[] = [];\n\n      // Add specific validation rules for permissions\n      if (typeof permissions !== \"object\" || permissions === null) {\n        errors.push(\"Permissions must be an object\");\n      }\n\n      // Add more specific validation as needed based on RelationshipPermissions type\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n      };\n    },\n    [],\n  );\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  return {\n    ...state,\n    migrateSingleUserData,\n    checkMigrationStatus,\n    validateRequestForm,\n    validatePermissionsForm,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/security/audit-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/security/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/security/useAuditLog.ts","messages":[{"ruleId":"no-case-declarations","severity":1,"message":"Unexpected lexical declaration in case block.","line":193,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":198,"endColumn":11,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4444,4674],"text":"{ const severityOrder: Record<string, number> = {\n          low: 0,\n          medium: 1,\n          high: 2,\n          critical: 3,\n        };\n        comparison = severityOrder[a.severity] - severityOrder[b.severity];\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":246,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":246,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":246,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":246,"endColumn":38},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":247,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":247,"endColumn":18},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":247,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":247,"endColumn":33},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":248,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":248,"endColumn":22},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":248,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":248,"endColumn":37},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'createActionHandlers' has too many lines (94). Maximum allowed is 75.","line":267,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":368,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":271,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":271,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":271,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createActionHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":273,"column":21,"nodeType":"Identifier","endLine":273,"endColumn":32},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createActionHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":310,"column":28,"nodeType":"Identifier","endLine":310,"endColumn":39},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createActionHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":347,"column":30,"nodeType":"Identifier","endLine":347,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":371,"column":33,"nodeType":"Identifier","endLine":371,"endColumn":44},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":380,"column":32,"nodeType":"Identifier","endLine":380,"endColumn":43},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":389,"column":28,"nodeType":"Identifier","endLine":389,"endColumn":39},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createQueryHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":400,"column":25,"nodeType":"Identifier","endLine":400,"endColumn":36},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'createManagementHandlers' has too many lines (120). Maximum allowed is 75.","line":420,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":568,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":423,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":423,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":423,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":423,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":425,"column":24,"nodeType":"Identifier","endLine":425,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":432,"column":30,"nodeType":"Identifier","endLine":432,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":467,"column":32,"nodeType":"Identifier","endLine":467,"endColumn":43},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":498,"column":27,"nodeType":"Identifier","endLine":498,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":543,"column":31,"nodeType":"Identifier","endLine":543,"endColumn":42},{"ruleId":"no-undef","severity":1,"message":"'relationshipId' is not defined.","line":545,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":545,"endColumn":26},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"createManagementHandlers\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":556,"column":33,"nodeType":"Identifier","endLine":556,"endColumn":44},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (504). Maximum allowed is 500.","line":604,"column":1,"nodeType":null,"messageId":"exceed","endLine":608,"endColumn":1}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useAuditLog - Comprehensive Audit System Hook\n *\n * Complete audit logging system for transparency, compliance, and security monitoring\n * across all user actions.\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport {\n  AuditLogState,\n  AuditEntry,\n  AuditAction,\n  AuditCategory,\n  AuditContext,\n  AuditDetails,\n  AuditSeverity,\n  AuditOutcome,\n  AuditFilter,\n  AuditSearchQuery,\n  SecurityEvent,\n  SecurityAuditSummary,\n  ComplianceReport,\n  ExportFormat,\n  AuditExport,\n  AuditPrivacySettings,\n  CleanupResult as _CleanupResult,\n} from \"../../types/security\";\nimport { PermissionContext } from \"../../types/security\";\nimport {\n  getCategoryForAction,\n  getClientIP,\n  saveAuditEntry,\n  fetchRecentAuditEntries,\n  savePrivacySettings,\n  applyAuditFilters,\n  convertToCSV,\n  generatePDF,\n  calculateSecurityScore,\n  generateSecurityRecommendations,\n} from \"./audit-utils\";\n\ninterface UseAuditLogOptions {\n  userId: string;\n  relationshipId?: string;\n  autoLogActions?: boolean;\n  retentionDays?: number;\n}\n\nexport const useAuditLog = (options: UseAuditLogOptions) => {\n  const {\n    userId,\n    relationshipId,\n    _autoLogActions = true,\n    retentionDays = 365,\n  } = options;\n\n  // Initialize state\n  const [auditState, setAuditState] = useState<AuditLogState>(() =>\n    initializeAuditState(retentionDays),\n  );\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load recent audit entries on mount\n  useEffect(() => {\n    if (userId) {\n      loadAuditEntries(\n        userId,\n        relationshipId,\n        setAuditState,\n        setError,\n        setLoading,\n      );\n    }\n  }, [userId, relationshipId]);\n\n  // Create action handlers\n  const actionHandlers = useMemo(\n    () =>\n      createActionHandlers(userId, relationshipId, auditState, setAuditState),\n    [userId, relationshipId, auditState],\n  );\n\n  // Create query handlers\n  const queryHandlers = useMemo(\n    () => createQueryHandlers(auditState),\n    [auditState],\n  );\n\n  // Create management handlers\n  const managementHandlers = useMemo(\n    () => createManagementHandlers(userId, auditState, setAuditState),\n    [userId, auditState],\n  );\n\n  // Computed values\n  const computedValues = useMemo(\n    () => calculateComputedValues(auditState),\n    [auditState],\n  );\n\n  return {\n    // Audit data\n    recentEntries: auditState.recentEntries,\n    categories: auditState.categories,\n    filters: auditState.filters,\n    loading,\n    error,\n\n    // Action handlers\n    ...actionHandlers,\n\n    // Query handlers\n    ...queryHandlers,\n\n    // Management handlers\n    ...managementHandlers,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Search helper functions\nfunction applyTextSearch(entries: AuditEntry[], query?: string): AuditEntry[] {\n  if (!query) return entries;\n\n  const searchTerm = query.toLowerCase();\n  return entries.filter(\n    (entry) =>\n      entry.details.description.toLowerCase().includes(searchTerm) ||\n      entry.action.toLowerCase().includes(searchTerm),\n  );\n}\n\nfunction applySearchFilters(\n  entries: AuditEntry[],\n  filters?: AuditFilter,\n): AuditEntry[] {\n  if (!filters) return entries;\n\n  let results = entries;\n\n  if (filters.startDate && filters.endDate) {\n    results = results.filter(\n      (entry) =>\n        entry.timestamp >= filters.startDate! &&\n        entry.timestamp <= filters.endDate!,\n    );\n  }\n\n  if (filters.userId) {\n    results = results.filter((entry) => entry.userId === filters.userId);\n  }\n\n  if (filters.actions && filters.actions.length > 0) {\n    results = results.filter((entry) =>\n      filters.actions!.includes(entry.action),\n    );\n  }\n\n  if (filters.categories && filters.categories.length > 0) {\n    results = results.filter((entry) =>\n      filters.categories!.includes(entry.category),\n    );\n  }\n\n  if (filters.severity) {\n    results = results.filter((entry) => entry.severity === filters.severity);\n  }\n\n  if (filters.outcome) {\n    results = results.filter((entry) => entry.outcome === filters.outcome);\n  }\n\n  return results;\n}\n\nfunction applySorting(\n  entries: AuditEntry[],\n  sortBy?: string,\n  sortOrder?: \"asc\" | \"desc\",\n): AuditEntry[] {\n  if (!sortBy) return entries;\n\n  return [...entries].sort((a, b) => {\n    let comparison = 0;\n\n    switch (sortBy) {\n      case \"timestamp\":\n        comparison = a.timestamp.getTime() - b.timestamp.getTime();\n        break;\n      case \"severity\":\n        const severityOrder: Record<string, number> = {\n          low: 0,\n          medium: 1,\n          high: 2,\n          critical: 3,\n        };\n        comparison = severityOrder[a.severity] - severityOrder[b.severity];\n        break;\n      case \"category\":\n        comparison = a.category.localeCompare(b.category);\n        break;\n    }\n\n    return sortOrder === \"desc\" ? -comparison : comparison;\n  });\n}\n\nfunction applyPagination(\n  entries: AuditEntry[],\n  limit?: number,\n  offset?: number,\n): AuditEntry[] {\n  if (!limit && !offset) return entries;\n\n  const start = offset || 0;\n  const end = start + (limit || entries.length);\n  return entries.slice(start, end);\n}\n\n// Initialization and handler creation helpers\nfunction initializeAuditState(retentionDays: number): AuditLogState {\n  return {\n    recentEntries: [],\n    categories: Object.values(AuditCategory),\n    filters: {},\n    exportOptions: {\n      formats: [\"json\", \"csv\", \"pdf\"],\n      maxRecords: 10000,\n      includeMetadata: true,\n    },\n    privacySettings: {\n      shareWithKeyholder: false,\n      includeIPAddresses: false,\n      includeUserAgent: false,\n      retentionDays,\n      anonymizeAfterDays: 90,\n    },\n  };\n}\n\nasync function loadAuditEntries(\n  userId: string,\n  relationshipId: string | undefined,\n  setAuditState: React.Dispatch<React.SetStateAction<AuditLogState>>,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>,\n): Promise<void> {\n  try {\n    setIsLoading(true);\n    setError(null);\n\n    const entries = await fetchRecentAuditEntries(userId, relationshipId);\n\n    setAuditState((prev) => ({\n      ...prev,\n      recentEntries: entries,\n    }));\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to load audit log\");\n  } finally {\n    setIsLoading(false);\n  }\n}\n\nfunction createActionHandlers(\n  userId: string,\n  relationshipId: string | undefined,\n  auditState: AuditLogState,\n  setAuditState: React.Dispatch<React.SetStateAction<AuditLogState>>,\n) {\n  const logAction = useCallback(\n    async (\n      action: AuditAction,\n      details: AuditDetails,\n      context?: AuditContext,\n    ): Promise<void> => {\n      try {\n        const entry: AuditEntry = {\n          id: `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          timestamp: new Date(),\n          userId,\n          action,\n          category: getCategoryForAction(action),\n          context: context || { relationshipId },\n          details,\n          severity: AuditSeverity.LOW,\n          outcome: AuditOutcome.SUCCESS,\n          ipAddress: auditState.privacySettings.includeIPAddresses\n            ? await getClientIP()\n            : undefined,\n          userAgent: auditState.privacySettings.includeUserAgent\n            ? navigator.userAgent\n            : undefined,\n        };\n\n        await saveAuditEntry(entry);\n        setAuditState((prev) => ({\n          ...prev,\n          recentEntries: [entry, ...prev.recentEntries.slice(0, 99)],\n        }));\n      } catch {\n        // Failed to log audit action\n      }\n    },\n    [userId, relationshipId, auditState.privacySettings, setAuditState],\n  );\n\n  const logSecurityEvent = useCallback(\n    async (event: SecurityEvent): Promise<void> => {\n      const details: AuditDetails = {\n        description: event.description,\n        metadata: event.metadata,\n      };\n\n      const entry: AuditEntry = {\n        id: `security_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date(),\n        userId,\n        action: AuditAction.PERMISSION_CHECK,\n        category: AuditCategory.SECURITY,\n        context: { relationshipId },\n        details,\n        severity: event.severity,\n        outcome:\n          event.type === \"failed_login\"\n            ? AuditOutcome.FAILURE\n            : AuditOutcome.SUCCESS,\n        ipAddress: auditState.privacySettings.includeIPAddresses\n          ? await getClientIP()\n          : undefined,\n        userAgent: auditState.privacySettings.includeUserAgent\n          ? navigator.userAgent\n          : undefined,\n      };\n\n      await saveAuditEntry(entry);\n      setAuditState((prev) => ({\n        ...prev,\n        recentEntries: [entry, ...prev.recentEntries.slice(0, 99)],\n      }));\n    },\n    [userId, relationshipId, auditState.privacySettings, setAuditState],\n  );\n\n  const logPermissionCheck = useCallback(\n    async (\n      permission: string,\n      granted: boolean,\n      context?: PermissionContext,\n    ): Promise<void> => {\n      const details: AuditDetails = {\n        description: `Permission check: ${permission}`,\n        metadata: { permission, granted, context },\n      };\n\n      await logAction(\n        AuditAction.PERMISSION_CHECK,\n        details,\n        context as AuditContext,\n      );\n    },\n    [logAction],\n  );\n\n  return { logAction, logSecurityEvent, logPermissionCheck };\n}\n\nfunction createQueryHandlers(auditState: AuditLogState) {\n  const getEntriesByDateRange = useCallback(\n    async (start: Date, end: Date): Promise<AuditEntry[]> => {\n      return auditState.recentEntries.filter(\n        (entry) => entry.timestamp >= start && entry.timestamp <= end,\n      );\n    },\n    [auditState.recentEntries],\n  );\n\n  const getEntriesByCategory = useCallback(\n    async (category: AuditCategory): Promise<AuditEntry[]> => {\n      return auditState.recentEntries.filter(\n        (entry) => entry.category === category,\n      );\n    },\n    [auditState.recentEntries],\n  );\n\n  const getEntriesByUser = useCallback(\n    async (targetUserId: string): Promise<AuditEntry[]> => {\n      return auditState.recentEntries.filter(\n        (entry) =>\n          entry.userId === targetUserId ||\n          entry.context.targetUserId === targetUserId,\n      );\n    },\n    [auditState.recentEntries],\n  );\n\n  const searchEntries = useCallback(\n    async (query: AuditSearchQuery): Promise<AuditEntry[]> => {\n      let results = auditState.recentEntries;\n      results = applyTextSearch(results, query.query);\n      results = applySearchFilters(results, query.filters);\n      results = applySorting(results, query.sortBy, query.sortOrder);\n      results = applyPagination(results, query.limit, query.offset);\n      return results;\n    },\n    [auditState.recentEntries],\n  );\n\n  return {\n    getEntriesByDateRange,\n    getEntriesByCategory,\n    getEntriesByUser,\n    searchEntries,\n  };\n}\n\nfunction createManagementHandlers(\n  userId: string,\n  auditState: AuditLogState,\n  setAuditState: React.Dispatch<React.SetStateAction<AuditLogState>>,\n) {\n  const applyFilters = useCallback(\n    (filters: AuditFilter): void => {\n      setAuditState((prev) => ({ ...prev, filters }));\n    },\n    [setAuditState],\n  );\n\n  const getSecuritySummary = useCallback((): SecurityAuditSummary => {\n    const securityEntries = auditState.recentEntries.filter(\n      (entry) => entry.category === AuditCategory.SECURITY,\n    );\n\n    const failedLogins = auditState.recentEntries.filter(\n      (entry) =>\n        entry.action === AuditAction.LOGIN &&\n        entry.outcome === AuditOutcome.FAILURE,\n    ).length;\n\n    const permissionViolations = auditState.recentEntries.filter(\n      (entry) =>\n        entry.action === AuditAction.PERMISSION_CHECK &&\n        entry.outcome === AuditOutcome.UNAUTHORIZED,\n    ).length;\n\n    const dataExports = auditState.recentEntries.filter(\n      (entry) => entry.action === AuditAction.DATA_EXPORT,\n    ).length;\n\n    const lastSecurityEvent =\n      securityEntries.length > 0 ? securityEntries[0].timestamp : undefined;\n\n    return {\n      totalEntries: auditState.recentEntries.length,\n      securityEvents: securityEntries.length,\n      failedLogins,\n      permissionViolations,\n      dataExports,\n      lastSecurityEvent,\n    };\n  }, [auditState.recentEntries]);\n\n  // Get compliance report (not yet exposed in return)\n  const _getComplianceReport = useCallback((): ComplianceReport => {\n    const now = new Date();\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    const periodEntries = auditState.recentEntries.filter(\n      (entry) => entry.timestamp >= thirtyDaysAgo,\n    );\n\n    const actionsByCategory = periodEntries.reduce(\n      (acc, entry) => {\n        acc[entry.category] = (acc[entry.category] || 0) + 1;\n        return acc;\n      },\n      {} as Record<AuditCategory, number>,\n    );\n\n    const securityScore = calculateSecurityScore(periodEntries);\n\n    return {\n      period: {\n        start: thirtyDaysAgo,\n        end: now,\n      },\n      totalActions: periodEntries.length,\n      actionsByCategory,\n      securityScore,\n      recommendations: generateSecurityRecommendations(periodEntries),\n    };\n  }, [auditState.recentEntries]);\n\n  // Export audit log (not yet exposed in return)\n  const _exportAuditLog = useCallback(\n    async (\n      format: ExportFormat,\n      filters?: AuditFilter,\n    ): Promise<AuditExport> => {\n      let entries = auditState.recentEntries;\n\n      // Apply filters if provided\n      if (filters) {\n        // Implementation would filter entries based on criteria\n        entries = applyAuditFilters(entries, filters);\n      }\n\n      // Generate export data based on format\n      let data: string | Uint8Array;\n      let filename: string;\n\n      switch (format) {\n        case \"json\":\n          data = JSON.stringify(entries, null, 2);\n          filename = `audit-log-${Date.now()}.json`;\n          break;\n        case \"csv\":\n          data = convertToCSV(entries);\n          filename = `audit-log-${Date.now()}.csv`;\n          break;\n        case \"pdf\":\n          data = await generatePDF(entries);\n          filename = `audit-log-${Date.now()}.pdf`;\n          break;\n        default:\n          throw new Error(`Unsupported export format: ${format}`);\n      }\n\n      return {\n        format,\n        data,\n        filename,\n        generatedAt: new Date(),\n      };\n    },\n    [auditState.recentEntries],\n  );\n\n  // Share with keyholder (not yet exposed in return)\n  const _shareWithKeyholder = useCallback(\n    async (_entries: string[]): Promise<void> => {\n      if (!relationshipId) {\n        throw new Error(\"No relationship context for sharing\");\n      }\n\n      // In real implementation, this would share selected entries with keyholder\n      // In real implementation, this would share selected entries with keyholder\n    },\n    [],\n  );\n\n  // Update privacy settings\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<AuditPrivacySettings>): Promise<void> => {\n      setAuditState((prev) => ({\n        ...prev,\n        privacySettings: { ...prev.privacySettings, ...settings },\n      }));\n      await savePrivacySettings(userId, settings);\n    },\n    [userId, setAuditState],\n  );\n\n  return { applyFilters, getSecuritySummary, updatePrivacySettings };\n}\n\nfunction calculateComputedValues(auditState: AuditLogState) {\n  const totalEntries = auditState.recentEntries.length;\n  const securityAlerts = auditState.recentEntries.filter(\n    (entry) => entry.severity === AuditSeverity.HIGH,\n  ).length;\n\n  const lastLoginEntry = auditState.recentEntries.find(\n    (entry) => entry.action === AuditAction.LOGIN,\n  );\n  const lastLoginTime = lastLoginEntry?.timestamp;\n\n  const actionCounts = auditState.recentEntries.reduce(\n    (acc, entry) => {\n      acc[entry.action] = (acc[entry.action] || 0) + 1;\n      return acc;\n    },\n    {} as Record<string, number>,\n  );\n\n  const mostCommonActions = Object.entries(actionCounts)\n    .sort(([, a], [, b]) => b - a)\n    .slice(0, 5)\n    .map(([action, count]) => ({ action, count }));\n\n  const hasSecurityConcerns = auditState.recentEntries.some(\n    (entry) =>\n      entry.category === AuditCategory.SECURITY &&\n      entry.severity === AuditSeverity.HIGH,\n  );\n\n  return {\n    totalEntries,\n    securityAlerts,\n    lastLoginTime,\n    mostCommonActions,\n    hasSecurityConcerns,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/security/usePermissions.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (205). Maximum allowed is 75.","line":32,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":300,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * usePermissions - Granular Permission System Hook\n *\n * Provides comprehensive permission checking system that validates user permissions\n * in real-time across all application contexts.\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { UserRole } from \"../../types/core\";\nimport {\n  Permission,\n  PermissionState,\n  PermissionContext,\n  PermissionDetails,\n  PermissionHistoryEntry,\n  PermissionRequest,\n  ElevatedAccessRequest,\n  PermissionCategory,\n  PermissionLevel,\n  PermissionScope,\n  RolePermission,\n  ContextPermission,\n  PermissionCheckLog,\n} from \"../../types/security\";\n\ninterface UsePermissionsOptions {\n  userId: string;\n  context?: PermissionContext;\n  cacheEnabled?: boolean;\n  cacheTTL?: number; // milliseconds\n}\n\nexport const usePermissions = (options: UsePermissionsOptions) => {\n  const {\n    userId,\n    context,\n    cacheEnabled = true,\n    cacheTTL = 5 * 60 * 1000,\n  } = options;\n\n  // Permission state\n  const [permissionState, setPermissionState] = useState<PermissionState>({\n    userPermissions: [],\n    rolePermissions: [],\n    contextPermissions: [],\n    permissionCache: {},\n    permissionChecks: [],\n  });\n\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load user permissions on mount\n  useEffect(() => {\n    const loadPermissions = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // In a real implementation, this would fetch from your backend/Firebase\n        // For now, we'll simulate with default permissions based on user role\n        const defaultPermissions = await getDefaultPermissions(userId);\n\n        setPermissionState((prev) => ({\n          ...prev,\n          userPermissions: defaultPermissions.userPermissions,\n          rolePermissions: defaultPermissions.rolePermissions,\n          contextPermissions: defaultPermissions.contextPermissions,\n        }));\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : \"Failed to load permissions\",\n        );\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    if (userId) {\n      loadPermissions();\n    }\n  }, [userId]);\n\n  // Core permission checking function\n  const hasPermission = useCallback(\n    (permission: string, checkContext?: PermissionContext): boolean => {\n      const contextToUse = checkContext || context;\n      const cacheKey = `${permission}_${JSON.stringify(contextToUse)}`;\n\n      // Check cache first if enabled\n      if (cacheEnabled) {\n        const cached = permissionState.permissionCache[cacheKey];\n        if (cached && cached.expiresAt > new Date()) {\n          return cached.result;\n        }\n      }\n\n      const hasAccess = checkPermissionAccess(\n        permission,\n        contextToUse,\n        permissionState,\n      );\n\n      // Cache and log the result\n      cacheAndLogPermissionCheck({\n        cacheKey,\n        hasAccess,\n        permission,\n        context: contextToUse,\n        userId,\n        cacheEnabled,\n        cacheTTL,\n        setPermissionState,\n      });\n\n      return hasAccess;\n    },\n    [permissionState, context, userId, cacheEnabled, cacheTTL],\n  );\n\n  // Check multiple permissions (any)\n  const hasAnyPermission = useCallback(\n    (permissions: string[], checkContext?: PermissionContext): boolean => {\n      return permissions.some((permission) =>\n        hasPermission(permission, checkContext),\n      );\n    },\n    [hasPermission],\n  );\n\n  // Check multiple permissions (all)\n  const hasAllPermissions = useCallback(\n    (permissions: string[], checkContext?: PermissionContext): boolean => {\n      return permissions.every((permission) =>\n        hasPermission(permission, checkContext),\n      );\n    },\n    [hasPermission],\n  );\n\n  // Role-based checks\n  const hasRole = useCallback(\n    (role: UserRole): boolean => {\n      return permissionState.rolePermissions.some((rp) => rp.role === role);\n    },\n    [permissionState.rolePermissions],\n  );\n\n  // Action-based permission check\n  const canPerformAction = useCallback(\n    (action: string, target?: string): boolean => {\n      const actionPermission = `${action}${target ? `_${target}` : \"\"}`;\n      return hasPermission(actionPermission);\n    },\n    [hasPermission],\n  );\n\n  // Resource access check\n  const canAccessResource = useCallback(\n    (resource: string, action: string): boolean => {\n      return hasPermission(`${resource}_${action}`);\n    },\n    [hasPermission],\n  );\n\n  // Data modification check\n  const canModifyData = useCallback(\n    (dataType: string, ownerId: string): boolean => {\n      // Can modify own data or have admin permissions\n      return userId === ownerId || hasPermission(`${dataType}_modify_any`);\n    },\n    [hasPermission, userId],\n  );\n\n  // Permission request\n  const requestPermission = useCallback(\n    async (\n      permission: string,\n      justification: string,\n    ): Promise<PermissionRequest> => {\n      // In real implementation, this would submit to backend\n      const request: PermissionRequest = {\n        id: `req_${Date.now()}`,\n        userId,\n        permission,\n        justification,\n        status: \"pending\",\n        requestedAt: new Date(),\n      };\n\n      // Simulate async request submission\n      return new Promise((resolve) => {\n        setTimeout(() => resolve(request), 100);\n      });\n    },\n    [userId],\n  );\n\n  // Elevated access request\n  const requestElevatedAccess = useCallback(\n    async (\n      duration: number,\n      reason: string,\n    ): Promise<ElevatedAccessRequest> => {\n      const request: ElevatedAccessRequest = {\n        id: `elev_${Date.now()}`,\n        userId,\n        duration,\n        reason,\n        status: \"pending\",\n        requestedAt: new Date(),\n      };\n\n      return new Promise((resolve) => {\n        setTimeout(() => resolve(request), 100);\n      });\n    },\n    [userId],\n  );\n\n  // Get permission details\n  const getPermissionDetails = useCallback(\n    (permission: string): PermissionDetails | null => {\n      const userPerm = permissionState.userPermissions.find(\n        (p) => p.name === permission,\n      );\n      if (!userPerm) return null;\n\n      return {\n        permission: userPerm,\n        currentStatus: hasPermission(permission),\n        reasons: [\"User permission\"],\n        restrictions: [],\n        expiresAt: userPerm.expiresAt,\n      };\n    },\n    [permissionState.userPermissions, hasPermission],\n  );\n\n  // Get permission history\n  const getPermissionHistory = useCallback((): PermissionHistoryEntry[] => {\n    // In real implementation, this would fetch from backend\n    return [];\n  }, []);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    const isAdmin = hasRole(UserRole.KEYHOLDER);\n    const isKeyholder = hasRole(UserRole.KEYHOLDER);\n    const canElevate = hasPermission(\"request_elevation\");\n\n    const hasExpiredPermissions = permissionState.userPermissions.some(\n      (p) => p.expiresAt && p.expiresAt < new Date(),\n    );\n\n    const permissionLevel = calculateOverallPermissionLevel(\n      permissionState.userPermissions,\n    );\n\n    return {\n      isAdmin,\n      isKeyholder,\n      canElevate,\n      hasExpiredPermissions,\n      permissionLevel,\n    };\n  }, [permissionState.userPermissions, hasRole, hasPermission]);\n\n  return {\n    // Permission state\n    permissions: permissionState.userPermissions,\n    rolePermissions: permissionState.rolePermissions,\n    contextPermissions: permissionState.contextPermissions,\n    loading,\n    error,\n\n    // Permission checking\n    hasPermission,\n    hasAnyPermission,\n    hasAllPermissions,\n\n    // Role-based checks\n    hasRole,\n    canPerformAction,\n\n    // Context-specific checks\n    canAccessResource,\n    canModifyData,\n\n    // Permission requests\n    requestPermission,\n    requestElevatedAccess,\n\n    // Permission management\n    getPermissionDetails,\n    getPermissionHistory,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Helper functions\nfunction matchesPermission(\n  permission: Permission,\n  requested: string,\n  context?: PermissionContext,\n): boolean {\n  if (permission.name !== requested) return false;\n\n  // Check if permission is expired\n  if (permission.expiresAt && permission.expiresAt < new Date()) {\n    return false;\n  }\n\n  // Check conditions if present\n  if (permission.conditions && permission.conditions.length > 0) {\n    return permission.conditions.every((condition) =>\n      evaluateCondition(condition, context),\n    );\n  }\n\n  return true;\n}\n\nfunction contextsMatch(\n  permissionContext: PermissionContext,\n  requestContext: PermissionContext,\n): boolean {\n  return (\n    permissionContext.relationshipId === requestContext.relationshipId &&\n    permissionContext.sessionId === requestContext.sessionId &&\n    permissionContext.targetUserId === requestContext.targetUserId &&\n    permissionContext.resourceType === requestContext.resourceType &&\n    permissionContext.resourceId === requestContext.resourceId\n  );\n}\n\nfunction evaluateCondition(\n  _condition: {\n    type: string;\n    value: string | number | boolean | Date | string[];\n    operator: string;\n  },\n  _context?: PermissionContext,\n): boolean {\n  // Simplified condition evaluation\n  // In real implementation, this would be more sophisticated\n  return true;\n}\n\nfunction calculateOverallPermissionLevel(\n  permissions: Permission[],\n): PermissionLevel {\n  if (permissions.some((p) => p.level === PermissionLevel.ADMIN)) {\n    return PermissionLevel.ADMIN;\n  }\n  if (permissions.some((p) => p.level === PermissionLevel.WRITE)) {\n    return PermissionLevel.WRITE;\n  }\n  if (permissions.some((p) => p.level === PermissionLevel.READ)) {\n    return PermissionLevel.READ;\n  }\n  return PermissionLevel.NONE;\n}\n\nasync function getDefaultPermissions(_userId: string): Promise<{\n  userPermissions: Permission[];\n  rolePermissions: RolePermission[];\n  contextPermissions: ContextPermission[];\n}> {\n  // Simulate fetching default permissions\n  // In real implementation, this would query your backend\n\n  const defaultUserPermissions: Permission[] = [\n    {\n      id: \"session_manage_own\",\n      name: \"session_manage_own\",\n      category: PermissionCategory.SESSION,\n      level: PermissionLevel.WRITE,\n      scope: PermissionScope.SELF,\n    },\n    {\n      id: \"profile_edit_own\",\n      name: \"profile_edit_own\",\n      category: PermissionCategory.PROFILE,\n      level: PermissionLevel.WRITE,\n      scope: PermissionScope.SELF,\n    },\n  ];\n\n  const defaultRolePermissions: RolePermission[] = [\n    {\n      role: UserRole.SUBMISSIVE,\n      permissions: defaultUserPermissions,\n    },\n  ];\n\n  return {\n    userPermissions: defaultUserPermissions,\n    rolePermissions: defaultRolePermissions,\n    contextPermissions: [],\n  };\n}\n\n// Permission checking helper functions\nfunction checkPermissionAccess(\n  permission: string,\n  context: PermissionContext | undefined,\n  permissionState: PermissionState,\n): boolean {\n  let hasAccess = false;\n\n  // Check user permissions\n  for (const userPerm of permissionState.userPermissions) {\n    if (matchesPermission(userPerm, permission, context)) {\n      hasAccess = true;\n      break;\n    }\n  }\n\n  // Check role permissions if user permission not found\n  if (!hasAccess) {\n    for (const rolePerm of permissionState.rolePermissions) {\n      for (const perm of rolePerm.permissions) {\n        if (matchesPermission(perm, permission, context)) {\n          hasAccess = true;\n          break;\n        }\n      }\n      if (hasAccess) break;\n    }\n  }\n\n  // Check context permissions\n  if (!hasAccess && context) {\n    for (const contextPerm of permissionState.contextPermissions) {\n      if (contextsMatch(contextPerm.context, context)) {\n        for (const perm of contextPerm.permissions) {\n          if (matchesPermission(perm, permission, context)) {\n            hasAccess = true;\n            break;\n          }\n        }\n      }\n      if (hasAccess) break;\n    }\n  }\n\n  return hasAccess;\n}\n\nfunction cacheAndLogPermissionCheck(params: {\n  cacheKey: string;\n  hasAccess: boolean;\n  permission: string;\n  context: PermissionContext | undefined;\n  userId: string;\n  cacheEnabled: boolean;\n  cacheTTL: number;\n  setPermissionState: React.Dispatch<React.SetStateAction<PermissionState>>;\n}): void {\n  const {\n    cacheKey,\n    hasAccess,\n    permission,\n    context,\n    userId,\n    cacheEnabled,\n    cacheTTL,\n    setPermissionState,\n  } = params;\n  // Cache the result\n  if (cacheEnabled) {\n    setPermissionState((prev) => ({\n      ...prev,\n      permissionCache: {\n        ...prev.permissionCache,\n        [cacheKey]: {\n          result: hasAccess,\n          timestamp: new Date(),\n          expiresAt: new Date(Date.now() + cacheTTL),\n        },\n      },\n    }));\n  }\n\n  // Log the permission check\n  const checkLog: PermissionCheckLog = {\n    permission,\n    context,\n    result: hasAccess,\n    timestamp: new Date(),\n    userId,\n  };\n\n  setPermissionState((prev) => ({\n    ...prev,\n    permissionChecks: [...prev.permissionChecks.slice(-99), checkLog], // Keep last 100 checks\n  }));\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/security/useSecuritySettings.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (236). Maximum allowed is 75.","line":71,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":369,"endColumn":2}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":124,"column":36,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":124,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSecuritySettings - Security Configuration Hook\n *\n * Manages comprehensive security settings including session timeouts,\n * IP restrictions, and security policies.\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport {\n  SecuritySettingsState,\n  SessionSecuritySettings,\n  AccessControlSettings,\n  MonitoringSettings,\n  PrivacySecuritySettings,\n  DeviceInfo,\n  SecurityScore,\n  SecurityRecommendation,\n  SecurityHealthCheck,\n  SecurityIssue,\n} from \"../../types/security\";\n\ninterface UseSecuritySettingsOptions {\n  userId: string;\n  autoSave?: boolean;\n  syncInterval?: number; // minutes\n}\n\nconst defaultSessionSettings: SessionSecuritySettings = {\n  sessionTimeout: 60, // 1 hour\n  adminSessionTimeout: 30, // 30 minutes\n  requireReauthForSensitive: true,\n  logoutOnBrowserClose: false,\n  allowConcurrentSessions: true,\n  maxConcurrentSessions: 3,\n};\n\nconst defaultAccessSettings: AccessControlSettings = {\n  trustedDevices: [],\n  ipWhitelist: [],\n  geoRestrictions: [],\n  timeRestrictions: [],\n};\n\nconst defaultMonitoringSettings: MonitoringSettings = {\n  enableSecurityAlerts: true,\n  alertThresholds: [\n    {\n      type: \"failed_logins\",\n      count: 5,\n      timeWindow: 15,\n      action: \"alert\",\n    },\n    {\n      type: \"permission_violations\",\n      count: 3,\n      timeWindow: 60,\n      action: \"block\",\n    },\n  ],\n  notificationChannels: [\"in_app\"],\n  logLevel: \"standard\",\n};\n\nconst defaultPrivacySettings: PrivacySecuritySettings = {\n  shareAuditWithKeyholder: false,\n  anonymizeOldData: true,\n  dataRetentionDays: 365,\n  allowDataExport: true,\n  requirePasswordForSensitiveActions: true,\n};\n\nexport const useSecuritySettings = (options: UseSecuritySettingsOptions) => {\n  const { userId, autoSave = true } = options;\n\n  // Security settings state\n  const [securityState, setSecurityState] = useState<SecuritySettingsState>({\n    sessionSettings: defaultSessionSettings,\n    accessSettings: defaultAccessSettings,\n    monitoringSettings: defaultMonitoringSettings,\n    privacySettings: defaultPrivacySettings,\n  });\n\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);\n\n  // Load settings on mount\n  useEffect(() => {\n    const loadSettings = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // In real implementation, fetch from backend/Firebase\n        const settings = await fetchSecuritySettings(userId);\n        const mergedSettings = mergeWithDefaultSettings(settings);\n        setSecurityState(mergedSettings);\n      } catch (err) {\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to load security settings\",\n        );\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    if (userId) {\n      loadSettings();\n    }\n  }, [userId]);\n\n  // Auto-save when settings change\n  useEffect(() => {\n    if (autoSave && hasUnsavedChanges && !loading) {\n      const saveTimer = setTimeout(() => {\n        handleAutoSave(userId, securityState, setHasUnsavedChanges, setError);\n      }, 2000); // 2 second debounce\n\n      return () => clearTimeout(saveTimer);\n    }\n    // 'loading' is a state variable, not a store action - safe to include in deps\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [hasUnsavedChanges, autoSave, loading, userId, securityState]);\n\n  // Update session settings\n  const updateSessionSettings = useCallback(\n    async (settings: Partial<SessionSecuritySettings>): Promise<void> => {\n      setSecurityState((prev) => ({\n        ...prev,\n        sessionSettings: {\n          ...prev.sessionSettings,\n          ...settings,\n        },\n      }));\n      setHasUnsavedChanges(true);\n\n      if (!autoSave) {\n        await saveSecuritySettings(userId, {\n          ...securityState,\n          sessionSettings: {\n            ...securityState.sessionSettings,\n            ...settings,\n          },\n        });\n      }\n    },\n    [userId, autoSave, securityState],\n  );\n\n  // Set session timeout\n  const setSessionTimeout = useCallback(\n    async (minutes: number): Promise<void> => {\n      if (minutes < 5 || minutes > 480) {\n        // 5 minutes to 8 hours\n        throw new Error(\n          \"Session timeout must be between 5 minutes and 8 hours\",\n        );\n      }\n\n      await updateSessionSettings({ sessionTimeout: minutes });\n    },\n    [updateSessionSettings],\n  );\n\n  // Enable/disable reauthentication requirement\n  const enableReauthRequirement = useCallback(\n    async (enabled: boolean): Promise<void> => {\n      await updateSessionSettings({ requireReauthForSensitive: enabled });\n    },\n    [updateSessionSettings],\n  );\n\n  // Update access control settings\n  const updateAccessSettings = useCallback(\n    async (settings: Partial<AccessControlSettings>): Promise<void> => {\n      setSecurityState((prev) => ({\n        ...prev,\n        accessSettings: {\n          ...prev.accessSettings,\n          ...settings,\n        },\n      }));\n      setHasUnsavedChanges(true);\n\n      if (!autoSave) {\n        await saveSecuritySettings(userId, {\n          ...securityState,\n          accessSettings: {\n            ...securityState.accessSettings,\n            ...settings,\n          },\n        });\n      }\n    },\n    [userId, autoSave, securityState],\n  );\n\n  // Add trusted device\n  const addTrustedDevice = useCallback(\n    async (device: DeviceInfo): Promise<void> => {\n      const updatedDevices = [\n        ...securityState.accessSettings.trustedDevices,\n        device,\n      ];\n      await updateAccessSettings({ trustedDevices: updatedDevices });\n    },\n    [securityState.accessSettings.trustedDevices, updateAccessSettings],\n  );\n\n  // Remove trusted device\n  const removeTrustedDevice = useCallback(\n    async (deviceId: string): Promise<void> => {\n      const updatedDevices = securityState.accessSettings.trustedDevices.filter(\n        (device) => device.id !== deviceId,\n      );\n      await updateAccessSettings({ trustedDevices: updatedDevices });\n    },\n    [securityState.accessSettings.trustedDevices, updateAccessSettings],\n  );\n\n  // Update monitoring settings\n  const updateMonitoringSettings = useCallback(\n    async (settings: Partial<MonitoringSettings>): Promise<void> => {\n      setSecurityState((prev) => ({\n        ...prev,\n        monitoringSettings: {\n          ...prev.monitoringSettings,\n          ...settings,\n        },\n      }));\n      setHasUnsavedChanges(true);\n\n      if (!autoSave) {\n        await saveSecuritySettings(userId, {\n          ...securityState,\n          monitoringSettings: {\n            ...securityState.monitoringSettings,\n            ...settings,\n          },\n        });\n      }\n    },\n    [userId, autoSave, securityState],\n  );\n\n  // Enable/disable security alerts\n  const enableSecurityAlerts = useCallback(\n    async (enabled: boolean): Promise<void> => {\n      await updateMonitoringSettings({ enableSecurityAlerts: enabled });\n    },\n    [updateMonitoringSettings],\n  );\n\n  // Update privacy settings\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<PrivacySecuritySettings>): Promise<void> => {\n      setSecurityState((prev) => ({\n        ...prev,\n        privacySettings: {\n          ...prev.privacySettings,\n          ...settings,\n        },\n      }));\n      setHasUnsavedChanges(true);\n\n      if (!autoSave) {\n        await saveSecuritySettings(userId, {\n          ...securityState,\n          privacySettings: {\n            ...securityState.privacySettings,\n            ...settings,\n          },\n        });\n      }\n    },\n    [userId, autoSave, securityState],\n  );\n\n  // Get security score\n  const getSecurityScore = useCallback((): SecurityScore => {\n    return calculateSecurityScore(securityState);\n  }, [securityState]);\n\n  // Get security recommendations\n  const getSecurityRecommendations =\n    useCallback((): SecurityRecommendation[] => {\n      return generateSecurityRecommendations(securityState);\n    }, [securityState]);\n\n  // Check security health\n  const checkSecurityHealth = useCallback((): SecurityHealthCheck => {\n    const issues = findSecurityIssues(securityState);\n\n    let status: SecurityHealthCheck[\"status\"] = \"healthy\";\n    if (issues.some((issue) => issue.severity === \"critical\")) {\n      status = \"critical\";\n    } else if (issues.some((issue) => issue.severity === \"high\")) {\n      status = \"critical\";\n    } else if (issues.some((issue) => issue.severity === \"medium\")) {\n      status = \"warning\";\n    }\n\n    return {\n      status,\n      issues,\n      lastCheck: new Date(),\n      nextCheck: new Date(Date.now() + 24 * 60 * 60 * 1000), // Next day\n    };\n  }, [securityState]);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    const securityLevel = calculateSecurityLevel(\n      securityState.sessionSettings,\n      securityState.accessSettings,\n    );\n\n    const isSecure = securityLevel >= \"medium\";\n    const needsAttention = getSecurityRecommendations().some(\n      (r) => r.priority === \"high\",\n    );\n    const sessionTimeoutMinutes = securityState.sessionSettings.sessionTimeout;\n    const hasStrictSecurity = securityLevel === \"strict\";\n\n    return {\n      isSecure,\n      needsAttention,\n      sessionTimeoutMinutes,\n      hasStrictSecurity,\n    };\n  }, [securityState, getSecurityRecommendations]);\n\n  return {\n    // Settings state\n    sessionSettings: securityState.sessionSettings,\n    accessSettings: securityState.accessSettings,\n    monitoringSettings: securityState.monitoringSettings,\n    privacySettings: securityState.privacySettings,\n    loading,\n    error,\n    hasUnsavedChanges,\n\n    // Session management\n    updateSessionSettings,\n    setSessionTimeout,\n    enableReauthRequirement,\n\n    // Access control\n    updateAccessSettings,\n    addTrustedDevice,\n    removeTrustedDevice,\n\n    // Security monitoring\n    updateMonitoringSettings,\n    enableSecurityAlerts,\n\n    // Privacy controls\n    updatePrivacySettings,\n\n    // Security status\n    getSecurityScore,\n    getSecurityRecommendations,\n    checkSecurityHealth,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Helper functions\nasync function fetchSecuritySettings(\n  _userId: string,\n): Promise<Partial<SecuritySettingsState>> {\n  // In real implementation, fetch from backend/Firebase\n  // For now, return default settings\n  return {\n    sessionSettings: defaultSessionSettings,\n    accessSettings: defaultAccessSettings,\n    monitoringSettings: defaultMonitoringSettings,\n    privacySettings: defaultPrivacySettings,\n  };\n}\n\nasync function saveSecuritySettings(\n  _userId: string,\n  _settings: SecuritySettingsState,\n): Promise<void> {\n  // In real implementation, save to backend/Firebase\n}\n\nfunction calculateSecurityScore(\n  settings: SecuritySettingsState,\n): SecurityScore {\n  let authScore = 50;\n  let accessScore = 50;\n  let monitoringScore = 50;\n  let privacyScore = 50;\n\n  // Authentication scoring\n  if (settings.sessionSettings.requireReauthForSensitive) authScore += 15;\n  if (settings.sessionSettings.sessionTimeout <= 60) authScore += 10;\n  if (settings.sessionSettings.logoutOnBrowserClose) authScore += 10;\n  if (!settings.sessionSettings.allowConcurrentSessions) authScore += 15;\n\n  // Access control scoring\n  if (settings.accessSettings.trustedDevices.length > 0) accessScore += 20;\n  if (settings.accessSettings.ipWhitelist.length > 0) accessScore += 15;\n  if (settings.accessSettings.geoRestrictions.length > 0) accessScore += 10;\n  if (settings.accessSettings.timeRestrictions.length > 0) accessScore += 5;\n\n  // Monitoring scoring\n  if (settings.monitoringSettings.enableSecurityAlerts) monitoringScore += 20;\n  if (settings.monitoringSettings.logLevel === \"detailed\")\n    monitoringScore += 15;\n  if (settings.monitoringSettings.alertThresholds.length > 0)\n    monitoringScore += 15;\n\n  // Privacy scoring\n  if (settings.privacySettings.anonymizeOldData) privacyScore += 15;\n  if (settings.privacySettings.requirePasswordForSensitiveActions)\n    privacyScore += 20;\n  if (settings.privacySettings.dataRetentionDays <= 365) privacyScore += 15;\n\n  // Cap scores at 100\n  authScore = Math.min(100, authScore);\n  accessScore = Math.min(100, accessScore);\n  monitoringScore = Math.min(100, monitoringScore);\n  privacyScore = Math.min(100, privacyScore);\n\n  const overall = Math.round(\n    (authScore + accessScore + monitoringScore + privacyScore) / 4,\n  );\n\n  const recommendations = generateSecurityRecommendations(settings);\n\n  return {\n    overall,\n    breakdown: {\n      authentication: authScore,\n      access_control: accessScore,\n      monitoring: monitoringScore,\n      privacy: privacyScore,\n    },\n    recommendations,\n  };\n}\n\nfunction generateSecurityRecommendations(\n  settings: SecuritySettingsState,\n): SecurityRecommendation[] {\n  const recommendations: SecurityRecommendation[] = [];\n\n  // Session recommendations\n  if (settings.sessionSettings.sessionTimeout > 120) {\n    recommendations.push({\n      id: \"session_timeout\",\n      title: \"Reduce session timeout\",\n      description:\n        \"Consider reducing session timeout to 2 hours or less for better security\",\n      priority: \"medium\",\n      category: \"authentication\",\n      action: \"Reduce session timeout in settings\",\n    });\n  }\n\n  if (!settings.sessionSettings.requireReauthForSensitive) {\n    recommendations.push({\n      id: \"reauth_sensitive\",\n      title: \"Enable reauthentication for sensitive actions\",\n      description: \"Require password confirmation for sensitive operations\",\n      priority: \"high\",\n      category: \"authentication\",\n      action: \"Enable reauthentication requirement\",\n    });\n  }\n\n  // Access control recommendations\n  if (settings.accessSettings.trustedDevices.length === 0) {\n    recommendations.push({\n      id: \"trusted_devices\",\n      title: \"Register trusted devices\",\n      description:\n        \"Register your commonly used devices for better security tracking\",\n      priority: \"low\",\n      category: \"access_control\",\n      action: \"Add trusted devices in access control settings\",\n    });\n  }\n\n  // Monitoring recommendations\n  if (!settings.monitoringSettings.enableSecurityAlerts) {\n    recommendations.push({\n      id: \"security_alerts\",\n      title: \"Enable security alerts\",\n      description: \"Stay informed about security events with real-time alerts\",\n      priority: \"high\",\n      category: \"monitoring\",\n      action: \"Enable security alerts in monitoring settings\",\n    });\n  }\n\n  // Privacy recommendations\n  if (!settings.privacySettings.anonymizeOldData) {\n    recommendations.push({\n      id: \"anonymize_data\",\n      title: \"Enable data anonymization\",\n      description: \"Automatically anonymize old audit data for better privacy\",\n      priority: \"medium\",\n      category: \"privacy\",\n      action: \"Enable data anonymization in privacy settings\",\n    });\n  }\n\n  return recommendations;\n}\n\nfunction findSecurityIssues(settings: SecuritySettingsState): SecurityIssue[] {\n  const issues: SecurityIssue[] = [];\n\n  // Check for critical issues\n  if (settings.sessionSettings.sessionTimeout > 480) {\n    // 8 hours\n    issues.push({\n      type: \"long_session_timeout\",\n      severity: \"high\",\n      description: \"Session timeout is set to more than 8 hours\",\n      recommendation: \"Reduce session timeout to improve security\",\n      autoFixable: true,\n    });\n  }\n\n  if (!settings.sessionSettings.requireReauthForSensitive) {\n    issues.push({\n      type: \"no_reauth_required\",\n      severity: \"medium\",\n      description: \"Sensitive actions do not require reauthentication\",\n      recommendation: \"Enable reauthentication for sensitive operations\",\n      autoFixable: true,\n    });\n  }\n\n  if (!settings.monitoringSettings.enableSecurityAlerts) {\n    issues.push({\n      type: \"security_alerts_disabled\",\n      severity: \"medium\",\n      description: \"Security alerts are disabled\",\n      recommendation: \"Enable security alerts to stay informed about threats\",\n      autoFixable: true,\n    });\n  }\n\n  return issues;\n}\n\nfunction calculateSecurityLevel(\n  sessionSettings: SessionSecuritySettings,\n  accessSettings: AccessControlSettings,\n): \"low\" | \"medium\" | \"high\" | \"strict\" {\n  let score = 0;\n\n  // Session security factors\n  if (sessionSettings.requireReauthForSensitive) score += 2;\n  if (sessionSettings.sessionTimeout <= 60) score += 2;\n  if (sessionSettings.logoutOnBrowserClose) score += 1;\n  if (!sessionSettings.allowConcurrentSessions) score += 2;\n\n  // Access control factors\n  if (accessSettings.trustedDevices.length > 0) score += 1;\n  if (accessSettings.ipWhitelist.length > 0) score += 2;\n  if (accessSettings.geoRestrictions.length > 0) score += 1;\n  if (accessSettings.timeRestrictions.length > 0) score += 1;\n\n  if (score >= 8) return \"strict\";\n  if (score >= 6) return \"high\";\n  if (score >= 3) return \"medium\";\n  return \"low\";\n}\n\n// Settings management helper functions\nfunction mergeWithDefaultSettings(\n  settings: Partial<SecuritySettingsState>,\n): SecuritySettingsState {\n  return {\n    sessionSettings: {\n      ...defaultSessionSettings,\n      ...settings.sessionSettings,\n    },\n    accessSettings: {\n      ...defaultAccessSettings,\n      ...settings.accessSettings,\n    },\n    monitoringSettings: {\n      ...defaultMonitoringSettings,\n      ...settings.monitoringSettings,\n    },\n    privacySettings: {\n      ...defaultPrivacySettings,\n      ...settings.privacySettings,\n    },\n  };\n}\n\nasync function handleAutoSave(\n  userId: string,\n  securityState: SecuritySettingsState,\n  setHasUnsavedChanges: React.Dispatch<React.SetStateAction<boolean>>,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n): Promise<void> {\n  try {\n    await saveSecuritySettings(userId, securityState);\n    setHasUnsavedChanges(false);\n  } catch (err) {\n    setError(err instanceof Error ? err.message : \"Failed to save settings\");\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/types/PauseResume.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/types/SessionGoals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/types/sessionHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useCooldownState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/usePauseDurationTracking.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updatePauseDuration'. Either include it or remove the dependency array. If 'updatePauseDuration' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":26,"column":6,"nodeType":"ArrayExpression","endLine":26,"endColumn":56,"suggestions":[{"desc":"Update the dependencies array to be: [pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]","fix":{"range":[748,798],"text":"[pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pause Duration Tracking Hook\n * Tracks current pause duration with live updates\n */\nimport { useEffect } from \"react\";\nimport type { PauseStatus } from \"../../types/pauseResume\";\n\nexport function usePauseDurationTracking(\n  pauseStatus: PauseStatus,\n  updatePauseDuration: (duration: number) => void,\n) {\n  useEffect(() => {\n    if (!pauseStatus.isPaused || !pauseStatus.pauseStartTime) {\n      return;\n    }\n\n    const interval = setInterval(() => {\n      const duration = Math.floor(\n        (Date.now() - pauseStatus.pauseStartTime!.getTime()) / 1000,\n      );\n      updatePauseDuration(duration);\n    }, 1000);\n\n    return () => clearInterval(interval);\n    // updatePauseDuration should be stable (useCallback) in parent component\n  }, [pauseStatus.isPaused, pauseStatus.pauseStartTime]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/usePauseResume.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (146). Maximum allowed is 75.","line":36,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":210,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useRef } from 'react';\nimport { doc, setDoc } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} PauseEvent\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {string} reason\n * @property {number} [duration]\n */\n\n/**\n * @typedef {Object} PauseResumeState\n * @property {boolean} isPaused\n * @property {Date|null} pauseStartTime\n * @property {number} totalPauseTime\n * @property {PauseEvent[]} pauseEvents\n * @property {Date|null} cooldownEndTime\n */\n\n/**\n * @typedef {Object} PauseResumeOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {boolean} sessionActive\n * @property {Function} [onStateChange]\n */\n\n/**\n * Hook for managing session pause/resume functionality\n * @param {PauseResumeOptions} options\n * @returns {Object}\n */\nexport const usePauseResume = ({ \n  userId, \n  isAuthReady, \n  sessionActive, \n  onStateChange \n}) => {\n  const [pauseState, setPauseState] = useState({\n    isPaused: false,\n    pauseStartTime: null,\n    totalPauseTime: 0,\n    pauseEvents: [],\n    cooldownEndTime: null\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const pauseTimerRef = useRef(null);\n  const cooldownTimerRef = useRef(null);\n\n  const saveStateToFirestore = useCallback(async (newState) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { pauseResumeState: newState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save pause state');\n    }\n  }, [userId, isAuthReady]);\n\n  const pauseSession = useCallback(async (reason = 'Manual pause') => {\n    if (!sessionActive || pauseState.isPaused) {\n      setError('Cannot pause: session not active or already paused');\n      return;\n    }\n\n    // Check cooldown\n    if (pauseState.cooldownEndTime && new Date() < pauseState.cooldownEndTime) {\n      const remainingTime = Math.ceil((pauseState.cooldownEndTime.getTime() - new Date().getTime()) / 1000);\n      setError(`Pause is on cooldown. Try again in ${remainingTime} seconds.`);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const pauseStartTime = new Date();\n      const newPauseEvent = {\n        id: crypto.randomUUID(),\n        startTime: pauseStartTime,\n        reason\n      };\n\n      const newState = {\n        ...pauseState,\n        isPaused: true,\n        pauseStartTime,\n        pauseEvents: [...pauseState.pauseEvents, newPauseEvent]\n      };\n\n      setPauseState(newState);\n      await saveStateToFirestore(newState);\n      if (onStateChange) onStateChange(newState);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to pause session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionActive, pauseState, saveStateToFirestore, onStateChange]);\n\n  const resumeSession = useCallback(async () => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      setError('Cannot resume: session not paused');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const resumeTime = new Date();\n      const pauseDuration = Math.floor((resumeTime.getTime() - pauseState.pauseStartTime.getTime()) / 1000);\n\n      // Update the last pause event with end time and duration\n      const updatedPauseEvents = [...pauseState.pauseEvents];\n      const lastEventIndex = updatedPauseEvents.length - 1;\n      if (lastEventIndex >= 0) {\n        updatedPauseEvents[lastEventIndex] = {\n          ...updatedPauseEvents[lastEventIndex],\n          endTime: resumeTime,\n          duration: pauseDuration\n        };\n      }\n\n      // Set cooldown (12 hours from now)\n      const cooldownEndTime = new Date(resumeTime.getTime() + (12 * 60 * 60 * 1000));\n\n      const newState = {\n        ...pauseState,\n        isPaused: false,\n        pauseStartTime: null,\n        totalPauseTime: pauseState.totalPauseTime + pauseDuration,\n        pauseEvents: updatedPauseEvents,\n        cooldownEndTime\n      };\n\n      setPauseState(newState);\n      await saveStateToFirestore(newState);\n      if (onStateChange) onStateChange(newState);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to resume session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [pauseState, saveStateToFirestore, onStateChange]);\n\n  const getCurrentPauseDuration = useCallback(() => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      return 0;\n    }\n    return Math.floor((new Date().getTime() - pauseState.pauseStartTime.getTime()) / 1000);\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Timer to update current pause duration\n  useEffect(() => {\n    if (pauseState.isPaused && pauseState.pauseStartTime) {\n      pauseTimerRef.current = setInterval(() => {\n        // Force re-render to update current pause duration in UI\n        setPauseState(prev => ({ ...prev }));\n      }, 1000);\n    } else {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n        pauseTimerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n      }\n    };\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Cooldown timer\n  useEffect(() => {\n    if (pauseState.cooldownEndTime && pauseState.cooldownEndTime > new Date()) {\n      const timeUntilCooldownEnd = pauseState.cooldownEndTime.getTime() - new Date().getTime();\n      \n      cooldownTimerRef.current = setTimeout(() => {\n        setPauseState(prev => ({ ...prev, cooldownEndTime: null }));\n      }, timeUntilCooldownEnd);\n    }\n\n    return () => {\n      if (cooldownTimerRef.current) {\n        clearTimeout(cooldownTimerRef.current);\n      }\n    };\n  }, [pauseState.cooldownEndTime]);\n\n  return {\n    pauseState,\n    isLoading,\n    error,\n    pauseSession,\n    resumeSession,\n    getCurrentPauseDuration,\n    canPause: sessionActive && !pauseState.isPaused && (!pauseState.cooldownEndTime || new Date() >= pauseState.cooldownEndTime),\n    canResume: pauseState.isPaused\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/usePauseResume.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (298). Maximum allowed is 75.","line":58,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":428,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (28). Maximum allowed is 25.","line":58,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":428,"endColumn":2}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'sessionId'. Either include it or remove the dependency array.","line":137,"column":6,"nodeType":"ArrayExpression","endLine":137,"endColumn":61,"suggestions":[{"desc":"Update the dependencies array to be: [keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]","fix":{"range":[4185,4240],"text":"[keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'initializeKeyholderOverrides', 'loadCooldownState', 'loadPauseAnalytics', 'loadPauseHistory', and 'loadPauseState'. Either include them or remove the dependency array.","line":182,"column":6,"nodeType":"ArrayExpression","endLine":182,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]","fix":{"range":[5406,5433],"text":"[sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Pause/Resume System Hook (Refactored)\n * Provides advanced pause/resume functionality with keyholder overrides,\n * intelligent cooldown management, and comprehensive analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { PauseCooldownService } from \"../../services/PauseCooldownService\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type {\n  PauseStatus as _PauseStatus,\n  CooldownState as _CooldownState,\n  KeyholderOverrideCapabilities,\n  PauseHistoryEntry as _PauseHistoryEntry,\n  PauseAnalytics,\n  PauseReason,\n  PauseRequestStatus,\n  OverrideRequestStatus,\n  PausePattern,\n  CooldownAnalytics,\n} from \"../../types/pauseResume\";\nimport {\n  calculatePauseFrequency,\n  calculateCooldownDuration,\n  calculatePauseAnalytics,\n  analyzePausePatterns,\n  calculateCooldownEffectiveness,\n} from \"../../utils/pauseAnalytics\";\nimport {\n  calculatePauseDuration,\n  updatePauseHistoryOnResume,\n  updatePauseStatusOnResume,\n  createKeyholderOverrides,\n} from \"../../utils/pauseResumeHelpers\";\nimport { usePauseState } from \"./usePauseState\";\nimport { useCooldownState } from \"./useCooldownState\";\nimport { usePauseDurationTracking } from \"./usePauseDurationTracking\";\n\nconst logger = serviceLogger(\"usePauseResume\");\n\nconst createInitialKeyholderOverrides = (): KeyholderOverrideCapabilities => ({\n  canOverrideCooldown: false,\n  canForcePause: false,\n  canForceResume: false,\n  canModifyCooldownDuration: false,\n  requiresReason: true,\n});\n\nconst createInitialPauseAnalytics = (): PauseAnalytics => ({\n  totalPauses: 0,\n  averagePauseDuration: 0,\n  pauseFrequency: 0,\n  emergencyPauseCount: 0,\n  keyholderInitiatedCount: 0,\n  cooldownViolations: 0,\n  patterns: [],\n});\n\nexport const usePauseResume = (sessionId: string, relationshipId?: string) => {\n  // Use sub-hooks for state management\n  const {\n    pauseStatus,\n    pauseHistory,\n    setPauseStatus,\n    setPauseHistory,\n    startPause,\n    updatePauseDuration,\n  } = usePauseState(sessionId);\n\n  const { cooldownState, startCooldown, clearCooldown } = useCooldownState();\n\n  const [keyholderOverrides, setKeyholderOverrides] = useState(\n    createInitialKeyholderOverrides,\n  );\n  const [pauseAnalytics, setPauseAnalytics] = useState(\n    createInitialPauseAnalytics,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track pause duration\n  usePauseDurationTracking(pauseStatus, updatePauseDuration);\n\n  // Computed values\n  const canPause = useMemo(\n    () => !pauseStatus.isPaused && !cooldownState.isInCooldown,\n    [pauseStatus.isPaused, cooldownState.isInCooldown],\n  );\n\n  const canResume = useMemo(() => pauseStatus.isPaused, [pauseStatus.isPaused]);\n\n  const timeUntilNextPause = useMemo(() => {\n    if (!cooldownState.nextPauseAvailable) return 0;\n    return Math.max(\n      0,\n      Math.floor(\n        (cooldownState.nextPauseAvailable.getTime() - Date.now()) / 1000,\n      ),\n    );\n  }, [cooldownState.nextPauseAvailable]);\n\n  const hasKeyholderOverride = useMemo(\n    () => keyholderOverrides.canOverrideCooldown,\n    [keyholderOverrides.canOverrideCooldown],\n  );\n\n  const pauseFrequency = useMemo(\n    () => calculatePauseFrequency(pauseHistory),\n    [pauseHistory],\n  );\n\n  // Initialize keyholder overrides\n  const initializeKeyholderOverrides = useCallback(() => {\n    if (relationshipId) {\n      setKeyholderOverrides(createKeyholderOverrides());\n    }\n  }, [relationshipId]);\n\n  // Load data functions\n  const loadPauseState = useCallback(async () => {\n    // Integration with pause state service\n  }, []);\n\n  const loadCooldownState = useCallback(async () => {\n    try {\n      const cooldownInfo = await PauseCooldownService.canUserPause(sessionId);\n      if (cooldownInfo && !cooldownInfo.canPause) {\n        startCooldown(\n          cooldownInfo.cooldownRemaining || 0,\n          keyholderOverrides.canOverrideCooldown,\n        );\n      }\n    } catch (err) {\n      logger.error(\"Failed to load cooldown state\", { error: err });\n    }\n    // sessionId is a stable prop from the component, safe to omit from deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [keyholderOverrides.canOverrideCooldown, startCooldown]);\n\n  const loadPauseHistory = useCallback(async () => {\n    // Load pause history from service\n  }, []);\n\n  const loadPauseAnalytics = useCallback(async () => {\n    try {\n      const analytics = calculatePauseAnalytics(pauseHistory);\n      setPauseAnalytics(analytics);\n    } catch (err) {\n      logger.error(\"Failed to load pause analytics\", { error: err });\n    }\n  }, [pauseHistory]);\n\n  // Initialization\n  useEffect(() => {\n    const initializePauseSystem = async () => {\n      if (!sessionId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        initializeKeyholderOverrides();\n        await Promise.all([\n          loadPauseState(),\n          loadCooldownState(),\n          loadPauseHistory(),\n          loadPauseAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize pause system\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize pause system\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializePauseSystem();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId, relationshipId]);\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason: PauseReason): Promise<void> => {\n      if (!canPause) {\n        throw new Error(\"Cannot pause: either already paused or in cooldown\");\n      }\n\n      try {\n        logger.debug(\"Pausing session\", { sessionId, reason });\n        startPause(reason);\n        logger.info(\"Session paused successfully\", { sessionId, reason });\n      } catch (err) {\n        logger.error(\"Failed to pause session\", { error: err });\n        throw err;\n      }\n    },\n    [canPause, sessionId, startPause],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    if (!canResume) {\n      throw new Error(\"Cannot resume: session is not paused\");\n    }\n\n    try {\n      logger.debug(\"Resuming session\", { sessionId });\n\n      const resumeTime = new Date();\n      const duration = calculatePauseDuration(\n        pauseStatus.pauseStartTime,\n        resumeTime,\n      );\n\n      setPauseStatus(updatePauseStatusOnResume(pauseStatus));\n      setPauseHistory((prev) =>\n        updatePauseHistoryOnResume(prev, resumeTime, duration),\n      );\n\n      const cooldownDur = calculateCooldownDuration(pauseAnalytics, duration);\n      startCooldown(cooldownDur, keyholderOverrides.canOverrideCooldown);\n\n      logger.info(\"Session resumed successfully\", {\n        sessionId,\n        pauseDuration: duration,\n      });\n    } catch (err) {\n      logger.error(\"Failed to resume session\", { error: err });\n      throw err;\n    }\n  }, [\n    canResume,\n    sessionId,\n    pauseStatus,\n    pauseAnalytics,\n    keyholderOverrides.canOverrideCooldown,\n    setPauseStatus,\n    setPauseHistory,\n    startCooldown,\n  ]);\n\n  // Emergency pause\n  const requestEmergencyPause = useCallback(\n    async (reason: string): Promise<PauseRequestStatus> => {\n      try {\n        logger.debug(\"Requesting emergency pause\", { sessionId, reason });\n\n        if (cooldownState.isInCooldown) {\n          logger.warn(\"Emergency pause bypassing cooldown\", { sessionId });\n        }\n\n        await pauseSession(\"emergency\");\n\n        return {\n          approved: true,\n          reason: \"Emergency pause approved automatically\",\n          requestId: `emergency_${Date.now()}`,\n          approvedBy: \"emergency_protocol\",\n          approvedAt: new Date(),\n        };\n      } catch (err) {\n        logger.error(\"Failed to request emergency pause\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `emergency_${Date.now()}`,\n        };\n      }\n    },\n    [sessionId, cooldownState.isInCooldown, pauseSession],\n  );\n\n  // Request cooldown override\n  const requestCooldownOverride = useCallback(\n    async (justification: string): Promise<OverrideRequestStatus> => {\n      if (!relationshipId) {\n        return {\n          approved: false,\n          reason: \"Cooldown override requires keyholder relationship\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n\n      try {\n        logger.debug(\"Requesting cooldown override\", {\n          sessionId,\n          justification,\n        });\n\n        return {\n          approved: false,\n          reason: \"Override request sent to keyholder\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      } catch (err) {\n        logger.error(\"Failed to request cooldown override\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n    },\n    [sessionId, relationshipId],\n  );\n\n  // Keyholder force pause\n  const keyholderForcePause = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForcePause) {\n        throw new Error(\"Keyholder does not have force pause permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing pause\", { sessionId, reason });\n        startPause(\"keyholder_request\", \"keyholder\");\n        logger.info(\"Keyholder force pause successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force pause\", { error: err });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForcePause, sessionId, startPause],\n  );\n\n  // Keyholder force resume\n  const keyholderForceResume = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForceResume) {\n        throw new Error(\"Keyholder does not have force resume permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing resume\", { sessionId, reason });\n        await resumeSession();\n        logger.info(\"Keyholder force resume successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force resume\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForceResume, sessionId, resumeSession],\n  );\n\n  // Keyholder override cooldown\n  const keyholderOverrideCooldown = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canOverrideCooldown) {\n        throw new Error(\n          \"Keyholder does not have cooldown override permissions\",\n        );\n      }\n\n      try {\n        logger.debug(\"Keyholder overriding cooldown\", { sessionId, reason });\n        clearCooldown();\n        logger.info(\"Keyholder cooldown override successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder cooldown override\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canOverrideCooldown, sessionId, clearCooldown],\n  );\n\n  // Analytics\n  const getPausePatterns = useCallback((): PausePattern[] => {\n    return analyzePausePatterns(pauseHistory);\n  }, [pauseHistory]);\n\n  const getCooldownEffectiveness = useCallback((): CooldownAnalytics => {\n    return {\n      effectiveness: calculateCooldownEffectiveness(\n        pauseHistory,\n        cooldownState,\n      ),\n      averageCooldownDuration: cooldownState.adaptiveDuration,\n      overrideFrequency: 0,\n      adaptiveAdjustments: 0,\n    };\n  }, [pauseHistory, cooldownState]);\n\n  return {\n    // Enhanced state\n    pauseStatus,\n    cooldownState,\n    keyholderOverrides,\n    pauseAnalytics,\n\n    // Basic actions\n    pauseSession,\n    resumeSession,\n\n    // Enhanced actions\n    requestEmergencyPause,\n    requestCooldownOverride,\n\n    // Keyholder actions\n    keyholderForcePause,\n    keyholderForceResume,\n    keyholderOverrideCooldown,\n\n    // Analytics\n    getPausePatterns,\n    getCooldownEffectiveness,\n\n    // Computed values\n    canPause,\n    canResume,\n    timeUntilNextPause,\n    hasKeyholderOverride,\n    pauseFrequency,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/usePauseState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSession.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (192). Maximum allowed is 75.","line":35,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":254,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { doc, setDoc, onSnapshot, serverTimestamp } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} Session\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {boolean} isActive\n * @property {number} [duration]\n * @property {string} [reason]\n */\n\n/**\n * @typedef {Object} SessionState\n * @property {Session|null} currentSession\n * @property {boolean} isSessionActive\n * @property {Date|null} sessionStartTime\n * @property {number} elapsedTime\n */\n\n/**\n * @typedef {Object} SessionOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {Function} [onSessionChange]\n */\n\n/**\n * Hook for managing user sessions\n * @param {SessionOptions} options\n * @returns {Object}\n */\nexport const useSession = ({ userId, isAuthReady, onSessionChange }) => {\n  const [sessionState, setSessionState] = useState({\n    currentSession: null,\n    isSessionActive: false,\n    sessionStartTime: null,\n    elapsedTime: 0\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const timerRef = useRef(null);\n  const unsubscribeRef = useRef(null);\n\n  const saveSessionToFirestore = useCallback(async (sessionData) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { \n        currentSession: sessionData,\n        sessionUpdatedAt: serverTimestamp()\n      }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save session');\n    }\n  }, [userId, isAuthReady]);\n\n  const startSession = useCallback(async () => {\n    if (sessionState.isSessionActive) {\n      setError('Session already active');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const startTime = new Date();\n      const newSession = {\n        id: crypto.randomUUID(),\n        startTime,\n        isActive: true\n      };\n\n      const newState = {\n        currentSession: newSession,\n        isSessionActive: true,\n        sessionStartTime: startTime,\n        elapsedTime: 0\n      };\n\n      setSessionState(newState);\n      await saveSessionToFirestore(newSession);\n      if (onSessionChange) onSessionChange(newSession);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to start session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionState.isSessionActive, saveSessionToFirestore, onSessionChange]);\n\n  const endSession = useCallback(async (reason) => {\n    if (!sessionState.isSessionActive || !sessionState.currentSession) {\n      setError('No active session to end');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const endTime = new Date();\n      const duration = sessionState.sessionStartTime \n        ? Math.floor((endTime.getTime() - sessionState.sessionStartTime.getTime()) / 1000)\n        : 0;\n\n      const endedSession = {\n        ...sessionState.currentSession,\n        endTime,\n        isActive: false,\n        duration,\n        reason\n      };\n\n      const newState = {\n        currentSession: null,\n        isSessionActive: false,\n        sessionStartTime: null,\n        elapsedTime: 0\n      };\n\n      setSessionState(newState);\n      await saveSessionToFirestore(endedSession);\n      if (onSessionChange) onSessionChange(null);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to end session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    sessionState.isSessionActive, \n    sessionState.currentSession, \n    sessionState.sessionStartTime,\n    saveSessionToFirestore, \n    onSessionChange\n  ]);\n\n  const updateSession = useCallback(async (updates) => {\n    if (!sessionState.currentSession) {\n      setError('No active session to update');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const updatedSession = {\n        ...sessionState.currentSession,\n        ...updates\n      };\n\n      setSessionState(prev => ({\n        ...prev,\n        currentSession: updatedSession\n      }));\n\n      await saveSessionToFirestore(updatedSession);\n      if (onSessionChange) onSessionChange(updatedSession);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to update session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionState.currentSession, saveSessionToFirestore, onSessionChange]);\n\n  // Real-time session listener\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.currentSession) {\n            const session = {\n              ...data.currentSession,\n              startTime: data.currentSession.startTime?.toDate(),\n              endTime: data.currentSession.endTime?.toDate()\n            };\n\n            setSessionState(prev => ({\n              ...prev,\n              currentSession: session,\n              isSessionActive: session.isActive,\n              sessionStartTime: session.startTime\n            }));\n          } else {\n            setSessionState({\n              currentSession: null,\n              isSessionActive: false,\n              sessionStartTime: null,\n              elapsedTime: 0\n            });\n          }\n        }\n        setError(null);\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    unsubscribeRef.current = unsubscribe;\n    return () => {\n      if (unsubscribeRef.current) {\n        unsubscribeRef.current();\n      }\n    };\n  }, [userId, isAuthReady]);\n\n  // Timer for elapsed time\n  useEffect(() => {\n    if (sessionState.isSessionActive && sessionState.sessionStartTime) {\n      timerRef.current = setInterval(() => {\n        const elapsed = Math.floor((new Date().getTime() - sessionState.sessionStartTime.getTime()) / 1000);\n        setSessionState(prev => ({\n          ...prev,\n          elapsedTime: elapsed\n        }));\n      }, 1000);\n    } else {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, [sessionState.isSessionActive, sessionState.sessionStartTime]);\n\n  return {\n    sessionState,\n    isLoading,\n    error,\n    startSession,\n    endSession,\n    updateSession,\n    clearError: useCallback(() => setError(null), [])\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSession.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (338). Maximum allowed is 75.","line":132,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":562,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (28). Maximum allowed is 25.","line":132,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":562,"endColumn":2}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadAnalytics', 'loadCurrentSession', 'loadGoals', and 'loadHistory'. Either include them or remove the dependency array.","line":266,"column":6,"nodeType":"ArrayExpression","endLine":266,"endColumn":30,"suggestions":[{"desc":"Update the dependencies array to be: [userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]","fix":{"range":[7299,7323],"text":"[userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Session Management Hook\n * Provides comprehensive session management with keyholder integration,\n * goal tracking, and advanced analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { DBSession, DBGoal } from \"../../types/database\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { KeyholderRelationshipService } from \"../../services/KeyholderRelationshipService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSession\");\n\n// ==================== INTERFACES ====================\n\nexport interface SessionGoals {\n  personal: DBGoal[];\n  keyholderAssigned: DBGoal[];\n  active: DBGoal[];\n}\n\nexport interface SessionContext {\n  userId: string;\n  relationshipId?: string;\n  sessionType: \"self_managed\" | \"keyholder_managed\" | \"collaborative\";\n  permissions: SessionPermission[];\n}\n\nexport interface KeyholderInfo {\n  id: string;\n  name: string;\n  lastSeen: Date;\n}\n\nexport interface KeyholderSessionControls {\n  canModify: boolean;\n  canOverride: boolean;\n  activeKeyholder: KeyholderInfo;\n  controlHistory: ControlAction[];\n}\n\nexport interface SessionAnalytics {\n  averageSessionLength: number;\n  completionRate: number;\n  goalAchievementRate: number;\n  totalSessions: number;\n  consistencyScore: number;\n}\n\nexport interface SessionInsights {\n  predictedDuration: number;\n  optimalGoalDuration: number;\n  completionProbability: number;\n  riskFactors: string[];\n  recommendations: string[];\n}\n\nexport interface PredictiveAnalytics {\n  nextSessionPrediction: {\n    suggestedDuration: number;\n    successProbability: number;\n    recommendedGoals: string[];\n  };\n  weeklyTrend: {\n    direction: \"improving\" | \"declining\" | \"stable\";\n    confidence: number;\n  };\n}\n\nexport interface SessionHistoryEntry {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  goals: DBGoal[];\n  completedGoals: string[];\n  notes?: string;\n  rating?: number;\n}\n\nexport interface EnhancedSessionState {\n  currentSession: DBSession | null;\n  sessionContext: SessionContext;\n  keyholderControls: KeyholderSessionControls | null;\n  goals: SessionGoals;\n  history: SessionHistoryEntry[];\n  analytics: SessionAnalytics;\n}\n\nexport type SessionPermission =\n  | \"start_session\"\n  | \"end_session\"\n  | \"modify_goals\"\n  | \"pause_session\"\n  | \"self_modify\"\n  | \"override_restrictions\";\n\nexport interface ControlAction {\n  id: string;\n  action: string;\n  timestamp: Date;\n  reason?: string;\n  performedBy: \"keyholder\" | \"submissive\" | \"system\";\n}\n\nexport interface SessionModifications {\n  goalDuration?: number;\n  goals?: Partial<DBGoal>[];\n  notes?: string;\n  endReason?: string;\n}\n\nexport interface ModificationRequest {\n  id: string;\n  type: \"goal_change\" | \"early_end\" | \"time_extension\";\n  requestedBy: string;\n  reason: string;\n  details: Record<string, unknown>;\n  status: \"pending\" | \"approved\" | \"rejected\";\n  createdAt: Date;\n}\n\nexport interface ApprovalStatus {\n  approved: boolean;\n  reason?: string;\n  approvedBy?: string;\n  approvedAt?: Date;\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\nexport const useSession = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [goals, setGoals] = useState<SessionGoals>({\n    personal: [],\n    keyholderAssigned: [],\n    active: [],\n  });\n  const [_history, setHistory] = useState<SessionHistoryEntry[]>([]);\n  const [keyholderControls, setKeyholderControls] =\n    useState<KeyholderSessionControls | null>(null);\n  const [analytics, setAnalytics] = useState<SessionAnalytics>({\n    averageSessionLength: 0,\n    completionRate: 0,\n    goalAchievementRate: 0,\n    totalSessions: 0,\n    consistencyScore: 0,\n  });\n  const [relationship, setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const sessionContext = useMemo((): SessionContext => {\n    if (!userId) {\n      return {\n        userId: \"\",\n        sessionType: \"self_managed\",\n        permissions: [],\n      };\n    }\n\n    return {\n      userId,\n      relationshipId,\n      sessionType: relationshipId\n        ? keyholderControls?.canModify\n          ? \"keyholder_managed\"\n          : \"collaborative\"\n        : \"self_managed\",\n      permissions: derivePermissions(relationship, keyholderControls),\n    };\n  }, [userId, relationshipId, keyholderControls, relationship]);\n\n  const isActive = useMemo(\n    () => currentSession?.endTime == null && currentSession != null,\n    [currentSession],\n  );\n\n  const duration = useMemo(\n    () => (currentSession ? calculateDuration(currentSession) : 0),\n    [currentSession],\n  );\n\n  const goalProgress = useMemo(\n    () => calculateGoalProgress(currentSession, goals),\n    [currentSession, goals],\n  );\n\n  const isUnderKeyholderControl = useMemo(\n    () => !!relationshipId && !!keyholderControls,\n    [relationshipId, keyholderControls],\n  );\n\n  const canSelfModify = useMemo(\n    () =>\n      !keyholderControls?.canModify ||\n      sessionContext.permissions.includes(\"self_modify\"),\n    [keyholderControls, sessionContext.permissions],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSession = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship if provided\n        if (relationshipId) {\n          const relationships =\n            await KeyholderRelationshipService.getUserRelationships(userId);\n          const activeRelationship =\n            relationships.asSubmissive.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            ) ||\n            relationships.asKeyholder.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            );\n\n          setRelationship(activeRelationship || null);\n\n          if (activeRelationship) {\n            setKeyholderControls({\n              canModify:\n                activeRelationship.permissions.canLockSessions || false,\n              canOverride:\n                activeRelationship.permissions.canUnlockSessions || false,\n              activeKeyholder: {\n                id: activeRelationship.keyholderUserId,\n                name: \"Keyholder\", // Would get from user profile\n                lastSeen: new Date(),\n              },\n              controlHistory: [],\n            });\n          }\n        }\n\n        // Load current session, goals, history, and analytics\n        await Promise.all([\n          loadCurrentSession(),\n          loadGoals(),\n          loadHistory(),\n          loadAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSession();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadCurrentSession = useCallback(async () => {\n    // This would integrate with your existing session service\n    // For now, return mock data structure\n    setCurrentSession(null);\n  }, []); // userId is passed but not used in mock implementation\n\n  const loadGoals = useCallback(async () => {\n    // This would integrate with your existing goals service\n    setGoals({\n      personal: [],\n      keyholderAssigned: [],\n      active: [],\n    });\n  }, []); // userId and relationshipId are passed but not used in mock\n\n  const loadHistory = useCallback(async () => {\n    // This would integrate with your existing history service\n    setHistory([]);\n  }, []); // userId is passed but not used in mock\n\n  const loadAnalytics = useCallback(async () => {\n    // This would integrate with your existing analytics service\n    setAnalytics({\n      averageSessionLength: 0,\n      completionRate: 0,\n      goalAchievementRate: 0,\n      totalSessions: 0,\n      consistencyScore: 0,\n    });\n  }, []); // userId is passed but not used in mock\n\n  // ==================== SESSION LIFECYCLE ====================\n\n  const startSession = useCallback(\n    async (sessionGoals?: SessionGoals): Promise<DBSession> => {\n      if (!userId) throw new Error(\"User ID required to start session\");\n\n      try {\n        logger.debug(\"Starting new session\", {\n          userId,\n          hasGoals: !!sessionGoals,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"start_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to start session\");\n        }\n\n        // Create new session\n        const newSession: DBSession = {\n          id: `session_${Date.now()}`,\n          userId,\n          startTime: new Date(),\n          isPaused: false,\n          accumulatedPauseTime: 0,\n          isHardcoreMode: false,\n          keyholderApprovalRequired:\n            sessionContext.sessionType === \"keyholder_managed\",\n          syncStatus: \"pending\",\n          lastModified: new Date(),\n        };\n\n        // Add goals if provided\n        if (sessionGoals) {\n          await setGoals(sessionGoals);\n        }\n\n        setCurrentSession(newSession);\n        logger.info(\"Session started successfully\", {\n          sessionId: newSession.id,\n        });\n\n        return newSession;\n      } catch (error) {\n        logger.error(\"Failed to start session\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionContext],\n  );\n\n  const stopSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to stop\");\n\n      try {\n        logger.debug(\"Stopping session\", {\n          sessionId: currentSession.id,\n          reason,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"end_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to end session\");\n        }\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          endTime: new Date(),\n          endReason: reason,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        await loadHistory(); // Refresh history\n        await loadAnalytics(); // Refresh analytics\n\n        logger.info(\"Session stopped successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to stop session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, sessionContext, loadHistory, loadAnalytics],\n  );\n\n  // ==================== ENHANCED CONTROLS ====================\n\n  const modifySession = useCallback(\n    async (modifications: SessionModifications): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to modify\");\n\n      if (!canSelfModify) {\n        throw new Error(\"Session modification requires keyholder approval\");\n      }\n\n      try {\n        logger.debug(\"Modifying session\", {\n          sessionId: currentSession.id,\n          modifications,\n        });\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          ...modifications,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        logger.info(\"Session modified successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to modify session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, canSelfModify],\n  );\n\n  const setSessionGoals = useCallback(\n    async (sessionGoals: SessionGoals): Promise<void> => {\n      if (!sessionContext.permissions.includes(\"modify_goals\")) {\n        throw new Error(\"Goal modification requires appropriate permissions\");\n      }\n\n      try {\n        logger.debug(\"Setting session goals\", {\n          userId,\n          goalCount: sessionGoals.active.length,\n        });\n        setGoals(sessionGoals);\n        logger.info(\"Session goals updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to set session goals\", { error });\n        throw error;\n      }\n    },\n    [sessionContext.permissions, userId],\n  );\n\n  const requestModification = useCallback(\n    async (request: ModificationRequest): Promise<void> => {\n      if (!relationshipId)\n        throw new Error(\"Modification requests require active relationship\");\n\n      try {\n        logger.debug(\"Creating modification request\", {\n          requestId: request.id,\n          type: request.type,\n        });\n        // This would integrate with your notification/request system\n        logger.info(\"Modification request created successfully\", {\n          requestId: request.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to create modification request\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const requestKeyholderApproval = useCallback(\n    async (action: string): Promise<ApprovalStatus> => {\n      if (!keyholderControls) {\n        return { approved: true }; // Auto-approve if no keyholder control\n      }\n\n      try {\n        logger.debug(\"Requesting keyholder approval\", {\n          action,\n          keyholderId: keyholderControls.activeKeyholder.id,\n        });\n\n        // This would integrate with your keyholder notification system\n        // For now, return pending status\n        return {\n          approved: false,\n          reason: \"Approval request sent to keyholder\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to request keyholder approval\", { error });\n        throw error;\n      }\n    },\n    [keyholderControls],\n  );\n\n  // ==================== ANALYTICS AND INSIGHTS ====================\n\n  const getSessionInsights = useCallback((): SessionInsights => {\n    return {\n      predictedDuration: analytics.averageSessionLength,\n      optimalGoalDuration: analytics.averageSessionLength * 1.2,\n      completionProbability: analytics.completionRate,\n      riskFactors: [],\n      recommendations: [],\n    };\n  }, [analytics]);\n\n  const getPredictiveAnalytics = useCallback((): PredictiveAnalytics => {\n    return {\n      nextSessionPrediction: {\n        suggestedDuration: analytics.averageSessionLength,\n        successProbability: analytics.completionRate,\n        recommendedGoals: [\"Duration Goal\", \"Consistency Goal\"],\n      },\n      weeklyTrend: {\n        direction: \"stable\",\n        confidence: 0.8,\n      },\n    };\n  }, [analytics]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Enhanced state\n    session: currentSession,\n    context: sessionContext,\n    keyholderControls,\n    goals,\n    analytics,\n\n    // Session lifecycle\n    startSession,\n    stopSession,\n\n    // Enhanced controls\n    modifySession,\n    setGoals: setSessionGoals,\n    requestModification,\n\n    // Keyholder integration\n    requestKeyholderApproval,\n\n    // Analytics and insights\n    getSessionInsights,\n    getPredictiveAnalytics,\n\n    // Computed values\n    isActive,\n    duration,\n    goalProgress,\n    isUnderKeyholderControl,\n    canSelfModify,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction derivePermissions(\n  relationship: KeyholderRelationship | null,\n  controls: KeyholderSessionControls | null,\n): SessionPermission[] {\n  const permissions: SessionPermission[] = [];\n\n  if (!relationship || !controls) {\n    // Self-managed session - all permissions\n    return [\n      \"start_session\",\n      \"end_session\",\n      \"modify_goals\",\n      \"pause_session\",\n      \"self_modify\",\n    ];\n  }\n\n  // Keyholder-managed permissions\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"start_session\");\n  if (relationship.permissions.canUnlockSessions)\n    permissions.push(\"end_session\");\n  if (relationship.permissions.canEditGoals) permissions.push(\"modify_goals\");\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"pause_session\");\n  // Add basic self-modify permission for submissives\n  permissions.push(\"self_modify\");\n  if (controls.canOverride) permissions.push(\"override_restrictions\");\n\n  return permissions;\n}\n\nfunction calculateDuration(session: DBSession): number {\n  if (!session.startTime) return 0;\n\n  const endTime = session.endTime || new Date();\n  const totalTime = endTime.getTime() - session.startTime.getTime();\n\n  return Math.max(0, Math.floor(totalTime / 1000));\n}\n\nfunction calculateGoalProgress(\n  session: DBSession | null,\n  goals: SessionGoals,\n): number {\n  if (!session || goals.active.length === 0) return 0;\n\n  const completedGoals = goals.active.filter((goal) => goal.isCompleted).length;\n  return Math.floor((completedGoals / goals.active.length) * 100);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionActions.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionActions' has too many lines (165). Maximum allowed is 75.","line":60,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":271,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Actions Hook\n * Provides session control operations (start, end, pause, resume, lock, unlock)\n * Extracts session action logic from ActionButtons component\n */\nimport { useState, useCallback, useMemo } from \"react\";\nimport { useSession } from \"./useSession\";\nimport { usePauseResume } from \"./usePauseResume\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type { DBGoal } from \"../../types/database\";\n\nconst logger = serviceLogger(\"useSessionActions\");\n\nexport interface SessionConfig {\n  goalDuration?: number;\n  isHardcoreMode?: boolean;\n  keyholderApprovalRequired?: boolean;\n  goals?: DBGoal[];\n  notes?: string;\n}\n\nexport interface UseSessionActionsReturn {\n  // Actions\n  startSession: (config?: SessionConfig) => Promise<void>;\n  endSession: (reason?: string) => Promise<void>;\n  pauseSession: (reason?: string) => Promise<void>;\n  resumeSession: () => Promise<void>;\n\n  // State\n  isStarting: boolean;\n  isEnding: boolean;\n  isPausing: boolean;\n  isResuming: boolean;\n\n  // Permissions\n  canStart: boolean;\n  canEnd: boolean;\n  canPause: boolean;\n  canResume: boolean;\n\n  // Error handling\n  error: Error | null;\n  clearError: () => void;\n\n  // Current session info\n  isActive: boolean;\n  isPaused: boolean;\n  sessionId: string | null;\n}\n\nexport interface UseSessionActionsOptions {\n  userId: string;\n  onSessionStarted?: () => void;\n  onSessionEnded?: () => void;\n  onSessionPaused?: () => void;\n  onSessionResumed?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport function useSessionActions({\n  userId,\n  onSessionStarted,\n  onSessionEnded,\n  onSessionPaused,\n  onSessionResumed,\n  onError,\n}: UseSessionActionsOptions): UseSessionActionsReturn {\n  const [isStarting, setIsStarting] = useState(false);\n  const [isEnding, setIsEnding] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Use existing session management hooks\n  const {\n    session,\n    isActive,\n    startSession: startSessionCore,\n    stopSession: stopSessionCore,\n    canSelfModify,\n  } = useSession(userId);\n\n  const {\n    pauseStatus,\n    cooldownState,\n    pauseSession: pauseSessionCore,\n    resumeSession: resumeSessionCore,\n  } = usePauseResume(userId, session?.id);\n\n  const isPaused = pauseStatus.isPaused;\n  const isPausing = pauseStatus.pauseCount > 0 && pauseStatus.isPaused;\n  const isResuming = false; // Track this internally if needed\n\n  // Permissions\n  const canStart = useMemo(() => {\n    return !isActive && canSelfModify && !isStarting;\n  }, [isActive, canSelfModify, isStarting]);\n\n  const canEnd = useMemo(() => {\n    return isActive && canSelfModify && !isEnding;\n  }, [isActive, canSelfModify, isEnding]);\n\n  const canPause = useMemo(() => {\n    return (\n      isActive &&\n      !isPaused &&\n      pauseStatus.canResume &&\n      !cooldownState.isInCooldown\n    );\n  }, [isActive, isPaused, pauseStatus.canResume, cooldownState.isInCooldown]);\n\n  const canResume = useMemo(() => {\n    return isActive && isPaused && pauseStatus.canResume;\n  }, [isActive, isPaused, pauseStatus.canResume]);\n\n  // Clear error\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Handle errors internally\n  const handleError = useCallback(\n    (err: unknown, context: string) => {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      logger.error(`${context} failed`, { error, userId });\n      onError?.(error);\n      return error;\n    },\n    [userId, onError],\n  );\n\n  // Start session\n  const startSession = useCallback(\n    async (config?: SessionConfig): Promise<void> => {\n      if (!canStart) {\n        const err = new Error(\"Cannot start session\");\n        handleError(err, \"Start session\");\n        return;\n      }\n\n      setIsStarting(true);\n      setError(null);\n\n      try {\n        logger.debug(\"Starting session\", { userId, config });\n\n        await startSessionCore({\n          goalDuration: config?.goalDuration,\n          isHardcoreMode: config?.isHardcoreMode || false,\n          keyholderApprovalRequired: config?.keyholderApprovalRequired || false,\n          notes: config?.notes,\n        });\n\n        logger.info(\"Session started successfully\", { userId });\n        onSessionStarted?.();\n      } catch (err) {\n        handleError(err, \"Start session\");\n        throw err;\n      } finally {\n        setIsStarting(false);\n      }\n    },\n    [canStart, userId, startSessionCore, handleError, onSessionStarted],\n  );\n\n  // End session\n  const endSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!canEnd) {\n        const err = new Error(\"Cannot end session\");\n        handleError(err, \"End session\");\n        return;\n      }\n\n      setIsEnding(true);\n      setError(null);\n\n      try {\n        logger.debug(\"Ending session\", { userId, reason });\n\n        await stopSessionCore(reason || \"User ended session\");\n\n        logger.info(\"Session ended successfully\", { userId });\n        onSessionEnded?.();\n      } catch (err) {\n        handleError(err, \"End session\");\n        throw err;\n      } finally {\n        setIsEnding(false);\n      }\n    },\n    [canEnd, userId, stopSessionCore, handleError, onSessionEnded],\n  );\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!canPause) {\n        const err = new Error(\"Cannot pause session\");\n        handleError(err, \"Pause session\");\n        return;\n      }\n\n      setError(null);\n\n      try {\n        logger.debug(\"Pausing session\", { userId, reason });\n\n        await pauseSessionCore(reason || \"bathroom\");\n\n        logger.info(\"Session paused successfully\", { userId });\n        onSessionPaused?.();\n      } catch (err) {\n        handleError(err, \"Pause session\");\n        throw err;\n      }\n    },\n    [canPause, userId, pauseSessionCore, handleError, onSessionPaused],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    if (!canResume) {\n      const err = new Error(\"Cannot resume session\");\n      handleError(err, \"Resume session\");\n      return;\n    }\n\n    setError(null);\n\n    try {\n      logger.debug(\"Resuming session\", { userId });\n\n      await resumeSessionCore();\n\n      logger.info(\"Session resumed successfully\", { userId });\n      onSessionResumed?.();\n    } catch (err) {\n      handleError(err, \"Resume session\");\n      throw err;\n    }\n  }, [canResume, userId, resumeSessionCore, handleError, onSessionResumed]);\n\n  return {\n    // Actions\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n\n    // State\n    isStarting,\n    isEnding,\n    isPausing,\n    isResuming,\n\n    // Permissions\n    canStart,\n    canEnd,\n    canPause,\n    canResume,\n\n    // Error handling\n    error,\n    clearError,\n\n    // Current session info\n    isActive,\n    isPaused,\n    sessionId: session?.id || null,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionGoals.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (171). Maximum allowed is 75.","line":37,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":242,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { doc, setDoc, onSnapshot, collection, addDoc, query, orderBy, getDocs } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} Goal\n * @property {string} id\n * @property {string} title\n * @property {string} description\n * @property {number} targetDuration - in seconds\n * @property {boolean} isCompleted\n * @property {Date} createdAt\n * @property {Date} [completedAt]\n * @property {string} [reward]\n */\n\n/**\n * @typedef {Object} GoalsState\n * @property {Goal[]} goals\n * @property {Goal|null} activeGoal\n * @property {number} progress - percentage\n */\n\n/**\n * @typedef {Object} SessionGoalsOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} currentSessionDuration\n * @property {Function} [onGoalCompleted]\n */\n\n/**\n * Hook for managing session goals\n * @param {SessionGoalsOptions} options\n * @returns {Object}\n */\nexport const useSessionGoals = ({ \n  userId, \n  isAuthReady, \n  currentSessionDuration,\n  onGoalCompleted \n}) => {\n  const [goalsState, setGoalsState] = useState({\n    goals: [],\n    activeGoal: null,\n    progress: 0\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const saveGoalsToFirestore = useCallback(async (goals) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { goals }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save goals');\n    }\n  }, [userId, isAuthReady]);\n\n  const addGoal = useCallback(async (goalData) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const newGoal = {\n        ...goalData,\n        id: crypto.randomUUID(),\n        isCompleted: false,\n        createdAt: new Date()\n      };\n\n      const goalsCollection = collection(db, 'users', userId, 'goals');\n      await addDoc(goalsCollection, newGoal);\n\n      setGoalsState(prev => ({\n        ...prev,\n        goals: [...prev.goals, newGoal]\n      }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to add goal');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const completeGoal = useCallback(async (goalId) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const updatedGoals = goalsState.goals.map(goal => \n        goal.id === goalId \n          ? { ...goal, isCompleted: true, completedAt: new Date() }\n          : goal\n      );\n\n      const completedGoal = updatedGoals.find(goal => goal.id === goalId);\n      \n      setGoalsState(prev => ({\n        ...prev,\n        goals: updatedGoals,\n        activeGoal: prev.activeGoal?.id === goalId ? null : prev.activeGoal\n      }));\n\n      await saveGoalsToFirestore(updatedGoals);\n      \n      if (completedGoal && onGoalCompleted) {\n        onGoalCompleted(completedGoal);\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to complete goal');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, goalsState.goals, saveGoalsToFirestore, onGoalCompleted]);\n\n  const setActiveGoal = useCallback(async (goalId) => {\n    const activeGoal = goalId ? goalsState.goals.find(goal => goal.id === goalId) || null : null;\n    \n    setGoalsState(prev => ({\n      ...prev,\n      activeGoal\n    }));\n\n    if (userId && isAuthReady) {\n      try {\n        const userDocRef = doc(db, 'users', userId);\n        await setDoc(userDocRef, { activeGoalId: goalId }, { merge: true });\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to set active goal');\n      }\n    }\n  }, [goalsState.goals, userId, isAuthReady]);\n\n  const fetchGoals = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const goalsCollection = collection(db, 'users', userId, 'goals');\n      const q = query(goalsCollection, orderBy('createdAt', 'desc'));\n      const querySnapshot = await getDocs(q);\n      \n      const goals = querySnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id,\n        createdAt: doc.data().createdAt?.toDate() || new Date(),\n        completedAt: doc.data().completedAt?.toDate()\n      }));\n\n      setGoalsState(prev => ({ ...prev, goals }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch goals');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  // Load goals and active goal on mount\n  useEffect(() => {\n    fetchGoals();\n  }, [fetchGoals]);\n\n  // Listen for active goal updates\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.activeGoalId) {\n            const activeGoal = goalsState.goals.find(goal => goal.id === data.activeGoalId);\n            setGoalsState(prev => ({ ...prev, activeGoal: activeGoal || null }));\n          }\n        }\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [userId, isAuthReady, goalsState.goals]);\n\n  // Calculate progress for active goal\n  useEffect(() => {\n    if (goalsState.activeGoal && currentSessionDuration > 0) {\n      const progress = Math.min(\n        (currentSessionDuration / goalsState.activeGoal.targetDuration) * 100,\n        100\n      );\n      \n      setGoalsState(prev => ({ ...prev, progress }));\n\n      // Auto-complete goal if target reached\n      if (progress >= 100 && !goalsState.activeGoal.isCompleted) {\n        completeGoal(goalsState.activeGoal.id);\n      }\n    } else {\n      setGoalsState(prev => ({ ...prev, progress: 0 }));\n    }\n  }, [goalsState.activeGoal, currentSessionDuration, completeGoal]);\n\n  const getNextGoal = useCallback(() => {\n    return goalsState.goals\n      .filter(goal => !goal.isCompleted)\n      .sort((a, b) => a.targetDuration - b.targetDuration)[0] || null;\n  }, [goalsState.goals]);\n\n  return {\n    goalsState,\n    isLoading,\n    error,\n    addGoal,\n    completeGoal,\n    setActiveGoal,\n    getNextGoal,\n    refreshGoals: fetchGoals\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionGoals.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (491). Maximum allowed is 75.","line":17,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":637,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (36). Maximum allowed is 25.","line":17,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":637,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":20,"column":50,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":61},{"ruleId":"no-undef","severity":1,"message":"'GoalTemplate' is not defined.","line":21,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'GoalProgress' is not defined.","line":22,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":56},{"ruleId":"no-undef","severity":1,"message":"'KeyholderAssignedGoal' is not defined.","line":23,"column":56,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":77},{"ruleId":"no-undef","severity":1,"message":"'GoalHistoryEntry' is not defined.","line":26,"column":50,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'GoalAchievement' is not defined.","line":27,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":27,"endColumn":67},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateActiveGoalProgress'. Either include it or remove the dependency array.","line":105,"column":6,"nodeType":"ArrayExpression","endLine":105,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [activeGoals, updateActiveGoalProgress]","fix":{"range":[3337,3350],"text":"[activeGoals, updateActiveGoalProgress]"}}]},{"ruleId":"no-undef","severity":1,"message":"'GoalTemplate' is not defined.","line":121,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":121,"endColumn":36},{"ruleId":"no-undef","severity":1,"message":"'CreateGoalRequest' is not defined.","line":206,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":206,"endColumn":42},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":206,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":206,"endColumn":64},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":210,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":210,"endColumn":35},{"ruleId":"no-undef","severity":1,"message":"'GoalHistoryEntry' is not defined.","line":230,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":230,"endColumn":45},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":252,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":252,"endColumn":56},{"ruleId":"no-undef","severity":1,"message":"'GoalHistoryEntry' is not defined.","line":265,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":45},{"ruleId":"no-undef","severity":1,"message":"'GoalHistoryEntry' is not defined.","line":293,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":43},{"ruleId":"no-undef","severity":1,"message":"'GoalCompletionStatus' is not defined.","line":360,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":360,"endColumn":25},{"ruleId":"no-undef","severity":1,"message":"'GoalCompletionStatus' is not defined.","line":363,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":363,"endColumn":53},{"ruleId":"no-undef","severity":1,"message":"'ModificationRequest' is not defined.","line":444,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":444,"endColumn":72},{"ruleId":"no-undef","severity":1,"message":"'ModificationRequest' is not defined.","line":454,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":43},{"ruleId":"no-undef","severity":1,"message":"'GoalSuggestion' is not defined.","line":478,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":478,"endColumn":59},{"ruleId":"no-undef","severity":1,"message":"'GoalSuggestion' is not defined.","line":481,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":481,"endColumn":40},{"ruleId":"no-undef","severity":1,"message":"'GoalCustomization' is not defined.","line":502,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":502,"endColumn":41},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":503,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":503,"endColumn":27},{"ruleId":"no-undef","severity":1,"message":"'CreateGoalRequest' is not defined.","line":510,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":510,"endColumn":45},{"ruleId":"no-undef","severity":1,"message":"'GoalAnalytics' is not defined.","line":533,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":533,"endColumn":57},{"ruleId":"no-undef","severity":1,"message":"'PredictiveGoalSuggestion' is not defined.","line":554,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":554,"endColumn":70},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":560,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":560,"endColumn":38},{"ruleId":"no-undef","severity":1,"message":"'GoalAchievement' is not defined.","line":563,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":563,"endColumn":47},{"ruleId":"no-undef","severity":1,"message":"'GoalProgress' is not defined.","line":641,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":641,"endColumn":56},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (564). Maximum allowed is 500.","line":645,"column":1,"nodeType":null,"messageId":"exceed","endLine":723,"endColumn":1},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":650,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":650,"endColumn":55},{"ruleId":"no-undef","severity":1,"message":"'GoalDifficulty' is not defined.","line":650,"column":60,"nodeType":"Identifier","messageId":"undef","endLine":650,"endColumn":74},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":669,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":669,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'GoalProgress' is not defined.","line":670,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":670,"endColumn":25},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":690,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":690,"endColumn":49},{"ruleId":"no-undef","severity":1,"message":"'GoalProgress' is not defined.","line":690,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":690,"endColumn":64},{"ruleId":"no-undef","severity":1,"message":"'SessionGoal' is not defined.","line":704,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":704,"endColumn":20},{"ruleId":"no-undef","severity":1,"message":"'GoalProgress' is not defined.","line":705,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":705,"endColumn":25}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadAchievements', 'loadActiveGoals', 'loadGoalHistory', 'loadGoalTemplates', 'loadKeyholderGoals', and 'loadProgress'. Either include them or remove the dependency array.","line":94,"column":6,"nodeType":"ArrayExpression","endLine":94,"endColumn":30,"suggestions":[{"desc":"Update the dependencies array to be: [userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]","fix":{"range":[2974,2998],"text":"[userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":39,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Goals Management Hook\n * Provides comprehensive goal management with keyholder controls,\n * progress tracking, and achievement integration\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSessionGoals\");\n\n// ==================== INTERFACES ====================\n\nimport type * as _Types from \"./types/SessionGoals\";\nexport type * from \"./types/SessionGoals\";\n\nexport const useSessionGoals = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [activeGoals, setActiveGoals] = useState<SessionGoal[]>([]);\n  const [goalTemplates, setGoalTemplates] = useState<GoalTemplate[]>([]);\n  const [progress, setProgress] = useState<GoalProgress[]>([]);\n  const [keyholderGoals, setKeyholderGoals] = useState<KeyholderAssignedGoal[]>(\n    [],\n  );\n  const [goalHistory, setGoalHistory] = useState<GoalHistoryEntry[]>([]);\n  const [achievements, setAchievements] = useState<GoalAchievement[]>([]);\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalActiveGoals = useMemo(() => activeGoals.length, [activeGoals]);\n\n  const completionRate = useMemo(\n    () => calculateCompletionRate(progress),\n    [progress],\n  );\n\n  const hasRequiredGoals = useMemo(\n    () => activeGoals.some((goal) => goal.isRequired),\n    [activeGoals],\n  );\n\n  const goalDifficulty = useMemo(\n    () => calculateOverallDifficulty(activeGoals),\n    [activeGoals],\n  );\n\n  const estimatedCompletionTime = useMemo(\n    () => predictCompletionTime(activeGoals, progress),\n    [activeGoals, progress],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeGoals = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // This would load keyholder goals and permissions\n        }\n\n        // Load all goal-related data\n        await Promise.all([\n          loadActiveGoals(),\n          loadGoalTemplates(),\n          loadProgress(),\n          loadKeyholderGoals(),\n          loadGoalHistory(),\n          loadAchievements(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize goals\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize goals\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeGoals();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== PROGRESS TRACKING ====================\n\n  useEffect(() => {\n    const updateProgressInterval = setInterval(() => {\n      updateActiveGoalProgress();\n    }, 30000); // Update every 30 seconds\n\n    return () => clearInterval(updateProgressInterval);\n    // updateActiveGoalProgress is stable (useCallback)\n  }, [activeGoals]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadActiveGoals = useCallback(async () => {\n    try {\n      // This would integrate with your goal database service\n      setActiveGoals([]);\n    } catch (error) {\n      logger.error(\"Failed to load active goals\", { error });\n    }\n  }, []); // userId is passed but not used in mock\n\n  const loadGoalTemplates = useCallback(async () => {\n    try {\n      // Load pre-defined goal templates\n      const templates: GoalTemplate[] = [\n        {\n          id: \"duration_24h\",\n          name: \"24 Hour Challenge\",\n          description: \"Complete a full 24-hour session without breaks\",\n          category: \"session_length\",\n          defaultTarget: {\n            value: 24,\n            unit: \"hours\",\n            comparison: \"minimum\",\n          },\n          difficulty: \"intermediate\",\n          estimatedDuration: 1440,\n          tags: [\"endurance\", \"milestone\"],\n          isPopular: true,\n        },\n        {\n          id: \"consistency_7day\",\n          name: \"7-Day Consistency\",\n          description: \"Complete daily sessions for 7 consecutive days\",\n          category: \"daily_goals\",\n          defaultTarget: {\n            value: 7,\n            unit: \"days\",\n            comparison: \"exact\",\n          },\n          difficulty: \"beginner\",\n          estimatedDuration: 10080,\n          tags: [\"consistency\", \"habit\"],\n          isPopular: true,\n        },\n      ];\n\n      setGoalTemplates(templates);\n    } catch (error) {\n      logger.error(\"Failed to load goal templates\", { error });\n    }\n  }, []);\n\n  const loadProgress = useCallback(async () => {\n    try {\n      // Calculate progress for all active goals\n      const progressData = activeGoals.map((goal) =>\n        calculateGoalProgress(goal),\n      );\n      setProgress(progressData);\n    } catch (error) {\n      logger.error(\"Failed to load goal progress\", { error });\n    }\n  }, [activeGoals]);\n\n  const loadKeyholderGoals = useCallback(async () => {\n    try {\n      if (!relationshipId) {\n        setKeyholderGoals([]);\n        return;\n      }\n      // Load goals assigned by keyholder\n      setKeyholderGoals([]);\n    } catch (error) {\n      logger.error(\"Failed to load keyholder goals\", { error });\n    }\n  }, [relationshipId]);\n\n  const loadGoalHistory = useCallback(async () => {\n    try {\n      // Load historical goal data\n      setGoalHistory([]);\n    } catch (error) {\n      logger.error(\"Failed to load goal history\", { error });\n    }\n  }, []);\n\n  const loadAchievements = useCallback(async () => {\n    try {\n      // Load goal-related achievements\n      setAchievements([]);\n    } catch (error) {\n      logger.error(\"Failed to load achievements\", { error });\n    }\n  }, []);\n\n  // ==================== GOAL MANAGEMENT ====================\n\n  const setGoal = useCallback(\n    async (goalRequest: CreateGoalRequest): Promise<SessionGoal> => {\n      try {\n        logger.debug(\"Creating new goal\", { userId, goalRequest });\n\n        const newGoal: SessionGoal = {\n          id: `goal_${Date.now()}`,\n          type: goalRequest.type,\n          category: goalRequest.category,\n          target: goalRequest.target,\n          current: 0,\n          progress: 0,\n          assignedBy: \"self\",\n          isRequired: goalRequest.isRequired || false,\n          deadline: goalRequest.deadline,\n          priority: goalRequest.priority,\n          status: \"active\",\n          createdAt: new Date(),\n          description: goalRequest.description,\n          tags: goalRequest.tags,\n        };\n\n        setActiveGoals((prev) => [...prev, newGoal]);\n\n        // Add to history\n        const historyEntry: GoalHistoryEntry = {\n          id: `history_${Date.now()}`,\n          goalId: newGoal.id,\n          action: \"created\",\n          timestamp: new Date(),\n          details: { goalRequest },\n          performedBy: \"submissive\",\n        };\n\n        setGoalHistory((prev) => [...prev, historyEntry]);\n\n        logger.info(\"Goal created successfully\", { goalId: newGoal.id });\n        return newGoal;\n      } catch (error) {\n        logger.error(\"Failed to create goal\", { error });\n        throw error;\n      }\n    },\n    [userId],\n  );\n\n  const updateGoal = useCallback(\n    async (goalId: string, updates: Partial<SessionGoal>): Promise<void> => {\n      try {\n        logger.debug(\"Updating goal\", { goalId, updates });\n\n        setActiveGoals((prev) =>\n          prev.map((goal) =>\n            goal.id === goalId\n              ? { ...goal, ...updates, updatedAt: new Date() }\n              : goal,\n          ),\n        );\n\n        // Add to history\n        const historyEntry: GoalHistoryEntry = {\n          id: `history_${Date.now()}`,\n          goalId,\n          action: \"updated\",\n          timestamp: new Date(),\n          details: { updates },\n          performedBy: \"submissive\",\n        };\n\n        setGoalHistory((prev) => [...prev, historyEntry]);\n\n        logger.info(\"Goal updated successfully\", { goalId });\n      } catch (error) {\n        logger.error(\"Failed to update goal\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const removeGoal = useCallback(async (goalId: string): Promise<void> => {\n    try {\n      logger.debug(\"Removing goal\", { goalId });\n\n      setActiveGoals((prev) => prev.filter((goal) => goal.id !== goalId));\n      setProgress((prev) => prev.filter((p) => p.goalId !== goalId));\n\n      // Add to history\n      const historyEntry: GoalHistoryEntry = {\n        id: `history_${Date.now()}`,\n        goalId,\n        action: \"abandoned\",\n        timestamp: new Date(),\n        details: {},\n        performedBy: \"submissive\",\n      };\n\n      setGoalHistory((prev) => [...prev, historyEntry]);\n\n      logger.info(\"Goal removed successfully\", { goalId });\n    } catch (error) {\n      logger.error(\"Failed to remove goal\", { error });\n      throw error;\n    }\n  }, []);\n\n  // ==================== PROGRESS TRACKING ====================\n\n  const updateProgress = useCallback(\n    async (goalId: string, progressValue: number): Promise<void> => {\n      try {\n        logger.debug(\"Updating goal progress\", { goalId, progressValue });\n\n        setProgress((prev) =>\n          prev.map((p) =>\n            p.goalId === goalId\n              ? {\n                  ...p,\n                  currentValue: progressValue,\n                  progressPercentage: Math.min(\n                    100,\n                    (progressValue / p.targetValue) * 100,\n                  ),\n                  lastUpdated: new Date(),\n                }\n              : p,\n          ),\n        );\n\n        // Update the goal's current value\n        setActiveGoals((prev) =>\n          prev.map((goal) =>\n            goal.id === goalId\n              ? {\n                  ...goal,\n                  current: progressValue,\n                  progress: Math.min(\n                    100,\n                    (progressValue / goal.target.value) * 100,\n                  ),\n                }\n              : goal,\n          ),\n        );\n\n        logger.debug(\"Goal progress updated\", { goalId, progressValue });\n      } catch (error) {\n        logger.error(\"Failed to update goal progress\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const checkGoalCompletion = useCallback(async (): Promise<\n    GoalCompletionStatus[]\n  > => {\n    try {\n      const completionStatuses: GoalCompletionStatus[] = [];\n\n      for (const goal of activeGoals) {\n        const goalProgress = progress.find((p) => p.goalId === goal.id);\n        if (!goalProgress) continue;\n\n        const isCompleted = checkIfGoalCompleted(goal, goalProgress);\n        const completionPercentage = goalProgress.progressPercentage;\n\n        completionStatuses.push({\n          goalId: goal.id,\n          isCompleted,\n          completionPercentage,\n          timeRemaining: goalProgress.estimatedCompletion\n            ? Math.max(\n                0,\n                goalProgress.estimatedCompletion.getTime() - Date.now(),\n              ) / 1000\n            : undefined,\n          canComplete: goal.status === \"active\",\n          blockers: [],\n        });\n\n        // If goal is completed, update its status\n        if (isCompleted && goal.status !== \"completed\") {\n          await updateGoal(goal.id, {\n            status: \"completed\",\n            completedAt: new Date(),\n          });\n\n          // Check for achievements\n          await checkForAchievements(goal);\n        }\n      }\n\n      return completionStatuses;\n    } catch (error) {\n      logger.error(\"Failed to check goal completion\", { error });\n      return [];\n    }\n  }, [activeGoals, progress, updateGoal, checkForAchievements]);\n\n  const updateActiveGoalProgress = useCallback(async () => {\n    try {\n      // This would calculate progress based on current session data\n      // For now, just trigger completion check\n      await checkGoalCompletion();\n    } catch (error) {\n      logger.error(\"Failed to update active goal progress\", { error });\n    }\n  }, [checkGoalCompletion]);\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const acceptKeyholderGoal = useCallback(\n    async (goalId: string): Promise<void> => {\n      try {\n        logger.debug(\"Accepting keyholder goal\", { goalId });\n\n        const keyholderGoal = keyholderGoals.find((g) => g.id === goalId);\n        if (!keyholderGoal) {\n          throw new Error(\"Keyholder goal not found\");\n        }\n\n        // Move from keyholder goals to active goals\n        setActiveGoals((prev) => [\n          ...prev,\n          { ...keyholderGoal, assignedBy: \"keyholder\" },\n        ]);\n        setKeyholderGoals((prev) => prev.filter((g) => g.id !== goalId));\n\n        logger.info(\"Keyholder goal accepted\", { goalId });\n      } catch (error) {\n        logger.error(\"Failed to accept keyholder goal\", { error });\n        throw error;\n      }\n    },\n    [keyholderGoals],\n  );\n\n  const requestGoalModification = useCallback(\n    async (goalId: string, reason: string): Promise<ModificationRequest> => {\n      if (!relationshipId) {\n        throw new Error(\n          \"Goal modification requests require keyholder relationship\",\n        );\n      }\n\n      try {\n        logger.debug(\"Requesting goal modification\", { goalId, reason });\n\n        const request: ModificationRequest = {\n          id: `mod_req_${Date.now()}`,\n          goalId,\n          requestedChanges: {}, // Would be populated with specific changes\n          reason,\n          status: \"pending\",\n          createdAt: new Date(),\n        };\n\n        // This would send the request to the keyholder\n        logger.info(\"Goal modification request created\", {\n          requestId: request.id,\n        });\n        return request;\n      } catch (error) {\n        logger.error(\"Failed to request goal modification\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== TEMPLATES AND SUGGESTIONS ====================\n\n  const getSuggestedGoals = useCallback((): GoalSuggestion[] => {\n    try {\n      // Analyze user history and preferences to suggest goals\n      const suggestions: GoalSuggestion[] = goalTemplates\n        .filter((template) => template.isPopular)\n        .map((template) => ({\n          templateId: template.id,\n          name: template.name,\n          description: template.description,\n          reasonForSuggestion: \"Popular template for your experience level\",\n          confidence: 80,\n          basedOn: \"trending\" as const,\n        }));\n\n      return suggestions;\n    } catch (error) {\n      logger.error(\"Failed to get suggested goals\", { error });\n      return [];\n    }\n  }, [goalTemplates]);\n\n  const createGoalFromTemplate = useCallback(\n    async (\n      templateId: string,\n      customizations?: GoalCustomization,\n    ): Promise<SessionGoal> => {\n      try {\n        const template = goalTemplates.find((t) => t.id === templateId);\n        if (!template) {\n          throw new Error(\"Goal template not found\");\n        }\n\n        const goalRequest: CreateGoalRequest = {\n          type: \"duration\", // Map from template\n          category: template.category,\n          target: customizations?.target\n            ? { ...template.defaultTarget, ...customizations.target }\n            : template.defaultTarget,\n          priority: customizations?.priority || \"medium\",\n          deadline: customizations?.deadline,\n          description: customizations?.description || template.description,\n          tags: customizations?.tags || template.tags,\n        };\n\n        return await setGoal(goalRequest);\n      } catch (error) {\n        logger.error(\"Failed to create goal from template\", { error });\n        throw error;\n      }\n    },\n    [goalTemplates, setGoal],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getGoalAnalytics = useCallback((): GoalAnalytics => {\n    const completedGoals = goalHistory.filter((h) => h.action === \"completed\");\n    const totalGoals = goalHistory.filter((h) => h.action === \"created\");\n\n    return {\n      completionRate:\n        totalGoals.length > 0\n          ? (completedGoals.length / totalGoals.length) * 100\n          : 0,\n      averageCompletionTime: 0, // Calculate from history\n      mostSuccessfulCategories: [],\n      challengingCategories: [],\n      streakData: {\n        current: 0,\n        best: 0,\n        type: \"daily_completion\",\n      },\n      improvementTrends: [],\n    };\n  }, [goalHistory]);\n\n  const getPredictiveGoals = useCallback((): PredictiveGoalSuggestion[] => {\n    // AI-powered goal suggestions based on user data\n    return [];\n  }, []);\n\n  const checkForAchievements = useCallback(\n    async (completedGoal: SessionGoal): Promise<void> => {\n      try {\n        // Check if goal completion unlocks any achievements\n        const newAchievements: GoalAchievement[] = [];\n\n        // Example achievement checks\n        if (\n          completedGoal.type === \"duration\" &&\n          completedGoal.target.value >= 24\n        ) {\n          newAchievements.push({\n            id: `achievement_${Date.now()}`,\n            goalId: completedGoal.id,\n            name: \"Endurance Master\",\n            description: \"Completed a 24+ hour goal\",\n            earnedAt: new Date(),\n            category: \"endurance\",\n            points: 100,\n            rarity: \"uncommon\",\n          });\n        }\n\n        if (newAchievements.length > 0) {\n          setAchievements((prev) => [...prev, ...newAchievements]);\n          logger.info(\"New achievements unlocked\", {\n            count: newAchievements.length,\n          });\n        }\n      } catch (error) {\n        logger.error(\"Failed to check for achievements\", { error });\n      }\n    },\n    [],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Goals state\n    activeGoals,\n    goalTemplates,\n    progress,\n    keyholderGoals,\n    achievements,\n\n    // Goal management\n    setGoal,\n    updateGoal,\n    removeGoal,\n\n    // Progress tracking\n    updateProgress,\n    checkGoalCompletion,\n\n    // Keyholder integration\n    acceptKeyholderGoal,\n    requestGoalModification,\n\n    // Templates and suggestions\n    getSuggestedGoals,\n    createGoalFromTemplate,\n\n    // Analytics\n    getGoalAnalytics,\n    getPredictiveGoals,\n\n    // Computed values\n    totalActiveGoals,\n    completionRate,\n    hasRequiredGoals,\n    goalDifficulty,\n    estimatedCompletionTime,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction calculateCompletionRate(progress: GoalProgress[]): number {\n  if (progress.length === 0) return 0;\n\n  const completedGoals = progress.filter(\n    (p) => p.progressPercentage >= 100,\n  ).length;\n  return Math.floor((completedGoals / progress.length) * 100);\n}\n\nfunction calculateOverallDifficulty(goals: SessionGoal[]): GoalDifficulty {\n  if (goals.length === 0) return \"beginner\";\n\n  // Simple difficulty calculation based on goal types and targets\n  const highPriorityGoals = goals.filter(\n    (g) => g.priority === \"high\" || g.priority === \"critical\",\n  ).length;\n  const complexGoals = goals.filter(\n    (g) => g.type === \"behavioral\" || g.type === \"performance\",\n  ).length;\n\n  if (highPriorityGoals > 2 || complexGoals > 1) return \"expert\";\n  if (highPriorityGoals > 1 || complexGoals > 0) return \"advanced\";\n  if (goals.length > 3) return \"intermediate\";\n\n  return \"beginner\";\n}\n\nfunction predictCompletionTime(\n  goals: SessionGoal[],\n  progress: GoalProgress[],\n): number {\n  if (goals.length === 0 || progress.length === 0) return 0;\n\n  // Calculate estimated completion time based on current progress velocity\n  let totalEstimatedTime = 0;\n\n  for (const goalProgress of progress) {\n    if (goalProgress.progressPercentage >= 100) continue;\n\n    const remainingProgress = 100 - goalProgress.progressPercentage;\n    const velocity = goalProgress.velocity || 1; // Progress per hour\n    const estimatedHours = remainingProgress / velocity;\n\n    totalEstimatedTime = Math.max(totalEstimatedTime, estimatedHours);\n  }\n\n  return Math.floor(totalEstimatedTime * 60); // Return in minutes\n}\n\nfunction calculateGoalProgress(goal: SessionGoal): GoalProgress {\n  return {\n    goalId: goal.id,\n    currentValue: goal.current,\n    targetValue: goal.target.value,\n    progressPercentage: goal.progress,\n    milestones: [], // Would be populated with actual milestones\n    lastUpdated: new Date(),\n    velocity: 1, // Would be calculated from historical data\n    estimatedCompletion: goal.deadline,\n  };\n}\n\nfunction checkIfGoalCompleted(\n  goal: SessionGoal,\n  progress: GoalProgress,\n): boolean {\n  switch (goal.target.comparison) {\n    case \"minimum\":\n      return progress.currentValue >= goal.target.value;\n    case \"exact\":\n      return progress.currentValue === goal.target.value;\n    case \"maximum\":\n      return progress.currentValue <= goal.target.value;\n    case \"range\":\n      return (\n        progress.currentValue >= goal.target.value &&\n        progress.currentValue <= (goal.target.rangeMax || goal.target.value)\n      );\n    default:\n      return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionHistory.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (179). Maximum allowed is 75.","line":38,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":243,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { collection, query, orderBy, limit, startAfter, getDocs, doc, deleteDoc } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} HistorySession\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} endTime\n * @property {number} duration\n * @property {string} [reason]\n * @property {Array} [pauseEvents]\n * @property {number} [totalPauseTime]\n * @property {number} [netDuration] - duration minus pause time\n */\n\n/**\n * @typedef {Object} HistoryFilters\n * @property {Object} [dateRange]\n * @property {Date} dateRange.start\n * @property {Date} dateRange.end\n * @property {number} [minDuration]\n * @property {number} [maxDuration]\n */\n\n/**\n * @typedef {Object} SessionHistoryOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} [pageSize=20]\n */\n\n/**\n * Hook for managing session history\n * @param {SessionHistoryOptions} options\n * @returns {Object}\n */\nexport const useSessionHistory = ({ \n  userId, \n  isAuthReady, \n  pageSize = 20 \n}) => {\n  const [sessions, setSessions] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [filters, setFilters] = useState({});\n\n  const fetchSessions = useCallback(async (\n    append = false, \n    lastDoc\n  ) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const historyCollection = collection(db, 'users', userId, 'sessionHistory');\n      let q = query(\n        historyCollection, \n        orderBy('startTime', 'desc'),\n        limit(pageSize)\n      );\n\n      if (lastDoc) {\n        q = query(\n          historyCollection,\n          orderBy('startTime', 'desc'),\n          startAfter(lastDoc),\n          limit(pageSize)\n        );\n      }\n\n      const querySnapshot = await getDocs(q);\n      const newSessions = querySnapshot.docs.map(doc => {\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          startTime: data.startTime?.toDate() || new Date(),\n          endTime: data.endTime?.toDate() || new Date(),\n          pauseEvents: data.pauseEvents?.map((event) => ({\n            ...event,\n            startTime: event.startTime?.toDate(),\n            endTime: event.endTime?.toDate()\n          })) || []\n        };\n      });\n\n      // Apply filters\n      const filteredSessions = newSessions.filter(session => {\n        if (filters.dateRange) {\n          const sessionDate = session.startTime;\n          if (sessionDate < filters.dateRange.start || sessionDate > filters.dateRange.end) {\n            return false;\n          }\n        }\n        \n        if (filters.minDuration && session.duration < filters.minDuration) {\n          return false;\n        }\n        \n        if (filters.maxDuration && session.duration > filters.maxDuration) {\n          return false;\n        }\n        \n        return true;\n      });\n\n      setSessions(prev => append ? [...prev, ...filteredSessions] : filteredSessions);\n      setHasMore(querySnapshot.docs.length === pageSize);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch session history');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, pageSize, filters]);\n\n  const loadMore = useCallback(() => {\n    if (sessions.length > 0 && hasMore && !isLoading) {\n      const lastSession = sessions[sessions.length - 1];\n      fetchSessions(true, lastSession);\n    }\n  }, [sessions, hasMore, isLoading, fetchSessions]);\n\n  const deleteSession = useCallback(async (sessionId) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const sessionDocRef = doc(db, 'users', userId, 'sessionHistory', sessionId);\n      await deleteDoc(sessionDocRef);\n      \n      setSessions(prev => prev.filter(session => session.id !== sessionId));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to delete session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const updateFilters = useCallback((newFilters) => {\n    setFilters(newFilters);\n    setSessions([]);\n    setHasMore(true);\n  }, []);\n\n  const getStatistics = useCallback(() => {\n    const totalSessions = sessions.length;\n    const totalDuration = sessions.reduce((acc, session) => acc + session.duration, 0);\n    const averageDuration = totalSessions > 0 ? totalDuration / totalSessions : 0;\n    const longestSession = sessions.reduce((max, session) => \n      Math.max(max, session.duration), 0);\n    const shortestSession = sessions.reduce((min, session) => \n      Math.min(min, session.duration), Infinity);\n\n    // Calculate net duration (excluding pause time)\n    const totalNetDuration = sessions.reduce((acc, session) => {\n      const pauseTime = session.totalPauseTime || 0;\n      return acc + (session.duration - pauseTime);\n    }, 0);\n    const averageNetDuration = totalSessions > 0 ? totalNetDuration / totalSessions : 0;\n\n    return {\n      totalSessions,\n      totalDuration,\n      averageDuration,\n      longestSession: longestSession === 0 ? 0 : longestSession,\n      shortestSession: shortestSession === Infinity ? 0 : shortestSession,\n      totalNetDuration,\n      averageNetDuration\n    };\n  }, [sessions]);\n\n  const exportHistory = useCallback(() => {\n    if (sessions.length === 0) {\n      setError('No sessions to export');\n      return;\n    }\n\n    try {\n      const dataToExport = {\n        exportedAt: new Date().toISOString(),\n        userId,\n        sessions: sessions.map(session => ({\n          ...session,\n          startTime: session.startTime.toISOString(),\n          endTime: session.endTime.toISOString(),\n          pauseEvents: session.pauseEvents?.map(event => ({\n            ...event,\n            startTime: event.startTime?.toISOString(),\n            endTime: event.endTime?.toISOString()\n          }))\n        })),\n        statistics: getStatistics()\n      };\n\n      const dataStr = JSON.stringify(dataToExport, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      const url = URL.createObjectURL(dataBlob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `session-history-${new Date().toISOString().slice(0, 10)}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to export history');\n    }\n  }, [sessions, userId, getStatistics]);\n\n  // Initial load\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  return {\n    sessions,\n    isLoading,\n    error,\n    hasMore,\n    filters,\n    loadMore,\n    deleteSession,\n    updateFilters,\n    getStatistics,\n    exportHistory,\n    refresh: useCallback(() => {\n      setSessions([]);\n      setHasMore(true);\n      fetchSessions();\n    }, [fetchSessions])\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionHistory.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (522). Maximum allowed is 75.","line":257,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":892,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (30). Maximum allowed is 25.","line":257,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":892,"endColumn":2},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":386,"column":5,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":386,"endColumn":17},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":387,"column":5,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":387,"endColumn":24},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (748). Maximum allowed is 500.","line":597,"column":1,"nodeType":null,"messageId":"exceed","endLine":893,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session History Management Hook\n * Provides comprehensive session history with privacy controls,\n * data visualization support, and keyholder access management\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  createEmptyTrendData,\n  calculateOverallCompletionRate,\n  calculateLongestStreak,\n  calculatePauseFrequency,\n  calculateImprovementTrend,\n  calculateConsistencyScore,\n  calculateSessionLengthTrend,\n  calculateGoalCompletionTrend,\n  calculateConsistencyTrend,\n  calculatePauseFrequencyTrend,\n  calculateOverallProgressTrend,\n} from \"../../utils/sessionHistoryHelpers\";\n\nconst logger = serviceLogger(\"useSessionHistory\");\n\n// ==================== INTERFACES ====================\n\nexport interface HistoricalSession {\n  id: string;\n  startTime: Date;\n  endTime: Date;\n  duration: number; // Total duration in seconds\n  effectiveDuration: number; // Duration minus pauses\n  goals: SessionGoal[];\n  goalCompletion: GoalCompletionRecord[];\n  pauseEvents: PauseEvent[];\n  keyholderInteractions: KeyholderInteraction[];\n  tags: string[];\n  notes: string;\n  rating?: SessionRating;\n  isHardcoreMode: boolean;\n  wasKeyholderControlled: boolean;\n  endReason?: string;\n  emergencyEnd?: boolean;\n}\n\nexport interface SessionGoal {\n  id: string;\n  type: string;\n  target: number;\n  unit: string;\n  completed: boolean;\n  progress: number;\n}\n\nexport interface GoalCompletionRecord {\n  goalId: string;\n  goalName: string;\n  targetValue: number;\n  achievedValue: number;\n  completionPercentage: number;\n  completed: boolean;\n  completedAt?: Date;\n}\n\nexport interface PauseEvent {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  reason: string;\n  initiatedBy: \"submissive\" | \"keyholder\" | \"emergency\";\n}\n\nexport interface KeyholderInteraction {\n  id: string;\n  type: \"message\" | \"control_action\" | \"approval\" | \"modification\";\n  timestamp: Date;\n  description: string;\n  keyholderName: string;\n}\n\nexport interface SessionRating {\n  overall: number; // 1-5 stars\n  difficulty: number; // 1-5\n  satisfaction: number; // 1-5\n  wouldRepeat: boolean;\n  notes?: string;\n}\n\nexport interface HistoryPrivacySettings {\n  shareWithKeyholder: boolean;\n  shareDuration: boolean;\n  shareGoals: boolean;\n  sharePauses: boolean;\n  shareNotes: boolean;\n  shareRatings: boolean;\n  retentionPeriod: number; // Days to keep history\n  allowExport: boolean;\n  anonymizeOldData: boolean;\n}\n\nexport interface KeyholderHistoryAccess {\n  hasAccess: boolean;\n  accessLevel: \"summary\" | \"detailed\" | \"full\";\n  canViewRatings: boolean;\n  canViewNotes: boolean;\n  canViewPauses: boolean;\n  lastAccessedAt?: Date;\n}\n\nexport interface HistoryInsights {\n  totalSessions: number;\n  totalEffectiveTime: number;\n  averageSessionLength: number;\n  longestSession: HistoricalSession;\n  shortestSession: HistoricalSession;\n  mostRecentSession: HistoricalSession;\n  goalCompletionRate: number;\n  pauseFrequency: number;\n  improvementTrend: \"improving\" | \"stable\" | \"declining\";\n  consistencyScore: number; // 0-100\n  keyholderSatisfactionScore?: number;\n}\n\nexport interface HistoryTrends {\n  sessionLength: TrendData;\n  goalCompletion: TrendData;\n  consistency: TrendData;\n  pauseFrequency: TrendData;\n  overallProgress: TrendData;\n}\n\nexport interface TrendData {\n  direction: \"improving\" | \"stable\" | \"declining\";\n  changePercentage: number;\n  confidence: number; // 0-100\n  timeframe: \"week\" | \"month\" | \"quarter\" | \"year\";\n  dataPoints: TrendPoint[];\n}\n\nexport interface TrendPoint {\n  date: Date;\n  value: number;\n  label?: string;\n}\n\nexport interface SessionHistoryState {\n  sessions: HistoricalSession[];\n  privacySettings: HistoryPrivacySettings;\n  keyholderAccess: KeyholderHistoryAccess;\n  insights: HistoryInsights;\n  trends: HistoryTrends;\n}\n\nexport interface HistorySearchQuery {\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  minDuration?: number;\n  maxDuration?: number;\n  goalTypes?: string[];\n  hasKeyholderControl?: boolean;\n  completedGoals?: boolean;\n  tags?: string[];\n  rating?: {\n    min: number;\n    max: number;\n  };\n  textSearch?: string;\n}\n\nexport interface PersonalDataExport {\n  exportId: string;\n  generatedAt: Date;\n  format: \"json\" | \"csv\" | \"pdf\";\n  data: {\n    sessions: HistoricalSession[];\n    goals: SessionGoal[];\n    settings: HistoryPrivacySettings;\n    analytics: HistoryInsights;\n  };\n  fileSize: number;\n  downloadUrl: string;\n  expiresAt: Date;\n}\n\nexport interface KeyholderHistoryView {\n  allowedSessions: Partial<HistoricalSession>[];\n  summaryStats: {\n    totalSessions: number;\n    averageDuration: number;\n    goalCompletionRate: number;\n    lastSessionDate: Date;\n  };\n  accessLevel: \"summary\" | \"detailed\" | \"full\";\n  restrictions: string[];\n}\n\nexport interface PerformanceTrends {\n  sessionDuration: {\n    average: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n    weeklyChange: number;\n  };\n  goalAchievement: {\n    rate: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n    weeklyChange: number;\n  };\n  consistency: {\n    score: number;\n    streak: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n  };\n}\n\nexport interface GoalProgressHistory {\n  goalId: string;\n  goalName: string;\n  progressOverTime: {\n    date: Date;\n    progress: number;\n  }[];\n  milestones: {\n    date: Date;\n    description: string;\n    achieved: boolean;\n  }[];\n}\n\nexport interface ComparisonMetrics {\n  thisWeek: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  lastWeek: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  thisMonth: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  lastMonth: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\nexport const useSessionHistory = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessions, setSessions] = useState<HistoricalSession[]>([]);\n  const [privacySettings, setPrivacySettings] =\n    useState<HistoryPrivacySettings>({\n      shareWithKeyholder: false,\n      shareDuration: true,\n      shareGoals: true,\n      sharePauses: false,\n      shareNotes: false,\n      shareRatings: false,\n      retentionPeriod: 365, // 1 year\n      allowExport: true,\n      anonymizeOldData: false,\n    });\n  const [keyholderAccess, setKeyholderAccess] =\n    useState<KeyholderHistoryAccess>({\n      hasAccess: false,\n      accessLevel: \"summary\",\n      canViewRatings: false,\n      canViewNotes: false,\n      canViewPauses: false,\n    });\n  const [insights, setInsights] = useState<HistoryInsights>({\n    totalSessions: 0,\n    totalEffectiveTime: 0,\n    averageSessionLength: 0,\n    longestSession: {} as HistoricalSession,\n    shortestSession: {} as HistoricalSession,\n    mostRecentSession: {} as HistoricalSession,\n    goalCompletionRate: 0,\n    pauseFrequency: 0,\n    improvementTrend: \"stable\",\n    consistencyScore: 0,\n  });\n  const [trends, setTrends] = useState<HistoryTrends>({\n    sessionLength: createEmptyTrendData(),\n    goalCompletion: createEmptyTrendData(),\n    consistency: createEmptyTrendData(),\n    pauseFrequency: createEmptyTrendData(),\n    overallProgress: createEmptyTrendData(),\n  });\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalSessions = useMemo(() => sessions.length, [sessions]);\n\n  const averageSessionLength = useMemo(\n    () =>\n      sessions.length > 0\n        ? sessions.reduce(\n            (sum, session) => sum + session.effectiveDuration,\n            0,\n          ) / sessions.length\n        : 0,\n    [sessions],\n  );\n\n  const goalCompletionRate = useMemo(\n    () => calculateOverallCompletionRate(sessions),\n    [sessions],\n  );\n\n  const longestStreak = useMemo(\n    () => calculateLongestStreak(sessions),\n    [sessions],\n  );\n\n  const hasPrivacyRestrictions = useMemo(\n    () => !privacySettings.shareWithKeyholder,\n    [privacySettings.shareWithKeyholder],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeHistory = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // Set keyholder access based on relationship permissions\n          setKeyholderAccess({\n            hasAccess: privacySettings.shareWithKeyholder,\n            accessLevel: privacySettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: privacySettings.shareRatings,\n            canViewNotes: privacySettings.shareNotes,\n            canViewPauses: privacySettings.sharePauses,\n          });\n        }\n\n        // Load historical data\n        await Promise.all([\n          loadSessions(),\n          loadPrivacySettings(),\n          calculateInsights(),\n          calculateTrends(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session history\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize session history\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeHistory();\n  }, [\n    userId,\n    relationshipId,\n    privacySettings.shareWithKeyholder,\n    privacySettings.shareRatings,\n    privacySettings.shareNotes,\n    privacySettings.sharePauses,\n    loadSessions,\n    loadPrivacySettings,\n    calculateTrends,\n    calculateInsights,\n  ]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessions = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Load sessions with privacy filtering applied\n      const allSessions: HistoricalSession[] = [];\n\n      // Apply retention policy\n      const retentionDate = new Date();\n      retentionDate.setDate(\n        retentionDate.getDate() - privacySettings.retentionPeriod,\n      );\n\n      const filteredSessions = allSessions.filter(\n        (session) => session.startTime >= retentionDate,\n      );\n\n      setSessions(filteredSessions);\n    } catch (error) {\n      logger.error(\"Failed to load sessions\", { error });\n    }\n  }, [privacySettings.retentionPeriod]);\n\n  const loadPrivacySettings = useCallback(async () => {\n    try {\n      // Load user's privacy preferences from database\n      // For now, use defaults\n    } catch (error) {\n      logger.error(\"Failed to load privacy settings\", { error });\n    }\n  }, []);\n\n  const calculateInsights = useCallback(async () => {\n    try {\n      if (sessions.length === 0) return;\n\n      const totalEffectiveTime = sessions.reduce(\n        (sum, s) => sum + s.effectiveDuration,\n        0,\n      );\n      const sortedByDuration = [...sessions].sort(\n        (a, b) => b.effectiveDuration - a.effectiveDuration,\n      );\n      const sortedByDate = [...sessions].sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n\n      const newInsights: HistoryInsights = {\n        totalSessions: sessions.length,\n        totalEffectiveTime,\n        averageSessionLength: totalEffectiveTime / sessions.length,\n        longestSession: sortedByDuration[0],\n        shortestSession: sortedByDuration[sortedByDuration.length - 1],\n        mostRecentSession: sortedByDate[0],\n        goalCompletionRate: calculateOverallCompletionRate(sessions),\n        pauseFrequency: calculatePauseFrequency(sessions),\n        improvementTrend: calculateImprovementTrend(sessions),\n        consistencyScore: calculateConsistencyScore(sessions),\n      };\n\n      setInsights(newInsights);\n    } catch (error) {\n      logger.error(\"Failed to calculate insights\", { error });\n    }\n  }, [sessions]);\n\n  const calculateTrends = useCallback(async () => {\n    try {\n      const newTrends: HistoryTrends = {\n        sessionLength: calculateSessionLengthTrend(sessions),\n        goalCompletion: calculateGoalCompletionTrend(sessions),\n        consistency: calculateConsistencyTrend(sessions),\n        pauseFrequency: calculatePauseFrequencyTrend(sessions),\n        overallProgress: calculateOverallProgressTrend(sessions),\n      };\n\n      setTrends(newTrends);\n    } catch (error) {\n      logger.error(\"Failed to calculate trends\", { error });\n    }\n  }, [sessions]);\n\n  // ==================== DATA RETRIEVAL ====================\n\n  const getSessionsByDateRange = useCallback(\n    (start: Date, end: Date): HistoricalSession[] => {\n      return sessions.filter(\n        (session) => session.startTime >= start && session.startTime <= end,\n      );\n    },\n    [sessions],\n  );\n\n  const getSessionsByGoal = useCallback(\n    (goalType: string): HistoricalSession[] => {\n      return sessions.filter((session) =>\n        session.goals.some((goal) => goal.type === goalType),\n      );\n    },\n    [sessions],\n  );\n\n  const searchSessions = useCallback(\n    (query: HistorySearchQuery): HistoricalSession[] => {\n      let filteredSessions = [...sessions];\n\n      // Date range filter\n      if (query.dateRange) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.startTime >= query.dateRange!.start &&\n            session.startTime <= query.dateRange!.end,\n        );\n      }\n\n      // Duration filters\n      if (query.minDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration >= query.minDuration!,\n        );\n      }\n\n      if (query.maxDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration <= query.maxDuration!,\n        );\n      }\n\n      // Goal type filter\n      if (query.goalTypes && query.goalTypes.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          session.goals.some((goal) => query.goalTypes!.includes(goal.type)),\n        );\n      }\n\n      // Keyholder control filter\n      if (query.hasKeyholderControl !== undefined) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.wasKeyholderControlled === query.hasKeyholderControl,\n        );\n      }\n\n      // Completed goals filter\n      if (query.completedGoals !== undefined) {\n        filteredSessions = filteredSessions.filter((session) => {\n          const hasCompletedGoals = session.goals.some(\n            (goal) => goal.completed,\n          );\n          return hasCompletedGoals === query.completedGoals;\n        });\n      }\n\n      // Tags filter\n      if (query.tags && query.tags.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          query.tags!.some((tag) => session.tags.includes(tag)),\n        );\n      }\n\n      // Rating filter\n      if (query.rating && query.rating.min && query.rating.max) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.rating &&\n            session.rating.overall >= query.rating!.min &&\n            session.rating.overall <= query.rating!.max,\n        );\n      }\n\n      // Text search\n      if (query.textSearch) {\n        const searchTerm = query.textSearch.toLowerCase();\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.notes.toLowerCase().includes(searchTerm) ||\n            session.tags.some((tag) =>\n              tag.toLowerCase().includes(searchTerm),\n            ) ||\n            session.endReason?.toLowerCase().includes(searchTerm),\n        );\n      }\n\n      return filteredSessions;\n    },\n    [sessions],\n  );\n\n  // ==================== PRIVACY MANAGEMENT ====================\n\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<HistoryPrivacySettings>): Promise<void> => {\n      try {\n        logger.debug(\"Updating privacy settings\", { settings });\n\n        const updatedSettings = { ...privacySettings, ...settings };\n        setPrivacySettings(updatedSettings);\n\n        // Update keyholder access based on new settings\n        if (relationshipId) {\n          setKeyholderAccess((prev) => ({\n            ...prev,\n            hasAccess: updatedSettings.shareWithKeyholder,\n            accessLevel: updatedSettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: updatedSettings.shareRatings,\n            canViewNotes: updatedSettings.shareNotes,\n            canViewPauses: updatedSettings.sharePauses,\n          }));\n        }\n\n        // Reload sessions if retention period changed\n        if (\n          settings.retentionPeriod &&\n          settings.retentionPeriod !== privacySettings.retentionPeriod\n        ) {\n          await loadSessions();\n        }\n\n        logger.info(\"Privacy settings updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update privacy settings\", { error });\n        throw error;\n      }\n    },\n    [privacySettings, relationshipId, loadSessions],\n  );\n\n  const exportPersonalData =\n    useCallback(async (): Promise<PersonalDataExport> => {\n      try {\n        logger.debug(\"Exporting personal data\", { userId });\n\n        const exportData: PersonalDataExport = {\n          exportId: `export_${Date.now()}`,\n          generatedAt: new Date(),\n          format: \"json\",\n          data: {\n            sessions,\n            goals: sessions.flatMap((s) => s.goals),\n            settings: privacySettings,\n            analytics: insights,\n          },\n          fileSize: 0, // Would be calculated\n          downloadUrl: \"\", // Would be generated\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n        logger.info(\"Personal data export created\", {\n          exportId: exportData.exportId,\n        });\n        return exportData;\n      } catch (error) {\n        logger.error(\"Failed to export personal data\", { error });\n        throw error;\n      }\n    }, [sessions, privacySettings, insights, userId]);\n\n  const deleteHistoricalData = useCallback(\n    async (before: Date): Promise<void> => {\n      try {\n        logger.debug(\"Deleting historical data\", { before, userId });\n\n        const sessionsToKeep = sessions.filter(\n          (session) => session.startTime >= before,\n        );\n        const deletedCount = sessions.length - sessionsToKeep.length;\n\n        setSessions(sessionsToKeep);\n\n        // Recalculate insights and trends\n        await Promise.all([calculateInsights(), calculateTrends()]);\n\n        logger.info(\"Historical data deleted\", { deletedCount });\n      } catch (error) {\n        logger.error(\"Failed to delete historical data\", { error });\n        throw error;\n      }\n    },\n    [sessions, calculateInsights, calculateTrends, userId],\n  );\n\n  // ==================== KEYHOLDER ACCESS ====================\n\n  const getKeyholderView = useCallback((): KeyholderHistoryView => {\n    if (!keyholderAccess.hasAccess) {\n      return {\n        allowedSessions: [],\n        summaryStats: {\n          totalSessions: 0,\n          averageDuration: 0,\n          goalCompletionRate: 0,\n          lastSessionDate: new Date(),\n        },\n        accessLevel: \"summary\",\n        restrictions: [\"No access granted by submissive\"],\n      };\n    }\n\n    const allowedSessions = sessions.map((session) => {\n      const filteredSession: Partial<HistoricalSession> = {\n        id: session.id,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        duration: privacySettings.shareDuration ? session.duration : undefined,\n        effectiveDuration: privacySettings.shareDuration\n          ? session.effectiveDuration\n          : undefined,\n        goals: privacySettings.shareGoals ? session.goals : [],\n        pauseEvents: privacySettings.sharePauses ? session.pauseEvents : [],\n        notes: privacySettings.shareNotes ? session.notes : \"\",\n        rating: privacySettings.shareRatings ? session.rating : undefined,\n        keyholderInteractions: session.keyholderInteractions,\n      };\n\n      return filteredSession;\n    });\n\n    return {\n      allowedSessions,\n      summaryStats: {\n        totalSessions: sessions.length,\n        averageDuration: averageSessionLength,\n        goalCompletionRate,\n        lastSessionDate:\n          sessions.length > 0 ? sessions[0].startTime : new Date(),\n      },\n      accessLevel: keyholderAccess.accessLevel,\n      restrictions: [],\n    };\n  }, [\n    keyholderAccess,\n    sessions,\n    privacySettings,\n    averageSessionLength,\n    goalCompletionRate,\n  ]);\n\n  const shareHistoryWithKeyholder = useCallback(\n    async (sessionIds: string[]): Promise<void> => {\n      try {\n        logger.debug(\"Sharing specific sessions with keyholder\", {\n          sessionIds,\n        });\n\n        // This would create a special sharing link or send specific data\n        // For now, just log the action\n        logger.info(\"History shared with keyholder\", {\n          sessionCount: sessionIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to share history with keyholder\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getPerformanceTrends = useCallback((): PerformanceTrends => {\n    return {\n      sessionDuration: {\n        average: averageSessionLength,\n        trend: trends.sessionLength.direction,\n        weeklyChange: trends.sessionLength.changePercentage,\n      },\n      goalAchievement: {\n        rate: goalCompletionRate,\n        trend: trends.goalCompletion.direction,\n        weeklyChange: trends.goalCompletion.changePercentage,\n      },\n      consistency: {\n        score: insights.consistencyScore,\n        streak: longestStreak,\n        trend: trends.consistency.direction,\n      },\n    };\n  }, [\n    averageSessionLength,\n    trends,\n    goalCompletionRate,\n    insights.consistencyScore,\n    longestStreak,\n  ]);\n\n  const getGoalProgressHistory = useCallback((): GoalProgressHistory[] => {\n    const goalProgressMap = new Map<string, GoalProgressHistory>();\n\n    sessions.forEach((session) => {\n      session.goals.forEach((goal) => {\n        if (!goalProgressMap.has(goal.id)) {\n          goalProgressMap.set(goal.id, {\n            goalId: goal.id,\n            goalName: goal.type,\n            progressOverTime: [],\n            milestones: [],\n          });\n        }\n\n        const progressHistory = goalProgressMap.get(goal.id)!;\n        progressHistory.progressOverTime.push({\n          date: session.startTime,\n          progress: goal.progress,\n        });\n      });\n    });\n\n    return Array.from(goalProgressMap.values());\n  }, [sessions]);\n\n  const getComparisonMetrics = useCallback((): ComparisonMetrics => {\n    const now = new Date();\n    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);\n    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const twoMonthsAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);\n\n    const thisWeekSessions = getSessionsByDateRange(weekAgo, now);\n    const lastWeekSessions = getSessionsByDateRange(twoWeeksAgo, weekAgo);\n    const thisMonthSessions = getSessionsByDateRange(monthAgo, now);\n    const lastMonthSessions = getSessionsByDateRange(twoMonthsAgo, monthAgo);\n\n    return {\n      thisWeek: {\n        sessions: thisWeekSessions.length,\n        totalTime: thisWeekSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(thisWeekSessions),\n      },\n      lastWeek: {\n        sessions: lastWeekSessions.length,\n        totalTime: lastWeekSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(lastWeekSessions),\n      },\n      thisMonth: {\n        sessions: thisMonthSessions.length,\n        totalTime: thisMonthSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(thisMonthSessions),\n      },\n      lastMonth: {\n        sessions: lastMonthSessions.length,\n        totalTime: lastMonthSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(lastMonthSessions),\n      },\n    };\n  }, [getSessionsByDateRange]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // History data\n    sessions,\n    insights,\n    trends,\n    privacySettings,\n\n    // Data retrieval\n    getSessionsByDateRange,\n    getSessionsByGoal,\n    searchSessions,\n\n    // Privacy management\n    updatePrivacySettings,\n    exportPersonalData,\n    deleteHistoricalData,\n\n    // Keyholder access\n    getKeyholderView,\n    shareHistoryWithKeyholder,\n\n    // Analytics\n    getPerformanceTrends,\n    getGoalProgressHistory,\n    getComparisonMetrics,\n\n    // Computed values\n    totalSessions,\n    averageSessionLength,\n    goalCompletionRate,\n    longestStreak,\n    hasPrivacyRestrictions,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionHistoryQueries.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (165). Maximum allowed is 75.","line":17,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":223,"endColumn":2},{"ruleId":"max-params","severity":1,"message":"Arrow function has too many parameters (8). Maximum allowed is 5.","line":26,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":26,"endColumn":5}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session History Query Functions\n * Composable hook for querying and managing session history data\n */\nimport { useCallback } from \"react\";\nimport type {\n  HistoricalSession,\n  HistorySearchQuery,\n  HistoryPrivacySettings,\n  HistoryInsights,\n  PersonalDataExport,\n} from \"./types/sessionHistory\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSessionHistoryQueries\");\n\nexport const useSessionHistoryQueries = (\n  sessions: HistoricalSession[],\n  privacySettings: HistoryPrivacySettings,\n  insights: HistoryInsights,\n  userId: string,\n  setSessions: (sessions: HistoricalSession[]) => void,\n  setPrivacySettings: (settings: HistoryPrivacySettings) => void,\n  calculateInsights: () => void,\n  calculateTrends: () => void,\n) => {\n  // ==================== DATA RETRIEVAL ====================\n\n  const getSessionsByDateRange = useCallback(\n    (start: Date, end: Date): HistoricalSession[] => {\n      return sessions.filter(\n        (session) => session.startTime >= start && session.startTime <= end,\n      );\n    },\n    [sessions],\n  );\n\n  const getSessionsByGoal = useCallback(\n    (goalType: string): HistoricalSession[] => {\n      return sessions.filter((session) =>\n        session.goals.some((goal) => goal.type === goalType),\n      );\n    },\n    [sessions],\n  );\n\n  const searchSessions = useCallback(\n    (query: HistorySearchQuery): HistoricalSession[] => {\n      let filteredSessions = [...sessions];\n\n      // Date range filter\n      if (query.dateRange) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.startTime >= query.dateRange!.start &&\n            session.startTime <= query.dateRange!.end,\n        );\n      }\n\n      // Duration filters\n      if (query.minDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration >= query.minDuration!,\n        );\n      }\n\n      if (query.maxDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration <= query.maxDuration!,\n        );\n      }\n\n      // Goal type filter\n      if (query.goalTypes && query.goalTypes.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          session.goals.some((goal) => query.goalTypes!.includes(goal.type)),\n        );\n      }\n\n      // Keyholder control filter\n      if (query.hasKeyholderControl !== undefined) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.wasKeyholderControlled === query.hasKeyholderControl,\n        );\n      }\n\n      // Completed goals filter\n      if (query.completedGoals !== undefined) {\n        filteredSessions = filteredSessions.filter((session) => {\n          const hasCompletedGoals = session.goals.some(\n            (goal) => goal.completed,\n          );\n          return query.completedGoals ? hasCompletedGoals : !hasCompletedGoals;\n        });\n      }\n\n      // Tags filter\n      if (query.tags && query.tags.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          query.tags!.some((tag) => session.tags.includes(tag)),\n        );\n      }\n\n      // Rating filter\n      if (query.rating && query.rating.min && query.rating.max) {\n        filteredSessions = filteredSessions.filter((session) => {\n          if (!session.rating) return false;\n          return (\n            session.rating.overall >= query.rating!.min &&\n            session.rating.overall <= query.rating!.max\n          );\n        });\n      }\n\n      // Text search (searches in notes and tags)\n      if (query.textSearch) {\n        const searchLower = query.textSearch.toLowerCase();\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.notes.toLowerCase().includes(searchLower) ||\n            session.tags.some((tag) => tag.toLowerCase().includes(searchLower)),\n        );\n      }\n\n      return filteredSessions;\n    },\n    [sessions],\n  );\n\n  // ==================== PRIVACY MANAGEMENT ====================\n\n  const updatePrivacySettings = useCallback(\n    async (newSettings: Partial<HistoryPrivacySettings>): Promise<void> => {\n      try {\n        logger.debug(\"Updating privacy settings\", { newSettings, userId });\n\n        const updatedSettings = {\n          ...privacySettings,\n          ...newSettings,\n        };\n\n        setPrivacySettings(updatedSettings);\n\n        // If reducing sharing permissions, we may need to notify keyholder\n        if (\n          privacySettings.shareWithKeyholder &&\n          !updatedSettings.shareWithKeyholder\n        ) {\n          logger.info(\"Keyholder access revoked\", { userId });\n        }\n      } catch (error) {\n        logger.error(\"Failed to update privacy settings\", { error });\n        throw error;\n      }\n    },\n    [privacySettings, userId, setPrivacySettings],\n  );\n\n  const exportPersonalData =\n    useCallback(async (): Promise<PersonalDataExport> => {\n      try {\n        logger.debug(\"Exporting personal data\", { userId });\n\n        const exportData: PersonalDataExport = {\n          exportId: `export-${Date.now()}`,\n          generatedAt: new Date(),\n          format: \"json\",\n          data: {\n            sessions,\n            goals: sessions.flatMap((s) => s.goals),\n            settings: privacySettings,\n            analytics: insights,\n          },\n          fileSize: 0, // Would be calculated based on actual data size\n          downloadUrl: \"\", // Would be generated by backend\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n        return exportData;\n      } catch (error) {\n        logger.error(\"Failed to export personal data\", { error });\n        throw error;\n      }\n    }, [sessions, privacySettings, insights, userId]);\n\n  const deleteHistoricalData = useCallback(\n    async (before: Date): Promise<void> => {\n      try {\n        logger.debug(\"Deleting historical data\", { before, userId });\n\n        const sessionsToKeep = sessions.filter(\n          (session) => session.startTime >= before,\n        );\n        const deletedCount = sessions.length - sessionsToKeep.length;\n\n        setSessions(sessionsToKeep);\n\n        // Recalculate insights and trends\n        calculateInsights();\n        calculateTrends();\n\n        logger.info(\"Historical data deleted\", { deletedCount, userId });\n      } catch (error) {\n        logger.error(\"Failed to delete historical data\", { error });\n        throw error;\n      }\n    },\n    [sessions, userId, setSessions, calculateInsights, calculateTrends],\n  );\n\n  return {\n    // Data retrieval\n    getSessionsByDateRange,\n    getSessionsByGoal,\n    searchSessions,\n\n    // Privacy management\n    updatePrivacySettings,\n    exportPersonalData,\n    deleteHistoricalData,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/session/useSessionLoader.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionLoader' has too many lines (111). Maximum allowed is 75.","line":33,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":183,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Loader Hook\n * Provides session loading and restoration functionality for SessionLoader component\n * Extracts business logic from component to maintain clean architecture\n */\nimport { useState, useCallback, useEffect } from \"react\";\nimport { useSessionPersistence } from \"../useSessionPersistence\";\nimport type { DBSession } from \"../../types/database\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSessionLoader\");\n\nexport interface UseSessionLoaderReturn {\n  // State\n  session: DBSession | null;\n  isLoading: boolean;\n  error: Error | null;\n  hasBackup: boolean;\n\n  // Actions\n  loadSession: (userId: string) => Promise<void>;\n  restoreFromBackup: () => Promise<DBSession | null>;\n  clearBackup: () => Promise<void>;\n\n  // Status\n  isRestoring: boolean;\n  canRestore: boolean;\n\n  // Progress tracking\n  progress: number;\n}\n\nexport function useSessionLoader(): UseSessionLoaderReturn {\n  const [session, setSession] = useState<DBSession | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [isRestoring, setIsRestoring] = useState(false);\n  const [progress, setProgress] = useState(0);\n\n  const {\n    initializeSession,\n    isInitializing,\n    restorationResult,\n    error: persistenceError,\n    getBackupState,\n  } = useSessionPersistence({ autoInitialize: false });\n\n  // Check if there's a backup available\n  const hasBackup = useCallback(() => {\n    const backupState = getBackupState();\n    return Boolean(backupState?.activeSessionId);\n  }, [getBackupState]);\n\n  // Determine if restore is possible\n  const canRestore = hasBackup() && !isRestoring && !isInitializing;\n\n  // Load session for a user\n  const loadSession = useCallback(\n    async (userId: string): Promise<void> => {\n      if (!userId) {\n        const err = new Error(\"User ID is required\");\n        setError(err);\n        logger.error(\"Load session failed: no user ID\", { error: err });\n        return;\n      }\n\n      try {\n        setError(null);\n        setProgress(25);\n\n        logger.debug(\"Loading session\", { userId });\n\n        // Initialize session state using the persistence hook\n        const result = await initializeSession(userId);\n        setProgress(75);\n\n        if (result.session) {\n          setSession(result.session);\n          logger.info(\"Session loaded successfully\", {\n            sessionId: result.session.id,\n            wasRestored: result.wasRestored,\n          });\n        }\n\n        setProgress(100);\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(error);\n        logger.error(\"Failed to load session\", { error, userId });\n      }\n    },\n    [initializeSession],\n  );\n\n  // Restore session from backup\n  const restoreFromBackup = useCallback(async (): Promise<DBSession | null> => {\n    try {\n      setIsRestoring(true);\n      setError(null);\n\n      const backupState = getBackupState();\n      if (!backupState?.activeSessionId) {\n        throw new Error(\"No backup available to restore\");\n      }\n\n      logger.debug(\"Restoring session from backup\", {\n        sessionId: backupState.activeSessionId,\n      });\n\n      // The restoration is handled by the persistence service\n      // We just need to signal that we're restoring and get the result\n      const restoredSession = restorationResult?.session || null;\n\n      if (restoredSession) {\n        setSession(restoredSession);\n        logger.info(\"Session restored from backup\", {\n          sessionId: restoredSession.id,\n        });\n      }\n\n      return restoredSession;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      logger.error(\"Failed to restore from backup\", { error });\n      throw error;\n    } finally {\n      setIsRestoring(false);\n    }\n  }, [getBackupState, restorationResult]);\n\n  // Clear backup data\n  const clearBackup = useCallback(async (): Promise<void> => {\n    try {\n      logger.debug(\"Clearing session backup\");\n\n      // Clear localStorage backup\n      localStorage.removeItem(\"chastity_session_backup\");\n\n      logger.info(\"Session backup cleared\");\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      logger.error(\"Failed to clear backup\", { error });\n      throw error;\n    }\n  }, []);\n\n  // Sync persistence error to local error state\n  useEffect(() => {\n    if (persistenceError) {\n      setError(new Error(persistenceError));\n    }\n  }, [persistenceError]);\n\n  // Update session when restoration result changes\n  useEffect(() => {\n    if (restorationResult?.session) {\n      setSession(restorationResult.session);\n    }\n  }, [restorationResult]);\n\n  const isLoading = isInitializing || isRestoring;\n\n  return {\n    // State\n    session,\n    isLoading,\n    error,\n    hasBackup: hasBackup(),\n\n    // Actions\n    loadSession,\n    restoreFromBackup,\n    clearBackup,\n\n    // Status\n    isRestoring,\n    canRestore,\n\n    // Progress\n    progress,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/system/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/system/useHealthCheck.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (278). Maximum allowed is 75.","line":78,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":433,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useHealthCheck Hook - System Health Monitoring\n *\n * Monitor overall system health, service availability, and provide early warning\n * for potential issues.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Health status enum\nexport enum HealthStatus {\n  HEALTHY = \"healthy\",\n  WARNING = \"warning\",\n  CRITICAL = \"critical\",\n  UNKNOWN = \"unknown\",\n}\n\n// Service status\nexport interface ServiceStatus {\n  name: string;\n  status: HealthStatus;\n  responseTime: number;\n  lastChecked: Date;\n  error?: string;\n  uptime: number;\n}\n\n// System metrics\nexport interface SystemMetrics {\n  memoryUsage: number;\n  cpuUsage: number;\n  storageUsage: number;\n  networkLatency: number;\n  errorRate: number;\n  activeConnections: number;\n}\n\n// Health check result\nexport interface HealthCheckResult {\n  overall: HealthStatus;\n  services: ServiceStatus[];\n  metrics: SystemMetrics;\n  alerts: HealthAlert[];\n  lastUpdated: Date;\n  checkDuration: number;\n}\n\n// Health alert\nexport interface HealthAlert {\n  id: string;\n  type: \"warning\" | \"error\" | \"info\";\n  message: string;\n  service?: string;\n  timestamp: Date;\n  acknowledged: boolean;\n}\n\n// Health check configuration\ninterface HealthCheckConfig {\n  checkInterval: number;\n  timeout: number;\n  retryAttempts: number;\n  services: string[];\n}\n\nconst DEFAULT_CONFIG: HealthCheckConfig = {\n  checkInterval: 30000, // 30 seconds\n  timeout: 5000, // 5 seconds\n  retryAttempts: 3,\n  services: [\"firebase\", \"storage\", \"network\"],\n};\n\n/**\n * System Health Check Hook\n */\nexport const useHealthCheck = (config: Partial<HealthCheckConfig> = {}) => {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const [alerts, setAlerts] = useState<HealthAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Check service health\n  const checkServiceHealth = useCallback(\n    async (serviceName: string): Promise<ServiceStatus> => {\n      const startTime = Date.now();\n      let status: HealthStatus = HealthStatus.UNKNOWN;\n      let error: string | undefined;\n      let responseTime = 0;\n\n      try {\n        switch (serviceName) {\n          case \"firebase\":\n            // Check Firebase connectivity\n            status = await checkFirebaseHealth();\n            break;\n          case \"storage\":\n            status = await checkStorageHealth();\n            break;\n          case \"network\":\n            status = await checkNetworkHealth();\n            break;\n          default:\n            status = HealthStatus.UNKNOWN;\n        }\n\n        responseTime = Date.now() - startTime;\n      } catch (err) {\n        status = HealthStatus.CRITICAL;\n        error = err instanceof Error ? err.message : \"Unknown error\";\n        responseTime = Date.now() - startTime;\n        logger.error(`Health check failed for ${serviceName}`, { error: err });\n      }\n\n      return {\n        name: serviceName,\n        status,\n        responseTime,\n        lastChecked: new Date(),\n        error,\n        uptime: calculateUptime(serviceName),\n      };\n    },\n    [],\n  );\n\n  // Check Firebase health\n  const checkFirebaseHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Simple connectivity test - try to access Firebase\n      if (\n        typeof window !== \"undefined\" &&\n        (window as Window & { firebase?: unknown }).firebase\n      ) {\n        return HealthStatus.HEALTHY;\n      }\n      return HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check storage health\n  const checkStorageHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Test localStorage availability\n      const testKey = \"health-check-test\";\n      const testValue = \"test\";\n\n      localStorage.setItem(testKey, testValue);\n      const retrieved = localStorage.getItem(testKey);\n      localStorage.removeItem(testKey);\n\n      if (retrieved === testValue) {\n        return HealthStatus.HEALTHY;\n      }\n      return HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check network health\n  const checkNetworkHealth = async (): Promise<HealthStatus> => {\n    if (!navigator.onLine) {\n      return HealthStatus.CRITICAL;\n    }\n\n    try {\n      const startTime = Date.now();\n      const response = await fetch(\"/favicon.ico\", {\n        method: \"HEAD\",\n        cache: \"no-cache\",\n      });\n      const responseTime = Date.now() - startTime;\n\n      if (response.ok && responseTime < 2000) {\n        return HealthStatus.HEALTHY;\n      } else if (response.ok && responseTime < 5000) {\n        return HealthStatus.WARNING;\n      }\n      return HealthStatus.CRITICAL;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Calculate service uptime (simplified)\n  const calculateUptime = (_serviceName: string): number => {\n    // In a real implementation, this would track actual uptime\n    // For now, return a mock value\n    return Math.random() * 100;\n  };\n\n  // Get system metrics\n  const getSystemMetrics = useCallback(async (): Promise<SystemMetrics> => {\n    const metrics: SystemMetrics = {\n      memoryUsage: 0,\n      cpuUsage: 0,\n      storageUsage: 0,\n      networkLatency: 0,\n      errorRate: 0,\n      activeConnections: 1,\n    };\n\n    try {\n      // Memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: { usedJSHeapSize: number; totalJSHeapSize: number };\n          }\n        ).memory;\n        if (memory) {\n          metrics.memoryUsage =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Storage usage\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        if (estimate.usage && estimate.quota) {\n          metrics.storageUsage = (estimate.usage / estimate.quota) * 100;\n        }\n      }\n\n      // Network latency (simplified)\n      const startTime = Date.now();\n      await fetch(\"/favicon.ico\", { method: \"HEAD\", cache: \"no-cache\" });\n      metrics.networkLatency = Date.now() - startTime;\n    } catch (error) {\n      logger.warn(\"Failed to get some system metrics\", error);\n    }\n\n    return metrics;\n  }, []);\n\n  // Determine overall health status\n  const calculateOverallHealth = useCallback(\n    (services: ServiceStatus[]): HealthStatus => {\n      const statuses = services.map((s) => s.status);\n\n      if (statuses.includes(HealthStatus.CRITICAL)) {\n        return HealthStatus.CRITICAL;\n      }\n\n      if (statuses.includes(HealthStatus.WARNING)) {\n        return HealthStatus.WARNING;\n      }\n\n      if (statuses.every((s) => s === HealthStatus.HEALTHY)) {\n        return HealthStatus.HEALTHY;\n      }\n\n      return HealthStatus.UNKNOWN;\n    },\n    [],\n  );\n\n  // Generate alerts based on health status\n  const generateAlerts = useCallback(\n    (services: ServiceStatus[], metrics: SystemMetrics): HealthAlert[] => {\n      const newAlerts: HealthAlert[] = [];\n\n      // Service alerts\n      services.forEach((service) => {\n        if (service.status === HealthStatus.CRITICAL) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"error\",\n            message: `Service ${service.name} is critical: ${service.error || \"Unknown error\"}`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        } else if (service.status === HealthStatus.WARNING) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"warning\",\n            message: `Service ${service.name} is experiencing issues`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        }\n      });\n\n      // Metrics alerts\n      if (metrics.memoryUsage > 90) {\n        newAlerts.push({\n          id: `memory-${Date.now()}`,\n          type: \"warning\",\n          message: `High memory usage: ${metrics.memoryUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.storageUsage > 90) {\n        newAlerts.push({\n          id: `storage-${Date.now()}`,\n          type: \"warning\",\n          message: `High storage usage: ${metrics.storageUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.networkLatency > 5000) {\n        newAlerts.push({\n          id: `network-${Date.now()}`,\n          type: \"warning\",\n          message: `High network latency: ${metrics.networkLatency}ms`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      return newAlerts;\n    },\n    [],\n  );\n\n  // Main health check query\n  const {\n    data: healthStatus,\n    isLoading,\n    error,\n    refetch,\n  } = useQuery<HealthCheckResult>({\n    queryKey: [\"system\", \"health\"],\n    queryFn: async () => {\n      const startTime = Date.now();\n\n      // Check all services\n      const serviceChecks = await Promise.all(\n        fullConfig.services.map((service) => checkServiceHealth(service)),\n      );\n\n      // Get system metrics\n      const metrics = await getSystemMetrics();\n\n      // Calculate overall health\n      const overall = calculateOverallHealth(serviceChecks);\n\n      // Generate alerts\n      const newAlerts = generateAlerts(serviceChecks, metrics);\n\n      const result: HealthCheckResult = {\n        overall,\n        services: serviceChecks,\n        metrics,\n        alerts: newAlerts,\n        lastUpdated: new Date(),\n        checkDuration: Date.now() - startTime,\n      };\n\n      // Update alerts state\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n\n      return result;\n    },\n    refetchInterval: isMonitoring ? fullConfig.checkInterval : false,\n    retry: fullConfig.retryAttempts,\n    staleTime: fullConfig.checkInterval / 2,\n  });\n\n  // Acknowledge alert\n  const acknowledgeAlert = useCallback((alertId: string) => {\n    setAlerts((prev) =>\n      prev.map((alert) =>\n        alert.id === alertId ? { ...alert, acknowledged: true } : alert,\n      ),\n    );\n    logger.info(\"Health alert acknowledged\", { alertId });\n  }, []);\n\n  // Clear acknowledged alerts\n  const clearAcknowledgedAlerts = useCallback(() => {\n    setAlerts((prev) => prev.filter((alert) => !alert.acknowledged));\n    logger.info(\"Acknowledged alerts cleared\");\n  }, []);\n\n  // Start/stop monitoring\n  const toggleMonitoring = useCallback((enabled: boolean) => {\n    setIsMonitoring(enabled);\n    logger.info(`Health monitoring ${enabled ? \"started\" : \"stopped\"}`);\n  }, []);\n\n  // Force health check\n  const forceCheck = useCallback(() => {\n    refetch();\n    logger.info(\"Manual health check triggered\");\n  }, [refetch]);\n\n  return {\n    // Health status\n    healthStatus,\n    isLoading,\n    error,\n\n    // Alerts\n    alerts: alerts.filter((alert) => !alert.acknowledged),\n    acknowledgedAlerts: alerts.filter((alert) => alert.acknowledged),\n    allAlerts: alerts,\n\n    // Controls\n    acknowledgeAlert,\n    clearAcknowledgedAlerts,\n    toggleMonitoring,\n    forceCheck,\n\n    // State\n    isMonitoring,\n\n    // Computed properties\n    isHealthy: healthStatus?.overall === HealthStatus.HEALTHY,\n    hasWarnings: healthStatus?.overall === HealthStatus.WARNING,\n    isCritical: healthStatus?.overall === HealthStatus.CRITICAL,\n    hasUnacknowledgedAlerts: alerts.some((alert) => !alert.acknowledged),\n    uptime:\n      healthStatus?.services.reduce((acc, service) => acc + service.uptime, 0) /\n      (healthStatus?.services.length || 1),\n    averageResponseTime:\n      healthStatus?.services.reduce(\n        (acc, service) => acc + service.responseTime,\n        0,\n      ) / (healthStatus?.services.length || 1),\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/system/useMigration.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (301). Maximum allowed is 75.","line":92,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":467,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Async arrow function has too many lines (79). Maximum allowed is 75.","line":254,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":348,"endColumn":6}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useMigration Hook - Data Migration Management\n *\n * Handle data migrations, schema updates, and legacy data conversion with\n * progress tracking and rollback capabilities.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Migration status\nexport enum MigrationStatus {\n  PENDING = \"pending\",\n  RUNNING = \"running\",\n  COMPLETED = \"completed\",\n  FAILED = \"failed\",\n  ROLLED_BACK = \"rolled_back\",\n}\n\n// Migration definition\nexport interface Migration {\n  id: string;\n  version: string;\n  name: string;\n  description: string;\n  status: MigrationStatus;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  progress: number;\n  error?: string;\n  rollbackAvailable: boolean;\n}\n\n// Migration batch\nexport interface MigrationBatch {\n  id: string;\n  migrations: Migration[];\n  status: MigrationStatus;\n  totalProgress: number;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\n// Migration result\nexport interface MigrationResult {\n  success: boolean;\n  migrationsRun: number;\n  errors: string[];\n  warnings: string[];\n  duration: number;\n}\n\n// Storage keys\nconst STORAGE_KEYS = {\n  MIGRATION_STATE: \"chastity-migration-state\",\n  MIGRATION_BACKUPS: \"chastity-migration-backups\",\n};\n\n// Sample migrations (in a real app, these would be defined elsewhere)\nconst AVAILABLE_MIGRATIONS: Omit<\n  Migration,\n  \"status\" | \"progress\" | \"createdAt\"\n>[] = [\n  {\n    id: \"v4.0.0-theme-system\",\n    version: \"4.0.0\",\n    name: \"Theme System Migration\",\n    description: \"Migrate existing theme preferences to new theme system\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-enhanced-goals\",\n    version: \"4.0.0\",\n    name: \"Enhanced Goals Migration\",\n    description: \"Convert legacy goals to enhanced goal format\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-gamification\",\n    version: \"4.0.0\",\n    name: \"Gamification System Migration\",\n    description: \"Initialize gamification data from existing achievements\",\n    rollbackAvailable: false,\n  },\n];\n\n/**\n * Data Migration Hook\n */\nexport const useMigration = () => {\n  const queryClient = useQueryClient();\n  const [isRunning, setIsRunning] = useState(false);\n\n  // Get migration state\n  const { data: migrationState } = useQuery({\n    queryKey: [\"migration\", \"state\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.MIGRATION_STATE);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n\n      // Initialize migration state\n      const initialMigrations: Migration[] = AVAILABLE_MIGRATIONS.map(\n        (migration) => ({\n          ...migration,\n          status: MigrationStatus.PENDING,\n          progress: 0,\n          createdAt: new Date(),\n        }),\n      );\n\n      return {\n        migrations: initialMigrations,\n        lastRun: null,\n        currentVersion: \"3.0.0\",\n      };\n    },\n    staleTime: Infinity,\n  });\n\n  // Get pending migrations\n  const pendingMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.PENDING,\n    ) || [];\n\n  // Get completed migrations\n  const completedMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.COMPLETED,\n    ) || [];\n\n  // Create backup before migration\n  const createBackup = useCallback(\n    async (migrationId: string) => {\n      try {\n        const backup = {\n          id: `backup-${migrationId}-${Date.now()}`,\n          migrationId,\n          timestamp: new Date(),\n          data: {\n            // In a real implementation, this would backup relevant data\n            localStorage: { ...localStorage },\n            version: migrationState?.currentVersion,\n          },\n        };\n\n        const existingBackups = JSON.parse(\n          localStorage.getItem(STORAGE_KEYS.MIGRATION_BACKUPS) || \"[]\",\n        );\n\n        const updatedBackups = [...existingBackups, backup];\n        localStorage.setItem(\n          STORAGE_KEYS.MIGRATION_BACKUPS,\n          JSON.stringify(updatedBackups),\n        );\n\n        logger.info(\"Migration backup created\", {\n          migrationId,\n          backupId: backup.id,\n        });\n        return backup.id;\n      } catch (error) {\n        logger.error(\"Failed to create migration backup\", {\n          migrationId,\n          error,\n        });\n        throw error;\n      }\n    },\n    [migrationState],\n  );\n\n  // Migration implementations\n  const migrateThemeSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(25);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      // Convert old theme settings\n      const oldTheme = localStorage.getItem(\"theme\");\n      if (oldTheme) {\n        localStorage.setItem(\n          \"chastity-theme-current\",\n          JSON.stringify(\n            oldTheme === \"dark\" ? \"default-dark\" : \"default-light\",\n          ),\n        );\n      }\n\n      onProgress(75);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateEnhancedGoals = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(30);\n      await new Promise((resolve) => setTimeout(resolve, 300));\n\n      // Convert legacy goals (simplified)\n      const legacyGoals = localStorage.getItem(\"personal-goals\");\n      if (legacyGoals) {\n        // Transform format here\n        onProgress(70);\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      }\n\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateGamificationSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(20);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n\n      // Initialize gamification data\n      onProgress(60);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n      onProgress(100);\n    },\n    [],\n  );\n\n  // Execute migration logic\n  const executeMigrationLogic = useCallback(\n    async (migrationId: string, onProgress: (progress: number) => void) => {\n      switch (migrationId) {\n        case \"v4.0.0-theme-system\":\n          await migrateThemeSystem(onProgress);\n          break;\n        case \"v4.0.0-enhanced-goals\":\n          await migrateEnhancedGoals(onProgress);\n          break;\n        case \"v4.0.0-gamification\":\n          await migrateGamificationSystem(onProgress);\n          break;\n        default:\n          throw new Error(`Unknown migration: ${migrationId}`);\n      }\n    },\n    [migrateThemeSystem, migrateEnhancedGoals, migrateGamificationSystem],\n  );\n\n  // Execute single migration\n  const executeMigration = useCallback(\n    async (migration: Migration): Promise<void> => {\n      logger.info(\"Starting migration\", { migrationId: migration.id });\n\n      // Update migration status\n      const updatedMigrations = migrationState.migrations.map((m: Migration) =>\n        m.id === migration.id\n          ? {\n              ...m,\n              status: MigrationStatus.RUNNING,\n              startedAt: new Date(),\n              progress: 0,\n            }\n          : m,\n      );\n\n      const newState = { ...migrationState, migrations: updatedMigrations };\n      localStorage.setItem(\n        STORAGE_KEYS.MIGRATION_STATE,\n        JSON.stringify(newState),\n      );\n      queryClient.setQueryData([\"migration\", \"state\"], newState);\n\n      try {\n        // Create backup if rollback is available\n        if (migration.rollbackAvailable) {\n          await createBackup(migration.id);\n        }\n\n        // Execute migration logic based on ID\n        await executeMigrationLogic(migration.id, (progress: number) => {\n          // Update progress\n          const progressUpdatedMigrations = migrationState.migrations.map(\n            (m: Migration) => (m.id === migration.id ? { ...m, progress } : m),\n          );\n\n          const progressState = {\n            ...migrationState,\n            migrations: progressUpdatedMigrations,\n          };\n          localStorage.setItem(\n            STORAGE_KEYS.MIGRATION_STATE,\n            JSON.stringify(progressState),\n          );\n          queryClient.setQueryData([\"migration\", \"state\"], progressState);\n        });\n\n        // Mark as completed\n        const completedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.COMPLETED,\n                  completedAt: new Date(),\n                  progress: 100,\n                }\n              : m,\n        );\n\n        const completedState = {\n          ...migrationState,\n          migrations: completedMigrations,\n        };\n        localStorage.setItem(\n          STORAGE_KEYS.MIGRATION_STATE,\n          JSON.stringify(completedState),\n        );\n        queryClient.setQueryData([\"migration\", \"state\"], completedState);\n\n        logger.info(\"Migration completed\", { migrationId: migration.id });\n      } catch (error) {\n        // Mark as failed\n        const failedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.FAILED,\n                  error:\n                    error instanceof Error ? error.message : \"Unknown error\",\n                }\n              : m,\n        );\n\n        const failedState = { ...migrationState, migrations: failedMigrations };\n        localStorage.setItem(\n          STORAGE_KEYS.MIGRATION_STATE,\n          JSON.stringify(failedState),\n        );\n        queryClient.setQueryData([\"migration\", \"state\"], failedState);\n\n        logger.error(\"Migration failed\", { migrationId: migration.id, error });\n        throw error;\n      }\n    },\n    [migrationState, queryClient, createBackup, executeMigrationLogic],\n  );\n\n  // Run migrations mutation\n  const runMigrationsMutation = useMutation({\n    mutationFn: async (migrationIds?: string[]) => {\n      setIsRunning(true);\n      const startTime = Date.now();\n      const result: MigrationResult = {\n        success: true,\n        migrationsRun: 0,\n        errors: [],\n        warnings: [],\n        duration: 0,\n      };\n\n      try {\n        const migrationsToRun = migrationIds\n          ? migrationState.migrations.filter((m: Migration) =>\n              migrationIds.includes(m.id),\n            )\n          : pendingMigrations;\n\n        for (const migration of migrationsToRun) {\n          try {\n            await executeMigration(migration);\n            result.migrationsRun++;\n          } catch (error) {\n            result.success = false;\n            result.errors.push(\n              `${migration.name}: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n            );\n          }\n        }\n\n        result.duration = Date.now() - startTime;\n        return result;\n      } finally {\n        setIsRunning(false);\n      }\n    },\n  });\n\n  // Rollback migration mutation\n  const rollbackMigrationMutation = useMutation({\n    mutationFn: async (migrationId: string) => {\n      const migration = migrationState.migrations.find(\n        (m: Migration) => m.id === migrationId,\n      );\n      if (!migration) throw new Error(\"Migration not found\");\n      if (!migration.rollbackAvailable)\n        throw new Error(\"Rollback not available for this migration\");\n\n      logger.info(\"Rolling back migration\", { migrationId });\n\n      // Find and restore backup\n      const backups = JSON.parse(\n        localStorage.getItem(STORAGE_KEYS.MIGRATION_BACKUPS) || \"[]\",\n      );\n      const backup = backups.find(\n        (b: { migrationId: string }) => b.migrationId === migrationId,\n      );\n\n      if (!backup) throw new Error(\"Backup not found\");\n\n      // Restore data from backup\n      Object.entries(backup.data.localStorage).forEach(([key, value]) => {\n        localStorage.setItem(key, value as string);\n      });\n\n      // Update migration status\n      const rolledBackMigrations = migrationState.migrations.map(\n        (m: Migration) =>\n          m.id === migrationId\n            ? { ...m, status: MigrationStatus.ROLLED_BACK }\n            : m,\n      );\n\n      const rolledBackState = {\n        ...migrationState,\n        migrations: rolledBackMigrations,\n      };\n      localStorage.setItem(\n        STORAGE_KEYS.MIGRATION_STATE,\n        JSON.stringify(rolledBackState),\n      );\n      queryClient.setQueryData([\"migration\", \"state\"], rolledBackState);\n\n      logger.info(\"Migration rolled back\", { migrationId });\n    },\n  });\n\n  return {\n    // Migration state\n    migrations: migrationState?.migrations || [],\n    pendingMigrations,\n    completedMigrations,\n    isRunning,\n\n    // Actions\n    runMigrations: runMigrationsMutation.mutate,\n    rollbackMigration: rollbackMigrationMutation.mutate,\n\n    // Status\n    hasPendingMigrations: pendingMigrations.length > 0,\n    hasFailedMigrations:\n      migrationState?.migrations?.some(\n        (m: Migration) => m.status === MigrationStatus.FAILED,\n      ) || false,\n\n    // Loading states\n    isRunningMigrations: runMigrationsMutation.isPending,\n    isRollingBack: rollbackMigrationMutation.isPending,\n\n    // Results\n    lastResult: runMigrationsMutation.data,\n    error: runMigrationsMutation.error || rollbackMigrationMutation.error,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/system/useOfflineStatus.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (250). Maximum allowed is 75.","line":64,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":377,"endColumn":2},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":78,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":85,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":85,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":92,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":92,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":310,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":310,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":317,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":317,"endColumn":66},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":324,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":324,"endColumn":66}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'addNetworkEvent', 'getNetworkInfo', and 'getNetworkQuality'. Either include them or remove the dependency array.","line":347,"column":6,"nodeType":"ArrayExpression","endLine":347,"endColumn":75,"suggestions":[{"desc":"Update the dependencies array to be: [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]","fix":{"range":[10310,10379],"text":"[handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useOfflineStatus Hook - Network Status Monitoring\n *\n * Monitor network connectivity and provide offline capabilities with intelligent\n * sync when connection is restored.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Network quality enum\nexport enum NetworkQuality {\n  EXCELLENT = \"excellent\",\n  GOOD = \"good\",\n  FAIR = \"fair\",\n  POOR = \"poor\",\n  OFFLINE = \"offline\",\n}\n\n// Connection type\nexport enum ConnectionType {\n  WIFI = \"wifi\",\n  CELLULAR = \"cellular\",\n  ETHERNET = \"ethernet\",\n  BLUETOOTH = \"bluetooth\",\n  UNKNOWN = \"unknown\",\n}\n\n// Offline status interface\nexport interface OfflineStatus {\n  isOnline: boolean;\n  isOffline: boolean;\n  networkQuality: NetworkQuality;\n  connectionType: ConnectionType;\n  downlink: number;\n  rtt: number;\n  effectiveType: string;\n  lastOnline: Date | null;\n  offlineDuration: number;\n  hasPendingSync: boolean;\n  syncQueueSize: number;\n}\n\n// Offline capabilities\nexport interface OfflineCapabilities {\n  canReadCache: boolean;\n  canWriteCache: boolean;\n  canQueueOperations: boolean;\n  estimatedStorageUsage: number;\n  maxStorageLimit: number;\n}\n\n// Network event\nexport interface NetworkEvent {\n  type: \"online\" | \"offline\" | \"quality-change\";\n  timestamp: Date;\n  details?: Record<string, string | number | boolean>;\n}\n\n/**\n * Network Status Hook\n */\nexport const useOfflineStatus = () => {\n  const queryClient = useQueryClient();\n  const [networkEvents, setNetworkEvents] = useState<NetworkEvent[]>([]);\n  const [syncQueue, setSyncQueue] = useState<Record<string, unknown>[]>([]);\n  const [lastOnline, setLastOnline] = useState<Date | null>(null);\n\n  // Get network information if available\n  const getNetworkInfo = useCallback(() => {\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n\n    return {\n      downlink: connection?.downlink || 0,\n      rtt: connection?.rtt || 0,\n      effectiveType: connection?.effectiveType || \"unknown\",\n      type: connection?.type || ConnectionType.UNKNOWN,\n    };\n  }, []);\n\n  // Determine network quality\n  const getNetworkQuality = useCallback(\n    (downlink: number, rtt: number): NetworkQuality => {\n      if (!navigator.onLine) return NetworkQuality.OFFLINE;\n\n      if (downlink >= 10 && rtt < 100) return NetworkQuality.EXCELLENT;\n      if (downlink >= 5 && rtt < 200) return NetworkQuality.GOOD;\n      if (downlink >= 1.5 && rtt < 500) return NetworkQuality.FAIR;\n      return NetworkQuality.POOR;\n    },\n    [],\n  );\n\n  // Current offline status query\n  const { data: offlineStatus } = useQuery<OfflineStatus>({\n    queryKey: [\"network\", \"status\"],\n    queryFn: () => {\n      const networkInfo = getNetworkInfo();\n      const quality = getNetworkQuality(networkInfo.downlink, networkInfo.rtt);\n      const now = new Date();\n\n      const offlineDuration =\n        lastOnline && !navigator.onLine\n          ? now.getTime() - lastOnline.getTime()\n          : 0;\n\n      return {\n        isOnline: navigator.onLine,\n        isOffline: !navigator.onLine,\n        networkQuality: quality,\n        connectionType: networkInfo.type,\n        downlink: networkInfo.downlink,\n        rtt: networkInfo.rtt,\n        effectiveType: networkInfo.effectiveType,\n        lastOnline,\n        offlineDuration,\n        hasPendingSync: syncQueue.length > 0,\n        syncQueueSize: syncQueue.length,\n      };\n    },\n    refetchInterval: 5000, // Check every 5 seconds\n    staleTime: 1000,\n  });\n\n  // Offline capabilities query\n  const { data: capabilities } = useQuery<OfflineCapabilities>({\n    queryKey: [\"network\", \"capabilities\"],\n    queryFn: async () => {\n      let storageUsage = 0;\n      let storageLimit = 0;\n\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        try {\n          const estimate = await navigator.storage.estimate();\n          storageUsage = estimate.usage || 0;\n          storageLimit = estimate.quota || 0;\n        } catch (error) {\n          logger.warn(\"Could not estimate storage\", error);\n        }\n      }\n\n      return {\n        canReadCache: \"caches\" in window,\n        canWriteCache: \"caches\" in window && navigator.onLine,\n        canQueueOperations: true,\n        estimatedStorageUsage: storageUsage,\n        maxStorageLimit: storageLimit,\n      };\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Add network event\n  const addNetworkEvent = useCallback(\n    (\n      type: NetworkEvent[\"type\"],\n      details?: Record<string, string | number | boolean>,\n    ) => {\n      const event: NetworkEvent = {\n        type,\n        timestamp: new Date(),\n        details,\n      };\n\n      setNetworkEvents((prev) => [...prev.slice(-49), event]); // Keep last 50 events\n      logger.info(`Network event: ${type}`, details);\n    },\n    [],\n  );\n\n  // Handle online event\n  const handleOnline = useCallback(() => {\n    setLastOnline(new Date());\n    addNetworkEvent(\"online\", {\n      wasOffline: !navigator.onLine,\n      syncQueueSize: syncQueue.length,\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n\n    // Process sync queue when back online\n    if (syncQueue.length > 0) {\n      processSyncQueue();\n    }\n  }, [syncQueue, addNetworkEvent, queryClient, processSyncQueue]);\n\n  // Handle offline event\n  const handleOffline = useCallback(() => {\n    addNetworkEvent(\"offline\", {\n      lastOnline: lastOnline?.toISOString(),\n      networkInfo: getNetworkInfo(),\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n  }, [lastOnline, addNetworkEvent, getNetworkInfo, queryClient]);\n\n  // Process sync queue\n  const processSyncQueue = useCallback(async () => {\n    if (!navigator.onLine || syncQueue.length === 0) return;\n\n    logger.info(\"Processing sync queue\", { queueSize: syncQueue.length });\n\n    const processedItems: Record<string, unknown>[] = [];\n\n    for (const item of syncQueue) {\n      try {\n        // Here you would implement actual sync logic\n        // For now, we'll just simulate processing\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        processedItems.push(item);\n        logger.debug(\"Sync item processed\", { item });\n      } catch (error) {\n        logger.error(\"Failed to sync item\", { item, error });\n        break; // Stop processing on error\n      }\n    }\n\n    // Remove processed items from queue\n    setSyncQueue((prev) =>\n      prev.filter((item) => !processedItems.includes(item)),\n    );\n\n    if (processedItems.length > 0) {\n      queryClient.invalidateQueries({ queryKey: [\"network\"] });\n      logger.info(\"Sync queue processed\", {\n        processedCount: processedItems.length,\n        remainingCount: syncQueue.length - processedItems.length,\n      });\n    }\n  }, [syncQueue, queryClient]);\n\n  // Add item to sync queue\n  const queueForSync = useCallback((item: Record<string, unknown>) => {\n    setSyncQueue((prev) => [...prev, { ...item, queuedAt: new Date() }]);\n    logger.debug(\"Item queued for sync\", { item });\n  }, []);\n\n  // Clear sync queue\n  const clearSyncQueue = useCallback(() => {\n    setSyncQueue([]);\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n    logger.info(\"Sync queue cleared\");\n  }, [queryClient]);\n\n  // Retry sync\n  const retrySync = useCallback(() => {\n    if (navigator.onLine) {\n      processSyncQueue();\n    } else {\n      logger.warn(\"Cannot retry sync while offline\");\n    }\n  }, [processSyncQueue]);\n\n  // Monitor connection changes\n  useEffect(() => {\n    const handleConnectionChange = () => {\n      const networkInfo = getNetworkInfo();\n      const newQuality = getNetworkQuality(\n        networkInfo.downlink,\n        networkInfo.rtt,\n      );\n\n      if (offlineStatus && newQuality !== offlineStatus.networkQuality) {\n        addNetworkEvent(\"quality-change\", {\n          oldQuality: offlineStatus.networkQuality,\n          newQuality,\n          networkInfo,\n        });\n      }\n\n      queryClient.invalidateQueries({ queryKey: [\"network\", \"status\"] });\n    };\n\n    // Listen for online/offline events\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes if supported\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (type: string, listener: EventListener) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n    if (connection) {\n      connection.addEventListener(\"change\", handleConnectionChange);\n    }\n\n    // Set initial online status\n    if (navigator.onLine && !lastOnline) {\n      setLastOnline(new Date());\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      if (connection) {\n        connection.removeEventListener(\"change\", handleConnectionChange);\n      }\n    };\n    // addNetworkEvent, getNetworkInfo, getNetworkQuality are stable (no/stable deps)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline]);\n\n  return {\n    // Status\n    ...offlineStatus,\n    capabilities,\n\n    // Events\n    networkEvents,\n\n    // Sync management\n    queueForSync,\n    clearSyncQueue,\n    retrySync,\n    processSyncQueue,\n\n    // Computed properties\n    connectionStrength: offlineStatus?.networkQuality || NetworkQuality.OFFLINE,\n    canPerformOperations: offlineStatus?.isOnline || false,\n    needsSync: (offlineStatus?.syncQueueSize || 0) > 0,\n\n    // Helper methods\n    isGoodConnection:\n      offlineStatus?.networkQuality === NetworkQuality.EXCELLENT ||\n      offlineStatus?.networkQuality === NetworkQuality.GOOD,\n    isPoorConnection: offlineStatus?.networkQuality === NetworkQuality.POOR,\n    hasRecentEvents:\n      networkEvents.filter((e) => Date.now() - e.timestamp.getTime() < 60000)\n        .length > 0,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/system/usePerformance.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (248). Maximum allowed is 75.","line":78,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":382,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'queryFn' has too many lines (80). Maximum allowed is 75.","line":85,"column":14,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":173,"endColumn":6}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * usePerformance Hook - Performance Monitoring\n *\n * Monitor application performance metrics, identify bottlenecks, and provide\n * optimization recommendations.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Performance metric types\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  lcp: number; // Largest Contentful Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout Shift\n\n  // Loading performance\n  domContentLoaded: number;\n  loadComplete: number;\n  firstPaint: number;\n  firstContentfulPaint: number;\n\n  // Memory usage\n  memoryUsed: number;\n  memoryTotal: number;\n  memoryUsagePercent: number;\n\n  // Network\n  networkType: string;\n  effectiveType: string;\n  downlink: number;\n  rtt: number;\n\n  // Custom metrics\n  componentRenderTime: number;\n  apiResponseTime: number;\n\n  timestamp: Date;\n}\n\n// Performance alert\nexport interface PerformanceAlert {\n  id: string;\n  type: \"warning\" | \"critical\";\n  metric: keyof PerformanceMetrics;\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: Date;\n}\n\n// Performance recommendation\nexport interface PerformanceRecommendation {\n  id: string;\n  category: \"loading\" | \"runtime\" | \"memory\" | \"network\";\n  priority: \"low\" | \"medium\" | \"high\";\n  title: string;\n  description: string;\n  impact: string;\n  effort: string;\n}\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  lcp: { good: 2500, poor: 4000 },\n  fid: { good: 100, poor: 300 },\n  cls: { good: 0.1, poor: 0.25 },\n  memoryUsagePercent: { good: 70, poor: 90 },\n  loadComplete: { good: 3000, poor: 6000 },\n  apiResponseTime: { good: 500, poor: 2000 },\n};\n\n/**\n * Performance Monitoring Hook\n */\nexport const usePerformance = () => {\n  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Get current performance metrics\n  const { data: metrics, isLoading } = useQuery<PerformanceMetrics>({\n    queryKey: [\"performance\", \"metrics\"],\n    queryFn: async () => {\n      const perfMetrics: PerformanceMetrics = {\n        lcp: 0,\n        fid: 0,\n        cls: 0,\n        domContentLoaded: 0,\n        loadComplete: 0,\n        firstPaint: 0,\n        firstContentfulPaint: 0,\n        memoryUsed: 0,\n        memoryTotal: 0,\n        memoryUsagePercent: 0,\n        networkType: \"unknown\",\n        effectiveType: \"unknown\",\n        downlink: 0,\n        rtt: 0,\n        componentRenderTime: 0,\n        apiResponseTime: 0,\n        timestamp: new Date(),\n      };\n\n      // Get performance timing\n      if (performance.timing) {\n        const timing = performance.timing;\n        perfMetrics.domContentLoaded =\n          timing.domContentLoadedEventEnd - timing.navigationStart;\n        perfMetrics.loadComplete = timing.loadEventEnd - timing.navigationStart;\n      }\n\n      // Get paint timing\n      const paintEntries = performance.getEntriesByType(\"paint\");\n      paintEntries.forEach((entry) => {\n        if (entry.name === \"first-paint\") {\n          perfMetrics.firstPaint = entry.startTime;\n        } else if (entry.name === \"first-contentful-paint\") {\n          perfMetrics.firstContentfulPaint = entry.startTime;\n        }\n      });\n\n      // Get memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: {\n              usedJSHeapSize: number;\n              totalJSHeapSize: number;\n            };\n          }\n        ).memory;\n        if (memory) {\n          perfMetrics.memoryUsed = memory.usedJSHeapSize;\n          perfMetrics.memoryTotal = memory.totalJSHeapSize;\n          perfMetrics.memoryUsagePercent =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Get network information\n      const nav = navigator as Navigator & {\n        connection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        mozConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        webkitConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n      };\n      const connection =\n        nav.connection || nav.mozConnection || nav.webkitConnection;\n      if (connection) {\n        perfMetrics.networkType = connection.type || \"unknown\";\n        perfMetrics.effectiveType = connection.effectiveType || \"unknown\";\n        perfMetrics.downlink = connection.downlink || 0;\n        perfMetrics.rtt = connection.rtt || 0;\n      }\n\n      return perfMetrics;\n    },\n    refetchInterval: isMonitoring ? 10000 : false, // Every 10 seconds\n    staleTime: 5000,\n  });\n\n  // Generate performance recommendations\n  const { data: recommendations = [] } = useQuery<PerformanceRecommendation[]>({\n    queryKey: [\"performance\", \"recommendations\", metrics],\n    queryFn: () => {\n      if (!metrics) return [];\n\n      const recs: PerformanceRecommendation[] = [];\n\n      // Loading performance recommendations\n      if (metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.poor) {\n        recs.push({\n          id: \"slow-loading\",\n          category: \"loading\",\n          priority: \"high\",\n          title: \"Slow Page Loading\",\n          description: \"Page load time exceeds recommended thresholds\",\n          impact: \"High - affects user experience and engagement\",\n          effort: \"Medium - requires code splitting and optimization\",\n        });\n      }\n\n      // Memory usage recommendations\n      if (\n        metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.poor\n      ) {\n        recs.push({\n          id: \"high-memory\",\n          category: \"memory\",\n          priority: \"high\",\n          title: \"High Memory Usage\",\n          description: \"Application is using excessive memory\",\n          impact: \"High - can cause crashes and slowdowns\",\n          effort: \"High - requires memory leak investigation\",\n        });\n      }\n\n      // Network recommendations\n      if (metrics.rtt > 500) {\n        recs.push({\n          id: \"high-latency\",\n          category: \"network\",\n          priority: \"medium\",\n          title: \"High Network Latency\",\n          description: \"Network requests are slow\",\n          impact: \"Medium - affects data loading\",\n          effort: \"Low - implement caching strategies\",\n        });\n      }\n\n      return recs;\n    },\n    enabled: Boolean(metrics),\n    staleTime: 60000, // 1 minute\n  });\n\n  // Check for performance issues and generate alerts\n  const checkPerformanceAlerts = useCallback(\n    (currentMetrics: PerformanceMetrics) => {\n      const newAlerts: PerformanceAlert[] = [];\n\n      // Check each threshold\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          newAlerts.push({\n            id: `${key}-critical-${Date.now()}`,\n            type: \"critical\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.poor,\n            message: `${key.toUpperCase()} is critically high: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        } else if (value > thresholds.good) {\n          newAlerts.push({\n            id: `${key}-warning-${Date.now()}`,\n            type: \"warning\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.good,\n            message: `${key.toUpperCase()} exceeds good threshold: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        }\n      });\n\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n    },\n    [],\n  );\n\n  // Monitor performance changes\n  useEffect(() => {\n    if (metrics && isMonitoring) {\n      checkPerformanceAlerts(metrics);\n    }\n  }, [metrics, isMonitoring, checkPerformanceAlerts]);\n\n  // Measure component render time\n  const measureRenderTime = useCallback(\n    (componentName: string, renderFn: () => void) => {\n      const startTime = performance.now();\n      renderFn();\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      logger.debug(\n        `Component ${componentName} render time: ${renderTime.toFixed(2)}ms`,\n      );\n      return renderTime;\n    },\n    [],\n  );\n\n  // Measure API response time\n  const measureApiTime = useCallback(\n    async <T>(apiCall: () => Promise<T>): Promise<T> => {\n      const startTime = performance.now();\n      try {\n        const result = await apiCall();\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.debug(`API response time: ${responseTime.toFixed(2)}ms`);\n        return { result, responseTime };\n      } catch (error) {\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.warn(`API error after ${responseTime.toFixed(2)}ms`, error);\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // Clear old alerts\n  const clearOldAlerts = useCallback(() => {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    setAlerts((prev) => prev.filter((alert) => alert.timestamp > oneHourAgo));\n  }, []);\n\n  // Performance score calculation\n  const performanceScore = useCallback(\n    (currentMetrics: PerformanceMetrics): number => {\n      if (!currentMetrics) return 0;\n\n      let score = 100;\n\n      // Deduct points for poor metrics\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          score -= 30;\n        } else if (value > thresholds.good) {\n          score -= 15;\n        }\n      });\n\n      return Math.max(0, score);\n    },\n    [],\n  );\n\n  return {\n    // Current metrics\n    metrics,\n    isLoading,\n\n    // Performance insights\n    performanceScore: metrics ? performanceScore(metrics) : 0,\n    recommendations,\n    alerts,\n\n    // Controls\n    isMonitoring,\n    setIsMonitoring,\n    clearOldAlerts,\n\n    // Measurement tools\n    measureRenderTime,\n    measureApiTime,\n\n    // Computed properties\n    isPerformant: metrics ? performanceScore(metrics) > 80 : false,\n    hasIssues: alerts.length > 0,\n    criticalIssues: alerts.filter((a) => a.type === \"critical\").length,\n    warningIssues: alerts.filter((a) => a.type === \"warning\").length,\n\n    // Quick checks\n    isSlowLoading: metrics?.loadComplete\n      ? metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.good\n      : false,\n    isHighMemory: metrics?.memoryUsagePercent\n      ? metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.good\n      : false,\n    isSlowNetwork: metrics?.rtt ? metrics.rtt > 500 : false,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tasks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tasks/useCountdownTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tasks/useTaskItem.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (96). Maximum allowed is 75.","line":24,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":135,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport type { DBTask, TaskStatus } from \"../../types/database\";\nimport {\n  FaCheckCircle,\n  FaTimesCircle,\n  FaTrophy,\n  FaClock,\n} from \"../../utils/iconImport\";\n\n// Task status configuration type\ninterface TaskStatusConfig {\n  icon: React.ReactNode;\n  text: string;\n  borderColor: string;\n}\n\n// Task priority styles type\ninterface TaskPriorityStyles {\n  bgColor: string;\n  textColor: string;\n}\n\n// Custom hook for task item logic\nexport const useTaskItem = (\n  task: DBTask,\n  onSubmit: (taskId: string, note: string) => void,\n) => {\n  const [note, setNote] = useState(\"\");\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Task status configuration logic\n  const getStatusConfig = (status: TaskStatus): TaskStatusConfig => {\n    switch (status) {\n      case \"pending\":\n        return {\n          icon: <FaClock className=\"text-nightly-aquamarine\" />,\n          text: \"Pending\",\n          borderColor: \"border-nightly-aquamarine\",\n        };\n      case \"submitted\":\n        return {\n          icon: <FaClock className=\"text-yellow-400\" />,\n          text: \"Submitted\",\n          borderColor: \"border-yellow-400\",\n        };\n      case \"approved\":\n        return {\n          icon: <FaCheckCircle className=\"text-green-400\" />,\n          text: \"Approved\",\n          borderColor: \"border-green-400\",\n        };\n      case \"rejected\":\n        return {\n          icon: <FaTimesCircle className=\"text-red-400\" />,\n          text: \"Rejected\",\n          borderColor: \"border-red-400\",\n        };\n      case \"completed\":\n        return {\n          icon: <FaTrophy className=\"text-nightly-lavender-floral\" />,\n          text: \"Completed\",\n          borderColor: \"border-nightly-lavender-floral\",\n        };\n      default:\n        return {\n          icon: <FaClock className=\"text-gray-400\" />,\n          text: \"Unknown\",\n          borderColor: \"border-gray-400\",\n        };\n    }\n  };\n\n  // Priority styling logic\n  const getPriorityStyles = (priority: string): TaskPriorityStyles => {\n    switch (priority) {\n      case \"critical\":\n        return {\n          bgColor: \"bg-red-500/20\",\n          textColor: \"text-red-300\",\n        };\n      case \"high\":\n        return {\n          bgColor: \"bg-orange-500/20\",\n          textColor: \"text-orange-300\",\n        };\n      case \"medium\":\n        return {\n          bgColor: \"bg-yellow-500/20\",\n          textColor: \"text-yellow-300\",\n        };\n      default:\n        return {\n          bgColor: \"bg-gray-500/20\",\n          textColor: \"text-gray-300\",\n        };\n    }\n  };\n\n  // Submit handler logic\n  const handleSubmit = async () => {\n    setIsSubmitting(true);\n    try {\n      await onSubmit(task.id, note);\n      setNote(\"\");\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Derived values\n  const statusConfig = getStatusConfig(task.status);\n  const priorityStyles = task.priority\n    ? getPriorityStyles(task.priority)\n    : null;\n  const isOverdue = task.dueDate && new Date() > task.dueDate;\n\n  return {\n    // State\n    note,\n    isSubmitting,\n\n    // Actions\n    setNote,\n    handleSubmit,\n\n    // Computed values\n    statusConfig,\n    priorityStyles,\n    isOverdue: Boolean(isOverdue),\n\n    // Helper functions (exposed for flexibility)\n    getStatusConfig,\n    getPriorityStyles,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tasks/useTaskManagement.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useTaskManagement' has too many lines (251). Maximum allowed is 75.","line":89,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":406,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task Management Hook\n *\n * Extracts task CRUD operations and management logic from TaskManagement component.\n * Provides comprehensive task filtering, sorting, and bulk operations.\n */\n\nimport { useState, useCallback, useMemo, useRef, useEffect } from \"react\";\nimport { Task, TaskStatus, TaskPriority } from \"@/types/core\";\nimport { Timestamp } from \"firebase/firestore\";\n\n// Filter and sort types\nexport interface TaskFilter {\n  status?: TaskStatus[];\n  priority?: TaskPriority[];\n  assignedBy?: (\"submissive\" | \"keyholder\")[];\n  hasDeadline?: boolean;\n  searchText?: string;\n}\n\nexport type TaskSortBy =\n  | \"createdAt\"\n  | \"dueDate\"\n  | \"priority\"\n  | \"status\"\n  | \"title\";\n\nexport type SortDirection = \"asc\" | \"desc\";\n\n// Input types for creating and updating tasks\nexport interface CreateTaskInput {\n  title: string;\n  description?: string;\n  category?: string;\n  priority?: TaskPriority;\n  dueDate?: Date;\n  assignedBy?: \"submissive\" | \"keyholder\";\n}\n\nexport interface UpdateTaskInput {\n  title?: string;\n  description?: string;\n  category?: string;\n  priority?: TaskPriority;\n  status?: TaskStatus;\n  dueDate?: Date;\n  submissiveNote?: string;\n  keyholderFeedback?: string;\n}\n\n// Hook return interface\nexport interface UseTaskManagementReturn {\n  // Data\n  tasks: Task[];\n  filteredTasks: Task[];\n  isLoading: boolean;\n  error: Error | null;\n\n  // Actions\n  createTask: (task: CreateTaskInput) => Promise<Task>;\n  updateTask: (id: string, updates: UpdateTaskInput) => Promise<Task>;\n  deleteTask: (id: string) => Promise<void>;\n  assignTask: (taskId: string, wearerId: string) => Promise<void>;\n  bulkAssign: (taskIds: string[], wearerId: string) => Promise<void>;\n  completeTask: (id: string) => Promise<void>;\n\n  // Filtering\n  setFilter: (filter: TaskFilter) => void;\n  currentFilter: TaskFilter;\n  clearFilters: () => void;\n\n  // Sorting\n  setSortBy: (sort: TaskSortBy, direction?: SortDirection) => void;\n  currentSort: TaskSortBy;\n  currentDirection: SortDirection;\n\n  // State\n  isCreating: boolean;\n  isUpdating: boolean;\n  isDeleting: boolean;\n}\n\n/**\n * Task Management Hook\n *\n * @param keyholderMode - Whether to operate in keyholder mode (shows all wearer tasks)\n * @returns Task management interface with CRUD operations and filtering\n */\nexport function useTaskManagement(\n  _keyholderMode: boolean = false,\n): UseTaskManagementReturn {\n  // State\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [currentFilter, setCurrentFilter] = useState<TaskFilter>({});\n  const [currentSort, setCurrentSort] = useState<TaskSortBy>(\"createdAt\");\n  const [currentDirection, setCurrentDirection] =\n    useState<SortDirection>(\"desc\");\n\n  // Action states\n  const [isCreating, setIsCreating] = useState<boolean>(false);\n  const [isUpdating, setIsUpdating] = useState<boolean>(false);\n  const [isDeleting, setIsDeleting] = useState<boolean>(false);\n\n  // Use a ref to always have access to the latest tasks\n  const tasksRef = useRef(tasks);\n  useEffect(() => {\n    tasksRef.current = tasks;\n  }, [tasks]);\n\n  // Filter tasks based on current filter\n  const filteredTasks = useMemo(() => {\n    let filtered = [...tasks];\n\n    // Status filter\n    if (currentFilter.status && currentFilter.status.length > 0) {\n      filtered = filtered.filter((task) =>\n        currentFilter.status!.includes(task.status),\n      );\n    }\n\n    // Priority filter\n    if (currentFilter.priority && currentFilter.priority.length > 0) {\n      filtered = filtered.filter((task) =>\n        currentFilter.priority!.includes(task.priority),\n      );\n    }\n\n    // Assigned by filter\n    if (currentFilter.assignedBy && currentFilter.assignedBy.length > 0) {\n      filtered = filtered.filter((task) =>\n        currentFilter.assignedBy!.includes(task.assignedBy),\n      );\n    }\n\n    // Has deadline filter\n    if (currentFilter.hasDeadline !== undefined) {\n      filtered = filtered.filter((task) =>\n        currentFilter.hasDeadline ? !!task.dueDate : !task.dueDate,\n      );\n    }\n\n    // Search text filter\n    if (currentFilter.searchText) {\n      const searchLower = currentFilter.searchText.toLowerCase();\n      filtered = filtered.filter(\n        (task) =>\n          task.title.toLowerCase().includes(searchLower) ||\n          (task.description?.toLowerCase().includes(searchLower) ?? false) ||\n          (task.category?.toLowerCase().includes(searchLower) ?? false),\n      );\n    }\n\n    // Sort tasks\n    filtered.sort((a, b) => {\n      let comparison = 0;\n\n      switch (currentSort) {\n        case \"createdAt\":\n          comparison =\n            (a.createdAt?.getTime() ?? 0) - (b.createdAt?.getTime() ?? 0);\n          break;\n        case \"dueDate\":\n          comparison =\n            (a.dueDate?.getTime() ?? Infinity) -\n            (b.dueDate?.getTime() ?? Infinity);\n          break;\n        case \"priority\": {\n          const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };\n          comparison = priorityOrder[a.priority] - priorityOrder[b.priority];\n          break;\n        }\n        case \"status\": {\n          const statusOrder = {\n            pending: 1,\n            in_progress: 2,\n            submitted: 3,\n            approved: 4,\n            rejected: 5,\n            completed: 6,\n            overdue: 7,\n          };\n          comparison = statusOrder[a.status] - statusOrder[b.status];\n          break;\n        }\n        case \"title\":\n          comparison = a.title.localeCompare(b.title);\n          break;\n      }\n\n      return currentDirection === \"asc\" ? comparison : -comparison;\n    });\n\n    return filtered;\n  }, [tasks, currentFilter, currentSort, currentDirection]);\n\n  // Create a new task\n  const createTask = useCallback(\n    async (task: CreateTaskInput): Promise<Task> => {\n      setIsCreating(true);\n      setError(null);\n\n      try {\n        // Mock implementation - in production, this would call Firebase/API\n        const newTask: Task = {\n          id: `task-${Date.now()}`,\n          userId: \"current-user-id\", // Would come from auth context\n          title: task.title,\n          description: task.description,\n          category: task.category,\n          status: TaskStatus.PENDING,\n          priority: task.priority ?? TaskPriority.MEDIUM,\n          assignedBy: task.assignedBy ?? \"submissive\",\n          createdAt: Timestamp.fromDate(new Date()),\n          dueDate: task.dueDate ? Timestamp.fromDate(task.dueDate) : undefined,\n          isRecurring: false,\n        };\n\n        setTasks((prev) => {\n          const newTasks = [...prev, newTask];\n          tasksRef.current = newTasks; // Update ref immediately\n          return newTasks;\n        });\n        return newTask;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to create task\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsCreating(false);\n      }\n    },\n    [],\n  );\n\n  // Update an existing task\n  const updateTask = useCallback(\n    async (id: string, updates: UpdateTaskInput): Promise<Task> => {\n      setIsUpdating(true);\n      setError(null);\n\n      try {\n        const currentTasks = tasksRef.current;\n        const taskIndex = currentTasks.findIndex((t) => t.id === id);\n\n        if (taskIndex === -1) {\n          throw new Error(`Task with id ${id} not found`);\n        }\n\n        const updatedTask = { ...currentTasks[taskIndex], ...updates };\n        const newTasks = [...currentTasks];\n        newTasks[taskIndex] = updatedTask;\n\n        setTasks(newTasks);\n        tasksRef.current = newTasks; // Update ref immediately\n\n        return updatedTask;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update task\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  // Delete a task\n  const deleteTask = useCallback(async (id: string): Promise<void> => {\n    setIsDeleting(true);\n    setError(null);\n\n    try {\n      setTasks((prev) => {\n        const newTasks = prev.filter((t) => t.id !== id);\n        tasksRef.current = newTasks; // Update ref immediately\n        return newTasks;\n      });\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to delete task\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsDeleting(false);\n    }\n  }, []);\n\n  // Assign a task to a wearer\n  const assignTask = useCallback(\n    async (taskId: string, _wearerId: string): Promise<void> => {\n      setError(null);\n\n      try {\n        // In production, this would update the task's wearer assignment\n        await updateTask(taskId, {\n          // Custom field for wearer assignment (not in base Task type)\n          // Would need to extend Task type or use metadata\n        } as Partial<Task>);\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to assign task\");\n        setError(error);\n        throw error;\n      }\n    },\n    [updateTask],\n  );\n\n  // Bulk assign tasks to a wearer\n  const bulkAssign = useCallback(\n    async (taskIds: string[], wearerId: string): Promise<void> => {\n      setError(null);\n\n      try {\n        await Promise.all(taskIds.map((id) => assignTask(id, wearerId)));\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to bulk assign tasks\");\n        setError(error);\n        throw error;\n      }\n    },\n    [assignTask],\n  );\n\n  // Complete a task\n  const completeTask = useCallback(\n    async (id: string): Promise<void> => {\n      setError(null);\n\n      try {\n        await updateTask(id, {\n          status: TaskStatus.COMPLETED,\n        });\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to complete task\");\n        setError(error);\n        throw error;\n      }\n    },\n    [updateTask],\n  );\n\n  // Set filter\n  const setFilter = useCallback((filter: TaskFilter) => {\n    setCurrentFilter(filter);\n  }, []);\n\n  // Clear all filters\n  const clearFilters = useCallback(() => {\n    setCurrentFilter({});\n  }, []);\n\n  // Set sort\n  const setSortBy = useCallback(\n    (sort: TaskSortBy, direction?: SortDirection) => {\n      setCurrentSort(sort);\n      if (direction) {\n        setCurrentDirection(direction);\n      }\n    },\n    [],\n  );\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    // Data\n    tasks,\n    filteredTasks,\n    isLoading,\n    error,\n\n    // Actions\n    createTask,\n    updateTask,\n    deleteTask,\n    assignTask,\n    bulkAssign,\n    completeTask,\n\n    // Filtering\n    setFilter,\n    currentFilter,\n    clearFilters,\n\n    // Sorting\n    setSortBy,\n    currentSort,\n    currentDirection,\n\n    // State\n    isCreating,\n    isUpdating,\n    isDeleting,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tracker/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tracker/useEmergencyUnlockModal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tracker/usePauseResumeControls.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/tracker/useTrackerStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/ui/useTheme.ts","messages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":384,"column":37,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":384,"endColumn":53},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":409,"column":37,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":409,"endColumn":53}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useTheme Hook - Enhanced Theme Management\n *\n * Advanced theme management beyond basic store functionality, with dynamic themes,\n * user customization, and accessibility features.\n */\n\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  UseMutationResult,\n} from \"@tanstack/react-query\";\nimport {\n  Theme,\n  CustomTheme,\n  CustomThemeDefinition,\n  ThemePreferences,\n  AccessibilitySettings,\n  EnhancedThemeState,\n  ThemeCategory,\n  FontScale,\n  ColorPalette,\n} from \"../../types/theme\";\nimport { logger } from \"../../utils/logging\";\n\n// Default themes\nconst DEFAULT_LIGHT_THEME: Theme = {\n  id: \"default-light\",\n  name: \"Light\",\n  category: ThemeCategory.LIGHT,\n  colors: {\n    primary: \"#6366f1\",\n    secondary: \"#8b5cf6\",\n    accent: \"#06b6d4\",\n    background: \"#ffffff\",\n    surface: \"#f8fafc\",\n    text: \"#1e293b\",\n    textSecondary: \"#64748b\",\n    border: \"#e2e8f0\",\n    success: \"#10b981\",\n    warning: \"#f59e0b\",\n    error: \"#ef4444\",\n    info: \"#3b82f6\",\n  },\n  typography: {\n    fontFamily: \"Inter, system-ui, sans-serif\",\n    baseSize: 16,\n    lineHeight: 1.5,\n    letterSpacing: 0,\n  },\n  spacing: {\n    xs: \"0.25rem\",\n    sm: \"0.5rem\",\n    md: \"1rem\",\n    lg: \"1.5rem\",\n    xl: \"2rem\",\n    xxl: \"3rem\",\n  },\n  animations: {\n    duration: 200,\n    easing: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n    enabled: true,\n  },\n  accessibility: {\n    highContrast: false,\n    reducedMotion: false,\n    focusVisible: true,\n    screenReader: false,\n  },\n};\n\nconst DEFAULT_DARK_THEME: Theme = {\n  ...DEFAULT_LIGHT_THEME,\n  id: \"default-dark\",\n  name: \"Dark\",\n  category: ThemeCategory.DARK,\n  colors: {\n    primary: \"#818cf8\",\n    secondary: \"#a78bfa\",\n    accent: \"#22d3ee\",\n    background: \"#0f172a\",\n    surface: \"#1e293b\",\n    text: \"#f1f5f9\",\n    textSecondary: \"#94a3b8\",\n    border: \"#334155\",\n    success: \"#34d399\",\n    warning: \"#fbbf24\",\n    error: \"#f87171\",\n    info: \"#60a5fa\",\n  },\n};\n\nconst DEFAULT_THEMES = [DEFAULT_LIGHT_THEME, DEFAULT_DARK_THEME];\n\n// Default preferences\nconst DEFAULT_PREFERENCES: ThemePreferences = {\n  autoSwitch: false,\n  lightThemeId: \"default-light\",\n  darkThemeId: \"default-dark\",\n  scheduleEnabled: false,\n  lightModeStart: \"06:00\",\n  darkModeStart: \"20:00\",\n  systemSyncEnabled: true,\n};\n\n// Default accessibility settings\nconst DEFAULT_ACCESSIBILITY: AccessibilitySettings = {\n  highContrast: false,\n  reducedMotion: false,\n  fontSize: FontScale.MEDIUM,\n  focusOutlines: true,\n  screenReaderMode: false,\n  keyboardNavigation: true,\n};\n\n// Storage keys\nconst STORAGE_KEYS = {\n  CURRENT_THEME: \"chastity-theme-current\",\n  CUSTOM_THEMES: \"chastity-theme-custom\",\n  PREFERENCES: \"chastity-theme-preferences\",\n  ACCESSIBILITY: \"chastity-theme-accessibility\",\n};\n\n// Custom hook for theme queries\nconst useThemeQueries = (customThemes: CustomTheme[]) => {\n  const customThemesQuery = useQuery<CustomTheme[]>({\n    queryKey: [\"themes\", \"custom\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.CUSTOM_THEMES);\n      return stored ? JSON.parse(stored) : [];\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  const preferencesQuery = useQuery<ThemePreferences>({\n    queryKey: [\"themes\", \"preferences\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.PREFERENCES);\n      return stored\n        ? { ...DEFAULT_PREFERENCES, ...JSON.parse(stored) }\n        : DEFAULT_PREFERENCES;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  const accessibilityQuery = useQuery<AccessibilitySettings>({\n    queryKey: [\"themes\", \"accessibility\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.ACCESSIBILITY);\n      return stored\n        ? { ...DEFAULT_ACCESSIBILITY, ...JSON.parse(stored) }\n        : DEFAULT_ACCESSIBILITY;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  const currentThemeQuery = useQuery<Theme>({\n    queryKey: [\"themes\", \"current\"],\n    queryFn: () => {\n      const stored = localStorage.getItem(STORAGE_KEYS.CURRENT_THEME);\n      if (stored) {\n        const themeId = JSON.parse(stored);\n        const allThemes = [...DEFAULT_THEMES, ...customThemes];\n        return allThemes.find((t) => t.id === themeId) || DEFAULT_LIGHT_THEME;\n      }\n      return DEFAULT_LIGHT_THEME;\n    },\n    staleTime: 1000,\n  });\n\n  return {\n    customThemes: customThemesQuery.data || [],\n    preferences: preferencesQuery.data || DEFAULT_PREFERENCES,\n    accessibilitySettings: accessibilityQuery.data || DEFAULT_ACCESSIBILITY,\n    currentTheme: currentThemeQuery.data || DEFAULT_LIGHT_THEME,\n  };\n};\n\n// Custom hook for theme mutations\nconst useThemeMutations = (\n  availableThemes: Theme[],\n  customThemes: CustomTheme[],\n) => {\n  const queryClient = useQueryClient();\n\n  const setThemeMutation = useMutation({\n    mutationFn: async (themeId: string) => {\n      const theme = availableThemes.find((t) => t.id === themeId);\n      if (!theme) throw new Error(\"Theme not found\");\n\n      localStorage.setItem(STORAGE_KEYS.CURRENT_THEME, JSON.stringify(themeId));\n      return theme;\n    },\n    onSuccess: (theme) => {\n      queryClient.setQueryData([\"themes\", \"current\"], theme);\n      applyThemeToDocument(theme);\n      logger.info(\"Theme changed\", {\n        themeId: theme.id,\n        themeName: theme.name,\n      });\n    },\n  });\n\n  const createCustomThemeMutation = useMutation({\n    mutationFn: async (definition: CustomThemeDefinition) => {\n      const baseTheme = availableThemes.find(\n        (t) => t.id === definition.baseTheme,\n      );\n      if (!baseTheme) throw new Error(\"Base theme not found\");\n\n      const newTheme: CustomTheme = {\n        ...baseTheme,\n        ...definition.overrides,\n        id: `custom-${Date.now()}`,\n        name: definition.name,\n        category: ThemeCategory.CUSTOM,\n        baseTheme: definition.baseTheme,\n        isUserCreated: true,\n        createdAt: new Date(),\n      };\n\n      const updatedCustomThemes = [...customThemes, newTheme];\n      localStorage.setItem(\n        STORAGE_KEYS.CUSTOM_THEMES,\n        JSON.stringify(updatedCustomThemes),\n      );\n\n      return newTheme;\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"themes\", \"custom\"] });\n      logger.info(\"Custom theme created\");\n    },\n  });\n\n  return { setThemeMutation, createCustomThemeMutation };\n};\n\n// Custom hook for preference mutations\nconst usePreferenceMutations = (\n  preferences: ThemePreferences,\n  accessibilitySettings: AccessibilitySettings,\n) => {\n  const queryClient = useQueryClient();\n\n  const updatePreferencesMutation = useMutation({\n    mutationFn: async (updates: Partial<ThemePreferences>) => {\n      const newPreferences = { ...preferences, ...updates };\n      localStorage.setItem(\n        STORAGE_KEYS.PREFERENCES,\n        JSON.stringify(newPreferences),\n      );\n      return newPreferences;\n    },\n    onSuccess: (newPreferences) => {\n      queryClient.setQueryData([\"themes\", \"preferences\"], newPreferences);\n      logger.info(\"Theme preferences updated\");\n    },\n  });\n\n  const updateAccessibilityMutation = useMutation({\n    mutationFn: async (updates: Partial<AccessibilitySettings>) => {\n      const newSettings = { ...accessibilitySettings, ...updates };\n      localStorage.setItem(\n        STORAGE_KEYS.ACCESSIBILITY,\n        JSON.stringify(newSettings),\n      );\n      return newSettings;\n    },\n    onSuccess: (newSettings) => {\n      queryClient.setQueryData([\"themes\", \"accessibility\"], newSettings);\n      applyAccessibilitySettings(newSettings);\n      logger.info(\"Accessibility settings updated\");\n    },\n  });\n\n  return { updatePreferencesMutation, updateAccessibilityMutation };\n};\n\n// Apply theme to document\nfunction applyThemeToDocument(theme: Theme) {\n  const root = document.documentElement;\n\n  // Apply CSS custom properties\n  Object.entries(theme.colors).forEach(([key, value]) => {\n    root.style.setProperty(`--color-${key}`, value);\n  });\n\n  // Apply typography\n  root.style.setProperty(\"--font-family\", theme.typography.fontFamily);\n  root.style.setProperty(\"--font-size-base\", `${theme.typography.baseSize}px`);\n  root.style.setProperty(\n    \"--line-height\",\n    theme.typography.lineHeight.toString(),\n  );\n  root.style.setProperty(\n    \"--letter-spacing\",\n    `${theme.typography.letterSpacing}px`,\n  );\n\n  // Apply spacing\n  Object.entries(theme.spacing).forEach(([key, value]) => {\n    root.style.setProperty(`--spacing-${key}`, value);\n  });\n\n  // Apply animations\n  root.style.setProperty(\n    \"--animation-duration\",\n    `${theme.animations.duration}ms`,\n  );\n  root.style.setProperty(\"--animation-easing\", theme.animations.easing);\n\n  // Set theme class\n  root.className = root.className.replace(/theme-\\w+/g, \"\");\n  root.classList.add(`theme-${theme.category}`);\n}\n\n// Apply accessibility settings\nfunction applyAccessibilitySettings(settings: AccessibilitySettings) {\n  const root = document.documentElement;\n\n  // High contrast\n  if (settings.highContrast) {\n    root.classList.add(\"high-contrast\");\n  } else {\n    root.classList.remove(\"high-contrast\");\n  }\n\n  // Reduced motion\n  if (settings.reducedMotion) {\n    root.classList.add(\"reduced-motion\");\n  } else {\n    root.classList.remove(\"reduced-motion\");\n  }\n\n  // Font size\n  root.classList.remove(\n    \"font-small\",\n    \"font-medium\",\n    \"font-large\",\n    \"font-extra-large\",\n  );\n  root.classList.add(`font-${settings.fontSize}`);\n\n  // Focus outlines\n  if (!settings.focusOutlines) {\n    root.classList.add(\"no-focus-outlines\");\n  } else {\n    root.classList.remove(\"no-focus-outlines\");\n  }\n}\n\n// Auto theme switching effect\nconst useAutoThemeSwitch = (\n  preferences: ThemePreferences,\n  currentTheme: Theme,\n  setThemeMutation: UseMutationResult<Theme, Error, string, unknown>,\n) => {\n  useEffect(() => {\n    if (!preferences.scheduleEnabled) return;\n\n    const checkSchedule = () => {\n      const now = new Date();\n      const currentTime = `${now.getHours().toString().padStart(2, \"0\")}:${now.getMinutes().toString().padStart(2, \"0\")}`;\n\n      const isLightTime =\n        currentTime >= preferences.lightModeStart &&\n        currentTime < preferences.darkModeStart;\n      const targetThemeId = isLightTime\n        ? preferences.lightThemeId\n        : preferences.darkThemeId;\n\n      if (currentTheme.id !== targetThemeId) {\n        setThemeMutation.mutate(targetThemeId);\n      }\n    };\n\n    checkSchedule();\n    const interval = setInterval(checkSchedule, 60000);\n\n    return () => clearInterval(interval);\n  }, [preferences, currentTheme.id, setThemeMutation]);\n};\n\n// System theme sync effect\nconst useSystemThemeSync = (\n  preferences: ThemePreferences,\n  currentTheme: Theme,\n  setThemeMutation: UseMutationResult<Theme, Error, string, unknown>,\n) => {\n  useEffect(() => {\n    if (!preferences.systemSyncEnabled) return;\n\n    const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n\n    const handleChange = (e: MediaQueryListEvent) => {\n      const targetThemeId = e.matches\n        ? preferences.darkThemeId\n        : preferences.lightThemeId;\n      if (currentTheme.id !== targetThemeId) {\n        setThemeMutation.mutate(targetThemeId);\n      }\n    };\n\n    mediaQuery.addEventListener(\"change\", handleChange);\n    return () => mediaQuery.removeEventListener(\"change\", handleChange);\n  }, [preferences, currentTheme.id, setThemeMutation]);\n};\n\n/**\n * Enhanced Theme Hook\n */\nexport const useTheme = () => {\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Get theme data\n  const { customThemes, preferences, accessibilitySettings, currentTheme } =\n    useThemeQueries([]);\n\n  // Combined available themes\n  const availableThemes = useMemo(\n    () => [...DEFAULT_THEMES, ...customThemes],\n    [customThemes],\n  );\n\n  // Check if dark mode\n  const isDarkMode = useMemo(\n    () => currentTheme.category === ThemeCategory.DARK,\n    [currentTheme],\n  );\n\n  // Get mutations\n  const { setThemeMutation, createCustomThemeMutation } = useThemeMutations(\n    availableThemes,\n    customThemes,\n  );\n  const { updatePreferencesMutation, updateAccessibilityMutation } =\n    usePreferenceMutations(preferences, accessibilitySettings);\n\n  // Auto switching effects\n  useAutoThemeSwitch(preferences, currentTheme, setThemeMutation);\n  useSystemThemeSync(preferences, currentTheme, setThemeMutation);\n\n  // Initialize theme on mount\n  useEffect(() => {\n    applyThemeToDocument(currentTheme);\n    applyAccessibilitySettings(accessibilitySettings);\n    setIsLoading(false);\n  }, [currentTheme, accessibilitySettings]);\n\n  // Hook return value\n  const state: EnhancedThemeState = {\n    currentTheme,\n    availableThemes,\n    customThemes,\n    preferences,\n    accessibilitySettings,\n    isLoading,\n    isDarkMode,\n  };\n\n  return {\n    // State\n    ...state,\n\n    // Theme management\n    setTheme: setThemeMutation.mutate,\n    createCustomTheme: createCustomThemeMutation.mutate,\n    updateThemePreferences: updatePreferencesMutation.mutate,\n\n    // Dynamic theming\n    setDynamicColors: useCallback((colors: Partial<ColorPalette>) => {\n      const root = document.documentElement;\n      Object.entries(colors).forEach(([key, value]) => {\n        root.style.setProperty(`--color-${key}`, value);\n      });\n    }, []),\n\n    enableAutoTheme: useCallback(\n      (enabled: boolean) => {\n        updatePreferencesMutation.mutate({ systemSyncEnabled: enabled });\n      },\n      [updatePreferencesMutation],\n    ),\n\n    // Accessibility\n    updateAccessibilitySettings: updateAccessibilityMutation.mutate,\n    enableHighContrast: useCallback(\n      (enabled: boolean) => {\n        updateAccessibilityMutation.mutate({ highContrast: enabled });\n      },\n      [updateAccessibilityMutation],\n    ),\n\n    setFontSize: useCallback(\n      (scale: FontScale) => {\n        updateAccessibilityMutation.mutate({ fontSize: scale });\n      },\n      [updateAccessibilityMutation],\n    ),\n\n    // Computed properties\n    hasCustomThemes: customThemes.length > 0,\n    isHighContrast: accessibilitySettings.highContrast,\n    currentFontScale: accessibilitySettings.fontSize,\n\n    // Loading states\n    isSettingTheme: setThemeMutation.isPending,\n    isCreatingTheme: createCustomThemeMutation.isPending,\n    isUpdatingPreferences: updatePreferencesMutation.isPending,\n    isUpdatingAccessibility: updateAccessibilityMutation.isPending,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useAccountLinkingDemo.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (110). Maximum allowed is 75.","line":51,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":183,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Custom hook for Account Linking Demo state and logic\n */\n\nimport { useState } from \"react\";\n\n// Mock data for demonstration\nconst mockInviteCodes = [\n  {\n    id: \"invite-1\",\n    code: \"ABC123\",\n    submissiveUserId: \"demo-user-123\",\n    submissiveName: \"Demo User\",\n    createdAt: new Date(Date.now() - 1000 * 60 * 30), // 30 minutes ago\n    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 23.5), // 23.5 hours from now\n    isUsed: false,\n  },\n  {\n    id: \"invite-2\",\n    code: \"XYZ789\",\n    submissiveUserId: \"demo-user-123\",\n    submissiveName: \"Demo User\",\n    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 2), // 2 hours ago\n    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 22), // 22 hours from now\n    isUsed: false,\n  },\n];\n\nconst mockActiveKeyholder = {\n  id: \"rel-1\",\n  submissiveUserId: \"demo-user-123\",\n  keyholderUserId: \"keyholder-456\",\n  status: \"active\" as const,\n  permissions: {\n    canLockSessions: true,\n    canUnlockSessions: false,\n    canCreateTasks: true,\n    canApproveTasks: true,\n    canViewFullHistory: true,\n    canEditGoals: false,\n  },\n  createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7), // 1 week ago\n  acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7),\n};\n\ntype DemoScenario =\n  | \"submissive-no-keyholder\"\n  | \"submissive-with-keyholder\"\n  | \"keyholder-mode\";\n\nexport const useAccountLinkingDemo = (scenario: DemoScenario) => {\n  // UI State\n  const [showCreateInvite, setShowCreateInvite] = useState(false);\n  const [showAcceptInvite, setShowAcceptInvite] = useState(false);\n  const [showPermissions, setShowPermissions] = useState<string | null>(null);\n  const [inviteCodeInput, setInviteCodeInput] = useState(\"\");\n  const [keyholderNameInput, setKeyholderNameInput] = useState(\"\");\n\n  // Message state\n  const [message, setMessage] = useState(\"\");\n  const [messageType, setMessageType] = useState<\"success\" | \"error\" | \"info\">(\n    \"info\",\n  );\n\n  // Generate mock data based on scenario\n  const getMockData = () => {\n    const activeKeyholder =\n      scenario === \"submissive-with-keyholder\" ? mockActiveKeyholder : null;\n\n    const activeInviteCodes =\n      scenario === \"submissive-no-keyholder\" ||\n      scenario === \"submissive-with-keyholder\"\n        ? mockInviteCodes\n        : [];\n\n    const relationshipSummary = {\n      totalAsSubmissive: scenario === \"submissive-with-keyholder\" ? 1 : 0,\n      totalAsKeyholder: scenario === \"keyholder-mode\" ? 2 : 0,\n    };\n\n    const relationships =\n      scenario === \"keyholder-mode\"\n        ? {\n            asSubmissive: [],\n            asKeyholder: [\n              {\n                id: \"rel-2\",\n                submissiveUserId: \"sub-1\",\n                keyholderUserId: \"demo-user-123\",\n                status: \"active\" as const,\n                permissions: mockActiveKeyholder.permissions,\n                createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3),\n                acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3),\n              },\n              {\n                id: \"rel-3\",\n                submissiveUserId: \"sub-2\",\n                keyholderUserId: \"demo-user-123\",\n                status: \"active\" as const,\n                permissions: mockActiveKeyholder.permissions,\n                createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 5),\n                acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 5),\n              },\n            ],\n          }\n        : { asSubmissive: [], asKeyholder: [] };\n\n    return {\n      activeKeyholder,\n      activeInviteCodes,\n      relationshipSummary,\n      relationships,\n    };\n  };\n\n  const mockData = getMockData();\n\n  // Message handlers\n  const showMessage = (\n    text: string,\n    type: \"success\" | \"error\" | \"info\" = \"info\",\n  ) => {\n    setMessage(text);\n    setMessageType(type);\n  };\n\n  const clearMessage = () => {\n    setMessage(\"\");\n    setMessageType(\"info\");\n  };\n\n  // Action handlers\n  const handleCreateInvite = () => {\n    showMessage(\"Demo: Invite code ABC123 created successfully!\", \"success\");\n    setShowCreateInvite(false);\n  };\n\n  const handleAcceptInvite = () => {\n    if (inviteCodeInput === \"ABC123\") {\n      showMessage(\"Demo: Successfully accepted invite code!\", \"success\");\n    } else {\n      showMessage(\"Demo: Invalid invite code. Try 'ABC123'\", \"error\");\n    }\n    setInviteCodeInput(\"\");\n    setKeyholderNameInput(\"\");\n    setShowAcceptInvite(false);\n  };\n\n  const copyToClipboard = async (text: string) => {\n    try {\n      await navigator.clipboard.writeText(text);\n      showMessage(`Copied \"${text}\" to clipboard`, \"success\");\n    } catch {\n      showMessage(\"Failed to copy to clipboard\", \"error\");\n    }\n  };\n\n  return {\n    // State\n    showCreateInvite,\n    setShowCreateInvite,\n    showAcceptInvite,\n    setShowAcceptInvite,\n    showPermissions,\n    setShowPermissions,\n    inviteCodeInput,\n    setInviteCodeInput,\n    keyholderNameInput,\n    setKeyholderNameInput,\n    message,\n    messageType,\n\n    // Actions\n    showMessage,\n    clearMessage,\n    handleCreateInvite,\n    handleAcceptInvite,\n    copyToClipboard,\n\n    // Mock data\n    ...mockData,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useAchievementGallery.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDifficultyColor' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (95). Maximum allowed is 75.","line":30,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":150,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Custom hook for Achievement Gallery state and logic\n */\n\nimport { useState, useMemo } from \"react\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  AchievementDifficulty,\n} from \"../types\";\nimport { AchievementCategory } from \"../types/achievements\";\nimport {\n  getCategoryName,\n  getDifficultyColor,\n} from \"./achievement-gallery-utils\";\n\ninterface AchievementWithProgress {\n  achievement: DBAchievement;\n  userAchievement?: DBUserAchievement;\n  progress: {\n    currentValue: number;\n    targetValue: number;\n    percentage: number;\n    isCompleted: boolean;\n  } | null;\n  isEarned: boolean;\n  isVisible: boolean;\n}\n\nexport const useAchievementGallery = (\n  achievementsWithProgress: AchievementWithProgress[],\n) => {\n  const [selectedCategory, setSelectedCategory] = useState<\n    AchievementCategory | \"all\"\n  >(\"all\");\n  const [selectedDifficulty, setSelectedDifficulty] = useState<\n    AchievementDifficulty | \"all\"\n  >(\"all\");\n  const [showOnlyEarned, setShowOnlyEarned] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  // Calculate stats\n  const stats = useMemo(() => {\n    const totalEarned = achievementsWithProgress.filter(\n      (a) => a.isEarned,\n    ).length;\n    const totalVisible = achievementsWithProgress.filter(\n      (a) => !a.achievement.isHidden,\n    ).length;\n    const totalPoints = achievementsWithProgress\n      .filter((a) => a.isEarned)\n      .reduce((sum, a) => sum + a.achievement.points, 0);\n\n    return {\n      totalEarned,\n      totalVisible,\n      totalPoints,\n      completionPercentage:\n        totalVisible > 0 ? (totalEarned / totalVisible) * 100 : 0,\n    };\n  }, [achievementsWithProgress]);\n\n  // Filter achievements\n  const filteredAchievements = useMemo(() => {\n    return achievementsWithProgress.filter((item) => {\n      const { achievement, isEarned } = item;\n\n      // Category filter\n      if (\n        selectedCategory !== \"all\" &&\n        achievement.category !== selectedCategory\n      ) {\n        return false;\n      }\n\n      // Difficulty filter\n      if (\n        selectedDifficulty !== \"all\" &&\n        achievement.difficulty !== selectedDifficulty\n      ) {\n        return false;\n      }\n\n      // Earned filter\n      if (showOnlyEarned && !isEarned) {\n        return false;\n      }\n\n      // Search filter\n      if (\n        searchTerm &&\n        !achievement.name.toLowerCase().includes(searchTerm.toLowerCase()) &&\n        !achievement.description\n          .toLowerCase()\n          .includes(searchTerm.toLowerCase())\n      ) {\n        return false;\n      }\n\n      // Hide hidden achievements if not earned\n      if (achievement.isHidden && !isEarned) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [\n    achievementsWithProgress,\n    selectedCategory,\n    selectedDifficulty,\n    showOnlyEarned,\n    searchTerm,\n  ]);\n\n  // Group by category\n  const groupedAchievements = useMemo(() => {\n    const groups: Record<string, AchievementWithProgress[]> = {};\n\n    filteredAchievements.forEach((item) => {\n      const categoryName = getCategoryName(\n        item.achievement.category as AchievementCategory,\n      );\n      if (!groups[categoryName]) {\n        groups[categoryName] = [];\n      }\n      groups[categoryName].push(item);\n    });\n\n    return groups;\n  }, [filteredAchievements]);\n\n  return {\n    // State\n    selectedCategory,\n    selectedDifficulty,\n    showOnlyEarned,\n    searchTerm,\n\n    // Setters\n    setSelectedCategory,\n    setSelectedDifficulty,\n    setShowOnlyEarned,\n    setSearchTerm,\n\n    // Computed values\n    stats,\n    filteredAchievements,\n    groupedAchievements,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useAchievements.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (225). Maximum allowed is 75.","line":25,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":345,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useAchievements Hook\n * React hook for managing achievements and progress\n */\n\nimport { useEffect, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService, achievementEngine } from \"../services\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  AchievementCategory,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<AchievementCategory, number>;\n  recentAchievements: DBUserAchievement[];\n}\n\nexport const useAchievements = (userId?: string) => {\n  const queryClient = useQueryClient();\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get all available achievements\n   */\n  const { data: allAchievements = [], isLoading: isLoadingAchievements } =\n    useQuery({\n      queryKey: [\"achievements\"],\n      queryFn: () => achievementDBService.getAllAchievements(),\n      enabled: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n\n  /**\n   * Get user's earned achievements\n   */\n  const { data: userAchievements = [], isLoading: isLoadingUserAchievements } =\n    useQuery({\n      queryKey: [\"achievements\", \"user\", userId],\n      queryFn: () => achievementDBService.getUserAchievements(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  const { data: visibleAchievements = [] } = useQuery({\n    queryKey: [\"achievements\", \"visible\", userId],\n    queryFn: () => achievementDBService.getUserVisibleAchievements(userId!),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's achievement progress\n   */\n  const { data: achievementProgress = [], isLoading: isLoadingProgress } =\n    useQuery({\n      queryKey: [\"achievements\", \"progress\", userId],\n      queryFn: () => achievementDBService.getUserAchievementProgress(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get unread notifications\n   */\n  const { data: unreadNotifications = [], isLoading: isLoadingNotifications } =\n    useQuery({\n      queryKey: [\"achievements\", \"notifications\", userId],\n      queryFn: () => achievementDBService.getUserUnreadNotifications(userId!),\n      enabled: Boolean(userId),\n      refetchInterval: 30 * 1000, // Check every 30 seconds\n    });\n\n  /**\n   * Get achievement statistics\n   */\n  const { data: achievementStats, isLoading: isLoadingStats } = useQuery({\n    queryKey: [\"achievements\", \"stats\", userId],\n    queryFn: async (): Promise<AchievementStats> => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const [stats, achievements] = await Promise.all([\n        achievementDBService.getUserAchievementStats(userId),\n        achievementDBService.getUserAchievements(userId),\n      ]);\n\n      // Get recent achievements (last 5)\n      const recentAchievements = achievements\n        .sort(\n          (a: DBUserAchievement, b: DBUserAchievement) =>\n            b.earnedAt.getTime() - a.earnedAt.getTime(),\n        )\n        .slice(0, 5);\n\n      return {\n        ...stats,\n        recentAchievements,\n      };\n    },\n    enabled: Boolean(userId),\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Toggle achievement visibility\n   */\n  const toggleVisibilityMutation = useMutation({\n    mutationFn: ({ achievementId }: { achievementId: string }) =>\n      achievementDBService.toggleAchievementVisibility(userId!, achievementId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"visible\", userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"user\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Mark notification as read\n   */\n  const markNotificationReadMutation = useMutation({\n    mutationFn: (notificationId: string) =>\n      achievementDBService.markNotificationRead(notificationId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"notifications\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Perform full achievement check\n   */\n  const performFullCheckMutation = useMutation({\n    mutationFn: () => achievementEngine.performFullCheck(userId!),\n    onSuccess: () => {\n      // Invalidate all achievement-related queries\n      queryClient.invalidateQueries({ queryKey: [\"achievements\"] });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  // ==================== HELPER FUNCTIONS ====================\n\n  /**\n   * Get achievement by ID\n   */\n  const getAchievementById = useCallback(\n    (achievementId: string): DBAchievement | undefined => {\n      return allAchievements.find((a: DBAchievement) => a.id === achievementId);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Check if user has specific achievement\n   */\n  const hasAchievement = useCallback(\n    (achievementId: string): boolean => {\n      return userAchievements.some(\n        (ua: DBUserAchievement) => ua.achievementId === achievementId,\n      );\n    },\n    [userAchievements],\n  );\n\n  /**\n   * Get progress for specific achievement\n   */\n  const getProgressForAchievement = useCallback(\n    (achievementId: string): DBAchievementProgress | undefined => {\n      return achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievementId,\n      );\n    },\n    [achievementProgress],\n  );\n\n  /**\n   * Get achievements by category\n   */\n  const getAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBAchievement[] => {\n      return allAchievements.filter(\n        (a: DBAchievement) => a.category === category,\n      );\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Get user's achievements by category\n   */\n  const getUserAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBUserAchievement[] => {\n      const categoryAchievementIds = allAchievements\n        .filter((a: DBAchievement) => a.category === category)\n        .map((a: DBAchievement) => a.id);\n\n      return userAchievements.filter((ua: DBUserAchievement) =>\n        categoryAchievementIds.includes(ua.achievementId),\n      );\n    },\n    [allAchievements, userAchievements],\n  );\n\n  /**\n   * Get achievements with progress information\n   */\n  const getAchievementsWithProgress = useCallback(() => {\n    return allAchievements.map((achievement: DBAchievement) => {\n      const userAchievement = userAchievements.find(\n        (ua: DBUserAchievement) => ua.achievementId === achievement.id,\n      );\n      const progress = achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievement.id,\n      );\n\n      return {\n        achievement,\n        userAchievement,\n        progress: progress\n          ? {\n              currentValue: progress.currentValue,\n              targetValue: progress.targetValue,\n              percentage: Math.min(\n                (progress.currentValue / progress.targetValue) * 100,\n                100,\n              ),\n              isCompleted: progress.isCompleted,\n            }\n          : null,\n        isEarned: Boolean(userAchievement),\n        isVisible: userAchievement?.isVisible ?? true,\n      };\n    });\n  }, [allAchievements, userAchievements, achievementProgress]);\n\n  // ==================== ACTIONS ====================\n\n  const toggleAchievementVisibility = useCallback(\n    (achievementId: string) => {\n      if (!userId) return;\n      toggleVisibilityMutation.mutate({ achievementId });\n    },\n    [userId, toggleVisibilityMutation],\n  );\n\n  const markNotificationRead = useCallback(\n    (notificationId: string) => {\n      markNotificationReadMutation.mutate(notificationId);\n    },\n    [markNotificationReadMutation],\n  );\n\n  const performFullCheck = useCallback(() => {\n    if (!userId) return;\n    performFullCheckMutation.mutate();\n  }, [userId, performFullCheckMutation]);\n\n  // ==================== EFFECTS ====================\n\n  /**\n   * Initialize achievement engine on mount\n   */\n  useEffect(() => {\n    achievementEngine.initialize().catch((error) => {\n      logger.error(\n        \"Failed to initialize achievement engine\",\n        error,\n        \"useAchievements\",\n      );\n    });\n  }, []);\n\n  // ==================== RETURN ====================\n\n  return {\n    // Data\n    allAchievements,\n    userAchievements,\n    visibleAchievements,\n    achievementProgress,\n    unreadNotifications,\n    achievementStats,\n\n    // Loading states\n    isLoading: isLoadingAchievements || isLoadingUserAchievements,\n    isLoadingProgress,\n    isLoadingNotifications,\n    isLoadingStats,\n\n    // Helper functions\n    getAchievementById,\n    hasAchievement,\n    getProgressForAchievement,\n    getAchievementsByCategory,\n    getUserAchievementsByCategory,\n    getAchievementsWithProgress,\n\n    // Actions\n    toggleAchievementVisibility,\n    markNotificationRead,\n    performFullCheck,\n\n    // Mutation states\n    isTogglingVisibility: toggleVisibilityMutation.isPending,\n    isMarkingRead: markNotificationReadMutation.isPending,\n    isPerformingCheck: performFullCheckMutation.isPending,\n  };\n};\n\n/**\n * Hook for achievement notifications (can be used globally)\n */\nexport const useAchievementNotifications = (userId?: string) => {\n  const { unreadNotifications, markNotificationRead, isLoadingNotifications } =\n    useAchievements(userId);\n\n  return {\n    notifications: unreadNotifications,\n    isLoading: isLoadingNotifications,\n    markAsRead: markNotificationRead,\n    hasUnread: unreadNotifications.length > 0,\n    unreadCount: unreadNotifications.length,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useDexieSync.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (115). Maximum allowed is 75.","line":20,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":178,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dexie Sync Hook\n * Provides easy access to Dexie services with automatic sync management\n */\nimport { useCallback, useMemo } from \"react\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { useApp } from \"@/contexts/AppContext\";\nimport {\n  sessionDBService,\n  eventDBService,\n  taskDBService,\n  goalDBService,\n  settingsDBService,\n} from \"@/services/database\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useDexieSync\");\n\nexport const useDexieSync = () => {\n  const { state: appState, actions: appActions } = useApp();\n  const { user } = useAuth();\n\n  /**\n   * Get all Dexie services\n   */\n  const services = useMemo(\n    () => ({\n      sessions: sessionDBService,\n      events: eventDBService,\n      tasks: taskDBService,\n      goals: goalDBService,\n      settings: settingsDBService,\n    }),\n    [],\n  );\n\n  /**\n   * Trigger manual sync\n   */\n  const triggerSync = useCallback(async () => {\n    if (!user?.uid) {\n      logger.warn(\"Cannot sync: no authenticated user\");\n      return;\n    }\n\n    try {\n      await appActions.triggerSync(user.uid);\n    } catch (error) {\n      logger.error(\"Sync failed\", { error: error as Error });\n      throw error;\n    }\n  }, [user?.uid, appActions]);\n\n  /**\n   * Create a record with automatic sync queuing\n   */\n  const createWithSync = useCallback(\n    async <T extends Record<string, unknown>>(\n      service: keyof typeof services,\n      data: T,\n    ): Promise<string> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      const id = await services[service].create(data);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n\n      return id;\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Update a record with automatic sync queuing\n   */\n  const updateWithSync = useCallback(\n    async <T extends Record<string, unknown>>(\n      service: keyof typeof services,\n      id: string,\n      updates: T,\n    ): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].update(id, updates);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Delete a record with automatic sync queuing\n   */\n  const deleteWithSync = useCallback(\n    async (service: keyof typeof services, id: string): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].delete(id);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  return {\n    // Services\n    services,\n\n    // Sync control\n    triggerSync,\n    syncStatus: appState.syncStatus,\n    lastSyncTime: appState.lastSyncTime,\n    isOnline: appState.isOnline,\n\n    // CRUD operations with sync\n    createWithSync,\n    updateWithSync,\n    deleteWithSync,\n\n    // Direct service access for read operations\n    findById: useCallback(\n      async (service: keyof typeof services, id: string) => {\n        return services[service].findById(id);\n      },\n      [services],\n    ),\n\n    findByUserId: useCallback(\n      async (service: keyof typeof services, userId: string) => {\n        return services[service].findByUserId(userId);\n      },\n      [services],\n    ),\n\n    paginate: useCallback(\n      async (\n        service: keyof typeof services,\n        userId: string,\n        offset: number = 0,\n        limit: number = 50,\n      ) => {\n        return services[service].paginate(userId, offset, limit);\n      },\n      [services],\n    ),\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useKeyholderRelationships.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useKeyholderRelationships' has too many lines (272). Maximum allowed is 75.","line":99,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":424,"endColumn":2}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":404,"column":18,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":404,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":404,"column":37,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":404,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":404,"column":54,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":404,"endColumn":77,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for managing keyholder relationships\n * Provides UI state and actions for account linking\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { KeyholderRelationshipService } from \"../services/KeyholderRelationshipService\";\nimport { KeyholderRelationship, KeyholderPermissions } from \"../types/core\";\nimport { InviteCode } from \"../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderRelationships\");\n\nexport interface KeyholderRelationshipState {\n  // Relationships\n  relationships: {\n    asSubmissive: KeyholderRelationship[];\n    asKeyholder: KeyholderRelationship[];\n  };\n  activeKeyholder: KeyholderRelationship | null;\n\n  // Invite codes\n  activeInviteCodes: InviteCode[];\n\n  // Loading states\n  isLoading: boolean;\n  isCreatingInvite: boolean;\n  isAcceptingInvite: boolean;\n  isUpdatingPermissions: boolean;\n\n  // Form states\n  inviteCodeInput: string;\n  keyholderNameInput: string;\n\n  // Messages\n  message: string;\n  messageType: \"success\" | \"error\" | \"info\";\n\n  // Summary\n  relationshipSummary: {\n    hasActiveKeyholder: boolean;\n    hasSubmissives: boolean;\n    activeKeyholderCount: number;\n    submissiveCount: number;\n  } | null;\n}\n\nexport interface KeyholderRelationshipActions {\n  // Data loading\n  loadRelationships: () => Promise<void>;\n  loadInviteCodes: () => Promise<void>;\n  loadRelationshipSummary: () => Promise<void>;\n\n  // Invite code management\n  createInviteCode: (expirationHours?: number) => Promise<InviteCode | null>;\n  acceptInviteCode: (code: string, keyholderName?: string) => Promise<boolean>;\n  revokeInviteCode: (codeId: string) => Promise<void>;\n\n  // Relationship management\n  updatePermissions: (\n    relationshipId: string,\n    permissions: KeyholderPermissions,\n  ) => Promise<void>;\n  endRelationship: (relationshipId: string) => Promise<void>;\n\n  // Form actions\n  setInviteCodeInput: (code: string) => void;\n  setKeyholderNameInput: (name: string) => void;\n  clearMessage: () => void;\n  clearForm: () => void;\n\n  // Utilities\n  validateInviteCode: (code: string) => boolean;\n  canCreateInviteCode: () => Promise<boolean>;\n  hasPermission: (\n    submissiveUserId: string,\n    permission: keyof KeyholderPermissions,\n  ) => Promise<boolean>;\n}\n\nconst initialState: KeyholderRelationshipState = {\n  relationships: {\n    asSubmissive: [],\n    asKeyholder: [],\n  },\n  activeKeyholder: null,\n  activeInviteCodes: [],\n  isLoading: false,\n  isCreatingInvite: false,\n  isAcceptingInvite: false,\n  isUpdatingPermissions: false,\n  inviteCodeInput: \"\",\n  keyholderNameInput: \"\",\n  message: \"\",\n  messageType: \"info\",\n  relationshipSummary: null,\n};\n\nexport function useKeyholderRelationships(): KeyholderRelationshipState &\n  KeyholderRelationshipActions {\n  const [state, setState] = useState<KeyholderRelationshipState>(initialState);\n  const { user } = useAuthState();\n\n  // Load relationships\n  const loadRelationships = useCallback(async () => {\n    if (!user?.uid) return;\n\n    setState((prev) => ({ ...prev, isLoading: true }));\n\n    try {\n      const relationships =\n        await KeyholderRelationshipService.getUserRelationships(user.uid);\n      const activeKeyholder =\n        await KeyholderRelationshipService.getActiveKeyholder(user.uid);\n\n      setState((prev) => ({\n        ...prev,\n        relationships,\n        activeKeyholder,\n        isLoading: false,\n      }));\n\n      logger.debug(\"Relationships loaded\", {\n        submissiveCount: relationships.asSubmissive.length,\n        keyholderCount: relationships.asKeyholder.length,\n      });\n    } catch (error) {\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        message: \"Failed to load relationships\",\n        messageType: \"error\",\n      }));\n      logger.error(\"Failed to load relationships\", { error: error as Error });\n    }\n  }, [user?.uid]);\n\n  // Load invite codes\n  const loadInviteCodes = useCallback(async () => {\n    if (!user?.uid) return;\n\n    try {\n      const activeInviteCodes =\n        await KeyholderRelationshipService.getActiveInviteCodes(user.uid);\n      setState((prev) => ({ ...prev, activeInviteCodes }));\n    } catch (error) {\n      logger.error(\"Failed to load invite codes\", { error: error as Error });\n    }\n  }, [user?.uid]);\n\n  // Load relationship summary\n  const loadRelationshipSummary = useCallback(async () => {\n    if (!user?.uid) return;\n\n    try {\n      const relationshipSummary =\n        await KeyholderRelationshipService.getRelationshipSummary(user.uid);\n      setState((prev) => ({ ...prev, relationshipSummary }));\n    } catch (error) {\n      logger.error(\"Failed to load relationship summary\", {\n        error: error as Error,\n      });\n    }\n  }, [user?.uid]);\n\n  // Create invite code\n  const createInviteCode = useCallback(\n    async (expirationHours = 24): Promise<InviteCode | null> => {\n      if (!user?.uid || !user.displayName) return null;\n\n      setState((prev) => ({ ...prev, isCreatingInvite: true, message: \"\" }));\n\n      try {\n        const canCreate =\n          await KeyholderRelationshipService.canCreateInviteCode(user.uid);\n        if (!canCreate) {\n          setState((prev) => ({\n            ...prev,\n            isCreatingInvite: false,\n            message: \"You already have an active keyholder relationship\",\n            messageType: \"error\",\n          }));\n          return null;\n        }\n\n        const inviteCode = await KeyholderRelationshipService.createInviteCode(\n          user.uid,\n          user.displayName,\n          expirationHours,\n        );\n\n        setState((prev) => ({\n          ...prev,\n          isCreatingInvite: false,\n          message: `Invite code created: ${inviteCode.code}`,\n          messageType: \"success\",\n        }));\n\n        logger.info(\"Invite code created successfully\", {\n          code: inviteCode.code,\n        });\n\n        // Reload invite codes\n        await loadInviteCodes();\n\n        return inviteCode;\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to create invite code\";\n        setState((prev) => ({\n          ...prev,\n          isCreatingInvite: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to create invite code\", { error: error as Error });\n        return null;\n      }\n    },\n    [user?.uid, user?.displayName, loadInviteCodes],\n  );\n\n  // Accept invite code\n  const acceptInviteCode = useCallback(\n    async (code: string, keyholderName?: string): Promise<boolean> => {\n      if (!user?.uid) return false;\n\n      setState((prev) => ({ ...prev, isAcceptingInvite: true, message: \"\" }));\n\n      try {\n        const _relationship =\n          await KeyholderRelationshipService.acceptInviteCode(\n            code,\n            user.uid,\n            keyholderName || user.displayName,\n          );\n\n        setState((prev) => ({\n          ...prev,\n          isAcceptingInvite: false,\n          message: \"Successfully linked with submissive!\",\n          messageType: \"success\",\n          inviteCodeInput: \"\",\n          keyholderNameInput: \"\",\n        }));\n\n        logger.info(\"Invite code accepted successfully\");\n\n        // Reload relationships\n        await loadRelationships();\n        await loadRelationshipSummary();\n\n        return true;\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to accept invite code\";\n        setState((prev) => ({\n          ...prev,\n          isAcceptingInvite: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to accept invite code\", { error: error as Error });\n        return false;\n      }\n    },\n    [user?.uid, user?.displayName, loadRelationships, loadRelationshipSummary],\n  );\n\n  // Revoke invite code\n  const revokeInviteCode = useCallback(\n    async (codeId: string) => {\n      if (!user?.uid) return;\n\n      try {\n        await KeyholderRelationshipService.revokeInviteCode(codeId, user.uid);\n        logger.info(\"Invite code revoked successfully\", { codeId });\n        await loadInviteCodes();\n      } catch (error) {\n        const _errorMessage =\n          (error as Error).message || \"Failed to revoke invite code\";\n        logger.error(\"Failed to revoke invite code\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadInviteCodes],\n  );\n\n  // Update permissions\n  const updatePermissions = useCallback(\n    async (relationshipId: string, permissions: KeyholderPermissions) => {\n      if (!user?.uid) return;\n\n      setState((prev) => ({ ...prev, isUpdatingPermissions: true }));\n\n      try {\n        await KeyholderRelationshipService.updatePermissions(\n          relationshipId,\n          permissions,\n          user.uid,\n        );\n        setState((prev) => ({\n          ...prev,\n          isUpdatingPermissions: false,\n          message: \"Permissions updated successfully\",\n          messageType: \"success\",\n        }));\n        logger.info(\"Permissions updated successfully\");\n        await loadRelationships();\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to update permissions\";\n        setState((prev) => ({\n          ...prev,\n          isUpdatingPermissions: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to update permissions\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadRelationships],\n  );\n\n  // End relationship\n  const endRelationship = useCallback(\n    async (relationshipId: string) => {\n      if (!user?.uid) return;\n\n      try {\n        await KeyholderRelationshipService.endRelationship(\n          relationshipId,\n          user.uid,\n        );\n        logger.info(\"Relationship ended successfully\");\n        await loadRelationships();\n        await loadRelationshipSummary();\n      } catch (error) {\n        const _errorMessage =\n          (error as Error).message || \"Failed to end relationship\";\n        logger.error(\"Failed to end relationship\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadRelationships, loadRelationshipSummary],\n  );\n\n  // Form actions\n  const setInviteCodeInput = useCallback((code: string) => {\n    setState((prev) => ({ ...prev, inviteCodeInput: code.toUpperCase() }));\n  }, []);\n\n  const setKeyholderNameInput = useCallback((name: string) => {\n    setState((prev) => ({ ...prev, keyholderNameInput: name }));\n  }, []);\n\n  const clearMessage = useCallback(() => {\n    setState((prev) => ({ ...prev, message: \"\", messageType: \"info\" }));\n  }, []);\n\n  const clearForm = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      inviteCodeInput: \"\",\n      keyholderNameInput: \"\",\n      message: \"\",\n      messageType: \"info\",\n    }));\n  }, []);\n\n  // Utilities\n  const validateInviteCode = useCallback((code: string): boolean => {\n    return KeyholderRelationshipService.validateInviteCodeFormat(code);\n  }, []);\n\n  const canCreateInviteCode = useCallback(async (): Promise<boolean> => {\n    if (!user?.uid) return false;\n    return await KeyholderRelationshipService.canCreateInviteCode(user.uid);\n  }, [user?.uid]);\n\n  const hasPermission = useCallback(\n    async (\n      submissiveUserId: string,\n      permission: keyof KeyholderPermissions,\n    ): Promise<boolean> => {\n      if (!user?.uid) return false;\n      return await KeyholderRelationshipService.hasPermission(\n        user.uid,\n        submissiveUserId,\n        permission,\n      );\n    },\n    [user?.uid],\n  );\n\n  // Load data on mount and user change\n  useEffect(() => {\n    if (user?.uid) {\n      loadRelationships();\n      loadInviteCodes();\n      loadRelationshipSummary();\n    } else {\n      setState(initialState);\n    }\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [user?.uid, loadRelationships, loadInviteCodes, loadRelationshipSummary]);\n\n  return {\n    ...state,\n    loadRelationships,\n    loadInviteCodes,\n    loadRelationshipSummary,\n    createInviteCode,\n    acceptInviteCode,\n    revokeInviteCode,\n    updatePermissions,\n    endRelationship,\n    setInviteCodeInput,\n    setKeyholderNameInput,\n    clearMessage,\n    clearForm,\n    validateInviteCode,\n    canCreateInviteCode,\n    hasPermission,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useLeaderboards.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (82). Maximum allowed is 75.","line":145,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":238,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useLeaderboards Hook\n * React hook for managing leaderboard data and user participation\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService } from \"../services\";\nimport {\n  LeaderboardCategory,\n  LeaderboardPeriod,\n  DBLeaderboardEntry,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface LeaderboardEntry {\n  id: string;\n  displayName: string;\n  value: number;\n  rank: number;\n  isCurrentUser: boolean;\n}\n\nexport interface UserRankInfo {\n  rank: number;\n  value: number;\n  totalParticipants: number;\n}\n\nexport interface LeaderboardPrivacySettings {\n  participateInGlobal: boolean;\n  participateInMonthly: boolean;\n  shareSessionTime: boolean;\n  shareStreakData: boolean;\n  shareAchievements: boolean;\n  displayName: \"real\" | \"username\" | \"anonymous\";\n  showOnPublicProfile: boolean;\n}\n\n// Default privacy settings for opting in\nconst DEFAULT_OPT_IN_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: true,\n  participateInMonthly: true,\n  shareSessionTime: true,\n  shareStreakData: true,\n  shareAchievements: true,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n// Default privacy settings for opting out\nconst DEFAULT_OPT_OUT_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: false,\n  participateInMonthly: false,\n  shareSessionTime: false,\n  shareStreakData: false,\n  shareAchievements: false,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n// Initial privacy settings state\nconst INITIAL_PRIVACY_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: false,\n  participateInMonthly: false,\n  shareSessionTime: false,\n  shareStreakData: false,\n  shareAchievements: true,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n/**\n * Generate display name based on privacy settings\n */\nfunction getDisplayName(\n  entry: DBLeaderboardEntry,\n  currentUserId?: string,\n): string {\n  if (entry.userId === currentUserId) {\n    return \"You\";\n  }\n\n  switch (entry.displayNameType) {\n    case \"real\":\n      return entry.displayName || \"Unknown User\";\n    case \"username\":\n      return entry.displayName || `User_${entry.userId.slice(-6)}`;\n    case \"anonymous\":\n    default:\n      return `ChastityUser_${entry.userId.slice(-4)}`;\n  }\n}\n\n/**\n * Process raw leaderboard data into displayable format\n */\nfunction processLeaderboardData(\n  rawData: DBLeaderboardEntry[],\n  userId?: string,\n): LeaderboardEntry[] {\n  return rawData.map((entry, index) => ({\n    id: entry.id,\n    displayName: getDisplayName(entry, userId),\n    value: entry.value,\n    rank: index + 1,\n    isCurrentUser: entry.userId === userId,\n  }));\n}\n\n/**\n * Create mutation callbacks for privacy settings updates\n */\nfunction createPrivacyMutationCallbacks(\n  setPrivacySettings: (settings: LeaderboardPrivacySettings) => void,\n  queryClient: ReturnType<typeof useQueryClient>,\n  actionName: string,\n) {\n  return {\n    onSuccess: (data: LeaderboardPrivacySettings) => {\n      setPrivacySettings(data);\n      queryClient.invalidateQueries({ queryKey: [\"leaderboards\"] });\n      logger.info(actionName, \"useLeaderboards\");\n    },\n    onError: (error: Error) => {\n      logger.error(`Failed: ${actionName}`, error, \"useLeaderboards\");\n    },\n  };\n}\n\n/**\n * Create opt-in/opt-out mutation function\n */\nfunction createPrivacyUpdateMutation(\n  userId: string | undefined,\n  settings: LeaderboardPrivacySettings,\n) {\n  return async () => {\n    if (!userId) throw new Error(\"User ID required\");\n    await achievementDBService.updateLeaderboardPrivacy(userId, settings);\n    return settings;\n  };\n}\n\nexport const useLeaderboards = (\n  userId?: string,\n  category: LeaderboardCategory = LeaderboardCategory.ACHIEVEMENT_POINTS,\n  period: LeaderboardPeriod = LeaderboardPeriod.ALL_TIME,\n) => {\n  const queryClient = useQueryClient();\n  const [privacySettings, setPrivacySettings] =\n    useState<LeaderboardPrivacySettings>(INITIAL_PRIVACY_SETTINGS);\n\n  // Get leaderboard data for a specific category and period\n  const {\n    data: rawLeaderboardData = [],\n    isLoading: isLoadingLeaderboard,\n    error: leaderboardError,\n  } = useQuery({\n    queryKey: [\"leaderboards\", category, period],\n    queryFn: () => achievementDBService.getLeaderboard(category, period),\n    enabled: true,\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  // Get user's rank in the leaderboard\n  const { data: userRank, isLoading: isLoadingUserRank } = useQuery({\n    queryKey: [\"leaderboards\", \"rank\", userId, category, period],\n    queryFn: () =>\n      achievementDBService.getUserLeaderboardRank(userId!, category, period),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  // Get user's leaderboard privacy settings\n  const { data: userPrivacySettings } = useQuery({\n    queryKey: [\"leaderboards\", \"privacy\", userId],\n    queryFn: () => achievementDBService.getLeaderboardPrivacy(userId!),\n    enabled: Boolean(userId),\n  });\n\n  useEffect(() => {\n    if (userPrivacySettings) {\n      setPrivacySettings(userPrivacySettings);\n    }\n  }, [userPrivacySettings]);\n\n  const optInMutation = useMutation({\n    mutationFn: createPrivacyUpdateMutation(userId, DEFAULT_OPT_IN_SETTINGS),\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"User opted into leaderboards\",\n    ),\n  });\n\n  const optOutMutation = useMutation({\n    mutationFn: createPrivacyUpdateMutation(userId, DEFAULT_OPT_OUT_SETTINGS),\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"User opted out of leaderboards\",\n    ),\n  });\n\n  const updatePrivacyMutation = useMutation({\n    mutationFn: async (settings: Partial<LeaderboardPrivacySettings>) => {\n      if (!userId) throw new Error(\"User ID required\");\n      const newSettings = { ...privacySettings, ...settings };\n      await achievementDBService.updateLeaderboardPrivacy(userId, newSettings);\n      return newSettings;\n    },\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"Updated leaderboard privacy settings\",\n    ),\n  });\n\n  const leaderboardData = processLeaderboardData(rawLeaderboardData, userId);\n\n  return {\n    leaderboardData,\n    userRank,\n    privacySettings,\n    isLoading: isLoadingLeaderboard || isLoadingUserRank,\n    error: leaderboardError,\n    optInToLeaderboards: optInMutation.mutateAsync,\n    optOutFromLeaderboards: optOutMutation.mutateAsync,\n    updateLeaderboardPrivacy: updatePrivacyMutation.mutateAsync,\n    isOptedIn:\n      privacySettings.participateInGlobal ||\n      privacySettings.participateInMonthly,\n    isOptingIn: optInMutation.isPending,\n    isOptingOut: optOutMutation.isPending,\n    isUpdatingPrivacy: updatePrivacyMutation.isPending,\n  };\n};\n\n// Named export only - hook files should only export hooks starting with 'use'\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useOfflineDemo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/usePauseState.ts","messages":[],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":65,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":65,"endColumn":17,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":93,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":93,"endColumn":17,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useRelationships.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationships' has too many lines (184). Maximum allowed is 75.","line":106,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":325,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Management (Composed)\n * Provides state management and actions for the dual-account keyholder system\n * Refactored to use focused hooks for better maintainability\n */\nimport { useEffect, useCallback, useMemo } from \"react\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport {\n  RelationshipTask,\n  RelationshipEvent,\n  RelationshipPermissions,\n  Relationship,\n} from \"@/types/relationships\";\nimport type { KeyholderRelationship } from \"@/types/core\";\nimport {\n  useRelationshipList,\n  useRelationshipInvites,\n  useRelationshipActions,\n  useRelationshipStatus,\n  useRelationshipPermissions,\n  useRelationshipTasks,\n  useRelationshipValidation,\n} from \"./relationships\";\n\n// Re-export types from the shared types file\nexport type {\n  RelationshipState,\n  BaseHookState,\n  BaseHookActions,\n} from \"./relationships/types\";\n\n// Maintain backward compatibility with the original interface\nexport interface RelationshipActions {\n  // Relationship management\n  sendRelationshipRequest: (\n    targetUserId: string,\n    role: \"submissive\" | \"keyholder\",\n    message?: string,\n  ) => Promise<void>;\n  acceptRelationshipRequest: (requestId: string) => Promise<void>;\n  rejectRelationshipRequest: (requestId: string) => Promise<void>;\n  endRelationship: (relationshipId: string) => Promise<void>;\n  updatePermissions: (\n    relationshipId: string,\n    permissions: RelationshipPermissions,\n  ) => Promise<void>;\n\n  // Session management\n  startSession: (\n    relationshipId: string,\n    options?: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    },\n  ) => Promise<void>;\n  endSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  pauseSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  resumeSession: (relationshipId: string, sessionId: string) => Promise<void>;\n\n  // Task management\n  createTask: (\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n  ) => Promise<void>;\n  updateTaskStatus: (\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTask[\"status\"],\n    note?: string,\n  ) => Promise<void>;\n\n  // Event logging\n  logEvent: (\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n  ) => Promise<void>;\n\n  // Migration\n  migrateSingleUserData: () => Promise<void>;\n  checkMigrationStatus: () => Promise<void>;\n\n  // Utility\n  setActiveRelationship: (relationship: KeyholderRelationship | null) => void;\n  refreshData: () => Promise<void>;\n  clearError: () => void;\n}\n\nexport function useRelationships() {\n  // Use focused hooks for specific functionalities\n  const relationshipList = useRelationshipList();\n  const relationshipInvites = useRelationshipInvites();\n  const relationshipActions = useRelationshipActions();\n  const relationshipStatus = useRelationshipStatus();\n  const relationshipPermissions = useRelationshipPermissions();\n  const relationshipTasks = useRelationshipTasks();\n  const relationshipValidation = useRelationshipValidation();\n\n  // Load data for active relationship when it changes\n  useEffect(() => {\n    if (relationshipList.activeRelationship) {\n      const relationshipId = relationshipList.activeRelationship.id;\n      relationshipStatus.loadRelationshipData(relationshipId);\n      relationshipTasks.loadRelationshipData(relationshipId);\n    }\n  }, [\n    relationshipList.activeRelationship,\n    relationshipStatus,\n    relationshipTasks,\n  ]);\n\n  // Set up real-time listeners for active relationship data\n  useEffect(() => {\n    if (!relationshipList.activeRelationship) return;\n\n    const relationshipId = relationshipList.activeRelationship.id;\n    let unsubscribeChastityData: (() => void) | null = null;\n    let unsubscribeTasks: (() => void) | null = null;\n\n    // Set up subscriptions\n    const setupSubscriptions = async () => {\n      unsubscribeChastityData =\n        await relationshipChastityService.subscribeToChastityData(\n          relationshipId,\n          (_chastityData) => {\n            // Update the status hook with new data\n            relationshipStatus.loadRelationshipData(relationshipId);\n          },\n        );\n\n      unsubscribeTasks = await relationshipChastityService.subscribeToTasks(\n        relationshipId,\n        (_tasks) => {\n          // Update the tasks hook with new data\n          relationshipTasks.loadRelationshipData(relationshipId);\n        },\n      );\n    };\n\n    setupSubscriptions();\n\n    return () => {\n      if (unsubscribeChastityData) unsubscribeChastityData();\n      if (unsubscribeTasks) unsubscribeTasks();\n    };\n  }, [\n    relationshipList.activeRelationship,\n    relationshipStatus,\n    relationshipTasks,\n  ]);\n\n  // Enhanced refresh function that coordinates all hooks\n  const refreshData = useCallback(async () => {\n    await Promise.all([\n      relationshipList.refreshRelationships(),\n      relationshipInvites.refreshPendingRequests(),\n      relationshipValidation.checkMigrationStatus(),\n    ]);\n\n    if (relationshipList.activeRelationship) {\n      const relationshipId = relationshipList.activeRelationship.id;\n      await Promise.all([\n        relationshipStatus.loadRelationshipData(relationshipId),\n        relationshipTasks.loadRelationshipData(relationshipId),\n      ]);\n    }\n  }, [\n    relationshipList,\n    relationshipInvites,\n    relationshipValidation,\n    relationshipStatus,\n    relationshipTasks,\n  ]);\n\n  // Unified error handling - combine errors from all hooks\n  const _hasError = useMemo(() => {\n    return !!(\n      relationshipList.error ||\n      relationshipInvites.error ||\n      relationshipActions.error ||\n      relationshipStatus.error ||\n      relationshipPermissions.error ||\n      relationshipTasks.error ||\n      relationshipValidation.error\n    );\n  }, [\n    relationshipList.error,\n    relationshipInvites.error,\n    relationshipActions.error,\n    relationshipStatus.error,\n    relationshipPermissions.error,\n    relationshipTasks.error,\n    relationshipValidation.error,\n  ]);\n\n  const combinedError = useMemo(() => {\n    const errors = [\n      relationshipList.error,\n      relationshipInvites.error,\n      relationshipActions.error,\n      relationshipStatus.error,\n      relationshipPermissions.error,\n      relationshipTasks.error,\n      relationshipValidation.error,\n    ].filter(Boolean);\n\n    return errors.length > 0 ? errors[0] : null;\n  }, [\n    relationshipList.error,\n    relationshipInvites.error,\n    relationshipActions.error,\n    relationshipStatus.error,\n    relationshipPermissions.error,\n    relationshipTasks.error,\n    relationshipValidation.error,\n  ]);\n\n  // Unified loading state - true if any hook is loading\n  const isLoading = useMemo(() => {\n    return !!(\n      relationshipList.isLoading ||\n      relationshipInvites.isLoading ||\n      relationshipActions.isLoading ||\n      relationshipStatus.isLoading ||\n      relationshipPermissions.isLoading ||\n      relationshipTasks.isLoading ||\n      relationshipValidation.isLoading\n    );\n  }, [\n    relationshipList.isLoading,\n    relationshipInvites.isLoading,\n    relationshipActions.isLoading,\n    relationshipStatus.isLoading,\n    relationshipPermissions.isLoading,\n    relationshipTasks.isLoading,\n    relationshipValidation.isLoading,\n  ]);\n\n  // Unified clear error function\n  const clearError = useCallback(() => {\n    relationshipList.clearError();\n    relationshipInvites.clearError();\n    relationshipActions.clearError();\n    relationshipStatus.clearError();\n    relationshipPermissions.clearError();\n    relationshipTasks.clearError();\n    relationshipValidation.clearError();\n  }, [\n    relationshipList,\n    relationshipInvites,\n    relationshipActions,\n    relationshipStatus,\n    relationshipPermissions,\n    relationshipTasks,\n    relationshipValidation,\n  ]);\n\n  // Enhanced setActiveRelationship that clears data when switching\n  const setActiveRelationship = useCallback(\n    (relationship: KeyholderRelationship | null) => {\n      // Cast KeyholderRelationship to Relationship for compatibility\n      // TODO: Align these types in the future\n      relationshipList.setActiveRelationship(\n        relationship as Relationship | null,\n      );\n\n      // Clear old data when switching relationships\n      if (!relationship) {\n        // Data will be automatically cleared since hooks are reactive\n      }\n    },\n    [relationshipList],\n  );\n\n  // Return combined state and actions for backward compatibility\n  return {\n    // Combined state - maintaining backward compatibility\n    relationships: relationshipList.relationships,\n    pendingRequests: relationshipInvites.pendingRequests,\n    activeRelationship: relationshipList.activeRelationship,\n    chastityData: relationshipStatus.chastityData,\n    tasks: relationshipTasks.tasks,\n    events: relationshipTasks.events,\n    sessions: relationshipStatus.sessions,\n    isLoading,\n    error: combinedError,\n    needsMigration: relationshipValidation.needsMigration,\n\n    // Combined actions - maintaining backward compatibility\n    sendRelationshipRequest: relationshipInvites.sendRelationshipRequest,\n    acceptRelationshipRequest: relationshipActions.acceptRelationshipRequest,\n    rejectRelationshipRequest: relationshipActions.rejectRelationshipRequest,\n    endRelationship: relationshipActions.endRelationship,\n    updatePermissions: relationshipPermissions.updatePermissions,\n    startSession: relationshipStatus.startSession,\n    endSession: relationshipStatus.endSession,\n    pauseSession: relationshipStatus.pauseSession,\n    resumeSession: relationshipStatus.resumeSession,\n    createTask: relationshipTasks.createTask,\n    updateTaskStatus: relationshipTasks.updateTaskStatus,\n    logEvent: relationshipTasks.logEvent,\n    migrateSingleUserData: relationshipValidation.migrateSingleUserData,\n    checkMigrationStatus: relationshipValidation.checkMigrationStatus,\n    setActiveRelationship,\n    refreshData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useRulesPage.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (81). Maximum allowed is 75.","line":4,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":96,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from \"react\";\nimport type { ChastityRule } from \"../components/rules\";\n\nexport const useRulesPage = (initialRules: ChastityRule[]) => {\n  const [rules, setRules] = useState<ChastityRule[]>(initialRules);\n  const [editingRule, setEditingRule] = useState<ChastityRule | null>(null);\n  const [showEditor, setShowEditor] = useState(false);\n  const [filter, setFilter] = useState<\"all\" | \"active\" | \"inactive\">(\"all\");\n\n  const filteredRules = rules\n    .filter((rule) => {\n      if (filter === \"all\") return true;\n      if (filter === \"active\") return rule.isActive;\n      if (filter === \"inactive\") return !rule.isActive;\n      return true;\n    })\n    .sort((a, b) => {\n      // Active rules first, then by last modified\n      if (a.isActive && !b.isActive) return -1;\n      if (!a.isActive && b.isActive) return 1;\n      return b.lastModified.getTime() - a.lastModified.getTime();\n    });\n\n  const handleEditRule = (ruleId: string) => {\n    const rule = rules.find((r) => r.id === ruleId);\n    setEditingRule(rule || null);\n    setShowEditor(true);\n  };\n\n  const handleToggleRule = (ruleId: string) => {\n    setRules((prev) =>\n      prev.map((rule) =>\n        rule.id === ruleId\n          ? { ...rule, isActive: !rule.isActive, lastModified: new Date() }\n          : rule,\n      ),\n    );\n  };\n\n  const handleSaveRule = (\n    ruleData: Omit<ChastityRule, \"id\" | \"createdAt\" | \"lastModified\">,\n  ) => {\n    const now = new Date();\n\n    if (editingRule) {\n      // Update existing rule\n      setRules((prev) =>\n        prev.map((rule) =>\n          rule.id === editingRule.id\n            ? {\n                ...rule,\n                ...ruleData,\n                lastModified: now,\n              }\n            : rule,\n        ),\n      );\n    } else {\n      // Create new rule\n      const newRule: ChastityRule = {\n        ...ruleData,\n        id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        createdAt: now,\n        lastModified: now,\n      };\n      setRules((prev) => [newRule, ...prev]);\n    }\n\n    setShowEditor(false);\n    setEditingRule(null);\n  };\n\n  const handleCancelEdit = () => {\n    setShowEditor(false);\n    setEditingRule(null);\n  };\n\n  const handleCreateNew = () => {\n    setEditingRule(null);\n    setShowEditor(true);\n  };\n\n  return {\n    rules,\n    editingRule,\n    showEditor,\n    filter,\n    filteredRules,\n    setFilter,\n    handleEditRule,\n    handleToggleRule,\n    handleSaveRule,\n    handleCancelEdit,\n    handleCreateNew,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useSessionPersistence.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionPersistence' has too many lines (133). Maximum allowed is 75.","line":38,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":202,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Persistence Hook\n * Provides React integration for session persistence functionality\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { sessionPersistenceService } from \"../services\";\nimport type {\n  SessionRestorationResult,\n  SessionPersistenceState,\n} from \"../services/SessionPersistenceService\";\nimport type { DBSession } from \"../types/database\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"useSessionPersistence\");\n\nexport interface UseSessionPersistenceOptions {\n  userId?: string;\n  autoInitialize?: boolean;\n}\n\nexport interface UseSessionPersistenceReturn {\n  isInitializing: boolean;\n  restorationResult: SessionRestorationResult | null;\n  error: string | null;\n  isSessionRestored: boolean;\n\n  // Actions\n  initializeSession: (userId: string) => Promise<SessionRestorationResult>;\n  backupSession: (session: DBSession) => Promise<void>;\n  startHeartbeat: (sessionId: string) => void;\n  stopHeartbeat: () => void;\n  detectAndRecover: (userId: string) => Promise<SessionRestorationResult>;\n\n  // State getters\n  getBackupState: () => SessionPersistenceState | null;\n}\n\nexport function useSessionPersistence(\n  options: UseSessionPersistenceOptions = {},\n): UseSessionPersistenceReturn {\n  const { userId, autoInitialize = true } = options;\n\n  const [isInitializing, setIsInitializing] = useState(false);\n  const [restorationResult, setRestorationResult] =\n    useState<SessionRestorationResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [isSessionRestored, setIsSessionRestored] = useState(false);\n\n  // Initialize session persistence when userId is available\n  const initializeSession = useCallback(\n    async (targetUserId: string): Promise<SessionRestorationResult> => {\n      try {\n        setIsInitializing(true);\n        setError(null);\n\n        logger.debug(\"Initializing session persistence\", {\n          userId: targetUserId,\n        });\n\n        const result =\n          await sessionPersistenceService.initializeSessionState(targetUserId);\n        setRestorationResult(result);\n        setIsSessionRestored(result.wasRestored);\n\n        if (!result.success && result.error) {\n          setError(result.error);\n        }\n\n        logger.debug(\"Session persistence initialized\", {\n          userId: targetUserId,\n          wasRestored: result.wasRestored,\n          success: result.success,\n        });\n\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        logger.error(\"Failed to initialize session persistence\", {\n          error: err as Error,\n          userId: targetUserId,\n        });\n\n        return {\n          success: false,\n          error: errorMessage,\n          wasRestored: false,\n        };\n      } finally {\n        setIsInitializing(false);\n      }\n    },\n    [],\n  );\n\n  // Backup session state\n  const backupSession = useCallback(\n    async (session: DBSession): Promise<void> => {\n      try {\n        await sessionPersistenceService.backupSessionState(session);\n        logger.debug(\"Session backed up\", { sessionId: session.id });\n      } catch (err) {\n        logger.error(\"Failed to backup session\", {\n          error: err as Error,\n          sessionId: session.id,\n        });\n        throw err;\n      }\n    },\n    [],\n  );\n\n  // Start heartbeat\n  const startHeartbeat = useCallback((sessionId: string): void => {\n    sessionPersistenceService.startHeartbeat(sessionId);\n    logger.debug(\"Heartbeat started\", { sessionId });\n  }, []);\n\n  // Stop heartbeat\n  const stopHeartbeat = useCallback((): void => {\n    sessionPersistenceService.stopHeartbeat();\n    logger.debug(\"Heartbeat stopped\");\n  }, []);\n\n  // Detect and recover from interruptions\n  const detectAndRecover = useCallback(\n    async (targetUserId: string): Promise<SessionRestorationResult> => {\n      try {\n        logger.debug(\"Detecting and recovering session\", {\n          userId: targetUserId,\n        });\n\n        const result =\n          await sessionPersistenceService.detectAndRecover(targetUserId);\n\n        if (result.wasRestored) {\n          setRestorationResult(result);\n          setIsSessionRestored(true);\n        }\n\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        logger.error(\"Failed to detect and recover session\", {\n          error: err as Error,\n          userId: targetUserId,\n        });\n\n        return {\n          success: false,\n          error: errorMessage,\n          wasRestored: false,\n        };\n      }\n    },\n    [],\n  );\n\n  // Get current backup state\n  const getBackupState = useCallback((): SessionPersistenceState | null => {\n    return sessionPersistenceService.getBackupState();\n  }, []);\n\n  // Auto-initialize when userId is provided\n  useEffect(() => {\n    if (autoInitialize && userId && !isInitializing && !restorationResult) {\n      initializeSession(userId);\n    }\n  }, [\n    userId,\n    autoInitialize,\n    isInitializing,\n    restorationResult,\n    initializeSession,\n  ]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopHeartbeat();\n    };\n  }, [stopHeartbeat]);\n\n  return {\n    isInitializing,\n    restorationResult,\n    error,\n    isSessionRestored,\n\n    // Actions\n    initializeSession,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n    detectAndRecover,\n\n    // State getters\n    getBackupState,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useSessionTimer.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionTimer' has too many lines (89). Maximum allowed is 75.","line":42,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":151,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useMultiSessionTimer' has too many lines (94). Maximum allowed is 75.","line":166,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":271,"endColumn":2}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":81,"column":24,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":81,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":201,"column":35,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":201,"endColumn":49,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Timer Hook\n * Provides real-time timer updates for active chastity sessions\n */\nimport { useState, useEffect, useMemo, useRef } from \"react\";\nimport type { DBSession } from \"../types/database\";\nimport { TimerService } from \"../services/TimerService\";\n\nexport interface SessionTimerData {\n  // Core timer values\n  effectiveTime: number; // Time in seconds excluding pauses\n  totalElapsedTime: number; // Total time including pauses\n  currentPauseDuration: number; // Current pause duration if paused\n\n  // Formatted strings\n  effectiveTimeFormatted: string;\n  totalElapsedTimeFormatted: string;\n  currentPauseDurationFormatted: string;\n\n  // Goal-related data\n  goalProgress: number; // Percentage (0-100)\n  remainingGoalTime: number; // Seconds remaining to goal\n  remainingGoalTimeFormatted: string;\n  isGoalCompleted: boolean;\n\n  // State flags\n  isActive: boolean; // Session exists and not ended\n  isPaused: boolean;\n\n  // Current time reference\n  currentTime: Date;\n}\n\nexport interface UseSessionTimerOptions {\n  updateInterval?: number; // Milliseconds, default 1000\n  enabled?: boolean; // Enable/disable timer updates, default true\n}\n\n/**\n * Hook for real-time session timer with live updates\n */\nexport function useSessionTimer(\n  session: DBSession | null | undefined,\n  options: UseSessionTimerOptions = {},\n): SessionTimerData {\n  const { updateInterval = 1000, enabled = true } = options;\n\n  const [currentTime, setCurrentTime] = useState(() => new Date());\n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Track session state changes manually to avoid zustand warnings\n  const sessionId = session?.id;\n  const sessionEndTime = session?.endTime;\n  const isSessionActive = enabled && sessionId && !sessionEndTime;\n\n  // Update current time every second\n  useEffect(() => {\n    if (!isSessionActive) {\n      // Clear interval if timer is disabled or session is not active\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n      return;\n    }\n\n    const updateCurrentTime = () => {\n      setCurrentTime(new Date());\n    };\n\n    // Set up interval\n    intervalRef.current = setInterval(updateCurrentTime, updateInterval);\n\n    // Cleanup on unmount or dependency change\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [isSessionActive, updateInterval]); // eslint-disable-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n\n  // Memoized calculations to prevent unnecessary recalculations\n  const timerData = useMemo((): SessionTimerData => {\n    // Default values when no session or session ended\n    const defaultData: SessionTimerData = {\n      effectiveTime: 0,\n      totalElapsedTime: 0,\n      currentPauseDuration: 0,\n      effectiveTimeFormatted: \"0s\",\n      totalElapsedTimeFormatted: \"0s\",\n      currentPauseDurationFormatted: \"0s\",\n      goalProgress: 0,\n      remainingGoalTime: 0,\n      remainingGoalTimeFormatted: \"0s\",\n      isGoalCompleted: false,\n      isActive: false,\n      isPaused: false,\n      currentTime,\n    };\n\n    if (!session || session.endTime) {\n      return defaultData;\n    }\n\n    // Calculate timer values\n    const effectiveTime = TimerService.calculateEffectiveTime(\n      session,\n      currentTime,\n    );\n    const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n      session,\n      currentTime,\n    );\n    const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n      session,\n      currentTime,\n    );\n\n    // Calculate goal-related data\n    const goalProgress = TimerService.calculateGoalProgress(\n      session,\n      currentTime,\n    );\n    const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n      session,\n      currentTime,\n    );\n    const isGoalCompleted = TimerService.isGoalCompleted(session, currentTime);\n\n    return {\n      effectiveTime,\n      totalElapsedTime,\n      currentPauseDuration,\n      effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n      totalElapsedTimeFormatted: TimerService.formatDuration(totalElapsedTime),\n      currentPauseDurationFormatted:\n        TimerService.formatDuration(currentPauseDuration),\n      goalProgress,\n      remainingGoalTime,\n      remainingGoalTimeFormatted:\n        TimerService.formatDuration(remainingGoalTime),\n      isGoalCompleted,\n      isActive: true,\n      isPaused: session.isPaused,\n      currentTime,\n    };\n  }, [session, currentTime]);\n\n  return timerData;\n}\n\n/**\n * Hook for getting a snapshot of timer data without live updates\n * Useful for components that don't need real-time updates\n */\nexport function useSessionTimerSnapshot(\n  session: DBSession | null | undefined,\n): SessionTimerData {\n  return useSessionTimer(session, { enabled: false });\n}\n\n/**\n * Hook for multiple sessions timer data (useful for dashboards)\n */\nexport function useMultiSessionTimer(\n  sessions: (DBSession | null | undefined)[],\n  options: UseSessionTimerOptions = {},\n): SessionTimerData[] {\n  const [currentTime, setCurrentTime] = useState(() => new Date());\n  const { updateInterval = 1000, enabled = true } = options;\n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Check if we have any active sessions\n  const hasActiveSessions = useMemo(() => {\n    return sessions.some((session) => session && !session.endTime);\n  }, [sessions]);\n\n  // Update current time for all sessions\n  useEffect(() => {\n    if (!enabled || !hasActiveSessions) {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n      return;\n    }\n\n    const updateCurrentTime = () => {\n      setCurrentTime(new Date());\n    };\n\n    intervalRef.current = setInterval(updateCurrentTime, updateInterval);\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [enabled, hasActiveSessions, updateInterval]); // eslint-disable-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n\n  // Calculate timer data for each session\n  const timerDataArray = useMemo(() => {\n    return sessions.map((session) => {\n      if (!session || session.endTime) {\n        return {\n          effectiveTime: 0,\n          totalElapsedTime: 0,\n          currentPauseDuration: 0,\n          effectiveTimeFormatted: \"0s\",\n          totalElapsedTimeFormatted: \"0s\",\n          currentPauseDurationFormatted: \"0s\",\n          goalProgress: 0,\n          remainingGoalTime: 0,\n          remainingGoalTimeFormatted: \"0s\",\n          isGoalCompleted: false,\n          isActive: false,\n          isPaused: false,\n          currentTime,\n        };\n      }\n\n      const effectiveTime = TimerService.calculateEffectiveTime(\n        session,\n        currentTime,\n      );\n      const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n        session,\n        currentTime,\n      );\n      const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n        session,\n        currentTime,\n      );\n      const goalProgress = TimerService.calculateGoalProgress(\n        session,\n        currentTime,\n      );\n      const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n        session,\n        currentTime,\n      );\n      const isGoalCompleted = TimerService.isGoalCompleted(\n        session,\n        currentTime,\n      );\n\n      return {\n        effectiveTime,\n        totalElapsedTime,\n        currentPauseDuration,\n        effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n        totalElapsedTimeFormatted:\n          TimerService.formatDuration(totalElapsedTime),\n        currentPauseDurationFormatted:\n          TimerService.formatDuration(currentPauseDuration),\n        goalProgress,\n        remainingGoalTime,\n        remainingGoalTimeFormatted:\n          TimerService.formatDuration(remainingGoalTime),\n        isGoalCompleted,\n        isActive: true,\n        isPaused: session.isPaused,\n        currentTime,\n      };\n    });\n  }, [sessions, currentTime]);\n\n  return timerDataArray;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useSpecialChallenges.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (195). Maximum allowed is 75.","line":27,"column":37,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":268,"endColumn":2}],"suppressedMessages":[{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":237,"column":43,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":237,"endColumn":62,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from \"react\";\nimport { goalDBService } from \"@/services/database/GoalDBService\";\nimport type { DBGoal } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { useAchievementIntegration } from \"@/constants/challengeAchievements\";\n\nconst logger = serviceLogger(\"useSpecialChallenges\");\n\nexport interface SpecialChallengeStatus {\n  locktober: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n  noNutNovember: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n}\n\n/**\n * Hook for managing special challenge goals (Locktober, No Nut November)\n */\nexport const useSpecialChallenges = (userId: string | null) => {\n  const [challengeStatus, setChallengeStatus] =\n    useState<SpecialChallengeStatus>({\n      locktober: { available: false, active: false, completed: false },\n      noNutNovember: { available: false, active: false, completed: false },\n    });\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const { checkForChallengeAchievements } = useAchievementIntegration();\n\n  /**\n   * Check if challenges are available based on current date\n   */\n  const checkChallengeAvailability = useCallback(() => {\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth(); // 0-based\n\n    return {\n      locktober: currentMonth === 9, // October\n      noNutNovember: currentMonth === 10, // November\n    };\n  }, []);\n\n  /**\n   * Load challenge status for the user\n   */\n  const loadChallengeStatus = useCallback(async () => {\n    if (!userId) {\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const availability = checkChallengeAvailability();\n      const specialGoals = await goalDBService.getSpecialChallengeGoals(userId);\n      const currentYear = new Date().getFullYear();\n\n      // Find current year's goals\n      const locktoberGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"locktober\" &&\n          goal.challengeYear === currentYear,\n      );\n      const noNutGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"no_nut_november\" &&\n          goal.challengeYear === currentYear,\n      );\n\n      setChallengeStatus({\n        locktober: {\n          available: availability.locktober,\n          active: !!locktoberGoal && !locktoberGoal.isCompleted,\n          completed: !!locktoberGoal?.isCompleted,\n          goal: locktoberGoal,\n        },\n        noNutNovember: {\n          available: availability.noNutNovember,\n          active: !!noNutGoal && !noNutGoal.isCompleted,\n          completed: !!noNutGoal?.isCompleted,\n          goal: noNutGoal,\n        },\n      });\n\n      logger.debug(\"Loaded challenge status\", {\n        userId,\n        hasLocktober: !!locktoberGoal,\n        hasNoNut: !!noNutGoal,\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Unknown error\";\n      setError(errorMessage);\n      logger.error(\"Failed to load challenge status\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, checkChallengeAvailability]);\n\n  /**\n   * Join a special challenge\n   */\n  const joinChallenge = useCallback(\n    async (challengeType: \"locktober\" | \"no_nut_november\") => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        setError(null);\n        const goal = await goalDBService.getOrCreateChallengeGoal(\n          userId,\n          challengeType,\n        );\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"User joined challenge\", {\n          userId,\n          challengeType,\n          goalId: goal.id,\n        });\n        return goal;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to join challenge\";\n        setError(errorMessage);\n        logger.error(\"Failed to join challenge\", {\n          error: err,\n          userId,\n          challengeType,\n        });\n        throw err;\n      }\n    },\n    [userId, loadChallengeStatus],\n  );\n\n  /**\n   * Update challenge progress\n   */\n  const updateChallengeProgress = useCallback(\n    async (\n      challengeType: \"locktober\" | \"no_nut_november\",\n      progressValue: number,\n    ) => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        const challengeMap = {\n          locktober: challengeStatus.locktober,\n          no_nut_november: challengeStatus.noNutNovember,\n        };\n        const challenge =\n          challengeMap[challengeType as keyof typeof challengeMap];\n        if (!challenge.goal) {\n          throw new Error(\"Challenge goal not found\");\n        }\n\n        await goalDBService.updateGoalProgress(\n          challenge.goal.id,\n          progressValue,\n        );\n\n        // Check if challenge was completed and trigger achievements\n        const updatedGoal = await goalDBService.findById(challenge.goal.id);\n        if (updatedGoal?.isCompleted) {\n          await checkForChallengeAchievements({\n            challengeType: updatedGoal.challengeType,\n            challengeYear: updatedGoal.challengeYear,\n            isCompleted: updatedGoal.isCompleted,\n          });\n        }\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"Updated challenge progress\", {\n          userId,\n          challengeType,\n          progressValue,\n          goalId: challenge.goal.id,\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to update progress\";\n        setError(errorMessage);\n        logger.error(\"Failed to update challenge progress\", {\n          error: err,\n          userId,\n          challengeType,\n          progressValue,\n        });\n        throw err;\n      }\n    },\n    [\n      userId,\n      challengeStatus,\n      loadChallengeStatus,\n      checkForChallengeAchievements,\n    ],\n  );\n\n  /**\n   * Get progress percentage for a challenge\n   */\n  const getChallengeProgress = useCallback(\n    (challengeType: \"locktober\" | \"no_nut_november\") => {\n      const challenge = challengeStatus[challengeType];\n      if (!challenge.goal) return 0;\n\n      return Math.min(\n        100,\n        (challenge.goal.currentValue / challenge.goal.targetValue) * 100,\n      );\n    },\n    [challengeStatus],\n  );\n\n  // Load challenge status on mount and when userId changes\n  useEffect(() => {\n    loadChallengeStatus();\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [userId, checkChallengeAvailability, loadChallengeStatus]);\n\n  // Refresh status every hour to check for date changes\n  useEffect(() => {\n    const interval = setInterval(\n      () => {\n        const availability = checkChallengeAvailability();\n        setChallengeStatus((prev) => ({\n          ...prev,\n          locktober: { ...prev.locktober, available: availability.locktober },\n          noNutNovember: {\n            ...prev.noNutNovember,\n            available: availability.noNutNovember,\n          },\n        }));\n      },\n      60 * 60 * 1000,\n    ); // Check every hour\n\n    return () => clearInterval(interval);\n  }, [checkChallengeAvailability]);\n\n  return {\n    challengeStatus,\n    isLoading,\n    error,\n    joinChallenge,\n    updateChallengeProgress,\n    getChallengeProgress,\n    refreshStatus: loadChallengeStatus,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useSync.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (99). Maximum allowed is 75.","line":27,"column":24,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":154,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSync Hook\n * Manages synchronization state and conflict resolution\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { SyncResult, ConflictInfo, SyncOptions } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSync\");\n\ninterface UseSyncState {\n  isSyncing: boolean;\n  lastSyncResult: SyncResult | null;\n  pendingConflicts: ConflictInfo[];\n  error: Error | null;\n}\n\ninterface UseSyncActions {\n  sync: (userId: string, options?: SyncOptions) => Promise<SyncResult>;\n  resolveConflicts: (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => Promise<void>;\n  clearError: () => void;\n}\n\nexport const useSync = (): UseSyncState & UseSyncActions => {\n  const [state, setState] = useState<UseSyncState>({\n    isSyncing: false,\n    lastSyncResult: null,\n    pendingConflicts: [],\n    error: null,\n  });\n\n  // Check for pending conflicts on mount\n  useEffect(() => {\n    const checkPendingConflicts = () => {\n      const conflicts = firebaseSync.getPendingConflicts();\n      setState((prev) => ({ ...prev, pendingConflicts: conflicts }));\n    };\n\n    checkPendingConflicts();\n\n    // Check periodically for conflicts\n    const interval = setInterval(checkPendingConflicts, 30000); // Every 30 seconds\n\n    return () => clearInterval(interval);\n  }, []);\n\n  const sync = useCallback(\n    async (userId: string, options?: SyncOptions): Promise<SyncResult> => {\n      setState((prev) => ({ ...prev, isSyncing: true, error: null }));\n\n      try {\n        logger.info(\"Starting sync\", { userId, options });\n        const result = await firebaseSync.syncUserData(userId, options);\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          lastSyncResult: result,\n          pendingConflicts:\n            result.conflicts.length > 0\n              ? result.conflicts\n              : prev.pendingConflicts,\n        }));\n\n        logger.info(\"Sync completed\", {\n          success: result.success,\n          conflicts: result.conflicts.length,\n        });\n\n        return result;\n      } catch (error) {\n        const err = error as Error;\n        logger.error(\"Sync failed\", { error: err });\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          error: err,\n        }));\n\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const resolveConflicts = useCallback(\n    async (resolutions: Record<string, \"local\" | \"remote\">): Promise<void> => {\n      try {\n        logger.info(\"Resolving conflicts\", {\n          resolutionCount: Object.keys(resolutions).length,\n        });\n\n        // Apply resolutions (implementation would depend on specific conflict resolution logic)\n        const resolvedIds: string[] = [];\n\n        for (const [conflictKey, resolution] of Object.entries(resolutions)) {\n          // conflictKey format: \"collection-documentId-index\" or similar\n          const conflict = state.pendingConflicts.find(\n            (c) =>\n              `${c.collection}-${c.documentId}` ===\n              conflictKey.split(\"-\").slice(0, 2).join(\"-\"),\n          );\n\n          if (conflict) {\n            // Apply the chosen resolution\n            const dataToApply =\n              resolution === \"local\" ? conflict.localData : conflict.remoteData;\n\n            // Update both local and remote with chosen data\n            await firebaseSync.applyRemoteChanges(conflict.collection, [\n              dataToApply,\n            ]);\n\n            resolvedIds.push(`${conflict.collection}-${conflict.documentId}`);\n          }\n        }\n\n        // Clear resolved conflicts\n        firebaseSync.clearResolvedConflicts(resolvedIds);\n\n        setState((prev) => ({\n          ...prev,\n          pendingConflicts: prev.pendingConflicts.filter(\n            (c) => !resolvedIds.includes(`${c.collection}-${c.documentId}`),\n          ),\n        }));\n\n        logger.info(\"Conflicts resolved\", {\n          resolvedCount: resolvedIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n        setState((prev) => ({ ...prev, error: error as Error }));\n        throw error;\n      }\n    },\n    [state.pendingConflicts],\n  );\n\n  const clearError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  return {\n    ...state,\n    sync,\n    resolveConflicts,\n    clearError,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useTrackerHandlers.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'backupSession'. Either include it or remove the dependency array. If 'backupSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":87,"column":6,"nodeType":"ArrayExpression","endLine":87,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [backupSession, currentSession, isSessionInitialized]","fix":{"range":[2786,2824],"text":"[backupSession, currentSession, isSessionInitialized]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setCurrentSession'. Either include it or remove the dependency array. If 'setCurrentSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":77,"column":6,"nodeType":"ArrayExpression","endLine":77,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setCurrentSession]","fix":{"range":[2443,2445],"text":"[setCurrentSession]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useCallback } from \"react\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession } from \"../types/database\";\n\ninterface UseTrackerHandlersProps {\n  setCurrentSession: (session: DBSession | null) => void;\n  setIsSessionInitialized: (initialized: boolean) => void;\n  startHeartbeat: (sessionId: string) => void;\n  stopHeartbeat: () => void;\n  backupSession: (session: DBSession) => Promise<void>;\n  mockData: {\n    sessionId: string;\n    userId: string;\n    refreshPauseState: () => void;\n  };\n  currentSession: DBSession | null;\n  isSessionInitialized: boolean;\n}\n\nexport const useTrackerHandlers = ({\n  setCurrentSession,\n  setIsSessionInitialized,\n  startHeartbeat: _startHeartbeat,\n  stopHeartbeat,\n  backupSession,\n  mockData,\n  currentSession,\n  isSessionInitialized,\n}: UseTrackerHandlersProps) => {\n  const handleSessionInitialized = useCallback(() => {\n    setIsSessionInitialized(true);\n    logger.debug(\"Session persistence initialized\");\n  }, [setIsSessionInitialized]);\n\n  const handleEmergencyUnlock = useCallback(() => {\n    logger.info(\"Emergency unlock completed - refreshing session state\", {\n      sessionId: mockData.sessionId,\n      userId: mockData.userId,\n    });\n  }, [mockData.sessionId, mockData.userId]);\n\n  const handlePause = useCallback(() => {\n    logger.info(\"Session paused\", {\n      sessionId: currentSession?.id,\n      userId: mockData.userId,\n    });\n    mockData.refreshPauseState();\n  }, [currentSession?.id, mockData]);\n\n  const handleResume = useCallback(() => {\n    logger.info(\"Session resumed\", {\n      sessionId: currentSession?.id,\n      userId: mockData.userId,\n    });\n    mockData.refreshPauseState();\n  }, [currentSession?.id, mockData]);\n\n  // Initialize mock session with real DBSession structure\n  useEffect(() => {\n    const mockSession: DBSession = {\n      id: \"session123\",\n      userId: \"user123\",\n      startTime: new Date(Date.now() - 86400000), // 1 day ago\n      endTime: undefined,\n      isPaused: false,\n      pauseStartTime: undefined,\n      accumulatedPauseTime: 3600, // 1 hour of accumulated pause time\n      goalDuration: 172800, // 48 hour goal\n      isHardcoreMode: false,\n      keyholderApprovalRequired: false,\n      syncStatus: \"synced\" as const,\n      lastModified: new Date(),\n    };\n    setCurrentSession(mockSession);\n    // setCurrentSession is a state setter (stable)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Backup session state when it changes\n  useEffect(() => {\n    if (currentSession && isSessionInitialized) {\n      backupSession(currentSession).catch((error) => {\n        logger.error(\"Failed to backup session\", { error: error as Error });\n      });\n    }\n    // backupSession should be stable (useCallback) in parent component\n  }, [currentSession, isSessionInitialized]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopHeartbeat();\n    };\n  }, [stopHeartbeat]);\n\n  return {\n    handleSessionInitialized,\n    handleEmergencyUnlock,\n    handlePause,\n    handleResume,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/AchievementPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/ChastityTracking.tsx","messages":[{"ruleId":"no-undef","severity":1,"message":"'useState' is not defined.","line":146,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":146,"endColumn":55},{"ruleId":"no-undef","severity":1,"message":"'useState' is not defined.","line":147,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":65},{"ruleId":"no-undef","severity":1,"message":"'useState' is not defined.","line":148,"column":59,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":67},{"ruleId":"no-undef","severity":1,"message":"'useState' is not defined.","line":149,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":59},{"ruleId":"no-undef","severity":1,"message":"'User' is not defined.","line":166,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":32},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (156). Maximum allowed is 75.","line":225,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":405,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 19. Maximum allowed is 15.","line":225,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":405,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { RestoreSessionPrompt } from \"../components/tracker/RestoreSessionPrompt\";\nimport { SessionLoader } from \"../components/tracker/SessionLoader\";\nimport { SessionRecoveryModal } from \"../components/tracker/SessionRecoveryModal\";\nimport { TrackerStats } from \"../components/tracker/TrackerStats\";\nimport { ActionButtons } from \"../components/tracker/ActionButtons\";\nimport { PauseResumeButtons } from \"../components/tracker/PauseResumeButtons\";\n// TODO: CooldownTimer temporarily disabled due to service import restrictions\n// import { CooldownTimer } from \"../components/tracker/CooldownTimer\";\nimport { ReasonModals } from \"../components/tracker/ReasonModals\";\nimport { TrackerHeader } from \"../components/tracker/TrackerHeader\";\nimport { useSessionPersistence } from \"../hooks/useSessionPersistence\";\nimport { useAuth } from \"../hooks/api/useAuth\";\nimport { useTrackerHandlers } from \"../hooks/useTrackerHandlers\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession } from \"../types/database\";\nimport type { SessionRestorationResult } from \"../services/SessionPersistenceService\";\n\n// Helper function to handle session restoration\nconst createSessionRestorationHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    startHeartbeat: (sessionId: string) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n  ) =>\n  (result: SessionRestorationResult) => {\n    logger.info(\"Session restoration completed\", {\n      wasRestored: result.wasRestored,\n      sessionId: result.session?.id,\n    });\n\n    if (result.session) {\n      setCurrentSession(result.session);\n      startHeartbeat(result.session.id);\n\n      // If session had validation issues but was recovered, show recovery modal\n      if (result.error && result.session) {\n        setCorruptedSession(result.session);\n        setShowSessionRecovery(true);\n      }\n    }\n  };\n\n// Helper function to handle session recovery\nconst createSessionRecoveryHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    backupSession: (session: DBSession) => Promise<void>,\n    startHeartbeat: (sessionId: string) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n  ) =>\n  async (session: DBSession) => {\n    logger.info(\"Session recovery initiated\", { sessionId: session.id });\n    try {\n      await backupSession(session);\n      setCurrentSession(session);\n      startHeartbeat(session.id);\n      setShowSessionRecovery(false);\n      setCorruptedSession(null);\n      logger.info(\"Session recovery completed\", { sessionId: session.id });\n    } catch (error) {\n      logger.error(\"Session recovery failed\", { error: error as Error });\n    }\n  };\n\n// Helper function to handle session discard\nconst createSessionDiscardHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    stopHeartbeat: () => void,\n  ) =>\n  () => {\n    setCurrentSession(null);\n    setShowSessionRecovery(false);\n    setCorruptedSession(null);\n    stopHeartbeat();\n    logger.info(\"Corrupted session discarded\");\n  };\n\n// Session Persistence Error Component\nconst SessionPersistenceError: React.FC<{ error: string }> = ({ error }) => (\n  <div className=\"mx-4 mb-4 p-3 bg-red-900/50 border border-red-500 rounded-lg\">\n    <p className=\"text-sm text-red-200\">\n      <strong>Session Error:</strong> {error}\n    </p>\n  </div>\n);\n\n// Cooldown Display Component\nconst CooldownDisplay: React.FC<{\n  pauseState: { cooldownRemaining?: number } | null;\n}> = ({ pauseState }) => {\n  if (!pauseState?.cooldownRemaining) return null;\n\n  return (\n    <div className=\"mx-4 text-center\">\n      <div className=\"text-yellow-600\">\n        Cooldown: {pauseState.cooldownRemaining}s remaining\n      </div>\n    </div>\n  );\n};\n\n// Debug Panel Component\ninterface PauseState {\n  canPause: boolean;\n  cooldownRemaining?: number;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n}\n\nconst DebugPanel: React.FC<{\n  pauseState: PauseState | null;\n  pauseStateLoading: boolean;\n  pauseStateError: string | null;\n}> = ({ pauseState, pauseStateLoading, pauseStateError }) => {\n  if (process.env.NODE_ENV !== \"development\") return null;\n\n  return (\n    <div className=\"mt-8 p-4 bg-gray-800 rounded-lg text-xs\">\n      <h4 className=\"text-yellow-400 font-bold mb-2\">Debug: Pause State</h4>\n      <pre className=\"text-gray-300\">\n        {JSON.stringify(\n          {\n            canPause: pauseState?.canPause,\n            cooldownRemaining: pauseState?.cooldownRemaining,\n            lastPauseTime: pauseState?.lastPauseTime,\n            nextPauseAvailable: pauseState?.nextPauseAvailable,\n            isLoading: pauseStateLoading,\n            error: pauseStateError,\n          },\n          null,\n          2,\n        )}\n      </pre>\n    </div>\n  );\n};\n\n// Custom hook for session state management\nconst useSessionState = () => {\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [showSessionRecovery, setShowSessionRecovery] = useState(false);\n  const [isSessionInitialized, setIsSessionInitialized] = useState(false);\n  const [corruptedSession, setCorruptedSession] = useState<DBSession | null>(\n    null,\n  );\n\n  return {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  };\n};\n\n// Custom hook for mock data (temporary until real implementation)\nconst useMockData = (user: User | null) => {\n  // Mock pause state data for now\n  const pauseState: PauseState = {\n    canPause: true,\n    cooldownRemaining: undefined,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n  };\n  const pauseStateLoading = false;\n  const pauseStateError = null;\n  const refreshPauseState = () => {};\n\n  // Mock session data - replace with real session management\n  const mockSessionData = {\n    isCageOn: true,\n    isPaused: false,\n    remainingGoalTime: 3600,\n    keyholderName: \"Keyholder\",\n    savedSubmissivesName: \"Submissive\",\n    requiredKeyholderDurationSeconds: 7200,\n    mainChastityDisplayTime: 3600,\n    topBoxLabel: \"Total Locked Time\",\n    topBoxTime: \"1d 2h 3m\",\n    livePauseDuration: 0,\n    accumulatedPauseTimeThisSession: 0,\n    timeCageOff: 0,\n    totalChastityTime: 86400,\n    totalTimeCageOff: 0,\n    showRestoreSessionPrompt: false,\n    pauseCooldownMessage: null,\n    denialCooldownActive: false,\n    hasPendingReleaseRequest: false,\n    isGoalActive: true,\n    isHardcoreGoal: false,\n    showReasonModal: false,\n    showPauseReasonModal: false,\n    useRealTimeTimer: false, // Feature flag for real-time timer\n    sessionId: \"mock-session-123\",\n    userId: user?.uid || \"mock-user-123\",\n  };\n\n  // Override pause state for demo - show that pause is available\n  const mockPauseState = {\n    canPause: true,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n    cooldownRemaining: undefined,\n  };\n\n  return {\n    pauseState,\n    pauseStateLoading,\n    pauseStateError,\n    refreshPauseState,\n    ...mockSessionData,\n    mockPauseState,\n  };\n};\n\nconst TrackerPage: React.FC = () => {\n  // Authentication state\n  const { data: user, isLoading: authLoading } = useAuth();\n\n  // Session persistence state\n  const {\n    isInitializing,\n    error: persistenceError,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n  } = useSessionPersistence({\n    userId: user?.uid,\n    autoInitialize: true,\n  });\n\n  // Session state management\n  const {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  } = useSessionState();\n\n  // Mock data (replace with real hooks)\n  const mockData = useMockData(user);\n\n  // Use tracker handlers hook for event handlers and effects\n  const {\n    handleSessionInitialized,\n    handleEmergencyUnlock,\n    handlePause,\n    handleResume,\n  } = useTrackerHandlers({\n    setCurrentSession,\n    setIsSessionInitialized,\n    startHeartbeat,\n    stopHeartbeat,\n    backupSession,\n    mockData: {\n      sessionId: mockData.sessionId,\n      userId: mockData.userId,\n      refreshPauseState: mockData.refreshPauseState,\n    },\n    currentSession,\n    isSessionInitialized,\n  });\n\n  // Create handlers using helper functions\n  const handleSessionRestored = createSessionRestorationHandler(\n    setCurrentSession,\n    startHeartbeat,\n    setCorruptedSession,\n    setShowSessionRecovery,\n  );\n\n  const handleRecoverSession = createSessionRecoveryHandler(\n    setCurrentSession,\n    backupSession,\n    startHeartbeat,\n    setShowSessionRecovery,\n    setCorruptedSession,\n  );\n\n  const handleDiscardSession = createSessionDiscardHandler(\n    setCurrentSession,\n    setShowSessionRecovery,\n    setCorruptedSession,\n    stopHeartbeat,\n  );\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Session Persistence Loading */}\n      {(authLoading || isInitializing) && user?.uid && (\n        <SessionLoader\n          userId={user.uid}\n          onSessionRestored={handleSessionRestored}\n          onInitialized={handleSessionInitialized}\n        />\n      )}\n\n      {/* Session Recovery Modal */}\n      {showSessionRecovery && corruptedSession && (\n        <SessionRecoveryModal\n          corruptedSession={corruptedSession}\n          onRecover={handleRecoverSession}\n          onDiscard={handleDiscardSession}\n        />\n      )}\n\n      {/* Session Persistence Error */}\n      {persistenceError && <SessionPersistenceError error={persistenceError} />}\n\n      {mockData.showRestoreSessionPrompt && (\n        <RestoreSessionPrompt onConfirm={() => {}} onDiscard={() => {}} />\n      )}\n\n      <TrackerHeader\n        remainingGoalTime={mockData.remainingGoalTime}\n        keyholderName={mockData.keyholderName}\n        savedSubmissivesName={mockData.savedSubmissivesName}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        isCageOn={mockData.isCageOn}\n        denialCooldownActive={mockData.denialCooldownActive}\n        pauseCooldownMessage={mockData.pauseCooldownMessage}\n      />\n\n      <TrackerStats\n        // Pass the real session when using real-time timer\n        currentSession={mockData.useRealTimeTimer ? currentSession : undefined}\n        // Legacy props for backward compatibility\n        mainChastityDisplayTime={\n          mockData.useRealTimeTimer\n            ? undefined\n            : mockData.mainChastityDisplayTime\n        }\n        topBoxLabel={mockData.topBoxLabel}\n        topBoxTime={mockData.useRealTimeTimer ? undefined : mockData.topBoxTime}\n        livePauseDuration={\n          mockData.useRealTimeTimer ? undefined : mockData.livePauseDuration\n        }\n        accumulatedPauseTimeThisSession={\n          mockData.useRealTimeTimer\n            ? undefined\n            : mockData.accumulatedPauseTimeThisSession\n        }\n        timeCageOff={mockData.timeCageOff}\n        isCageOn={mockData.isCageOn}\n        totalChastityTime={mockData.totalChastityTime}\n        totalTimeCageOff={mockData.totalTimeCageOff}\n        isPaused={mockData.isPaused}\n      />\n\n      {/* Enhanced Pause Controls with 4-hour cooldown */}\n      {mockData.isCageOn && currentSession && (\n        <>\n          <CooldownDisplay pauseState={mockData.pauseState} />\n          <PauseResumeButtons\n            sessionId={currentSession.id}\n            userId={user?.uid || \"\"}\n            isPaused={mockData.isPaused}\n            pauseState={mockData.mockPauseState} // Use mock state to show functionality\n            onPause={handlePause}\n            onResume={handleResume}\n          />\n        </>\n      )}\n\n      <ActionButtons\n        isCageOn={mockData.isCageOn}\n        isGoalActive={mockData.isGoalActive}\n        isHardcoreGoal={mockData.isHardcoreGoal}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        hasPendingReleaseRequest={mockData.hasPendingReleaseRequest}\n        sessionId={mockData.sessionId}\n        userId={mockData.userId}\n        onEmergencyUnlock={handleEmergencyUnlock}\n      />\n\n      <ReasonModals\n        showReasonModal={mockData.showReasonModal}\n        showPauseReasonModal={mockData.showPauseReasonModal}\n      />\n\n      <DebugPanel\n        pauseState={mockData.pauseState}\n        pauseStateLoading={mockData.pauseStateLoading}\n        pauseStateError={mockData.pauseStateError}\n      />\n    </div>\n  );\n};\n\nexport default TrackerPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/FullReportPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/KeyholderDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/KeyholderPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/LogEventPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/MobileShowcase.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/PublicProfilePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RelationshipsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RewardsPunishmentsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RulesPage.tsx","messages":[{"ruleId":"no-undef","severity":1,"message":"'ChastityRule' is not defined.","line":12,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport {\n  RuleCard,\n  RuleEditor,\n  RulesPageControls,\n  RulesInfoBanner,\n  RulesEmptyState,\n} from \"../components/rules\";\nimport { useRulesPage } from \"../hooks/useRulesPage\";\n\n// Mock rules data\nconst mockRules: ChastityRule[] = [\n  {\n    id: \"1\",\n    title: \"Daily Check-ins\",\n    content: `Must complete daily check-in form by 10 PM each night.\n\n**Required information:**\n- Current mood and energy level\n- Any challenges or temptations faced\n- Tomorrow's goals and commitments\n\n**Consequences for missing:**\n- +12 hours added to chastity time\n- Extra task assigned for the following day`,\n    isActive: true,\n    createdBy: \"keyholder\",\n    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),\n  },\n  {\n    id: \"2\",\n    title: \"Exercise Requirements\",\n    content: `Minimum 30 minutes of physical activity daily.\n\n**Acceptable activities:**\n- Cardio (running, cycling, swimming)\n- Strength training\n- Yoga or stretching\n- Sports activities\n\n**Tracking:**\n- Log activity type and duration\n- Include photo evidence when requested\n- Heart rate data if available\n\n**Rewards for consistency:**\n- 7 days straight: -4 hours\n- 14 days straight: -8 hours\n- 30 days straight: -24 hours`,\n    isActive: true,\n    createdBy: \"keyholder\",\n    createdAt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000),\n  },\n  {\n    id: \"3\",\n    title: \"Communication Protocol\",\n    content: `Clear communication expectations between keyholder and submissive.\n\n**Response times:**\n- Urgent messages: Within 1 hour\n- Regular messages: Within 4 hours\n- Check-ins: Daily by agreed time\n\n**Escalation process:**\n- If no response within timeframe\n- Emergency contact procedures\n- Safe words and their meanings`,\n    isActive: false,\n    createdBy: \"submissive\",\n    createdAt: new Date(Date.now() - 21 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 21 * 24 * 60 * 60 * 1000),\n  },\n];\n\nconst RulesPage: React.FC = () => {\n  const {\n    rules,\n    editingRule,\n    showEditor,\n    filter,\n    filteredRules,\n    setFilter,\n    handleEditRule,\n    handleToggleRule,\n    handleSaveRule,\n    handleCancelEdit,\n    handleCreateNew,\n  } = useRulesPage(mockRules);\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-4xl mx-auto\">\n        {/* Info Banner */}\n        <RulesInfoBanner />\n\n        {/* Controls */}\n        {!showEditor && (\n          <RulesPageControls\n            filter={filter}\n            onFilterChange={setFilter}\n            rules={rules}\n            onCreateNew={handleCreateNew}\n          />\n        )}\n\n        {/* Editor */}\n        {showEditor && (\n          <div className=\"mb-6\">\n            <RuleEditor\n              rule={editingRule}\n              onSave={handleSaveRule}\n              onCancel={handleCancelEdit}\n            />\n          </div>\n        )}\n\n        {/* Rules List */}\n        {!showEditor && (\n          <div className=\"space-y-6\">\n            {filteredRules.length === 0 ? (\n              <RulesEmptyState filter={filter} />\n            ) : (\n              filteredRules.map((rule) => (\n                <RuleCard\n                  key={rule.id}\n                  rule={rule}\n                  isEditable={true}\n                  onEdit={() => handleEditRule(rule.id)}\n                  onToggle={() => handleToggleRule(rule.id)}\n                />\n              ))\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default RulesPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/SettingsMainPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/SettingsPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (89). Maximum allowed is 75.","line":473,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":569,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { settingsDBService } from \"../services/database\";\nimport type { DBSettings } from \"../types/database\";\nimport { logger } from \"../utils/logging\";\nimport {\n  FaUser,\n  FaPalette,\n  FaGlobe,\n  FaBullseye,\n  FaCog,\n  FaDatabase,\n  FaDownload,\n  FaUpload,\n  FaTrash,\n  FaSpinner,\n  FaShieldAlt,\n} from \"../utils/iconImport\";\nimport { ToggleSwitch } from \"../components/settings/ToggleSwitch\";\nimport { ResetModal } from \"../components/settings/ResetModal\";\nimport { SecuritySettings } from \"../components/settings/SecuritySettings\";\nimport { DataControls } from \"../components/settings/DataControls\";\n\ntype SettingsTab =\n  | \"account\"\n  | \"display\"\n  | \"profile\"\n  | \"privacy\"\n  | \"goals\"\n  | \"sessions\"\n  | \"data\";\n\n// Account Settings Section\nconst AccountSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaUser className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Account Information\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Display Name\n          </label>\n          <input\n            type=\"text\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter display name\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Email\n          </label>\n          <input\n            type=\"email\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter email address\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Two-Factor Authentication\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Add extra security to your account\n            </div>\n          </div>\n          <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded transition-colors\">\n            Setup 2FA\n          </button>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Save Changes\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Display Settings Section\nconst DisplaySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaPalette className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Display Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Theme\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"dark\">Dark</option>\n            <option value=\"light\">Light</option>\n            <option value=\"auto\">Auto</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Language\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"en\">English</option>\n            <option value=\"es\">Spanish</option>\n            <option value=\"fr\">French</option>\n            <option value=\"de\">German</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Timezone\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"America/New_York\">Eastern Time</option>\n            <option value=\"America/Chicago\">Central Time</option>\n            <option value=\"America/Denver\">Mountain Time</option>\n            <option value=\"America/Los_Angeles\">Pacific Time</option>\n          </select>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Notifications\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Receive app notifications\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Public Profile Section\nconst ProfileSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaGlobe className=\"text-nightly-spring-green\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Public Profile\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Public Profile\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Make your profile visible to others\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Share Statistics\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Allow others to see your progress stats\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Bio\n          </label>\n          <textarea\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={3}\n            placeholder=\"Tell others about yourself...\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Profile URL\n          </label>\n          <div className=\"flex\">\n            <span className=\"bg-white/5 border border-white/10 border-r-0 rounded-l px-3 py-3 text-nightly-celadon text-sm\">\n              chastityos.com/profile/\n            </span>\n            <input\n              type=\"text\"\n              className=\"flex-1 bg-white/5 border border-white/10 rounded-r p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n              placeholder=\"your-username\"\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Privacy Settings Section\nconst PrivacySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaShieldAlt className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Privacy & Security\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <ToggleSwitch\n          label=\"Data Collection\"\n          description=\"Allow collection of usage analytics\"\n          checked={true}\n        />\n        <ToggleSwitch\n          label=\"Data Sharing\"\n          description=\"Share anonymous usage data to improve the app\"\n        />\n        <ToggleSwitch\n          label=\"Account Discoverable\"\n          description=\"Allow others to find your account by username\"\n          checked={true}\n        />\n        <ToggleSwitch\n          label=\"Show Activity Status\"\n          description=\"Let others see when you're active\"\n        />\n      </div>\n    </div>\n\n    <SecuritySettings />\n    <DataControls />\n  </div>\n);\n\n// Goals Section\nconst GoalsSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaBullseye className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Personal Goals\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Default Session Goal (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Goal Reminders\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Get notified about goal progress\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Create New Goal\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Session Settings Section\nconst SessionSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaCog className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Session Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Allow Emergency Unlock\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Enable emergency unlock feature\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Emergency Unlock Cooldown (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Require Keyholder Approval\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Sessions need keyholder approval to end\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Hardcore Mode\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Disable pause and emergency unlock\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-red-500\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Data Management Section\nconst DataSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => {\n  const [showResetModal, setShowResetModal] = useState(false);\n  const [resetStatus, setResetStatus] = useState<\n    \"idle\" | \"pending\" | \"success\" | \"error\"\n  >(\"idle\");\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <div className=\"flex items-center gap-3 mb-4\">\n          <FaDatabase className=\"text-nightly-spring-green\" />\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n            Data Management\n          </h3>\n        </div>\n\n        <div className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaDownload />\n              Export Data\n            </button>\n\n            <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaUpload />\n              Import Data\n            </button>\n          </div>\n\n          <div className=\"border-t border-white/10 pt-4\">\n            <div className=\"bg-red-500/10 border border-red-500/20 rounded-lg p-4\">\n              <h4 className=\"text-red-400 font-medium mb-2\">Danger Zone</h4>\n              <p className=\"text-nightly-celadon text-sm mb-4\">\n                Reset all data will permanently delete all your sessions, tasks,\n                goals, and settings. This action cannot be undone.\n              </p>\n              <button\n                onClick={() => setShowResetModal(true)}\n                className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n              >\n                <FaTrash />\n                Reset All Data\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Reset Modal */}\n      <ResetModal\n        show={showResetModal}\n        status={resetStatus}\n        onConfirm={() => {\n          setResetStatus(\"pending\");\n          setTimeout(() => {\n            setResetStatus(\"success\");\n            setTimeout(() => {\n              window.location.reload();\n            }, 2000);\n          }, 2000);\n        }}\n        onCancel={() => {\n          setShowResetModal(false);\n          setResetStatus(\"idle\");\n        }}\n      />\n    </div>\n  );\n};\n\nconst SettingsPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [settings, setSettings] = useState<DBSettings | null>(null);\n  const [activeTab, setActiveTab] = useState<SettingsTab>(\"account\");\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchSettings = async () => {\n      if (!user) return;\n\n      try {\n        setLoading(true);\n        // Try to get user settings\n        const userSettings = await settingsDBService.findByUserId(user.uid);\n        setSettings(userSettings[0] || null);\n      } catch (error) {\n        logger.error(\"Error fetching settings:\", error, \"SettingsPage\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchSettings();\n  }, [user]);\n\n  const tabs = [\n    { id: \"account\" as SettingsTab, label: \"Account\", icon: FaUser },\n    { id: \"display\" as SettingsTab, label: \"Display\", icon: FaPalette },\n    { id: \"profile\" as SettingsTab, label: \"Profile\", icon: FaGlobe },\n    { id: \"privacy\" as SettingsTab, label: \"Privacy\", icon: FaShieldAlt },\n    { id: \"goals\" as SettingsTab, label: \"Goals\", icon: FaBullseye },\n    { id: \"sessions\" as SettingsTab, label: \"Sessions\", icon: FaCog },\n    { id: \"data\" as SettingsTab, label: \"Data\", icon: FaDatabase },\n  ];\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"account\":\n        return <AccountSection settings={settings} />;\n      case \"display\":\n        return <DisplaySection settings={settings} />;\n      case \"profile\":\n        return <ProfileSection settings={settings} />;\n      case \"privacy\":\n        return <PrivacySection settings={settings} />;\n      case \"goals\":\n        return <GoalsSection settings={settings} />;\n      case \"sessions\":\n        return <SessionSection settings={settings} />;\n      case \"data\":\n        return <DataSection settings={settings} />;\n      default:\n        return <AccountSection settings={settings} />;\n    }\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      <div className=\"flex flex-col lg:flex-row\">\n        {/* Tab Navigation */}\n        <nav className=\"lg:w-64 p-4 border-b lg:border-b-0 lg:border-r border-white/10\">\n          <div className=\"space-y-2\">\n            {tabs.map((tab) => {\n              const Icon = tab.icon;\n              return (\n                <button\n                  key={tab.id}\n                  onClick={() => setActiveTab(tab.id)}\n                  className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg font-medium transition-colors ${\n                    activeTab === tab.id\n                      ? \"bg-nightly-aquamarine text-black\"\n                      : \"text-nightly-celadon hover:bg-white/10 hover:text-nightly-honeydew\"\n                  }`}\n                >\n                  <Icon />\n                  {tab.label}\n                </button>\n              );\n            })}\n          </div>\n        </nav>\n\n        {/* Content */}\n        <main className=\"flex-1 p-4 lg:p-6\">\n          {loading ? (\n            <div className=\"text-center py-8\">\n              <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n              <div className=\"text-nightly-celadon\">Loading settings...</div>\n            </div>\n          ) : (\n            <div className=\"max-w-4xl\">{renderTabContent()}</div>\n          )}\n        </main>\n      </div>\n    </div>\n  );\n};\n\nexport default SettingsPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/TasksPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/ButtonVariantsDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/HapticFeedbackDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/InputExamplesDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/PullToRefreshDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/ShowcaseHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/SwipeableCardDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/ToastDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/showcase/TouchTargetsDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/AchievementEngine.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Async method 'checkSpecialStartConditions' has a complexity of 16. Maximum allowed is 15.","line":319,"column":44,"nodeType":"FunctionExpression","messageId":"complex","endLine":382,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Engine\n * Handles achievement detection, progress tracking, and awarding\n */\n\nimport {\n  achievementDBService,\n  sessionDBService,\n  taskDBService,\n  goalDBService,\n} from \"./database\";\nimport { DBSession, DBGoal, DBTask, AchievementCategory } from \"../types\";\nimport { ACHIEVEMENTS_WITH_IDS } from \"../constants/achievements/index\";\nimport { logger } from \"../utils/logging\";\n\nexport class AchievementEngine {\n  private initialized = false;\n\n  /**\n   * Initialize the achievement engine with predefined achievements\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      logger.info(\"Initializing Achievement Engine\", \"AchievementEngine\");\n\n      // Check if achievements are already initialized\n      const existingAchievements =\n        await achievementDBService.getAllAchievements();\n\n      if (existingAchievements.length === 0) {\n        // Add all predefined achievements\n        for (const achievement of ACHIEVEMENTS_WITH_IDS) {\n          await achievementDBService.createAchievement(achievement);\n        }\n        logger.info(\n          `Initialized ${ACHIEVEMENTS_WITH_IDS.length} achievements`,\n          \"AchievementEngine\",\n        );\n      } else {\n        logger.info(\n          `Found ${existingAchievements.length} existing achievements`,\n          \"AchievementEngine\",\n        );\n      }\n\n      this.initialized = true;\n    } catch (error) {\n      logger.error(\n        \"Failed to initialize Achievement Engine\",\n        error,\n        \"AchievementEngine\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Process session events to check for achievement eligibility\n   */\n  async processSessionEvent(\n    userId: string,\n    eventType: \"session_start\" | \"session_end\",\n    sessionData?: DBSession,\n  ): Promise<void> {\n    try {\n      if (!this.initialized) await this.initialize();\n\n      switch (eventType) {\n        case \"session_start\":\n          await this.checkSpecialStartConditions(userId, sessionData);\n          break;\n        case \"session_end\":\n          await this.checkSessionMilestones(userId);\n          await this.checkConsistencyBadges(userId);\n          await this.checkStreakAchievements(userId);\n          break;\n      }\n    } catch (error) {\n      logger.error(\n        \"Failed to process session event\",\n        error,\n        \"AchievementEngine\",\n      );\n    }\n  }\n\n  /**\n   * Process task events to check for achievement eligibility\n   */\n  async processTaskEvent(\n    userId: string,\n    eventType: \"task_completed\" | \"task_approved\" | \"task_rejected\",\n  ): Promise<void> {\n    try {\n      if (!this.initialized) await this.initialize();\n\n      if (eventType === \"task_completed\" || eventType === \"task_approved\") {\n        await this.checkTaskAchievements(userId);\n      }\n    } catch (error) {\n      logger.error(\"Failed to process task event\", error, \"AchievementEngine\");\n    }\n  }\n\n  /**\n   * Process goal events to check for achievement eligibility\n   */\n  async processGoalEvent(\n    userId: string,\n    eventType: \"goal_completed\",\n    goalData?: DBGoal,\n  ): Promise<void> {\n    try {\n      if (!this.initialized) await this.initialize();\n\n      if (eventType === \"goal_completed\") {\n        await this.checkGoalAchievements(userId, goalData);\n      }\n    } catch (error) {\n      logger.error(\"Failed to process goal event\", error, \"AchievementEngine\");\n    }\n  }\n\n  /**\n   * Check session milestone achievements\n   */\n  private async checkSessionMilestones(userId: string): Promise<void> {\n    const sessions = await sessionDBService.getUserSessions(userId);\n    const completedSessions = sessions.filter((s: DBSession) => s.endTime);\n\n    if (completedSessions.length === 0) return;\n\n    // Get session milestone achievements\n    const milestoneAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.SESSION_MILESTONES,\n      );\n\n    for (const achievement of milestoneAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (requirement.type === \"session_count\") {\n        if (completedSessions.length >= requirement.value) {\n          await this.awardAchievementIfNotOwned(userId, achievement.id);\n        }\n      } else if (requirement.type === \"session_duration\") {\n        // Check if any session meets the duration requirement\n        const hasLongSession = completedSessions.some((session: DBSession) => {\n          if (!session.startTime || !session.endTime) return false;\n          const duration =\n            (session.endTime.getTime() - session.startTime.getTime()) / 1000;\n          return duration >= requirement.value;\n        });\n\n        if (hasLongSession) {\n          await this.awardAchievementIfNotOwned(userId, achievement.id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check consistency badge achievements\n   */\n  private async checkConsistencyBadges(userId: string): Promise<void> {\n    const sessions = await sessionDBService.getUserSessions(userId);\n    const completedSessions = sessions.filter((s: DBSession) => s.endTime);\n\n    const consistencyAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.CONSISTENCY_BADGES,\n      );\n\n    for (const achievement of consistencyAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (\n        requirement.type === \"session_count\" &&\n        completedSessions.length >= requirement.value\n      ) {\n        await this.awardAchievementIfNotOwned(userId, achievement.id);\n      }\n    }\n  }\n\n  /**\n   * Check streak achievements\n   */\n  private async checkStreakAchievements(userId: string): Promise<void> {\n    const sessions = await sessionDBService.getUserSessions(userId);\n    const completedSessions = sessions\n      .filter((s: DBSession) => s.endTime)\n      .sort(\n        (a: DBSession, b: DBSession) =>\n          a.startTime.getTime() - b.startTime.getTime(),\n      );\n\n    if (completedSessions.length === 0) return;\n\n    // Calculate current streak\n    const currentStreak = this.calculateCurrentStreak(completedSessions);\n\n    const streakAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.STREAK_ACHIEVEMENTS,\n      );\n\n    for (const achievement of streakAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (\n        requirement.type === \"streak_days\" &&\n        currentStreak >= requirement.value\n      ) {\n        await this.awardAchievementIfNotOwned(userId, achievement.id);\n      }\n    }\n  }\n\n  /**\n   * Check goal-based achievements\n   */\n  private async checkGoalAchievements(\n    userId: string,\n    goalData?: DBGoal,\n  ): Promise<void> {\n    const goals = await goalDBService.getGoals(userId);\n    const completedGoals = goals.filter((g: DBGoal) => g.isCompleted);\n\n    const goalAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.GOAL_BASED,\n      );\n\n    for (const achievement of goalAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (requirement.type === \"goal_completion\") {\n        if (completedGoals.length >= requirement.value) {\n          await this.awardAchievementIfNotOwned(userId, achievement.id);\n        }\n      } else if (requirement.type === \"special_condition\" && goalData) {\n        // Check special goal conditions\n        if (requirement.condition === \"exceed_goal_by_50_percent\") {\n          const exceeded = goalData.currentValue >= goalData.targetValue * 1.5;\n          if (exceeded) {\n            await this.awardAchievementIfNotOwned(userId, achievement.id);\n          }\n        } else if (requirement.condition === \"exact_goal_achievement\") {\n          const difference = Math.abs(\n            goalData.currentValue - goalData.targetValue,\n          );\n          const tolerance = 3600; // 1 hour in seconds\n          if (difference <= tolerance) {\n            await this.awardAchievementIfNotOwned(userId, achievement.id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check task-based achievements\n   */\n  private async checkTaskAchievements(userId: string): Promise<void> {\n    const tasks = await taskDBService.getTasks(userId);\n    const completedTasks = tasks.filter(\n      (t: DBTask) => t.status === \"completed\" || t.status === \"approved\",\n    );\n    const approvedTasks = tasks.filter((t: DBTask) => t.status === \"approved\");\n\n    const taskAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.TASK_COMPLETION,\n      );\n\n    for (const achievement of taskAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (requirement.type === \"task_completion\") {\n        if (completedTasks.length >= requirement.value) {\n          await this.awardAchievementIfNotOwned(userId, achievement.id);\n        }\n      } else if (requirement.type === \"special_condition\") {\n        if (requirement.condition === \"task_approval_rate\") {\n          const submittedTasks = tasks.filter(\n            (t: DBTask) => t.status !== \"pending\",\n          );\n          if (submittedTasks.length > 0) {\n            const approvalRate =\n              (approvedTasks.length / submittedTasks.length) * 100;\n            if (approvalRate >= requirement.value) {\n              await this.awardAchievementIfNotOwned(userId, achievement.id);\n            }\n          }\n        } else if (requirement.condition === \"tasks_completed_early\") {\n          const earlyTasks = tasks.filter(\n            (t: DBTask) =>\n              t.completedAt && t.dueDate && t.completedAt < t.dueDate,\n          );\n          if (earlyTasks.length >= requirement.value) {\n            await this.awardAchievementIfNotOwned(userId, achievement.id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check special start time conditions\n   */\n  private async checkSpecialStartConditions(\n    userId: string,\n    sessionData?: DBSession,\n  ): Promise<void> {\n    if (!sessionData) return;\n\n    const startTime = sessionData.startTime;\n    const hour = startTime.getHours();\n    const day = startTime.getDay(); // 0 = Sunday, 6 = Saturday\n    const isWeekend = day === 0 || day === 6;\n\n    const specialAchievements =\n      await achievementDBService.getAchievementsByCategory(\n        AchievementCategory.SPECIAL_ACHIEVEMENTS,\n      );\n\n    // Track special conditions\n    for (const achievement of specialAchievements) {\n      const requirement = achievement.requirements[0];\n      if (!requirement) continue; // Skip if no requirements\n\n      if (requirement.type === \"special_condition\") {\n        let shouldIncrement = false;\n\n        switch (requirement.condition) {\n          case \"sessions_before_8am\":\n            shouldIncrement = hour < 8;\n            break;\n          case \"sessions_after_10pm\":\n            shouldIncrement = hour >= 22;\n            break;\n          case \"weekend_sessions\":\n            shouldIncrement = isWeekend;\n            break;\n          case \"new_year_session\":\n            shouldIncrement =\n              startTime.getMonth() === 0 && startTime.getDate() === 1;\n            break;\n          case \"holiday_session\":\n            shouldIncrement = this.isHoliday(startTime);\n            break;\n        }\n\n        if (shouldIncrement) {\n          const progress = await achievementDBService.getAchievementProgress(\n            userId,\n            achievement.id,\n          );\n          const currentValue = (progress?.currentValue || 0) + 1;\n\n          await achievementDBService.updateAchievementProgress(\n            userId,\n            achievement.id,\n            currentValue,\n            requirement.value,\n          );\n\n          if (currentValue >= requirement.value) {\n            await this.awardAchievementIfNotOwned(userId, achievement.id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Award achievement if user doesn't already have it\n   */\n  private async awardAchievementIfNotOwned(\n    userId: string,\n    achievementId: string,\n  ): Promise<void> {\n    const userAchievements =\n      await achievementDBService.getUserAchievements(userId);\n    const alreadyHas = userAchievements.some(\n      (ua) => ua.achievementId === achievementId,\n    );\n\n    if (!alreadyHas) {\n      await achievementDBService.awardAchievement(userId, achievementId, 100);\n\n      // Create notification\n      const achievement =\n        await achievementDBService.getAchievementById(achievementId);\n      if (achievement) {\n        await achievementDBService.createNotification(\n          userId,\n          achievementId,\n          \"earned\",\n          \"Achievement Unlocked!\",\n          `You've earned the \"${achievement.name}\" achievement!`,\n        );\n\n        logger.info(\n          `Achievement awarded: ${achievement.name} to user ${userId}`,\n          \"AchievementEngine\",\n        );\n      }\n    }\n  }\n\n  /**\n   * Calculate current streak from sessions\n   */\n  private calculateCurrentStreak(sessions: DBSession[]): number {\n    if (sessions.length === 0) return 0;\n\n    let streak = 0;\n    const now = new Date();\n    const oneDayMs = 24 * 60 * 60 * 1000;\n\n    // Start from most recent session and work backwards\n    const sortedSessions = [...sessions].sort(\n      (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n    );\n\n    let expectedDate = new Date(now);\n    expectedDate.setHours(0, 0, 0, 0);\n\n    for (const session of sortedSessions) {\n      const sessionDate = new Date(session.startTime);\n      sessionDate.setHours(0, 0, 0, 0);\n\n      const timeDiff = expectedDate.getTime() - sessionDate.getTime();\n      const daysDiff = Math.round(timeDiff / oneDayMs);\n\n      if (daysDiff === 0 || daysDiff === 1) {\n        streak++;\n        expectedDate = new Date(sessionDate.getTime() - oneDayMs);\n      } else {\n        break;\n      }\n    }\n\n    return streak;\n  }\n\n  /**\n   * Check if a date is a major holiday\n   */\n  private isHoliday(date: Date): boolean {\n    const month = date.getMonth();\n    const day = date.getDate();\n\n    // Major holidays (simplified)\n    const holidays = [\n      { month: 0, day: 1 }, // New Year's Day\n      { month: 1, day: 14 }, // Valentine's Day\n      { month: 6, day: 4 }, // Independence Day (US)\n      { month: 9, day: 31 }, // Halloween\n      { month: 10, day: 25 }, // Thanksgiving (approximation)\n      { month: 11, day: 25 }, // Christmas\n      { month: 11, day: 31 }, // New Year's Eve\n    ];\n\n    return holidays.some((h) => h.month === month && h.day === day);\n  }\n\n  /**\n   * Perform a full achievement check for a user (useful for backfill)\n   */\n  async performFullCheck(userId: string): Promise<void> {\n    try {\n      logger.info(\n        `Performing full achievement check for user ${userId}`,\n        \"AchievementEngine\",\n      );\n\n      await this.checkSessionMilestones(userId);\n      await this.checkConsistencyBadges(userId);\n      await this.checkStreakAchievements(userId);\n      await this.checkTaskAchievements(userId);\n      await this.checkGoalAchievements(userId);\n\n      logger.info(\n        `Full achievement check completed for user ${userId}`,\n        \"AchievementEngine\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"AchievementEngine\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementEngine = new AchievementEngine();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/AchievementIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/EffectiveTimeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/KeyholderRelationshipService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/PauseCooldownService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/PauseService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/SessionPersistenceService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/TimerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/api/session-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/auth/account-linking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/auth/auth-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/cache-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/AchievementDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/BaseDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/EmergencyService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/EventDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/GoalDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/KeyholderRelationshipDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/MigrationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/PerformanceService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/RelationshipChastityService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/SessionDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/SettingsDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/TaskDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementBadgeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementCRUDService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementLeaderboardService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementNotificationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementProgressService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementStatsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastityEventService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastitySessionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastityTaskService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/RelationshipCoreService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/RelationshipPermissionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipCRUDService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipInviteService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipRoleService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipSearchService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipStatsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipStatusService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipValidationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/feedbackService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/migration/DataMigrationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/storage/ChastityDB.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/storage/dexie.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/AchievementDataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/ConflictResolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/EventDataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseListeners.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseSyncCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/OfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/RelationshipDataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/SessionDataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/SyncConflictResolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/TaskDataSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/UserSettingsSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/connectionStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/formStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/keyholderStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (105). Maximum allowed is 75.","line":186,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":313,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Keyholder Store\n * UI state management for keyholder mode functionality\n * Zustand store - handles keyholder UI state only\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport { sha256 } from \"@/utils/helpers/hash\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"KeyholderStore\");\n\n// Helper functions for password operations\nconst handlePasswordCheck = async (\n  passwordAttempt: string,\n  storedHash: string,\n  set: (state: Partial<KeyholderState>) => void,\n  get: () => KeyholderState,\n) => {\n  const state = get();\n\n  if (state.isCheckingPassword) {\n    logger.debug(\"Password check already in progress\");\n    return;\n  }\n\n  set({ isCheckingPassword: true, keyholderMessage: \"\" });\n\n  try {\n    logger.debug(\"Checking keyholder password\");\n\n    if (!storedHash) {\n      const message = \"Error: No keyholder password is set in the database.\";\n      set({\n        keyholderMessage: message,\n        isCheckingPassword: false,\n      });\n      logger.warn(\"No keyholder password hash found\");\n      return;\n    }\n\n    const attemptHash = await sha256(passwordAttempt);\n\n    if (attemptHash === storedHash) {\n      set({\n        isKeyholderModeUnlocked: true,\n        keyholderMessage: \"Controls are now unlocked.\",\n        isPasswordDialogOpen: false,\n        passwordAttempt: \"\",\n        isCheckingPassword: false,\n      });\n      logger.info(\"Keyholder password correct, mode unlocked\");\n    } else {\n      set({\n        keyholderMessage: \"Incorrect password. Please try again.\",\n        passwordAttempt: \"\",\n        isCheckingPassword: false,\n      });\n      logger.warn(\"Incorrect keyholder password attempt\");\n    }\n  } catch (error) {\n    const message = \"Failed to check password. Please try again.\";\n    set({\n      keyholderMessage: message,\n      isCheckingPassword: false,\n    });\n    logger.error(\"Error checking keyholder password\", {\n      error: error as Error,\n    });\n  }\n};\n\nconst handlePasswordSet = async (\n  newPassword: string,\n  onSave: (hash: string) => Promise<void>,\n  set: (state: Partial<KeyholderState>) => void,\n  get: () => KeyholderState,\n) => {\n  const state = get();\n\n  if (state.isSavingPassword) {\n    logger.debug(\"Password save already in progress\");\n    return;\n  }\n\n  if (!newPassword || newPassword.length < 6) {\n    set({\n      keyholderMessage: \"Password must be at least 6 characters long.\",\n    });\n    return;\n  }\n\n  set({ isSavingPassword: true, keyholderMessage: \"\" });\n\n  try {\n    logger.debug(\"Setting permanent keyholder password\");\n\n    const newHash = await sha256(newPassword);\n    await onSave(newHash);\n\n    set({\n      keyholderMessage: \"Permanent password has been updated successfully!\",\n      newPassword: \"\",\n      confirmPassword: \"\",\n      isPasswordSettingMode: false,\n      isPasswordDialogOpen: false,\n      isSavingPassword: false,\n    });\n\n    logger.info(\"Permanent keyholder password updated successfully\");\n  } catch (error) {\n    const message = \"Failed to update password. Please try again.\";\n    set({\n      keyholderMessage: message,\n      isSavingPassword: false,\n    });\n    logger.error(\"Error setting permanent password\", {\n      error: error as Error,\n    });\n  }\n};\n\nexport interface KeyholderState {\n  // UI State\n  isKeyholderModeUnlocked: boolean;\n  keyholderMessage: string;\n  isPasswordDialogOpen: boolean;\n  isPasswordSettingMode: boolean;\n\n  // Form State\n  passwordAttempt: string;\n  newPassword: string;\n  confirmPassword: string;\n\n  // Loading States\n  isCheckingPassword: boolean;\n  isSavingPassword: boolean;\n}\n\nexport interface KeyholderActions {\n  // Password Management\n  checkPassword: (passwordAttempt: string, storedHash: string) => Promise<void>;\n  setTempPassword: (keyholderName: string) => Promise<string>;\n  setPermanentPassword: (\n    newPassword: string,\n    onSave: (hash: string) => Promise<void>,\n  ) => Promise<void>;\n\n  // UI Actions\n  unlockKeyholderMode: () => void;\n  lockKeyholderControls: () => void;\n  setMessage: (message: string) => void;\n  clearMessage: () => void;\n\n  // Dialog Management\n  openPasswordDialog: () => void;\n  closePasswordDialog: () => void;\n  setPasswordSettingMode: (isSettingMode: boolean) => void;\n\n  // Form Actions\n  setPasswordAttempt: (password: string) => void;\n  setNewPassword: (password: string) => void;\n  setConfirmPassword: (password: string) => void;\n  clearForm: () => void;\n\n  // Reset\n  resetStore: () => void;\n}\n\nexport interface KeyholderStore extends KeyholderState, KeyholderActions {}\n\nconst initialState: KeyholderState = {\n  isKeyholderModeUnlocked: false,\n  keyholderMessage: \"\",\n  isPasswordDialogOpen: false,\n  isPasswordSettingMode: false,\n  passwordAttempt: \"\",\n  newPassword: \"\",\n  confirmPassword: \"\",\n  isCheckingPassword: false,\n  isSavingPassword: false,\n};\n\nexport const useKeyholderStore = create<KeyholderStore>()(\n  devtools(\n    (set, get) => ({\n      ...initialState,\n\n      // Password Management\n      checkPassword: async (passwordAttempt: string, storedHash: string) => {\n        await handlePasswordCheck(passwordAttempt, storedHash, set, get);\n      },\n\n      setTempPassword: async (keyholderName: string): Promise<string> => {\n        try {\n          logger.debug(\"Generating temporary keyholder password\", {\n            keyholderName,\n          });\n\n          const tempPassword = Math.random()\n            .toString(36)\n            .substring(2, 8)\n            .toUpperCase();\n          const message = `Your keyholder password is: ${tempPassword}. This is now the permanent password unless you set a custom one.`;\n\n          set({ keyholderMessage: message });\n\n          logger.info(\"Temporary keyholder password generated\");\n          return tempPassword;\n        } catch (error) {\n          const message = \"Failed to generate temporary password.\";\n          set({ keyholderMessage: message });\n          logger.error(\"Error generating temporary password\", {\n            error: error as Error,\n          });\n          throw error;\n        }\n      },\n\n      setPermanentPassword: async (\n        newPassword: string,\n        onSave: (hash: string) => Promise<void>,\n      ) => {\n        await handlePasswordSet(newPassword, onSave, set, get);\n      },\n\n      // UI Actions\n      unlockKeyholderMode: () => {\n        set({\n          isKeyholderModeUnlocked: true,\n          keyholderMessage: \"Controls are now unlocked.\",\n          isPasswordDialogOpen: false,\n        });\n        logger.info(\"Keyholder mode unlocked manually\");\n      },\n\n      lockKeyholderControls: () => {\n        set({\n          isKeyholderModeUnlocked: false,\n          keyholderMessage: \"\",\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n        logger.info(\"Keyholder controls locked\");\n      },\n\n      setMessage: (message: string) => {\n        set({ keyholderMessage: message });\n      },\n\n      clearMessage: () => {\n        set({ keyholderMessage: \"\" });\n      },\n\n      // Dialog Management\n      openPasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: true,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n        });\n      },\n\n      closePasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          isPasswordSettingMode: false,\n        });\n      },\n\n      setPasswordSettingMode: (isSettingMode: boolean) => {\n        set({\n          isPasswordSettingMode: isSettingMode,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n      },\n\n      // Form Actions\n      setPasswordAttempt: (password: string) => {\n        set({ passwordAttempt: password });\n      },\n\n      setNewPassword: (password: string) => {\n        set({ newPassword: password });\n      },\n\n      setConfirmPassword: (password: string) => {\n        set({ confirmPassword: password });\n      },\n\n      clearForm: () => {\n        set({\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          keyholderMessage: \"\",\n        });\n      },\n\n      // Reset\n      resetStore: () => {\n        set(initialState);\n        logger.debug(\"Keyholder store reset to initial state\");\n      },\n    }),\n    {\n      name: \"keyholder-store\",\n      // Only enable devtools in development\n      enabled:\n        import.meta.env.MODE === \"development\" ||\n        import.meta.env.MODE === \"nightly\",\n    },\n  ),\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/modalStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/navigationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/notificationStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (102). Maximum allowed is 75.","line":101,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":226,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Store - Temporary UI Feedback\n * Manages toast messages, alerts, and temporary UI feedback\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\nexport interface Notification {\n  id: string;\n  type: \"success\" | \"error\" | \"warning\" | \"info\";\n  priority: \"low\" | \"medium\" | \"high\" | \"urgent\";\n  title?: string;\n  message: string;\n  duration?: number; // in milliseconds, 0 means persistent\n  dismissible?: boolean;\n  requireInteraction?: boolean; // for urgent priority\n  position?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"top-center\"\n    | \"bottom-center\";\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  icon?: string; // optional custom icon\n  metadata?: Record<string, unknown>; // extensible metadata\n  timestamp: Date;\n}\n\nexport interface NotificationState {\n  // Notifications list\n  notifications: Notification[];\n\n  // Configuration\n  pauseOnHover?: boolean;\n\n  // Actions\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\">,\n  ) => string;\n  removeNotification: (id: string) => void;\n  clearAllNotifications: () => void;\n  updateNotification: (id: string, updates: Partial<Notification>) => void;\n\n  // Convenience methods\n  showSuccess: (message: string, title?: string, duration?: number) => string;\n  showError: (message: string, title?: string, duration?: number) => string;\n  showWarning: (message: string, title?: string, duration?: number) => string;\n  showInfo: (message: string, title?: string, duration?: number) => string;\n\n  // Reset function for testing\n  resetStore: () => void;\n}\n\n// Additional type exports for compatibility with index.ts\nexport interface NotificationActions {\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\">,\n  ) => string;\n  removeNotification: (id: string) => void;\n  clearAllNotifications: () => void;\n  showSuccess: (message: string, title?: string, duration?: number) => string;\n  showError: (message: string, title?: string, duration?: number) => string;\n  showWarning: (message: string, title?: string, duration?: number) => string;\n  showInfo: (message: string, title?: string, duration?: number) => string;\n}\n\nexport type NotificationStore = NotificationState;\nexport type NotificationType = \"success\" | \"error\" | \"warning\" | \"info\";\nexport type NotificationPriority = \"low\" | \"medium\" | \"high\" | \"urgent\";\nexport type NotificationAction = {\n  label: string;\n  onClick: () => void;\n};\n\n// Default durations for different notification priorities\nconst DEFAULT_DURATIONS = {\n  low: 3000,\n  medium: 5000,\n  high: 7000,\n  urgent: 0, // Persistent - requires interaction\n};\n\n// Fallback durations by type (legacy support)\nconst TYPE_DURATIONS = {\n  success: 4000,\n  error: 0, // Persistent for errors\n  warning: 6000,\n  info: 4000,\n};\n\nconst initialState = {\n  notifications: [],\n};\n\nexport const useNotificationStore = create<NotificationState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      ...initialState,\n      pauseOnHover: true,\n\n      // Actions\n      addNotification: (notification) => {\n        const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        \n        // Determine priority from type if not specified\n        const priority = notification.priority || (\n          notification.type === 'error' ? 'high' : \n          notification.type === 'warning' ? 'medium' : 'low'\n        );\n        \n        // Set duration based on priority, with fallback to type\n        const duration = notification.duration !== undefined \n          ? notification.duration \n          : DEFAULT_DURATIONS[priority] || TYPE_DURATIONS[notification.type];\n        \n        // Urgent priority requires interaction\n        const requireInteraction = priority === 'urgent' || notification.requireInteraction;\n        \n        const newNotification: Notification = {\n          id,\n          timestamp: new Date(),\n          priority,\n          duration,\n          dismissible: true,\n          requireInteraction,\n          ...notification,\n        };\n\n        set(\n          (state) => ({\n            notifications: [...state.notifications, newNotification],\n          }),\n          false,\n          `addNotification:${notification.type}:${priority}`,\n        );\n\n        // Auto-remove notification after duration if specified and not requiring interaction\n        if (newNotification.duration && newNotification.duration > 0 && !newNotification.requireInteraction) {\n          setTimeout(() => {\n            useNotificationStore.getState().removeNotification(id);\n          }, newNotification.duration);\n        }\n\n        return id;\n      },\n\n      removeNotification: (id: string) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.filter((n) => n.id !== id),\n          }),\n          false,\n          `removeNotification:${id}`,\n        ),\n\n      clearAllNotifications: () =>\n        set({ notifications: [] }, false, \"clearAllNotifications\"),\n\n      updateNotification: (id: string, updates: Partial<Notification>) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.map((n) =>\n              n.id === id ? { ...n, ...updates } : n,\n            ),\n          }),\n          false,\n          `updateNotification:${id}`,\n        ),\n\n      // Convenience methods\n      showSuccess: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"success\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showError: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"error\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showWarning: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"warning\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showInfo: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"info\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      // Reset function for testing\n      resetStore: () => set(initialState, false, \"resetStore\"),\n    }),\n    {\n      name: \"notification-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useNotifications = () =>\n  useNotificationStore((state) => state.notifications);\n\nexport const useNotificationActions = () =>\n  useNotificationStore((state) => ({\n    addNotification: state.addNotification,\n    removeNotification: state.removeNotification,\n    clearAllNotifications: state.clearAllNotifications,\n    showSuccess: state.showSuccess,\n    showError: state.showError,\n    showWarning: state.showWarning,\n    showInfo: state.showInfo,\n  }));\n\n// Utility hooks for common notification patterns\nexport const useErrorHandler = () => {\n  const { showError } = useNotificationActions();\n\n  const handleError = (error: Error | string, title = \"Error\") => {\n    const message = typeof error === \"string\" ? error : error.message;\n    return showError(message, title);\n  };\n\n  return { handleError };\n};\n\nexport const useSuccessHandler = () => {\n  const { showSuccess } = useNotificationActions();\n\n  const handleSuccess = (message: string, title = \"Success\") => {\n    return showSuccess(message, title);\n  };\n\n  return { handleSuccess };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/themeStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/uiPreferencesStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/test/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/test/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/account-linking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/feedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/gamification.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/goals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/pauseResume.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/realtime.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'key' is not defined.","line":180,"column":4,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Real-time communication and synchronization type definitions for ChastityOS\n */\n\n// ==================== REAL-TIME SYNC TYPES ====================\n\nexport enum ConnectionStatus {\n  DISCONNECTED = \"disconnected\",\n  CONNECTING = \"connecting\",\n  CONNECTED = \"connected\",\n  RECONNECTING = \"reconnecting\",\n  ERROR = \"error\",\n}\n\nexport enum ChannelType {\n  USER = \"user\",\n  RELATIONSHIP = \"relationship\",\n  SESSION = \"session\",\n  TASK = \"task\",\n  NOTIFICATION = \"notification\",\n  SYSTEM = \"system\",\n}\n\nexport interface SyncChannel {\n  id: string;\n  type: ChannelType;\n  participants: string[];\n  lastActivity: Date;\n  isActive: boolean;\n  encryptionEnabled: boolean;\n}\n\nexport interface RealtimeUpdate {\n  id: string;\n  type: string;\n  data: unknown;\n  timestamp: Date;\n  userId: string;\n  channelId: string;\n}\n\nexport interface RealtimeDataState {\n  [key: string]: unknown;\n}\n\nexport interface RealtimeSyncMetrics {\n  lastSuccessfulSync: Date;\n  syncErrors: number;\n  messagesReceived: number;\n  messagesSent: number;\n  averageLatency: number;\n  connectionUptime: number;\n}\n\nexport interface Subscription {\n  id: string;\n  dataType: string;\n  callback: UpdateCallback;\n  isActive: boolean;\n  created: Date;\n}\n\nexport type UpdateCallback = (update: RealtimeUpdate) => void;\n\nexport interface RealtimeSyncState {\n  connectionStatus: ConnectionStatus;\n  activeChannels: SyncChannel[];\n  realtimeData: RealtimeDataState;\n  syncMetrics: RealtimeSyncMetrics;\n}\n\n// ==================== NOTIFICATION TYPES ====================\n\nexport enum NotificationType {\n  INFO = \"info\",\n  SUCCESS = \"success\",\n  WARNING = \"warning\",\n  ERROR = \"error\",\n  TASK_ASSIGNED = \"task_assigned\",\n  TASK_APPROVED = \"task_approved\",\n  TASK_REJECTED = \"task_rejected\",\n  SESSION_STARTED = \"session_started\",\n  SESSION_ENDED = \"session_ended\",\n  RELATIONSHIP_REQUEST = \"relationship_request\",\n  RELATIONSHIP_ACCEPTED = \"relationship_accepted\",\n  KEYHOLDER_MESSAGE = \"keyholder_message\",\n  SYSTEM_ALERT = \"system_alert\",\n}\n\nexport enum NotificationPriority {\n  LOW = \"low\",\n  MEDIUM = \"medium\",\n  HIGH = \"high\",\n  URGENT = \"urgent\",\n}\n\nexport enum NotificationChannelType {\n  IN_APP = \"in_app\",\n  PUSH = \"push\",\n  EMAIL = \"email\",\n  SMS = \"sms\",\n  WEBHOOK = \"webhook\",\n}\n\nexport interface NotificationChannel {\n  type: NotificationChannelType;\n  enabled: boolean;\n  settings: NotificationChannelSettings;\n}\n\nexport interface NotificationChannelSettings {\n  [setting: string]: unknown;\n  // Email settings\n  emailAddress?: string;\n  // Push settings\n  endpoint?: string;\n  // SMS settings\n  phoneNumber?: string;\n  // Webhook settings\n  url?: string;\n  headers?: Record<string, string>;\n}\n\nexport interface Notification {\n  id: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  priority: NotificationPriority;\n  timestamp: Date;\n  isRead: boolean;\n  userId: string;\n\n  // Optional metadata\n  actionUrl?: string;\n  actionText?: string;\n  imageUrl?: string;\n  category?: string;\n  expiresAt?: Date;\n\n  // Relationship context\n  relationshipId?: string;\n  keyholderUserId?: string;\n\n  // Rich content\n  data?: Record<string, unknown>;\n}\n\nexport interface NotificationPreferences {\n  channels: NotificationChannel[];\n  quietHours: QuietHours;\n  categories: NotificationCategoryPreference[];\n  globalEnabled: boolean;\n}\n\nexport interface QuietHours {\n  enabled: boolean;\n  startTime: string; // HH:MM format\n  endTime: string; // HH:MM format\n  timezone: string;\n  days: number[]; // 0-6, Sunday is 0\n}\n\nexport interface NotificationCategoryPreference {\n  category: NotificationType;\n  enabled: boolean;\n  channels: NotificationChannelType[];\n  priority: NotificationPriority;\n}\n\nexport interface NotificationHistoryEntry {\n  notification: Notification;\n  deliveryStatus: NotificationDeliveryStatus;\n  deliveredAt?: Date;\n  readAt?: Date;\n  actionTakenAt?: Date;\n}\n\nexport interface NotificationDeliveryStatus {\n  [key in NotificationChannelType]?: {\n    status: \"pending\" | \"sent\" | \"delivered\" | \"failed\";\n    timestamp: Date;\n    error?: string;\n  };\n}\n\nexport interface NotificationState {\n  notifications: Notification[];\n  preferences: NotificationPreferences;\n  deliveryChannels: NotificationChannel[];\n  notificationHistory: NotificationHistoryEntry[];\n}\n\n// ==================== PRESENCE TYPES ====================\n\nexport enum PresenceStatus {\n  ONLINE = \"online\",\n  OFFLINE = \"offline\",\n  AWAY = \"away\",\n  BUSY = \"busy\",\n  IN_SESSION = \"in_session\",\n}\n\nexport interface UserPresence {\n  userId: string;\n  status: PresenceStatus;\n  lastSeen: Date;\n  customMessage?: string;\n\n  // Activity context\n  currentActivity?: ActivityContext;\n\n  // Session context\n  isInChastitySession?: boolean;\n  sessionStartTime?: Date;\n\n  // Device info\n  deviceType?: \"desktop\" | \"mobile\" | \"tablet\";\n  platform?: string;\n}\n\nexport interface ActivityContext {\n  type: \"viewing_page\" | \"editing\" | \"in_call\" | \"typing\";\n  details?: string;\n  timestamp: Date;\n}\n\nexport interface PresenceSubscription {\n  userIds: string[];\n  callback: (presences: UserPresence[]) => void;\n  isActive: boolean;\n}\n\nexport interface PresenceState {\n  userPresences: Record<string, UserPresence>;\n  subscriptions: PresenceSubscription[];\n  ownPresence: UserPresence;\n}\n\n// ==================== LIVE TIMER TYPES ====================\n\nexport enum TimerType {\n  CHASTITY_SESSION = \"chastity_session\",\n  TASK_DEADLINE = \"task_deadline\",\n  PUNISHMENT_DURATION = \"punishment_duration\",\n  KEYHOLDER_CONTROL = \"keyholder_control\",\n}\n\nexport enum TimerStatus {\n  RUNNING = \"running\",\n  PAUSED = \"paused\",\n  STOPPED = \"stopped\",\n  COMPLETED = \"completed\",\n}\n\nexport interface LiveTimer {\n  id: string;\n  type: TimerType;\n  status: TimerStatus;\n\n  // Time tracking\n  startTime: Date;\n  endTime?: Date;\n  currentTime: Date;\n  duration: number; // total duration in seconds\n  elapsed: number; // elapsed time in seconds\n  remaining: number; // remaining time in seconds\n\n  // Pause tracking\n  isPaused: boolean;\n  pausedAt?: Date;\n  totalPauseTime: number; // total pause time in seconds\n\n  // Context\n  userId: string;\n  relationshipId?: string;\n  sessionId?: string;\n  taskId?: string;\n\n  // Display\n  title: string;\n  description?: string;\n\n  // Permissions\n  canPause: boolean;\n  canStop: boolean;\n  canExtend: boolean;\n\n  // Keyholder control\n  isKeyholderControlled: boolean;\n  keyholderUserId?: string;\n}\n\nexport interface TimerSync {\n  timerId: string;\n  lastSync: Date;\n  serverTime: Date;\n  clientOffset: number; // ms difference between client and server\n  syncAccuracy: number; // confidence in sync accuracy (0-1)\n}\n\nexport interface TimerEvent {\n  id: string;\n  timerId: string;\n  type: \"start\" | \"pause\" | \"resume\" | \"stop\" | \"complete\" | \"extend\";\n  timestamp: Date;\n  userId: string;\n  data?: unknown;\n}\n\nexport interface TimerSubscription {\n  timerId: string;\n  callback: (timer: LiveTimer) => void;\n  events: string[]; // which events to listen for\n  isActive: boolean;\n}\n\nexport interface LiveTimerState {\n  activeTimers: LiveTimer[];\n  timerSyncs: TimerSync[];\n  subscriptions: TimerSubscription[];\n  events: TimerEvent[];\n}\n\n// ==================== COMBINED REAL-TIME STATE ====================\n\nexport interface RealtimeState {\n  sync: RealtimeSyncState;\n  notifications: NotificationState;\n  presence: PresenceState;\n  timers: LiveTimerState;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/relationships.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/dataSyncHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/formatting/date.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/formatting/time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/goalsHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/hash.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/sessionHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/statistics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/string.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/iconImport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/pauseAnalytics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/pauseResumeHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/sessionHistoryHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/statisticsHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/systemInfo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/toastBridge.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":18,"suggestions":[{"fix":{"range":[2679,2733],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":89,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":89,"endColumn":18,"suggestions":[{"fix":{"range":[3187,3230],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":117,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":117,"endColumn":17,"suggestions":[{"fix":{"range":[3880,3944],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":126,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":126,"endColumn":17,"suggestions":[{"fix":{"range":[4232,4298],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":135,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":135,"endColumn":18,"suggestions":[{"fix":{"range":[4580,4645],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":144,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":144,"endColumn":17,"suggestions":[{"fix":{"range":[4933,4999],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":153,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":153,"endColumn":17,"suggestions":[{"fix":{"range":[5278,5341],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":162,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":162,"endColumn":18,"suggestions":[{"fix":{"range":[5626,5692],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":171,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":171,"endColumn":19,"suggestions":[{"fix":{"range":[5917,5983],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":180,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":180,"endColumn":19,"suggestions":[{"fix":{"range":[6191,6251],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]