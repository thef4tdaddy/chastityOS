[
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/postcss.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/tailwind.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/build/vite.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/deployment/vercel.build.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/linting/commitlint.config.cjs",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/configs/linting/eslint.config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/App.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/Root.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/Navigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallery.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementGallerySubComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPageStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementPrivacySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/AchievementViewToggle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/LeaderboardView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/ConflictResolutionModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/DexieDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/SyncStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/common/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardLayouts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/DashboardMain.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/dashboard/FeatureCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/database/DatabaseDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/demo/SessionPersistenceDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/examples/IntegratedTaskManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackFAB.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/FeedbackModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/feedback/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/CurrentStatusSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/SessionHistorySection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/StatisticsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/full_report/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/goals/SpecialChallengeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AcceptInviteCodeSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinking.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingDemoComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingLoading.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AccountLinkingPreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveInviteCodesDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/ActiveKeyholderDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/AdminDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/InviteCodeCreationSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/KeyholderPasswordUnlock.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/LinkingMessageDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/RelationshipSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SessionControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/SubmissiveRelationshipsDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TaskManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/TypedKeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AchievementNotifications.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/AppLayout.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setPageTitle'. Either include it or remove the dependency array. Outer scope values like 'navItems' aren't valid dependencies because mutating them doesn't re-render the component.",
        "line": 66,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 66,
        "endColumn": 35,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [location.pathname, setPageTitle]",
            "fix": { "range": [2108, 2137], "text": "[location.pathname, setPageTitle]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'closeMobileMenu'. Either include it or remove the dependency array.",
        "line": 72,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 72,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [closeMobileMenu, location.pathname]",
            "fix": { "range": [2350, 2369], "text": "[closeMobileMenu, location.pathname]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/Header.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/MobileMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/layout/NavigationData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/EventList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/LogEventForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/log_event/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/BottomSheet.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/MobileInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/PullToRefresh.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/SwipeableCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/TouchTarget.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/VirtualList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/PrivacyPolicyModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/modals/privacy/PrivacyPolicyContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/notifications/NotificationToast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileErrorStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileRecentAchievements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/ProfileStatistics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/PublicProfileHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/ErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/MigrationBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/PendingRequestsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipRequestForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/relationships/RelationshipsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/LogItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/ManualEntryForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardPunishmentStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/RewardsPunishmentsControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rewards_punishments/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RuleEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/RulesPageControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/rules/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/AccountSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DataControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/DisplaySettingsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PersonalGoalSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/PublicProfileSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ResetModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SecuritySettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/SessionEditSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/settings/ToggleSwitch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/system/OfflineStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/CountdownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/TaskItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/CooldownTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/DenialCooldown.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/EmergencyUnlockModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/GoalDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/KeyholderRequirement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseCooldownMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/PauseResumeButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/ReasonModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/RestoreSessionPrompt.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionLoader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/SessionRecoveryModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/tracker/TrackerStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/components/ui/NotificationContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/consistency-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/goal-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/milestone-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/special-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/streak-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/achievements/task-achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/constants/challengeAchievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AppContext.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.",
        "line": 158,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 158,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setState]",
            "fix": { "range": [4486, 4488], "text": "[setState]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/AuthContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/SyncContext.tsx",
    "messages": [
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 119,
        "column": 5,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [3429, 3511], "text": " " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * Sync Context\n * Provides sync state and conflict resolution across the app\n */\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\nimport { useSync } from \"@/hooks/useSync\";\nimport { useAuth } from \"@/hooks/api/useAuth\";\nimport { ConflictResolutionModal } from \"@/components/common/ConflictResolutionModal\";\nimport type { ConflictInfo } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"SyncContext\");\n\ninterface SyncContextType {\n  isSyncing: boolean;\n  lastSyncTime: Date | null;\n  syncStatus: \"synced\" | \"pending\" | \"conflict\" | \"error\";\n  pendingConflicts: ConflictInfo[];\n  triggerSync: () => Promise<void>;\n  hasConflicts: boolean;\n}\n\nconst SyncContext = createContext<SyncContextType | undefined>(undefined);\n\nexport const useSyncContext = (): SyncContextType => {\n  const context = useContext(SyncContext);\n  if (!context) {\n    throw new Error(\"useSyncContext must be used within SyncProvider\");\n  }\n  return context;\n};\n\ninterface SyncProviderProps {\n  children: React.ReactNode;\n}\n\n// Helper function to determine sync status\nconst getSyncStatus = (\n  error: Error | null,\n  pendingConflicts: ConflictInfo[],\n  isSyncing: boolean,\n): SyncContextType[\"syncStatus\"] => {\n  if (error) return \"error\";\n  if (pendingConflicts.length > 0) return \"conflict\";\n  if (isSyncing) return \"pending\";\n  return \"synced\";\n};\n\n// Helper hook for conflict resolution handlers\nconst useConflictResolutionHandlers = (\n  resolveConflicts: (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => Promise<void>,\n  setShowConflictModal: (show: boolean) => void,\n  sync: (userId: string, options?: { force?: boolean }) => Promise<void>,\n  setLastSyncTime: (time: Date | null) => void,\n  userId: string | undefined,\n) => {\n  const handleResolveConflicts = async (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => {\n    try {\n      await resolveConflicts(resolutions);\n      setShowConflictModal(false);\n\n      // Trigger a sync after resolving conflicts\n      if (userId) {\n        await sync(userId);\n        setLastSyncTime(new Date());\n      }\n    } catch (error) {\n      logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n    }\n  };\n\n  const handleCancelConflictResolution = () => {\n    setShowConflictModal(false);\n    // Conflicts remain pending - user can resolve them later\n  };\n\n  return { handleResolveConflicts, handleCancelConflictResolution };\n};\n\nexport const SyncProvider: React.FC<SyncProviderProps> = ({ children }) => {\n  const { user } = useAuth();\n  const userId = user?.uid;\n  const {\n    isSyncing,\n    lastSyncResult: _lastSyncResult,\n    pendingConflicts,\n    sync,\n    resolveConflicts,\n    error,\n  } = useSync();\n\n  const [showConflictModal, setShowConflictModal] = useState(false);\n  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\n\n  // Auto-sync on user change and periodically\n  useEffect(() => {\n    if (!userId) return;\n\n    const performSync = async () => {\n      try {\n        await sync(userId, { conflictResolution: \"auto\" });\n        setLastSyncTime(new Date());\n      } catch (error) {\n        logger.error(\"Auto-sync failed\", { error: error as Error });\n      }\n    };\n\n    // Initial sync\n    performSync();\n\n    // Periodic sync every 5 minutes\n    const interval = setInterval(performSync, 5 * 60 * 1000);\n\n    return () => clearInterval(interval);\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [userId, sync]);\n\n  // Show conflict modal when conflicts are detected\n  useEffect(() => {\n    if (pendingConflicts.length > 0 && !showConflictModal) {\n      setShowConflictModal(true);\n    }\n  }, [pendingConflicts.length, showConflictModal]);\n\n  const triggerSync = async (): Promise<void> => {\n    if (!userId) {\n      throw new Error(\"No user authenticated\");\n    }\n\n    try {\n      await sync(userId, { force: true });\n      setLastSyncTime(new Date());\n    } catch (error) {\n      logger.error(\"Manual sync failed\", { error: error as Error });\n      throw error;\n    }\n  };\n\n  const { handleResolveConflicts, handleCancelConflictResolution } =\n    useConflictResolutionHandlers(\n      resolveConflicts,\n      setShowConflictModal,\n      sync,\n      setLastSyncTime,\n      userId,\n    );\n\n  const contextValue: SyncContextType = {\n    isSyncing,\n    lastSyncTime,\n    syncStatus: getSyncStatus(error, pendingConflicts, isSyncing),\n    pendingConflicts,\n    triggerSync,\n    hasConflicts: pendingConflicts.length > 0,\n  };\n\n  return (\n    <SyncContext.Provider value={contextValue}>\n      {children}\n\n      <ConflictResolutionModal\n        conflicts={pendingConflicts}\n        onResolve={handleResolveConflicts}\n        onCancel={handleCancelConflictResolution}\n        isOpen={showConflictModal}\n      />\n    </SyncContext.Provider>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/ToastProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/contexts/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useAccountLinkingDemo.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (114). Maximum allowed is 75.",
        "line": 94,
        "column": 38,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 230,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Custom hook for Account Linking Demo state and logic\n */\n\nimport { useState } from \"react\";\nimport { Timestamp } from \"firebase/firestore\";\nimport {\n  LinkCode,\n  AdminRelationship,\n  AdminPermissions,\n  SecuritySettings,\n  PrivacySettings,\n} from \"@/types/account-linking\";\n\n// Helper to create Timestamp from Date\nconst toTimestamp = (date: Date): Timestamp => {\n  return Timestamp.fromDate(date);\n};\n\n// Mock permissions\nconst mockPermissions: AdminPermissions = {\n  viewSessions: true,\n  viewEvents: true,\n  viewTasks: true,\n  viewSettings: true,\n  controlSessions: true,\n  manageTasks: true,\n  editSettings: false,\n  setGoals: false,\n  emergencyUnlock: false,\n  forceEnd: false,\n  viewAuditLog: true,\n  exportData: false,\n};\n\n// Mock security settings\nconst mockSecurity: SecuritySettings = {\n  requireConfirmation: true,\n  auditLog: true,\n  sessionTimeout: 60,\n  requireReauth: false,\n  ipRestrictions: [],\n};\n\n// Mock privacy settings\nconst mockPrivacy: PrivacySettings = {\n  wearerCanSeeAdminActions: true,\n  keyholderCanSeePrivateNotes: false,\n  shareStatistics: true,\n  retainDataAfterDisconnect: true,\n  anonymizeHistoricalData: false,\n};\n\n// Mock data for demonstration\nconst mockInviteCodes: LinkCode[] = [\n  {\n    id: \"invite-1\",\n    wearerId: \"demo-user-123\",\n    createdAt: toTimestamp(new Date(Date.now() - 1000 * 60 * 30)), // 30 minutes ago\n    expiresAt: toTimestamp(new Date(Date.now() + 1000 * 60 * 60 * 23.5)), // 23.5 hours from now\n    status: \"pending\",\n    maxUses: 1,\n    usedBy: null,\n  },\n  {\n    id: \"invite-2\",\n    wearerId: \"demo-user-123\",\n    createdAt: toTimestamp(new Date(Date.now() - 1000 * 60 * 60 * 2)), // 2 hours ago\n    expiresAt: toTimestamp(new Date(Date.now() + 1000 * 60 * 60 * 22)), // 22 hours from now\n    status: \"pending\",\n    maxUses: 1,\n    usedBy: null,\n  },\n];\n\nconst mockActiveKeyholder: AdminRelationship = {\n  id: \"rel-1\",\n  keyholderId: \"keyholder-456\",\n  wearerId: \"demo-user-123\",\n  establishedAt: toTimestamp(new Date(Date.now() - 1000 * 60 * 60 * 24 * 7)), // 1 week ago\n  status: \"active\",\n  permissions: mockPermissions,\n  security: mockSecurity,\n  privacy: mockPrivacy,\n  linkMethod: \"code\",\n  lastAdminAccess: toTimestamp(new Date(Date.now() - 1000 * 60 * 60)), // 1 hour ago\n};\n\ntype DemoScenario =\n  | \"submissive-no-keyholder\"\n  | \"submissive-with-keyholder\"\n  | \"keyholder-mode\";\n\nexport const useAccountLinkingDemo = (scenario: DemoScenario) => {\n  // UI State\n  const [showCreateInvite, setShowCreateInvite] = useState(false);\n  const [showAcceptInvite, setShowAcceptInvite] = useState(false);\n  const [showPermissions, setShowPermissions] = useState<string | null>(null);\n  const [inviteCodeInput, setInviteCodeInput] = useState(\"\");\n  const [keyholderNameInput, setKeyholderNameInput] = useState(\"\");\n\n  // Message state\n  const [message, setMessage] = useState(\"\");\n  const [messageType, setMessageType] = useState<\"success\" | \"error\" | \"info\">(\n    \"info\",\n  );\n\n  // Generate mock data based on scenario\n  const getMockData = () => {\n    const activeKeyholder =\n      scenario === \"submissive-with-keyholder\" ? mockActiveKeyholder : null;\n\n    const activeInviteCodes =\n      scenario === \"submissive-no-keyholder\" ||\n      scenario === \"submissive-with-keyholder\"\n        ? mockInviteCodes\n        : [];\n\n    const relationshipSummary = {\n      totalAsSubmissive: scenario === \"submissive-with-keyholder\" ? 1 : 0,\n      totalAsKeyholder: scenario === \"keyholder-mode\" ? 2 : 0,\n    };\n\n    const relationships =\n      scenario === \"keyholder-mode\"\n        ? {\n            asSubmissive: [],\n            asKeyholder: [\n              {\n                id: \"rel-2\",\n                keyholderId: \"demo-user-123\",\n                wearerId: \"sub-1\",\n                establishedAt: toTimestamp(new Date(Date.now() - 1000 * 60 * 60 * 24 * 3)),\n                status: \"active\" as const,\n                permissions: mockActiveKeyholder.permissions,\n                security: mockSecurity,\n                privacy: mockPrivacy,\n                linkMethod: \"code\" as const,\n              } as AdminRelationship,\n              {\n                id: \"rel-3\",\n                keyholderId: \"demo-user-123\",\n                wearerId: \"sub-2\",\n                establishedAt: toTimestamp(new Date(Date.now() - 1000 * 60 * 60 * 24 * 5)),\n                status: \"active\" as const,\n                permissions: mockActiveKeyholder.permissions,\n                security: mockSecurity,\n                privacy: mockPrivacy,\n                linkMethod: \"code\" as const,\n              } as AdminRelationship,\n            ],\n          }\n        : { asSubmissive: [], asKeyholder: [] };\n\n    return {\n      activeKeyholder,\n      activeInviteCodes,\n      relationshipSummary,\n      relationships,\n    };\n  };\n\n  const mockData = getMockData();\n\n  // Message handlers\n  const showMessage = (\n    text: string,\n    type: \"success\" | \"error\" | \"info\" = \"info\",\n  ) => {\n    setMessage(text);\n    setMessageType(type);\n  };\n\n  const clearMessage = () => {\n    setMessage(\"\");\n    setMessageType(\"info\");\n  };\n\n  // Action handlers\n  const handleCreateInvite = () => {\n    showMessage(\"Demo: Invite code ABC123 created successfully!\", \"success\");\n    setShowCreateInvite(false);\n  };\n\n  const handleAcceptInvite = () => {\n    if (inviteCodeInput === \"ABC123\") {\n      showMessage(\"Demo: Successfully accepted invite code!\", \"success\");\n    } else {\n      showMessage(\"Demo: Invalid invite code. Try 'ABC123'\", \"error\");\n    }\n    setInviteCodeInput(\"\");\n    setKeyholderNameInput(\"\");\n    setShowAcceptInvite(false);\n  };\n\n  const copyToClipboard = async (text: string) => {\n    try {\n      await navigator.clipboard.writeText(text);\n      showMessage(`Copied \"${text}\" to clipboard`, \"success\");\n    } catch {\n      showMessage(\"Failed to copy to clipboard\", \"error\");\n    }\n  };\n\n  return {\n    // State\n    showCreateInvite,\n    setShowCreateInvite,\n    showAcceptInvite,\n    setShowAcceptInvite,\n    showPermissions,\n    setShowPermissions,\n    inviteCodeInput,\n    setInviteCodeInput,\n    keyholderNameInput,\n    setKeyholderNameInput,\n    message,\n    messageType,\n\n    // Actions\n    showMessage,\n    clearMessage,\n    handleCreateInvite,\n    handleAcceptInvite,\n    copyToClipboard,\n\n    // Mock data\n    ...mockData,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useDexieSync.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (115). Maximum allowed is 75.",
        "line": 20,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 178,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Dexie Sync Hook\n * Provides easy access to Dexie services with automatic sync management\n */\nimport { useCallback, useMemo } from \"react\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { useApp } from \"@/contexts/AppContext\";\nimport {\n  sessionDBService,\n  eventDBService,\n  taskDBService,\n  goalDBService,\n  settingsDBService,\n} from \"@/services/database\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useDexieSync\");\n\nexport const useDexieSync = () => {\n  const { state: appState, actions: appActions } = useApp();\n  const { user } = useAuth();\n\n  /**\n   * Get all Dexie services\n   */\n  const services = useMemo(\n    () => ({\n      sessions: sessionDBService,\n      events: eventDBService,\n      tasks: taskDBService,\n      goals: goalDBService,\n      settings: settingsDBService,\n    }),\n    [],\n  );\n\n  /**\n   * Trigger manual sync\n   */\n  const triggerSync = useCallback(async () => {\n    if (!user?.uid) {\n      logger.warn(\"Cannot sync: no authenticated user\");\n      return;\n    }\n\n    try {\n      await appActions.triggerSync(user.uid);\n    } catch (error) {\n      logger.error(\"Sync failed\", { error: error as Error });\n      throw error;\n    }\n  }, [user?.uid, appActions]);\n\n  /**\n   * Create a record with automatic sync queuing\n   */\n  const createWithSync = useCallback(\n    async <T extends Record<string, unknown>>(\n      service: keyof typeof services,\n      data: T,\n    ): Promise<string> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      const id = await services[service].create(data);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n\n      return id;\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Update a record with automatic sync queuing\n   */\n  const updateWithSync = useCallback(\n    async <T extends Record<string, unknown>>(\n      service: keyof typeof services,\n      id: string,\n      updates: T,\n    ): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].update(id, updates);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Delete a record with automatic sync queuing\n   */\n  const deleteWithSync = useCallback(\n    async (service: keyof typeof services, id: string): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].delete(id);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  return {\n    // Services\n    services,\n\n    // Sync control\n    triggerSync,\n    syncStatus: appState.syncStatus,\n    lastSyncTime: appState.lastSyncTime,\n    isOnline: appState.isOnline,\n\n    // CRUD operations with sync\n    createWithSync,\n    updateWithSync,\n    deleteWithSync,\n\n    // Direct service access for read operations\n    findById: useCallback(\n      async (service: keyof typeof services, id: string) => {\n        return services[service].findById(id);\n      },\n      [services],\n    ),\n\n    findByUserId: useCallback(\n      async (service: keyof typeof services, userId: string) => {\n        return services[service].findByUserId(userId);\n      },\n      [services],\n    ),\n\n    paginate: useCallback(\n      async (\n        service: keyof typeof services,\n        userId: string,\n        offset: number = 0,\n        limit: number = 50,\n      ) => {\n        return services[service].paginate(userId, offset, limit);\n      },\n      [services],\n    ),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/demo/hooks/useOfflineDemo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/firebase.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/account-linking/useAccountLinking.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (270). Maximum allowed is 75.",
        "line": 30,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 349,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Account Linking Hook\n * React hook for managing keyholder-wearer account linking\n */\nimport { useState, useCallback, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AccountLinkingService } from \"../../services/auth/account-linking\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  AccountLinkingState,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useAccountLinking\");\n\n// Query keys\nconst QUERY_KEYS = {\n  relationships: (userId: string) => [\"adminRelationships\", userId],\n  validation: (code: string) => [\"linkCodeValidation\", code],\n  adminSession: (relationshipId: string) => [\"adminSession\", relationshipId],\n} as const;\n\nexport const useAccountLinking = () => {\n  const { user } = useAuthState();\n  const queryClient = useQueryClient();\n\n  // Local state\n  const [state, setState] = useState<AccountLinkingState>({\n    isGeneratingCode: false,\n    currentLinkCode: null,\n    linkCodeError: null,\n    isUsingCode: false,\n    codeUsageError: null,\n    adminRelationships: [],\n    selectedWearerId: null,\n    currentAdminSession: null,\n    isAdminSessionActive: false,\n    showQRCode: false,\n    showDisconnectionDialog: false,\n    showPermissionEditor: false,\n  });\n\n  // ==================== QUERIES ====================\n\n  // Get admin relationships for current user\n  const {\n    data: relationships = [],\n    isLoading: isLoadingRelationships,\n    error: relationshipsError,\n  } = useQuery({\n    queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n    queryFn: () => AccountLinkingService.getAdminRelationships(user!.uid),\n    enabled: !!user,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Update local state when relationships change\n  useEffect(() => {\n    setState((prev) => ({ ...prev, adminRelationships: relationships }));\n  }, [relationships]);\n\n  // ==================== MUTATIONS ====================\n\n  // Generate link code\n  const generateLinkCodeMutation = useMutation({\n    mutationFn: (request: GenerateLinkCodeRequest) =>\n      AccountLinkingService.generateLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isGeneratingCode: true,\n        linkCodeError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<LinkCodeResponse>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentLinkCode: response.data!,\n          isGeneratingCode: false,\n        }));\n        logger.info(\"Link code generated successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: response.error || \"Failed to generate link code\",\n          isGeneratingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        linkCodeError: error.message,\n        isGeneratingCode: false,\n      }));\n      logger.error(\"Failed to generate link code\", { error });\n    },\n  });\n\n  // Use link code\n  const useLinkCodeMutation = useMutation({\n    mutationFn: (request: UseLinkCodeRequest) =>\n      AccountLinkingService.redeemLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isUsingCode: true,\n        codeUsageError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          isUsingCode: false,\n        }));\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Link code used successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: response.error || \"Failed to use link code\",\n          isUsingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        codeUsageError: error.message,\n        isUsingCode: false,\n      }));\n      logger.error(\"Failed to use link code\", { error });\n    },\n  });\n\n  // Update relationship\n  const updateRelationshipMutation = useMutation({\n    mutationFn: (request: UpdateRelationshipRequest) =>\n      AccountLinkingService.updateRelationship(request),\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success) {\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Relationship updated successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to update relationship\", { error });\n    },\n  });\n\n  // Start admin session\n  const startAdminSessionMutation = useMutation({\n    mutationFn: (relationshipId: string) =>\n      AccountLinkingService.startAdminSession(relationshipId),\n    onSuccess: (response: ApiResponse<AdminSession>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentAdminSession: response.data!,\n          isAdminSessionActive: true,\n        }));\n        logger.info(\"Admin session started successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to start admin session\", { error });\n    },\n  });\n\n  // ==================== CALLBACK FUNCTIONS ====================\n\n  const generateLinkCode = useCallback(\n    (request: GenerateLinkCodeRequest = {}) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: \"Authentication required\",\n        }));\n        return;\n      }\n      generateLinkCodeMutation.mutate(request);\n    },\n    [user, generateLinkCodeMutation],\n  );\n\n  const redeemLinkCode = useCallback(\n    (request: UseLinkCodeRequest) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: \"Authentication required\",\n        }));\n        return;\n      }\n      useLinkCodeMutation.mutate(request);\n    },\n    [user, useLinkCodeMutation],\n  );\n\n  const updateRelationship = useCallback(\n    (request: UpdateRelationshipRequest) => {\n      updateRelationshipMutation.mutate(request);\n    },\n    [updateRelationshipMutation],\n  );\n\n  const startAdminSession = useCallback(\n    (relationshipId: string) => {\n      startAdminSessionMutation.mutate(relationshipId);\n    },\n    [startAdminSessionMutation],\n  );\n\n  const disconnectKeyholder = useCallback(\n    (relationshipId: string, reason?: string) => {\n      updateRelationship({\n        relationshipId,\n        status: \"terminated\",\n        terminationReason: reason,\n      });\n    },\n    [updateRelationship],\n  );\n\n  const clearLinkCode = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n    }));\n  }, []);\n\n  const clearAllErrors = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n      codeUsageError: null,\n    }));\n  }, []);\n\n  const setSelectedWearer = useCallback((wearerId: string | null) => {\n    setState((prev) => ({ ...prev, selectedWearerId: wearerId }));\n  }, []);\n\n  // Combined toggle function for boolean state properties\n  const toggleStateProperty = useCallback(\n    (\n      property: keyof Pick<\n        AccountLinkingState,\n        \"showQRCode\" | \"showDisconnectionDialog\" | \"showPermissionEditor\"\n      >,\n    ) => {\n      setState((prev) => ({ ...prev, [property]: !prev[property] }));\n    },\n    [],\n  );\n\n  const toggleQRCode = useCallback(\n    () => toggleStateProperty(\"showQRCode\"),\n    [toggleStateProperty],\n  );\n  const toggleDisconnectionDialog = useCallback(\n    () => toggleStateProperty(\"showDisconnectionDialog\"),\n    [toggleStateProperty],\n  );\n  const togglePermissionEditor = useCallback(\n    () => toggleStateProperty(\"showPermissionEditor\"),\n    [toggleStateProperty],\n  );\n\n  // ==================== DERIVED STATE ====================\n\n  // User role calculations\n  const userRoles = useMemo(\n    () => ({\n      isKeyholder: relationships.some((r) => r.keyholderId === user?.uid),\n      isWearer: relationships.some((r) => r.wearerId === user?.uid),\n      hasActiveRelationships: relationships.some((r) => r.status === \"active\"),\n    }),\n    [relationships, user?.uid],\n  );\n\n  // Relationship filtering\n  const relationshipsByRole = useMemo(\n    () => ({\n      keyholderRelationships: relationships.filter(\n        (r) => r.keyholderId === user?.uid,\n      ),\n      wearerRelationships: relationships.filter(\n        (r) => r.wearerId === user?.uid,\n      ),\n    }),\n    [relationships, user?.uid],\n  );\n\n  const selectedRelationship = state.selectedWearerId\n    ? relationships.find((r) => r.wearerId === state.selectedWearerId)\n    : null;\n\n  // ==================== RETURN OBJECT ====================\n\n  return {\n    // State\n    ...state,\n    relationships,\n    isLoadingRelationships,\n    relationshipsError,\n\n    // Derived state\n    ...userRoles,\n    selectedRelationship,\n    ...relationshipsByRole,\n\n    // Actions\n    generateLinkCode,\n    redeemLinkCode,\n    updateRelationship,\n    startAdminSession,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearAllErrors,\n    setSelectedWearer,\n    toggleQRCode,\n    toggleDisconnectionDialog,\n    togglePermissionEditor,\n\n    // Loading states\n    isGeneratingCode: generateLinkCodeMutation.isPending,\n    isUsingCode: useLinkCodeMutation.isPending,\n    isUpdatingRelationship: updateRelationshipMutation.isPending,\n    isStartingSession: startAdminSessionMutation.isPending,\n  };\n};\n\n// ==================== ADDITIONAL HOOKS ====================\n\n/**\n * Hook for validating link codes\n */\nexport const useLinkCodeValidation = (code: string) => {\n  return useQuery({\n    queryKey: QUERY_KEYS.validation(code),\n    queryFn: () => AccountLinkingService.validateLinkCode(code),\n    enabled: code.length > 0,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n};\n\n/**\n * Hook for admin access validation\n */\nexport const useAdminAccess = (wearerId: string) => {\n  const { user } = useAuthState();\n  const { relationships } = useAccountLinking();\n\n  const adminRelationship = relationships.find(\n    (r) =>\n      r.keyholderId === user?.uid &&\n      r.wearerId === wearerId &&\n      r.status === \"active\",\n  );\n\n  const hasAccess = !!adminRelationship;\n  const permissions = adminRelationship?.permissions || null;\n  const security = adminRelationship?.security || null;\n\n  const canPerformAction = useCallback(\n    (action: keyof typeof permissions) => {\n      return hasAccess && permissions?.[action] === true;\n    },\n    [hasAccess, permissions],\n  );\n\n  return {\n    hasAccess,\n    adminRelationship,\n    permissions,\n    security,\n    canPerformAction,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievement-gallery-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/useLeaderboardActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/achievements/usePrivacySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/auth-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/emergency-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/events-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/queryClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/tasks-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useAuth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEmergency.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEventQueries.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useEventMutations' has too many lines (184). Maximum allowed is 75.",
        "line": 89,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 307,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Events TanStack Query Hooks\n * Manages event log data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { eventDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBEvent, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useEventsQuery\");\n\n/**\n * Query for getting all events for a user\n */\nexport function useEventsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"events\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const events = await eventDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(userId).catch((error) => {\n          logger.warn(\"Background events sync failed\", { error });\n        });\n      }\n\n      return events;\n    },\n    ...cacheConfig.events, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting recent events (last 30 days)\n */\nexport function useRecentEventsQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"recent\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents\n        .filter((event) => event.timestamp >= thirtyDaysAgo)\n        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Query for getting events by type\n */\nexport function useEventsByTypeQuery(\n  userId: string | undefined,\n  eventType: EventType,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"type\", userId, eventType],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents.filter((event) => event.type === eventType);\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for event operations\n */\nexport function useEventMutations() {\n  const queryClient = useQueryClient();\n\n  const createEvent = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      type: EventType;\n      timestamp: Date;\n      notes?: string;\n      duration?: number;\n      isPrivate?: boolean;\n      sessionId?: string;\n      metadata?: Record<string, unknown>;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const { notes, duration, ...restParams } = params;\n      const eventData = {\n        ...restParams,\n        isPrivate: restParams.isPrivate ?? false, // Ensure isPrivate is always defined\n        details: {\n          notes,\n          duration,\n        },\n      };\n      const event = await eventDBService.createEvent(eventData);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event creation sync failed\", { error });\n        });\n      }\n\n      return event;\n    },\n    onSuccess: (data, variables) => {\n      // Add event to the cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return [data];\n          return [data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create event\", { error });\n    },\n  });\n\n  const updateEvent = useMutation({\n    mutationFn: async (params: {\n      eventId: string;\n      userId: string;\n      updates: Partial<DBEvent>;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedEvent = await eventDBService.updateEvent(\n        params.eventId,\n        params.updates,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event update sync failed\", { error });\n        });\n      }\n\n      return updatedEvent;\n    },\n    onSuccess: (data, variables) => {\n      // Update event in cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.map((event) =>\n            event.id === variables.eventId\n              ? { ...event, ...(data as Partial<DBEvent>) }\n              : event,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update event\", { error });\n    },\n  });\n\n  const deleteEvent = useMutation({\n    mutationFn: async (params: { eventId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await eventDBService.deleteEvent(params.eventId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event deletion sync failed\", { error });\n        });\n      }\n\n      return params.eventId;\n    },\n    onSuccess: (eventId, variables) => {\n      // Remove event from cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.filter((event) => event.id !== eventId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete event\", { error });\n    },\n  });\n\n  const bulkCreateEvents = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      events: Array<{\n        type: EventType;\n        timestamp: Date;\n        notes?: string;\n        duration?: number;\n        isPrivate?: boolean;\n        sessionId?: string;\n        metadata?: Record<string, unknown>;\n      }>;\n    }) => {\n      // 1. Create all events in local Dexie\n      const createdEvents = await Promise.all(\n        params.events.map((eventData) => {\n          const { notes, duration, ...restEventData } = eventData;\n          return eventDBService.createEvent({\n            ...restEventData,\n            userId: params.userId,\n            isPrivate: restEventData.isPrivate ?? false, // Ensure isPrivate is always defined\n            details: {\n              notes,\n              duration,\n            },\n          });\n        }),\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Bulk event creation sync failed\", { error });\n        });\n      }\n\n      return createdEvents;\n    },\n    onSuccess: (data, variables) => {\n      // Add all events to cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return data;\n          return [...data, ...oldEvents].sort((a, b) => {\n            // Type guard to ensure we have DBEvent objects with timestamp\n            if (typeof a === \"string\" || typeof b === \"string\") return 0;\n            return b.timestamp.getTime() - a.timestamp.getTime();\n          });\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to bulk create events\", { error });\n    },\n  });\n\n  return {\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    bulkCreateEvents,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useOfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSessionQuery.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSessionMutations' has too many lines (113). Maximum allowed is 75.",
        "line": 69,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 215,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session TanStack Query Hooks\n * Manages chastity session data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { sessionDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSessionQuery\");\n\n/**\n * Query for getting current active session\n */\nexport function useCurrentSession(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"session\", \"current\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      const session = await sessionDBService.getCurrentSession(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    ...cacheConfig.currentSession, // Apply specific cache settings\n    enabled: !!userId, // The query will not run until the userId is available\n  });\n}\n\n/**\n * Query for getting session history\n */\nexport function useSessionHistory(userId: string | undefined, enabled = true) {\n  return useQuery({\n    queryKey: [\"sessions\", \"history\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const sessions = await sessionDBService.findByUserId(userId);\n\n      // Trigger background sync if online\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session history sync failed:\", { error });\n        });\n      }\n\n      return sessions.sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n    },\n    ...cacheConfig.sessionHistory,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for session operations\n */\nexport function useSessionMutations() {\n  const queryClient = useQueryClient();\n\n  const startSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      startTime?: Date;\n      requiredDuration?: number;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const sessionId = await sessionDBService.startSession(params.userId, {\n        goalDuration: params.requiredDuration,\n        notes: `Session started at ${params.startTime || new Date()}`,\n      });\n\n      // Get the created session\n      const session = await sessionDBService.findById(sessionId);\n      if (!session) {\n        throw new Error(\"Failed to create session\");\n      }\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session start sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    onSuccess: (data, variables) => {\n      // Update the current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n\n      // Invalidate session history to include new session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to start session:\", { error });\n    },\n  });\n\n  const endSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      endTime?: Date;\n      reason?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.endSession(\n        params.userId,\n        params.endTime || new Date(),\n        params.reason,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session end sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Clear current session since it's ended\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], null);\n\n      // Invalidate session history to reflect ended session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to end session:\", { error });\n    },\n  });\n\n  const pauseSession = useMutation({\n    mutationFn: async (params: { userId: string; reason?: string }) => {\n      // 1. Get current session first\n      const currentSession = await sessionDBService.getCurrentSession(\n        params.userId,\n      );\n      if (!currentSession) {\n        throw new Error(\"No active session to pause\");\n      }\n\n      // 2. Update local Dexie immediately\n      await sessionDBService.pauseSession(currentSession.id, new Date());\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session pause sync failed:\", { error });\n        });\n      }\n\n      // Return the updated session\n      const updatedSession = await sessionDBService.getCurrentSession(\n        params.userId,\n      );\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to pause session:\", { error });\n    },\n  });\n\n  const resumeSession = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.resumeSession(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session resume sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to resume session:\", { error });\n    },\n  });\n\n  return {\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useSettingsQueries.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSettingsMutations' has too many lines (91). Maximum allowed is 75.",
        "line": 49,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 164,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Settings TanStack Query Hooks\n * Manages user settings with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { settingsDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBSettings } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSettingsQuery\");\n\n/**\n * Query for getting user settings\n */\nexport function useSettingsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"settings\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      let settings = await settingsDBService.getSettings(userId);\n\n      // If no settings exist, create default settings\n      if (!settings) {\n        await settingsDBService.createDefaultSettings(userId);\n        settings = await settingsDBService.getSettings(userId);\n      }\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(userId).catch((error) => {\n          logger.warn(\"Background settings sync failed:\", { error });\n        });\n      }\n\n      return settings;\n    },\n    ...cacheConfig.userSettings, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Mutations for settings operations\n */\nexport function useSettingsMutations() {\n  const queryClient = useQueryClient();\n\n  const updateSettings = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      settings: Partial<DBSettings>;\n    }) => {\n      // 1. Update local Dexie immediately for optimistic update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        params.settings,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache immediately\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update settings:\", { error });\n\n      // Invalidate cache to refetch from server in case of error\n      queryClient.invalidateQueries({\n        queryKey: [\"settings\", \"user\"],\n      });\n    },\n  });\n\n  const resetSettings = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Reset to defaults in local Dexie\n      const defaultSettings = await settingsDBService.createDefaultSettings(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings reset sync failed:\", { error });\n        });\n      }\n\n      return defaultSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache with default values\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to reset settings:\", { error });\n    },\n  });\n\n  const updateTheme = useMutation({\n    mutationFn: async (params: { userId: string; theme: \"light\" | \"dark\" }) => {\n      // Quick theme update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { theme: params.theme },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Theme update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update settings cache\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  const updateEventDisplayMode = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      eventDisplayMode: \"kinky\" | \"vanilla\";\n    }) => {\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { eventDisplayMode: params.eventDisplayMode },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Event display mode sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  return {\n    updateSettings,\n    resetSettings,\n    updateTheme,\n    updateEventDisplayMode,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTaskQuery.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useTaskMutations' has too many lines (149). Maximum allowed is 75.",
        "line": 65,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 244,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Task TanStack Query Hooks\n * Manages server state for tasks with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBTask, TaskStatus } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useTaskQuery\");\n\n/**\n * Query for getting all tasks for a user\n */\nexport function useTasksQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"tasks\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const tasks = await taskDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(userId).catch((error) => {\n          logger.warn(\"Background task sync failed\", { error });\n        });\n      }\n\n      return tasks;\n    },\n    ...cacheConfig.tasks, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting pending tasks that need keyholder attention\n */\nexport function usePendingTasksQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"tasks\", \"pending\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allTasks = await taskDBService.findByUserId(userId);\n      return allTasks.filter((task) =>\n        [\"pending\", \"submitted\"].includes(task.status),\n      );\n    },\n    ...cacheConfig.tasks,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for task operations\n */\nexport function useTaskMutations() {\n  const queryClient = useQueryClient();\n\n  const createTask = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      title: string;\n      description?: string;\n      deadline?: Date;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const task = await taskDBService.createTask({\n        ...params,\n        status: \"pending\" as TaskStatus,\n        text: params.description || params.title, // Use description or title as text\n        priority: \"medium\" as const, // Default priority\n        assignedBy: \"submissive\" as const, // Default assignment source\n      });\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task creation sync failed\", { error });\n        });\n      }\n\n      return task;\n    },\n    onSuccess: (data, variables) => {\n      // Invalidate and refetch tasks queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"user\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create task\", { error });\n    },\n  });\n\n  const updateTaskStatus = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      feedback?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        params.status,\n        {\n          keyholderFeedback: params.feedback,\n        },\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task status update sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update specific task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId\n              ? { ...task, ...(data as Partial<DBTask>) }\n              : task,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update task status\", { error });\n    },\n  });\n\n  const deleteTask = useMutation({\n    mutationFn: async (params: { taskId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await taskDBService.deleteTask(params.taskId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task deletion sync failed\", { error });\n        });\n      }\n\n      return params.taskId;\n    },\n    onSuccess: (taskId, variables) => {\n      // Remove task from cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.filter((task) => task.id !== taskId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete task\", { error });\n    },\n  });\n\n  const submitTaskForReview = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      note?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        \"submitted\",\n        {\n          submissiveNote: params.note,\n        },\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task submission sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId\n              ? { ...task, ...(data as Partial<DBTask>) }\n              : task,\n          );\n        },\n      );\n\n      // Invalidate pending tasks since this affects that query\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to submit task for review\", { error });\n    },\n  });\n\n  return {\n    createTask,\n    updateTaskStatus,\n    deleteTask,\n    submitTaskForReview,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/api/useTasks.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useUpdateTaskStatus' has too many lines (95). Maximum allowed is 75.",
        "line": 289,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 403,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"../../services/database/TaskDBService\";\nimport { Task, TaskStatus, DBTask, TaskFilters } from \"../../types/database\";\nimport { logger } from \"../../utils/logging\";\nimport { taskKeys } from \"./tasks-utils\";\n\n/**\n * Task Management Hooks - TanStack Query Integration\n *\n * Integrates with:\n * - taskDBService  Dexie  Firebase sync\n * - TasksPage.tsx, TaskManagement.tsx (critical fixes needed)\n *\n * Fixes:\n * - TasksPage.tsx:20 (taskDBService.findByUserId)\n * - TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n *\n * Strategy: Optimistic update + background sync\n */\n\n// Types\ninterface CreateTaskData {\n  title: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  assignedBy?: string; // keyholder UID\n  metadata?: Record<string, unknown>;\n}\n\ninterface UpdateTaskData {\n  title?: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Apply filters to task list\n */\nfunction applyTaskFilters(tasks: Task[], filters?: TaskFilters): Task[] {\n  let filteredTasks = tasks;\n\n  if (filters?.status) {\n    filteredTasks = filteredTasks.filter(\n      (task) => task.status === filters.status,\n    );\n  }\n\n  if (filters?.priority) {\n    filteredTasks = filteredTasks.filter(\n      (task) => task.priority === filters.priority,\n    );\n  }\n\n  if (filters?.category) {\n    filteredTasks = filteredTasks.filter(\n      (task) => task.category === filters.category,\n    );\n  }\n\n  if (filters?.assignedBy) {\n    filteredTasks = filteredTasks.filter(\n      (task) => task.assignedBy === filters.assignedBy,\n    );\n  }\n\n  if (filters?.dueDate) {\n    filteredTasks = filteredTasks.filter((task) => {\n      if (!task.dueDate) return false;\n      const taskDue = new Date(task.dueDate);\n\n      if (filters.dueDate?.start && taskDue < filters.dueDate.start)\n        return false;\n      if (filters.dueDate?.end && taskDue > filters.dueDate.end) return false;\n\n      return true;\n    });\n  }\n\n  return filteredTasks;\n}\n\n/**\n * Sort tasks by priority and due date\n */\nfunction sortTasks(tasks: Task[]): Task[] {\n  return tasks.sort((a, b) => {\n    // Priority sorting (urgent > high > medium > low)\n    const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };\n    const aPriority =\n      priorityOrder[a.priority as keyof typeof priorityOrder] ||\n      priorityOrder.medium;\n    const bPriority =\n      priorityOrder[b.priority as keyof typeof priorityOrder] ||\n      priorityOrder.medium;\n\n    if (aPriority !== bPriority) {\n      return bPriority - aPriority;\n    }\n\n    // Due date sorting (sooner first)\n    if (a.dueDate && b.dueDate) {\n      return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();\n    }\n\n    if (a.dueDate && !b.dueDate) return -1;\n    if (!a.dueDate && b.dueDate) return 1;\n\n    // Created date sorting (newest first)\n    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();\n  });\n}\n\n/**\n * Get tasks for a user with optional filtering\n * Fixes: TasksPage.tsx:20 (taskDBService.findByUserId)\n */\nexport function useTasks(userId: string, filters?: TaskFilters) {\n  return useQuery({\n    queryKey: taskKeys.list(userId, filters),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks\", { userId, filters });\n\n      try {\n        const tasks = await taskDBService.findByUserId(userId);\n        const filteredTasks = applyTaskFilters(tasks, filters);\n        const sortedTasks = sortTasks(filteredTasks);\n\n        logger.info(\"Tasks retrieved successfully\", {\n          userId,\n          totalTasks: tasks.length,\n          filteredTasks: sortedTasks.length,\n        });\n\n        return sortedTasks;\n      } catch (error) {\n        logger.error(\"Failed to fetch tasks\", {\n          error: error instanceof Error ? error.message : String(error),\n          userId,\n          filters,\n        });\n        throw error;\n      }\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes - active data\n    gcTime: 30 * 60 * 1000, // 30 minutes garbage collection\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get tasks by status (useful for kanban boards)\n */\nexport function useTasksByStatus(userId: string, status: TaskStatus) {\n  return useQuery({\n    queryKey: taskKeys.byStatus(userId, status),\n    queryFn: async (): Promise<Task[]> => {\n      const tasks = await taskDBService.findByUserId(userId);\n      return tasks.filter((task) => task.status === status);\n    },\n    staleTime: 2 * 60 * 1000,\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get single task by ID\n */\nexport function useTask(taskId: string) {\n  return useQuery({\n    queryKey: taskKeys.detail(taskId),\n    queryFn: async (): Promise<Task | null> => {\n      logger.info(\"Fetching task detail\", { taskId });\n      const task = await taskDBService.findById(taskId);\n      return task ?? null;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes - task details are stable\n    enabled: !!taskId,\n  });\n}\n\n/**\n * Get tasks assigned by a specific keyholder\n */\nexport function useTasksAssignedBy(keyholderUid: string) {\n  return useQuery({\n    queryKey: taskKeys.assignedBy(keyholderUid),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks assigned by keyholder\", { keyholderUid });\n\n      // Note: This would require a different query method in the future\n      // For now, we'll need to scan all tasks (inefficient but works)\n      const allTasks = await taskDBService.getAll();\n      return allTasks.filter((task: Task) => task.assignedBy === keyholderUid);\n    },\n    staleTime: 5 * 60 * 1000,\n    enabled: !!keyholderUid,\n  });\n}\n\n/**\n * Create new task\n */\nexport function useCreateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      taskData,\n    }: {\n      userId: string;\n      taskData: CreateTaskData;\n    }): Promise<DBTask> => {\n      logger.info(\"Creating new task\", { userId, title: taskData.title });\n\n      // Generate task ID\n      const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      const newTask: DBTask = {\n        id: taskId,\n        userId,\n        text: taskData.title, // DBTask uses 'text' field\n        title: taskData.title,\n        description: taskData.description || \"\",\n        status: \"pending\",\n        priority: taskData.priority || \"medium\",\n        category: taskData.category,\n        dueDate: taskData.dueDate,\n        assignedBy:\n          (taskData.assignedBy as \"submissive\" | \"keyholder\") || \"submissive\",\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      // Dexie-first write for immediate UI response\n      await taskDBService.create(newTask);\n\n      logger.info(\"Task created successfully\", {\n        taskId,\n        userId,\n        title: taskData.title,\n      });\n\n      return newTask;\n    },\n    onSuccess: (\n      newTask: Task,\n      { userId }: { userId: string; taskData: CreateTaskData },\n    ) => {\n      logger.info(\"Task creation successful\", { taskId: newTask.id, userId });\n\n      // Invalidate task lists to trigger refetch\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n\n      // Optimistically add to cache if we have existing data\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return [newTask, ...oldData];\n        },\n      );\n    },\n    onError: (error, { userId, taskData }) => {\n      logger.error(\"Task creation failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        userId,\n        title: taskData.title,\n      });\n    },\n  });\n}\n\n/**\n * Update task status (most common operation)\n * Fixes: TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n * Strategy: Optimistic update + background sync\n */\nexport function useUpdateTaskStatus() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      status,\n      completedAt,\n    }: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      completedAt?: Date;\n    }): Promise<Task> => {\n      logger.info(\"Updating task status\", { taskId, userId, status });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        status,\n        completedAt:\n          status === \"completed\" ? completedAt || new Date() : undefined,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.updateTaskStatus(taskId, status);\n\n      logger.info(\"Task status updated successfully\", {\n        taskId,\n        userId,\n        status,\n      });\n\n      return updatedTask;\n    },\n    onMutate: async ({ taskId, userId, status }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: taskKeys.detail(taskId) });\n      await queryClient.cancelQueries({ queryKey: taskKeys.list(userId) });\n\n      // Snapshot previous values\n      const previousTask = queryClient.getQueryData(taskKeys.detail(taskId));\n      const previousTasks = queryClient.getQueryData(taskKeys.list(userId));\n\n      // Optimistically update task detail\n      queryClient.setQueryData(\n        taskKeys.detail(taskId),\n        (old: Task | undefined) => {\n          if (!old) return old;\n          return { ...old, status, updatedAt: new Date() };\n        },\n      );\n\n      // Optimistically update task lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return oldData;\n          return oldData.map((task) =>\n            task.id === taskId\n              ? { ...task, status, updatedAt: new Date() }\n              : task,\n          );\n        },\n      );\n\n      return { previousTask, previousTasks };\n    },\n    onSuccess: (\n      updatedTask: Task,\n      {\n        userId,\n        taskId,\n      }: { userId: string; taskId: string; status: TaskStatus },\n    ) => {\n      logger.info(\"Task status update successful\", {\n        taskId,\n        userId,\n        status: updatedTask.status,\n      });\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n\n      // If task was completed, invalidate pending tasks\n      if (updatedTask.status === \"completed\") {\n        queryClient.invalidateQueries({\n          queryKey: taskKeys.byStatus(userId, \"pending\"),\n        });\n      }\n    },\n    onError: (error, { taskId, userId }, context) => {\n      logger.error(\"Task status update failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n\n      // Rollback optimistic updates\n      if (context?.previousTask) {\n        queryClient.setQueryData(taskKeys.detail(taskId), context.previousTask);\n      }\n      if (context?.previousTasks) {\n        queryClient.setQueryData(taskKeys.list(userId), context.previousTasks);\n      }\n    },\n  });\n}\n\n/**\n * Update full task details\n */\nexport function useUpdateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      updates,\n    }: {\n      taskId: string;\n      userId: string;\n      updates: UpdateTaskData;\n    }): Promise<Task> => {\n      logger.info(\"Updating task\", { taskId, userId });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.update(taskId, updatedTask);\n\n      logger.info(\"Task updated successfully\", { taskId, userId });\n\n      return updatedTask;\n    },\n    onSuccess: (\n      updatedTask: Task,\n      {\n        userId,\n        taskId,\n      }: { userId: string; taskId: string; updates: UpdateTaskData },\n    ) => {\n      logger.info(\"Task update successful\", { taskId, userId });\n\n      // Update detail cache\n      queryClient.setQueryData(taskKeys.detail(taskId), updatedTask);\n\n      // Invalidate list queries to reflect changes\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task update failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n    },\n  });\n}\n\n/**\n * Delete task\n */\nexport function useDeleteTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n    }: {\n      taskId: string;\n      userId: string;\n    }): Promise<void> => {\n      logger.info(\"Deleting task\", { taskId, userId });\n\n      await taskDBService.delete(taskId);\n\n      logger.info(\"Task deleted successfully\", { taskId, userId });\n    },\n    onSuccess: (\n      _: void,\n      { taskId, userId }: { taskId: string; userId: string },\n    ) => {\n      logger.info(\"Task deletion successful\", { taskId, userId });\n\n      // Remove from detail cache\n      queryClient.removeQueries({ queryKey: taskKeys.detail(taskId) });\n\n      // Invalidate list queries\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"completed\"),\n      });\n\n      // Optimistically remove from cached lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return oldData.filter((task) => task.id !== taskId);\n        },\n      );\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task deletion failed\", {\n        error: error instanceof Error ? error.message : String(error),\n        taskId,\n        userId,\n      });\n    },\n  });\n}\n\n/**\n * Get task statistics for dashboard\n */\nexport function useTaskStats(userId: string) {\n  return useQuery({\n    queryKey: [...taskKeys.all, \"stats\", userId],\n    queryFn: async () => {\n      logger.info(\"Calculating task statistics\", { userId });\n\n      const tasks = await taskDBService.findByUserId(userId);\n\n      const stats = {\n        total: tasks.length,\n        pending: tasks.filter((t) => t.status === \"pending\").length,\n        inProgress: tasks.filter((t) => t.status === \"submitted\").length, // Use submitted instead of in_progress\n        completed: tasks.filter((t) => t.status === \"completed\").length,\n        overdue: tasks.filter((t) => {\n          if (!t.dueDate || t.status === \"completed\") return false;\n          return new Date(t.dueDate) < new Date();\n        }).length,\n        byPriority: {\n          high: tasks.filter((t) => t.priority === \"high\").length,\n          medium: tasks.filter((t) => t.priority === \"medium\").length,\n          low: tasks.filter((t) => t.priority === \"low\").length,\n        },\n        completionRate:\n          tasks.length > 0\n            ? Math.round(\n                (tasks.filter((t) => t.status === \"completed\").length /\n                  tasks.length) *\n                  100,\n              )\n            : 0,\n      };\n\n      return stats;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    enabled: !!userId,\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/statistics-calculations.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'GoalStatistics' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 17
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 20,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 28,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 33,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 38,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 43,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 63,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 68,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 80,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 85,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 96,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Statistics Calculation Utilities\n * Extracted helper functions from useStatistics\n */\n\nimport type {\n  SessionStatistics,\n  GoalStatistics,\n  MonthlyTrends,\n  WeeklyBreakdown,\n  ComparisonResult,\n  BenchmarkData,\n  TimePeriod,\n  PeriodStatistics,\n} from \"./types/statistics\";\n\n/**\n * Get statistics for a specific time period\n */\nexport function getStatsForPeriod(_period: TimePeriod): PeriodStatistics {\n  return {\n    period: _period,\n    sessionCount: 0,\n    totalTime: 0,\n    goalCompletionRate: 0,\n    averageSatisfaction: 0,\n  };\n}\n\n/**\n * Calculate monthly trends for specified number of months\n */\nexport function getMonthlyTrends(_months: number): MonthlyTrends {\n  return {\n    months: [],\n    overallTrend: \"stable\",\n  };\n}\n\n/**\n * Analyze sessions by day of week\n */\nexport function getWeeklyBreakdown(): WeeklyBreakdown {\n  return {\n    weekdays: [],\n    weekendVsWeekday: {\n      weekday: {\n        period: { start: new Date(), end: new Date(), label: \"Weekday\" },\n        sessionCount: 0,\n        totalTime: 0,\n        goalCompletionRate: 0,\n        averageSatisfaction: 0,\n      },\n      weekend: {\n        period: { start: new Date(), end: new Date(), label: \"Weekend\" },\n        sessionCount: 0,\n        totalTime: 0,\n        goalCompletionRate: 0,\n        averageSatisfaction: 0,\n      },\n    },\n  };\n}\n\n/**\n * Compare current metrics with previous period\n */\nexport function compareWithPrevious(\n  _period: TimePeriod,\n  sessionStats: SessionStatistics,\n): ComparisonResult {\n  return {\n    metric: \"session_duration\",\n    currentValue: sessionStats.averageSessionLength,\n    previousValue: sessionStats.averageSessionLength * 0.9,\n    change: sessionStats.averageSessionLength * 0.1,\n    changePercentage: 10,\n    trend: \"improving\",\n  };\n}\n\n/**\n * Compare user metrics with anonymized community benchmarks\n */\nexport function getBenchmarkComparisons(\n  sessionStats: SessionStatistics,\n): BenchmarkData[] {\n  return [\n    {\n      userValue: sessionStats.averageSessionLength,\n      averageValue: 3000, // 50 minutes average\n      percentile: 75,\n      category: \"session_duration\",\n    },\n  ];\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/statistics-keyholder.ts",
    "messages": [
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 16,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 45,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 50,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 60,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Keyholder Statistics Utilities\n * Functions for keyholder dashboard and relationship stats\n */\n\nimport type {\n  KeyholderDashboardStats,\n  RelationshipComparisonStats,\n  SessionStatistics,\n  GoalStatistics,\n} from \"./types/statistics\";\n\n/**\n * Generate keyholder dashboard data\n */\nexport function generateKeyholderDashboard(\n  consistencyRating: number,\n  sessionStats: SessionStatistics,\n  goalStats: GoalStatistics,\n): KeyholderDashboardStats {\n  return {\n    submissiveOverview: {\n      name: \"Submissive\",\n      consistencyScore: consistencyRating,\n      improvementTrend: \"improving\",\n      lastActiveDate: new Date(),\n    },\n    sessionSummary: {\n      thisWeek: sessionStats.sessionsThisWeek,\n      thisMonth: sessionStats.sessionsThisMonth,\n      averageDuration: sessionStats.averageSessionLength,\n      completionRate: sessionStats.completionRate,\n    },\n    goalTracking: {\n      activeGoals: [],\n      completionRate: goalStats.completionRate,\n      upcomingDeadlines: [],\n    },\n    behaviorInsights: {\n      strengths: [],\n      areasForImprovement: [],\n      recommendations: [],\n    },\n  };\n}\n\n/**\n * Generate relationship comparison statistics\n */\nexport function generateRelationshipComparison(\n  sessionStats: SessionStatistics,\n): RelationshipComparisonStats {\n  return {\n    relationshipDuration: 90, // days\n    sharedSessions: sessionStats.sessionsThisMonth,\n    collaborationScore: 85,\n    satisfactionTrend: \"improving\",\n    milestones: [],\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/statistics-predictions.ts",
    "messages": [
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 14,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 27,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 32,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "restrictedSyntax",
        "endLine": 45,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Predictive Analytics Utilities\n * Functions for generating predictions and recommendations\n */\n\nimport type {\n  PredictiveInsights,\n  Recommendation,\n} from \"./types/statistics\";\n\n/**\n * Generate predictive insights based on user data\n */\nexport function generatePredictiveInsights(): PredictiveInsights {\n  return {\n    nextSessionSuccess: {\n      probability: 85,\n      factors: [\"consistent schedule\", \"appropriate goal setting\"],\n    },\n    goalAchievementLikelihood: [],\n    riskAssessment: {\n      burnoutRisk: \"low\",\n      consistencyRisk: \"low\",\n      factors: [],\n    },\n  };\n}\n\n/**\n * Generate personalized recommendations\n */\nexport function generateRecommendations(): Recommendation[] {\n  return [\n    {\n      id: \"rec1\",\n      type: \"session\",\n      title: \"Optimize Session Timing\",\n      description:\n        \"Consider starting sessions earlier in the day for better completion rates\",\n      priority: \"medium\",\n      expectedImpact: \"Improved session completion rate\",\n      actionRequired: \"Adjust session start time\",\n    },\n  ];\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/dataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/types/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useConflictResolution.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useDataSync.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (333). Maximum allowed is 75.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (31). Maximum allowed is 25.",
        "line": 37,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 481,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeRealTimeSync', 'loadPendingConflicts', 'loadRelationshipSyncStatus', 'loadSyncHistory', and 'loadSyncPermissions'. Either include them or remove the dependency array.",
        "line": 151,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 151,
        "endColumn": 49,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]",
            "fix": {
              "range": [4192, 4235],
              "text": "[userId, syncPermissions.allowRealTimeSync, loadSyncPermissions, loadSyncHistory, loadPendingConflicts, loadRelationshipSyncStatus, initializeRealTimeSync]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'performBackgroundSync'. Either include it or remove the dependency array.",
        "line": 167,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 167,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [performBackgroundSync, realTimeSyncEnabled, syncPermissions]",
            "fix": {
              "range": [4812, 4850],
              "text": "[performBackgroundSync, realTimeSyncEnabled, syncPermissions]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Data Synchronization Hook\n * Handles multi-user data sync, relationship data, and conflict resolution\n * with proper privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { SyncResult } from \"../../types/database\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateOverallSyncQuality,\n  getLastSuccessfulSync,\n  getSyncInterval,\n} from \"../../utils/dataSyncHelpers\";\nimport { useConflictResolution } from \"./useConflictResolution\";\nimport { useSyncBackup } from \"./useSyncBackup\";\nimport { useSyncMonitoring } from \"./useSyncMonitoring\";\n\nconst logger = serviceLogger(\"useDataSync\");\n\n// ==================== INTERFACES ====================\n\nimport type {\n  SyncStatus,\n  RelationshipSyncStatus,\n  DataConflict,\n  SyncPermissions,\n  SyncMetrics,\n  SyncScope,\n  DataEntityType,\n  RelationshipSyncResult,\n} from \"./types/dataSync\";\nimport type * as _Types from \"./types/dataSync\";\nexport type * from \"./types/dataSync\";\n\n// Complex sync orchestration hook requires many statements for proper state management\n// eslint-disable-next-line max-statements\nexport const useDataSync = (userId: string) => {\n  // ==================== STATE ====================\n\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    state: \"idle\",\n    lastSync: null,\n    progress: 0,\n    message: \"Ready to sync\",\n    error: null,\n  });\n\n  const [relationshipSync, setRelationshipSync] = useState<\n    RelationshipSyncStatus[]\n  >([]);\n\n  const [conflicts, setConflicts] = useState<DataConflict[]>([]);\n\n  const [syncPermissions, setSyncPermissions] = useState<SyncPermissions>({\n    allowDataSharing: true,\n    shareSessionData: true,\n    shareGoalData: true,\n    shareTaskData: true,\n    shareEventData: false,\n    allowRealTimeSync: false,\n    syncFrequency: \"moderate\",\n    privacyLevel: \"relationship_only\",\n  });\n\n  const [syncMetrics, setSyncMetrics] = useState<SyncMetrics>({\n    totalSyncs: 0,\n    successfulSyncs: 0,\n    failedSyncs: 0,\n    averageSyncTime: 0,\n    dataTransferred: 0,\n    conflictsResolved: 0,\n    lastSuccessfulSync: null,\n    reliabilityScore: 100,\n  });\n\n  const [realTimeSyncEnabled, setRealTimeSyncEnabled] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== SUB-HOOKS ====================\n\n  const conflictResolution = useConflictResolution({\n    conflicts,\n    setConflicts,\n    setSyncMetrics,\n  });\n\n  const syncBackup = useSyncBackup({ userId });\n\n  const syncMonitoring = useSyncMonitoring({ conflicts, syncMetrics });\n\n  // ==================== COMPUTED VALUES ====================\n\n  const isSyncing = useMemo(\n    () => syncStatus.state === \"syncing\",\n    [syncStatus.state],\n  );\n\n  const hasConflicts = useMemo(() => conflicts.length > 0, [conflicts.length]);\n\n  const syncQuality = useMemo(\n    () => calculateOverallSyncQuality(relationshipSync),\n    [relationshipSync],\n  );\n\n  const lastSuccessfulSync = useMemo(\n    () => getLastSuccessfulSync(syncMetrics),\n    [syncMetrics],\n  );\n\n  const needsAttention = useMemo(\n    () =>\n      conflicts.some((c) => c.priority === \"high\" || c.priority === \"critical\"),\n    [conflicts],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSync = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load sync state and configuration\n        await Promise.all([\n          loadSyncPermissions(),\n          loadSyncHistory(),\n          loadPendingConflicts(),\n          loadRelationshipSyncStatus(),\n        ]);\n\n        // Initialize real-time sync if enabled\n        if (syncPermissions.allowRealTimeSync) {\n          await initializeRealTimeSync();\n        }\n      } catch (err) {\n        logger.error(\"Failed to initialize data sync\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize sync\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSync();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, syncPermissions.allowRealTimeSync]);\n\n  // ==================== REAL-TIME SYNC ====================\n\n  useEffect(() => {\n    if (!realTimeSyncEnabled || !syncPermissions.allowRealTimeSync) return;\n\n    const syncInterval = getSyncInterval(syncPermissions.syncFrequency);\n    const interval = setInterval(() => {\n      performBackgroundSync();\n    }, syncInterval);\n\n    return () => clearInterval(interval);\n    // performBackgroundSync is stable (no deps)\n    // realTimeSyncEnabled and syncPermissions trigger re-setup of interval when changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [realTimeSyncEnabled, syncPermissions]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSyncPermissions = useCallback(async () => {\n    try {\n      // Load user's sync preferences from database\n      logger.debug(\"Loading sync permissions\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync permissions\", { error });\n    }\n  }, [userId]);\n\n  const loadSyncHistory = useCallback(async () => {\n    try {\n      // Load sync metrics and history\n      logger.debug(\"Loading sync history\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load sync history\", { error });\n    }\n  }, [userId]);\n\n  const loadPendingConflicts = useCallback(async () => {\n    try {\n      // Load unresolved conflicts\n      setConflicts([]);\n      logger.debug(\"Loading pending conflicts\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load pending conflicts\", { error });\n    }\n  }, [userId]);\n\n  const loadRelationshipSyncStatus = useCallback(async () => {\n    try {\n      // Load sync status for all relationships\n      setRelationshipSync([]);\n      logger.debug(\"Loading relationship sync status\", { userId });\n    } catch (error) {\n      logger.error(\"Failed to load relationship sync status\", { error });\n    }\n  }, [userId]);\n\n  // ==================== MANUAL SYNC OPERATIONS ====================\n\n  const forceSyncAll = useCallback(async (): Promise<SyncResult> => {\n    try {\n      logger.debug(\"Starting force sync all\", { userId });\n\n      setSyncStatus({\n        state: \"syncing\",\n        lastSync: null,\n        progress: 0,\n        message: \"Starting synchronization...\",\n        error: null,\n      });\n\n      // Simulate sync process\n      for (let i = 0; i <= 100; i += 20) {\n        setSyncStatus((prev) => ({\n          ...prev,\n          progress: i,\n          message: `Syncing... ${i}%`,\n        }));\n        await new Promise((resolve) => setTimeout(resolve, 200));\n      }\n\n      const result: SyncResult = {\n        success: true,\n        operations: {\n          uploaded: 15,\n          downloaded: 8,\n          conflicts: 2,\n        },\n        conflicts: [],\n        timestamp: new Date(),\n      };\n\n      setSyncStatus({\n        state: \"completed\",\n        lastSync: new Date(),\n        progress: 100,\n        message: \"Sync completed successfully\",\n        error: null,\n      });\n\n      // Update metrics\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        successfulSyncs: prev.successfulSyncs + 1,\n        lastSuccessfulSync: new Date(),\n      }));\n\n      logger.info(\"Force sync completed successfully\", { result });\n      return result;\n    } catch (error) {\n      logger.error(\"Force sync failed\", { error });\n\n      setSyncStatus({\n        state: \"error\",\n        lastSync: null,\n        progress: 0,\n        message: \"Sync failed\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      setSyncMetrics((prev) => ({\n        ...prev,\n        totalSyncs: prev.totalSyncs + 1,\n        failedSyncs: prev.failedSyncs + 1,\n      }));\n\n      throw error;\n    }\n  }, [userId]);\n\n  const syncRelationshipData = useCallback(\n    async (relationshipId: string): Promise<RelationshipSyncResult> => {\n      try {\n        logger.debug(\"Syncing relationship data\", { relationshipId });\n\n        const startTime = Date.now();\n\n        // Find relationship sync status\n        const relationshipStatus = relationshipSync.find(\n          (rs) => rs.relationshipId === relationshipId,\n        );\n        if (!relationshipStatus) {\n          throw new Error(\"Relationship not found\");\n        }\n\n        // Perform relationship-specific sync\n        const result: RelationshipSyncResult = {\n          relationshipId,\n          success: true,\n          syncedCollections: [\"sessions\", \"goals\", \"tasks\"],\n          conflictsFound: 1,\n          conflictsResolved: 0,\n          metrics: {\n            duration: Date.now() - startTime,\n            itemsSynced: 12,\n            bytesTransferred: 4096,\n          },\n        };\n\n        // Update relationship sync status\n        setRelationshipSync((prev) =>\n          prev.map((rs) =>\n            rs.relationshipId === relationshipId\n              ? { ...rs, lastSync: new Date() }\n              : rs,\n          ),\n        );\n\n        logger.info(\"Relationship sync completed\", { relationshipId, result });\n        return result;\n      } catch (error) {\n        logger.error(\"Relationship sync failed\", { error, relationshipId });\n\n        return {\n          relationshipId,\n          success: false,\n          syncedCollections: [],\n          conflictsFound: 0,\n          conflictsResolved: 0,\n          error: error instanceof Error ? error.message : \"Unknown error\",\n          metrics: {\n            duration: 0,\n            itemsSynced: 0,\n            bytesTransferred: 0,\n          },\n        };\n      }\n    },\n    [relationshipSync],\n  );\n\n  // ==================== PRIVACY AND PERMISSIONS ====================\n\n  const updateSyncPermissions = useCallback(\n    async (permissions: Partial<SyncPermissions>): Promise<void> => {\n      try {\n        logger.debug(\"Updating sync permissions\", { permissions });\n\n        const updatedPermissions = { ...syncPermissions, ...permissions };\n        setSyncPermissions(updatedPermissions);\n\n        // Update real-time sync based on new permissions\n        if (\n          updatedPermissions.allowRealTimeSync !==\n          syncPermissions.allowRealTimeSync\n        ) {\n          if (updatedPermissions.allowRealTimeSync) {\n            await initializeRealTimeSync();\n          } else {\n            setRealTimeSyncEnabled(false);\n          }\n        }\n\n        logger.info(\"Sync permissions updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update sync permissions\", { error });\n        throw error;\n      }\n    },\n    [syncPermissions, initializeRealTimeSync],\n  );\n\n  const configureSyncScope = useCallback(\n    async (scope: SyncScope): Promise<void> => {\n      try {\n        logger.debug(\"Configuring sync scope\", { scope });\n        // Configure what data gets synced\n        logger.info(\"Sync scope configured successfully\");\n      } catch (error) {\n        logger.error(\"Failed to configure sync scope\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== REAL-TIME SYNC ====================\n\n  const enableRealtimeSync = useCallback(\n    (entityTypes: DataEntityType[]): void => {\n      try {\n        logger.debug(\"Enabling realtime sync\", { entityTypes });\n        setRealTimeSyncEnabled(true);\n        // Set up WebSocket connections or other real-time mechanisms\n        logger.info(\"Realtime sync enabled successfully\");\n      } catch (error) {\n        logger.error(\"Failed to enable realtime sync\", { error });\n      }\n    },\n    [],\n  );\n\n  const disableRealtimeSync = useCallback((): void => {\n    try {\n      logger.debug(\"Disabling realtime sync\");\n      setRealTimeSyncEnabled(false);\n      // Clean up real-time connections\n      logger.info(\"Realtime sync disabled successfully\");\n    } catch (error) {\n      logger.error(\"Failed to disable realtime sync\", { error });\n    }\n  }, []);\n\n  // ==================== PRIVATE HELPER FUNCTIONS ====================\n\n  const initializeRealTimeSync = useCallback(async (): Promise<void> => {\n    try {\n      logger.debug(\"Initializing real-time sync\");\n      setRealTimeSyncEnabled(true);\n      // Set up WebSocket connections, event listeners, etc.\n    } catch (error) {\n      logger.error(\"Failed to initialize real-time sync\", { error });\n    }\n  }, []);\n\n  const performBackgroundSync = useCallback(async (): Promise<void> => {\n    try {\n      // Perform lightweight background sync\n      logger.debug(\"Performing background sync\");\n    } catch (error) {\n      logger.error(\"Background sync failed\", { error });\n    }\n  }, []);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Sync state\n    syncStatus,\n    relationshipSync,\n    conflicts,\n    syncMetrics,\n\n    // Manual sync operations\n    forceSyncAll,\n    syncRelationshipData,\n\n    // Conflict resolution (from useConflictResolution hook)\n    resolveConflict: conflictResolution.resolveConflict,\n    resolveAllConflicts: conflictResolution.resolveAllConflicts,\n\n    // Privacy and permissions\n    updateSyncPermissions,\n    configureSyncScope,\n\n    // Real-time sync\n    enableRealtimeSync,\n    disableRealtimeSync,\n\n    // Backup and recovery (from useSyncBackup hook)\n    createBackup: syncBackup.createBackup,\n    restoreFromBackup: syncBackup.restoreFromBackup,\n\n    // Monitoring (from useSyncMonitoring hook)\n    getSyncHealth: syncMonitoring.getSyncHealth,\n    getSyncHistory: syncMonitoring.getSyncHistory,\n\n    // Computed values\n    isSyncing,\n    hasConflicts,\n    syncQuality,\n    lastSuccessfulSync,\n    needsAttention,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (80). Maximum allowed is 75.",
        "line": 27,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 117,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { collection, query, getDocs, where, orderBy } from \"firebase/firestore\";\nimport { db } from \"../../firebase\";\n\n/**\n * @typedef {Object} SessionStats\n * @property {number} totalSessions\n * @property {number} averageDuration\n * @property {number} longestSession\n * @property {number} totalTimeInChastity\n */\n\n/**\n * @typedef {Object} StatisticsOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {Object} [dateRange]\n * @property {Date} dateRange.start\n * @property {Date} dateRange.end\n */\n\n/**\n * Hook for fetching and calculating session statistics\n * @param {StatisticsOptions} options\n * @returns {Object}\n */\nexport const useStatistics = ({ userId, isAuthReady, dateRange }) => {\n  const [stats, setStats] = useState({\n    totalSessions: 0,\n    averageDuration: 0,\n    longestSession: 0,\n    totalTimeInChastity: 0,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchStatistics = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = collection(db, \"users\", userId, \"sessions\");\n      let q = query(userDocRef, orderBy(\"startTime\", \"desc\"));\n\n      if (dateRange) {\n        q = query(\n          userDocRef,\n          where(\"startTime\", \">=\", dateRange.start),\n          where(\"startTime\", \"<=\", dateRange.end),\n          orderBy(\"startTime\", \"desc\"),\n        );\n      }\n\n      const querySnapshot = await getDocs(q);\n      const sessions = querySnapshot.docs.map((doc) => ({\n        id: doc.id,\n        ...doc.data(),\n        startTime: doc.data().startTime?.toDate(),\n        endTime: doc.data().endTime?.toDate(),\n      }));\n\n      const totalSessions = sessions.length;\n      const durations = sessions\n        .filter((session) => session.startTime && session.endTime)\n        .map(\n          (session) =>\n            (session.endTime.getTime() - session.startTime.getTime()) / 1000,\n        );\n\n      const totalTimeInChastity = durations.reduce(\n        (acc, duration) => acc + duration,\n        0,\n      );\n      const averageDuration =\n        totalSessions > 0 ? totalTimeInChastity / totalSessions : 0;\n      const longestSession = durations.length > 0 ? Math.max(...durations) : 0;\n\n      setStats({\n        totalSessions,\n        averageDuration,\n        longestSession,\n        totalTimeInChastity,\n      });\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : \"Failed to fetch statistics\",\n      );\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, dateRange]);\n\n  useEffect(() => {\n    fetchStatistics();\n  }, [fetchStatistics]);\n\n  const formattedStats = useMemo(\n    () => ({\n      ...stats,\n      averageDurationFormatted: formatDuration(stats.averageDuration),\n      longestSessionFormatted: formatDuration(stats.longestSession),\n      totalTimeFormatted: formatDuration(stats.totalTimeInChastity),\n    }),\n    [stats],\n  );\n\n  return {\n    stats: formattedStats,\n    isLoading,\n    error,\n    refetch: fetchStatistics,\n  };\n};\n\n/**\n * Format duration in seconds to human readable string\n * @param {number} seconds\n * @returns {string}\n */\nfunction formatDuration(seconds) {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n\n  if (days > 0) {\n    return `${days}d ${hours}h ${minutes}m`;\n  } else if (hours > 0) {\n    return `${hours}h ${minutes}m`;\n  } else {\n    return `${minutes}m`;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useStatistics.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'PeriodStatistics' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 46,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 46,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MonthlyTrends' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 47,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 47,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'WeeklyBreakdown' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 48,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 48,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ComparisonResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 49,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 49,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'BenchmarkData' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 50,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 50,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'KeyholderDashboardStats' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 51,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 51,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'RelationshipComparisonStats' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 53,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 53,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'PredictiveInsights' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 54,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 54,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Recommendation' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 55,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 55,
        "endColumn": 17
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (399). Maximum allowed is 75.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 551,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (33). Maximum allowed is 25.",
        "line": 65,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 551,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievementStatistics', 'loadComparativeStatistics', 'loadGoalStatistics', 'loadPredictiveAnalytics', 'loadRecommendations', 'loadSessionStatistics', and 'loadSharedStatistics'. Either include them or remove the dependency array.",
        "line": 245,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 245,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]",
            "fix": {
              "range": [6496, 6520],
              "text": "[userId, relationshipId, loadSessionStatistics, loadGoalStatistics, loadAchievementStatistics, loadComparativeStatistics, loadSharedStatistics, loadPredictiveAnalytics, loadRecommendations]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Comprehensive Statistics Hook\n * Provides analytics and insights for both users and keyholders\n * with appropriate privacy controls\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateImprovementScore,\n  calculateConsistencyRating,\n  calculateOverallProgress,\n  calculateKeyholderSatisfaction,\n} from \"../../utils/statisticsHelpers\";\nimport {\n  getStatsForPeriod as calculateStatsForPeriod,\n  getMonthlyTrends as calculateMonthlyTrends,\n  getWeeklyBreakdown as calculateWeeklyBreakdown,\n  compareWithPrevious as compareMetricsWithPrevious,\n  getBenchmarkComparisons as calculateBenchmarkComparisons,\n} from \"./statistics-calculations\";\nimport {\n  generateKeyholderDashboard,\n  generateRelationshipComparison,\n} from \"./statistics-keyholder\";\nimport {\n  generatePredictiveInsights,\n  generateRecommendations,\n} from \"./statistics-predictions\";\n\nconst logger = serviceLogger(\"useStatistics\");\n\n// ==================== INTERFACES ====================\n\n// Re-export all types from the types file\nexport type * from \"./types/statistics\";\n\nimport type {\n  SessionStatistics,\n  GoalStatistics,\n  AchievementStatistics,\n  ComparativeStatistics,\n  SharedStatistics,\n  PredictiveAnalytics,\n  RecommendationEngine,\n  TimePeriod,\n  PeriodStatistics,\n  MonthlyTrends,\n  WeeklyBreakdown,\n  ComparisonResult,\n  BenchmarkData,\n  KeyholderDashboardStats,\n  KeyholderStatisticsView,\n  RelationshipComparisonStats,\n  PredictiveInsights,\n  Recommendation,\n  StatisticsExport,\n  StatisticType,\n  ExportFormat,\n} from \"./types/statistics\";\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex statistics aggregation hook requires many statements for comprehensive metrics\n// eslint-disable-next-line max-statements\nexport const useStatistics = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessionStats, setSessionStats] = useState<SessionStatistics>({\n    totalSessionTime: 0,\n    averageSessionLength: 0,\n    longestSession: 0,\n    shortestSession: 0,\n    sessionsThisWeek: 0,\n    sessionsThisMonth: 0,\n    sessionFrequency: {\n      daily: 0,\n      weekly: 0,\n      monthly: 0,\n      trend: \"stable\",\n    },\n    completionRate: 0,\n    goalAchievementRate: 0,\n    satisfactionRating: 0,\n    trends: [],\n    streaks: {\n      current: 0,\n      longest: 0,\n      type: \"session_consistency\",\n    },\n  });\n\n  const [goalStats, setGoalStats] = useState<GoalStatistics>({\n    totalGoals: 0,\n    completedGoals: 0,\n    activeGoals: 0,\n    completionRate: 0,\n    averageCompletionTime: 0,\n    mostCommonGoalTypes: [],\n    hardestGoalTypes: [],\n    goalStreaks: {\n      current: 0,\n      longest: 0,\n      type: \"goal_completion\",\n    },\n  });\n\n  const [achievementStats, setAchievementStats] =\n    useState<AchievementStatistics>({\n      totalAchievements: 0,\n      recentAchievements: [],\n      achievementsByCategory: [],\n      rareAchievements: [],\n      achievementPoints: 0,\n      percentileRank: 0,\n    });\n\n  const [comparativeStats, setComparativeStats] =\n    useState<ComparativeStatistics>({\n      userPercentile: 50,\n      averageUserStats: sessionStats,\n      personalBest: {\n        longestSession: 0,\n        mostGoalsInSession: 0,\n        longestStreak: 0,\n        highestSatisfactionRating: 0,\n        bestMonth: {\n          month: \"\",\n          year: 0,\n          totalTime: 0,\n          sessionCount: 0,\n        },\n      },\n      improvements: {\n        sessionLength: { improvement: 0, timeframe: \"month\" },\n        consistency: { improvement: 0, timeframe: \"month\" },\n        goalCompletion: { improvement: 0, timeframe: \"month\" },\n      },\n    });\n\n  const [sharedStats, setSharedStats] = useState<SharedStatistics>({\n    allowedMetrics: [],\n    keyholderView: {\n      sessionOverview: {\n        totalSessions: 0,\n        averageDuration: 0,\n        lastSessionDate: new Date(),\n      },\n      goalProgress: {\n        activeGoals: 0,\n        completionRate: 0,\n      },\n      behaviorPatterns: {\n        consistency: 0,\n        pauseFrequency: 0,\n        improvementTrend: \"stable\",\n      },\n      allowedInsights: [],\n    },\n    lastSharedAt: new Date(),\n    sharingLevel: \"basic\",\n  });\n\n  const [_predictiveAnalytics, setPredictiveAnalytics] =\n    useState<PredictiveAnalytics>({\n      nextSessionPrediction: {\n        suggestedDuration: 0,\n        successProbability: 0,\n        optimalStartTime: new Date(),\n        riskFactors: [],\n      },\n      goalRecommendations: [],\n      improvementOpportunities: [],\n      trendPredictions: [],\n    });\n\n  const [_recommendations, setRecommendations] = useState<RecommendationEngine>(\n    {\n      sessionRecommendations: [],\n      goalRecommendations: [],\n      behaviorInsights: [],\n      personalizedTips: [],\n    },\n  );\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const improvementScore = useMemo(\n    () => calculateImprovementScore(sessionStats.trends),\n    [sessionStats.trends],\n  );\n\n  const consistencyRating = useMemo(\n    () => calculateConsistencyRating(sessionStats),\n    [sessionStats],\n  );\n\n  const overallProgress = useMemo(\n    () => calculateOverallProgress(goalStats),\n    [goalStats],\n  );\n\n  const keyholderSatisfaction = useMemo(\n    () => calculateKeyholderSatisfaction(sharedStats),\n    [sharedStats],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeStatistics = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load all statistics data\n        await Promise.all([\n          loadSessionStatistics(),\n          loadGoalStatistics(),\n          loadAchievementStatistics(),\n          loadComparativeStatistics(),\n          loadSharedStatistics(),\n          loadPredictiveAnalytics(),\n          loadRecommendations(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize statistics\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize statistics\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeStatistics();\n    // Callback functions are stable and don't need to be in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessionStatistics = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Calculate session statistics from historical data\n      const mockStats: SessionStatistics = {\n        totalSessionTime: 7200, // 2 hours\n        averageSessionLength: 3600, // 1 hour\n        longestSession: 7200,\n        shortestSession: 1800,\n        sessionsThisWeek: 3,\n        sessionsThisMonth: 12,\n        sessionFrequency: {\n          daily: 0.4,\n          weekly: 3,\n          monthly: 12,\n          trend: \"stable\",\n        },\n        completionRate: 85,\n        goalAchievementRate: 75,\n        satisfactionRating: 4.2,\n        trends: [],\n        streaks: {\n          current: 5,\n          longest: 12,\n          type: \"session_consistency\",\n        },\n      };\n\n      setSessionStats(mockStats);\n    } catch (error) {\n      logger.error(\"Failed to load session statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadGoalStatistics = useCallback(async () => {\n    try {\n      // Calculate goal statistics from historical goal data\n      setGoalStats({\n        totalGoals: 25,\n        completedGoals: 20,\n        activeGoals: 3,\n        completionRate: 80,\n        averageCompletionTime: 48, // hours\n        mostCommonGoalTypes: [],\n        hardestGoalTypes: [],\n        goalStreaks: {\n          current: 3,\n          longest: 8,\n          type: \"goal_completion\",\n        },\n      });\n    } catch (error) {\n      logger.error(\"Failed to load goal statistics\", { error });\n    }\n  }, []); // userId not actually used in mock implementation\n\n  const loadAchievementStatistics = useCallback(async () => {\n    try {\n      // Load achievement data\n      setAchievementStats({\n        totalAchievements: 15,\n        recentAchievements: [],\n        achievementsByCategory: [],\n        rareAchievements: [],\n        achievementPoints: 1500,\n        percentileRank: 75,\n      });\n    } catch (error) {\n      logger.error(\"Failed to load achievement statistics\", { error });\n    }\n  }, []);\n\n  const loadComparativeStatistics = useCallback(async () => {\n    try {\n      // Load comparative data (anonymized benchmarks)\n      setComparativeStats((prev) => ({\n        ...prev,\n        userPercentile: 72,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load comparative statistics\", { error });\n    }\n  }, []); // sessionStats not actually used for computation\n\n  const loadSharedStatistics = useCallback(async () => {\n    try {\n      if (!relationshipId) return;\n\n      // Load keyholder-specific statistics view\n      const keyholderView: KeyholderStatisticsView = {\n        sessionOverview: {\n          totalSessions: sessionStats.sessionsThisMonth,\n          averageDuration: sessionStats.averageSessionLength,\n          lastSessionDate: new Date(),\n        },\n        goalProgress: {\n          activeGoals: goalStats.activeGoals,\n          completionRate: goalStats.completionRate,\n        },\n        behaviorPatterns: {\n          consistency: consistencyRating,\n          pauseFrequency: 0.2,\n          improvementTrend: \"improving\",\n        },\n        allowedInsights: [\"session_duration\", \"goal_completion\"],\n      };\n\n      setSharedStats((prev) => ({\n        ...prev,\n        keyholderView,\n      }));\n    } catch (error) {\n      logger.error(\"Failed to load shared statistics\", { error });\n    }\n  }, [\n    relationshipId,\n    consistencyRating,\n    sessionStats.sessionsThisMonth,\n    sessionStats.averageSessionLength,\n    goalStats.activeGoals,\n    goalStats.completionRate,\n  ]);\n\n  const loadPredictiveAnalytics = useCallback(async () => {\n    try {\n      // Generate predictive insights based on historical data\n      setPredictiveAnalytics({\n        nextSessionPrediction: {\n          suggestedDuration: sessionStats.averageSessionLength * 1.1,\n          successProbability: 85,\n          optimalStartTime: new Date(),\n          riskFactors: [],\n        },\n        goalRecommendations: [],\n        improvementOpportunities: [],\n        trendPredictions: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load predictive analytics\", { error });\n    }\n  }, [sessionStats.averageSessionLength]);\n\n  const loadRecommendations = useCallback(async () => {\n    try {\n      // Generate personalized recommendations\n      setRecommendations({\n        sessionRecommendations: [],\n        goalRecommendations: [],\n        behaviorInsights: [],\n        personalizedTips: [],\n      });\n    } catch (error) {\n      logger.error(\"Failed to load recommendations\", { error });\n    }\n  }, []); // Static data for recommendations\n\n  // ==================== TIME-BASED QUERIES ====================\n\n  const getStatsForPeriod = useCallback(\n    (period: TimePeriod) => calculateStatsForPeriod(period),\n    [],\n  );\n\n  const getMonthlyTrends = useCallback(\n    (months: number) => calculateMonthlyTrends(months),\n    [],\n  );\n\n  const getWeeklyBreakdown = useCallback(\n    () => calculateWeeklyBreakdown(),\n    [],\n  );\n\n  // ==================== COMPARATIVE ANALYSIS ====================\n\n  const compareWithPrevious = useCallback(\n    (period: TimePeriod) => compareMetricsWithPrevious(period, sessionStats),\n    [sessionStats],\n  );\n\n  const getBenchmarkComparisons = useCallback(\n    () => calculateBenchmarkComparisons(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== KEYHOLDER FEATURES ====================\n\n  const getKeyholderDashboard = useCallback(\n    () => generateKeyholderDashboard(consistencyRating, sessionStats, goalStats),\n    [consistencyRating, sessionStats, goalStats],\n  );\n\n  const getRelationshipComparison = useCallback(\n    () => generateRelationshipComparison(sessionStats),\n    [sessionStats],\n  );\n\n  // ==================== PREDICTIVE ANALYTICS ====================\n\n  const getPredictiveInsights = useCallback(\n    () => generatePredictiveInsights(),\n    [],\n  );\n\n  const getRecommendations = useCallback(\n    () => generateRecommendations(),\n    [],\n  );\n\n  // ==================== EXPORT AND SHARING ====================\n\n  const exportStatistics = useCallback(\n    async (format: ExportFormat): Promise<StatisticsExport> => {\n      try {\n        logger.debug(\"Exporting statistics\", { format, userId });\n\n        const exportData = {\n          sessionStats,\n          goalStats,\n          achievementStats,\n          exportedAt: new Date(),\n        };\n\n        return {\n          format,\n          data: exportData,\n          generatedAt: new Date(),\n          fileSize: JSON.stringify(exportData).length,\n          downloadUrl: \"https://example.com/download/stats\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to export statistics\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionStats, goalStats, achievementStats],\n  );\n\n  const shareWithKeyholder = useCallback(\n    async (statTypes: StatisticType[]): Promise<void> => {\n      try {\n        if (!relationshipId) {\n          throw new Error(\"No keyholder relationship found\");\n        }\n\n        logger.debug(\"Sharing statistics with keyholder\", { statTypes });\n\n        setSharedStats((prev) => ({\n          ...prev,\n          allowedMetrics: statTypes,\n          lastSharedAt: new Date(),\n        }));\n\n        logger.info(\"Statistics shared with keyholder successfully\");\n      } catch (error) {\n        logger.error(\"Failed to share statistics with keyholder\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Statistics\n    sessionStats,\n    goalStats,\n    achievementStats,\n    comparativeStats,\n\n    // Time-based queries\n    getStatsForPeriod,\n    getMonthlyTrends,\n    getWeeklyBreakdown,\n\n    // Comparative analysis\n    compareWithPrevious,\n    getBenchmarkComparisons,\n\n    // Keyholder features\n    getKeyholderDashboard,\n    getRelationshipComparison,\n\n    // Predictive analytics\n    getPredictiveInsights,\n    getRecommendations,\n\n    // Export and sharing\n    exportStatistics,\n    shareWithKeyholder,\n\n    // Computed values\n    improvementScore,\n    consistencyRating,\n    overallProgress,\n    keyholderSatisfaction,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncBackup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/data/useSyncMonitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/account-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/display-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/gamification-constants.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'BadgeCategory' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 13,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 16
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 18,
        "column": 14,
        "nodeType": "VariableDeclarator",
        "messageId": "restrictedSyntax",
        "endLine": 26,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 29,
        "column": 14,
        "nodeType": "VariableDeclarator",
        "messageId": "restrictedSyntax",
        "endLine": 32,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 35,
        "column": 14,
        "nodeType": "VariableDeclarator",
        "messageId": "restrictedSyntax",
        "endLine": 74,
        "endColumn": 2
      },
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 77,
        "column": 14,
        "nodeType": "VariableDeclarator",
        "messageId": "restrictedSyntax",
        "endLine": 121,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Gamification Constants and Sample Data\n * Extracted from useGameification for better code organization\n */\n\nimport {\n  Challenge,\n  ChallengeType,\n  ChallengeDifficulty,\n  PlayerProfile,\n  PlayerTitle,\n  LeaderboardCategory,\n  BadgeCategory,\n  ExperienceSource,\n} from \"../../types/gamification\";\n\n// Experience values by source\nexport const EXPERIENCE_VALUES = {\n  [ExperienceSource.SESSION_COMPLETE]: 100,\n  [ExperienceSource.CHALLENGE_COMPLETE]: 250,\n  [ExperienceSource.MILESTONE_REACHED]: 150,\n  [ExperienceSource.BEHAVIOR_IMPROVEMENT]: 75,\n  [ExperienceSource.DAILY_CHECK_IN]: 25,\n  [ExperienceSource.SOCIAL_INTERACTION]: 50,\n  [ExperienceSource.GOAL_ACHIEVEMENT]: 200,\n};\n\n// Level thresholds\nexport const LEVEL_THRESHOLDS = [\n  0, 100, 250, 500, 1000, 1750, 2750, 4000, 5500, 7500, 10000, 13000, 16500,\n  20500, 25000, 30000, 35500, 41500, 48000, 55000, 62500,\n];\n\n// Default player profile\nexport const DEFAULT_PLAYER_PROFILE: PlayerProfile = {\n  level: 1,\n  experience: 0,\n  experienceToNext: 100,\n  title: PlayerTitle.NOVICE,\n  badges: [],\n  stats: {\n    totalExperience: 0,\n    challengesCompleted: 0,\n    currentStreak: 0,\n    longestStreak: 0,\n    totalDuration: 0,\n    badgesEarned: 0,\n    leaderboardRank: {\n      [LeaderboardCategory.EXPERIENCE]: 0,\n      [LeaderboardCategory.DURATION]: 0,\n      [LeaderboardCategory.CHALLENGES]: 0,\n      [LeaderboardCategory.STREAKS]: 0,\n      [LeaderboardCategory.SOCIAL]: 0,\n    },\n    socialConnections: 0,\n    achievementPoints: 0,\n  },\n  preferences: {\n    showLevel: true,\n    showBadges: true,\n    participateInLeaderboards: true,\n    allowSocialFeatures: true,\n    notificationSettings: {\n      levelUp: true,\n      badgeEarned: true,\n      challengeComplete: true,\n      leaderboardUpdate: false,\n      socialActivity: true,\n      seasonalEvents: true,\n    },\n  },\n  joinedAt: new Date(),\n  lastActive: new Date(),\n};\n\n// Sample challenges\nexport const SAMPLE_CHALLENGES: Challenge[] = [\n  {\n    id: \"challenge-streak-7\",\n    type: ChallengeType.DURATION,\n    name: \"7-Day Streak\",\n    description: \"Maintain a 7-day consecutive streak\",\n    difficulty: ChallengeDifficulty.BEGINNER,\n    requirements: [\n      {\n        id: \"req-1\",\n        type: \"duration\",\n        description: \"Complete 7 consecutive days\",\n        targetValue: 7,\n        currentValue: 0,\n        completed: false,\n      },\n    ],\n    rewards: [\n      {\n        type: \"experience\",\n        value: 500,\n        description: \"500 XP\",\n        claimed: false,\n      },\n      {\n        type: \"badge\",\n        value: 1,\n        description: \"Streak Master Badge\",\n        claimed: false,\n      },\n    ],\n    startDate: new Date(),\n    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    progress: {\n      percentage: 0,\n      requirementsCompleted: 0,\n      totalRequirements: 1,\n      lastUpdated: new Date(),\n      milestones: [],\n    },\n    isCompleted: false,\n    participants: 247,\n    isPublic: true,\n  },\n];\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/gamification-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/goals-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/types/Goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useAccountSettings.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useAccountSettings' has too many lines (76). Maximum allowed is 75.",
        "line": 36,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 112,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Account Settings Hook - Extracts account management from AccountSection component\n */\n\nimport { useState, useCallback } from \"react\";\nimport {\n  withErrorHandling,\n  withDeletionHandling,\n  handleEmailUpdate,\n  handlePasswordUpdate,\n  handle2FAEnable,\n  handle2FADisable,\n  handleAccountDelete,\n} from \"./account-settings-utils\";\n\nexport interface AccountData {\n  email: string;\n  has2FA: boolean;\n}\n\nexport interface UseAccountSettingsReturn {\n  account: AccountData;\n  isLoading: boolean;\n  updateEmail: (email: string) => Promise<void>;\n  updatePassword: (oldPassword: string, newPassword: string) => Promise<void>;\n  enable2FA: () => Promise<string>;\n  disable2FA: (code: string) => Promise<void>;\n  deleteAccount: (password: string) => Promise<void>;\n  isUpdating: boolean;\n  isDeleting: boolean;\n  error: Error | null;\n  has2FA: boolean;\n  qrCode: string | null;\n}\n\nexport function useAccountSettings(): UseAccountSettingsReturn {\n  const [account, setAccount] = useState<AccountData>({\n    email: \"\",\n    has2FA: false,\n  });\n  const [isLoading, setIsLoading] = useState(true);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [qrCode, setQrCode] = useState<string | null>(null);\n  const updateEmail = useCallback(\n    async (email: string): Promise<void> =>\n      withErrorHandling(\n        () => handleEmailUpdate(email, setAccount),\n        setIsUpdating,\n        setError,\n        \"Failed to update email\",\n      ),\n    [],\n  );\n  const updatePassword = useCallback(\n    async (oldPassword: string, newPassword: string): Promise<void> =>\n      withErrorHandling(\n        () => handlePasswordUpdate(oldPassword, newPassword),\n        setIsUpdating,\n        setError,\n        \"Failed to update password\",\n      ),\n    [],\n  );\n  const enable2FA = useCallback(\n    async (): Promise<string> =>\n      withErrorHandling(\n        () => handle2FAEnable(setQrCode, setAccount),\n        setIsUpdating,\n        setError,\n        \"Failed to enable 2FA\",\n      ),\n    [],\n  );\n  const disable2FA = useCallback(\n    async (code: string): Promise<void> =>\n      withErrorHandling(\n        () => handle2FADisable(code, setQrCode, setAccount),\n        setIsUpdating,\n        setError,\n        \"Failed to disable 2FA\",\n      ),\n    [],\n  );\n\n  const deleteAccount = useCallback(\n    async (password: string): Promise<void> =>\n      withDeletionHandling(\n        () => handleAccountDelete(password),\n        setIsDeleting,\n        setError,\n        \"Failed to delete account\",\n      ),\n    [],\n  );\n  useState(() => setTimeout(() => setIsLoading(false), 100));\n  return {\n    account,\n    isLoading,\n    updateEmail,\n    updatePassword,\n    enable2FA,\n    disable2FA,\n    deleteAccount,\n    isUpdating,\n    isDeleting,\n    error,\n    has2FA: account.has2FA,\n    qrCode,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useDisplaySettings.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useDisplaySettings' has too many lines (78). Maximum allowed is 75.",
        "line": 43,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 120,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Display Settings Hook - Extracts settings persistence from DisplaySettingsSection\n */\n\nimport { useState, useCallback } from \"react\";\nimport {\n  withErrorHandling,\n  handleThemeUpdate,\n  handleLanguageUpdate,\n  handleDateFormatUpdate,\n  handleTimeFormatUpdate,\n  handleResetToDefaults,\n} from \"./display-settings-utils\";\n\nexport interface DisplaySettings {\n  theme: \"light\" | \"dark\" | \"auto\";\n  language: string;\n  dateFormat: string;\n  timeFormat: \"12h\" | \"24h\";\n}\n\nexport interface UseDisplaySettingsReturn {\n  displaySettings: DisplaySettings;\n  isLoading: boolean;\n  updateTheme: (theme: \"light\" | \"dark\" | \"auto\") => Promise<void>;\n  updateLanguage: (language: string) => Promise<void>;\n  updateDateFormat: (format: string) => Promise<void>;\n  updateTimeFormat: (format: \"12h\" | \"24h\") => Promise<void>;\n  resetToDefaults: () => Promise<void>;\n  isUpdating: boolean;\n  error: Error | null;\n  previewSettings: (settings: Partial<DisplaySettings>) => void;\n  clearPreview: () => void;\n}\n\nconst defaultSettings: DisplaySettings = {\n  theme: \"auto\",\n  language: \"en\",\n  dateFormat: \"MM/DD/YYYY\",\n  timeFormat: \"12h\",\n};\n\nexport function useDisplaySettings(): UseDisplaySettingsReturn {\n  const [displaySettings, setDisplaySettings] =\n    useState<DisplaySettings>(defaultSettings);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [_previewedSettings, _setPreviewedSettings] =\n    useState<Partial<DisplaySettings> | null>(null);\n  const updateTheme = useCallback(\n    async (theme: \"light\" | \"dark\" | \"auto\"): Promise<void> =>\n      withErrorHandling(\n        () => handleThemeUpdate(theme, setDisplaySettings),\n        setIsUpdating,\n        setError,\n        \"Failed to update theme\",\n      ),\n    [],\n  );\n  const updateLanguage = useCallback(\n    async (language: string): Promise<void> =>\n      withErrorHandling(\n        () => handleLanguageUpdate(language, setDisplaySettings),\n        setIsUpdating,\n        setError,\n        \"Failed to update language\",\n      ),\n    [],\n  );\n  const updateDateFormat = useCallback(\n    async (dateFormat: string): Promise<void> =>\n      withErrorHandling(\n        () => handleDateFormatUpdate(dateFormat, setDisplaySettings),\n        setIsUpdating,\n        setError,\n        \"Failed to update date format\",\n      ),\n    [],\n  );\n  const updateTimeFormat = useCallback(\n    async (timeFormat: \"12h\" | \"24h\"): Promise<void> =>\n      withErrorHandling(\n        () => handleTimeFormatUpdate(timeFormat, setDisplaySettings),\n        setIsUpdating,\n        setError,\n        \"Failed to update time format\",\n      ),\n    [],\n  );\n  const resetToDefaults = useCallback(\n    async (): Promise<void> =>\n      withErrorHandling(\n        () => handleResetToDefaults(defaultSettings, setDisplaySettings),\n        setIsUpdating,\n        setError,\n        \"Failed to reset settings\",\n      ),\n    [],\n  );\n  const previewSettings = useCallback(\n    (settings: Partial<DisplaySettings>) => _setPreviewedSettings(settings),\n    [],\n  );\n  const clearPreview = useCallback(() => _setPreviewedSettings(null), []);\n  useState(() => setTimeout(() => setIsLoading(false), 100));\n  return {\n    displaySettings,\n    isLoading,\n    updateTheme,\n    updateLanguage,\n    updateDateFormat,\n    updateTimeFormat,\n    resetToDefaults,\n    isUpdating,\n    error,\n    previewSettings,\n    clearPreview,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGameification.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Badge' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 16,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 8
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'max-statements').",
        "line": 46,
        "column": 1,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [1173, 1189], "text": "" }
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (376). Maximum allowed is 75.",
        "line": 47,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 518,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "complexity",
        "severity": 1,
        "message": "Arrow function has a complexity of 16. Maximum allowed is 15.",
        "line": 47,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "complex",
        "endLine": 518,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * useGameification Hook - Enhanced Gamification System\n *\n * Comprehensive gamification system beyond basic achievements, including challenges,\n * leaderboards, seasons, and social features.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  PlayerProfile,\n  Challenge,\n  Leaderboard,\n  Season,\n  SocialGameFeatures,\n  Badge,\n  ExperienceSource,\n  LevelResult,\n  LevelUpResult,\n  ChallengeCompletion,\n  LeaderboardRank,\n  FriendComparison,\n  SeasonalReward,\n  ExperienceEvent,\n} from \"../../types/gamification\";\nimport { logger } from \"../../utils/logging\";\nimport { GamificationStorageService } from \"../../services/gamificationStorage\";\nimport {\n  DEFAULT_PLAYER_PROFILE,\n  LEVEL_THRESHOLDS,\n  SAMPLE_CHALLENGES,\n} from \"./gamification-constants\";\nimport {\n  generateSampleLeaderboards,\n  generateSeasonalRewards,\n  createBadgeFromReward,\n  generateLevelRewards,\n  getPlayerTitle,\n  getUnlockedFeatures,\n} from \"./gamification-utils\";\n\n/**\n * Enhanced Gamification Hook\n * Complex gamification logic with multiple queries, mutations, and game mechanics\n */\n// eslint-disable-next-line max-statements, complexity\nexport const useGameification = (userId: string) => {\n  const queryClient = useQueryClient();\n\n  // Get player profile\n  const { data: playerProfile = DEFAULT_PLAYER_PROFILE } =\n    useQuery<PlayerProfile>({\n      queryKey: [\"gamification\", \"profile\", userId],\n      queryFn: () => {\n        const stored =\n          GamificationStorageService.getPlayerProfile<PlayerProfile>();\n        return stored\n          ? { ...DEFAULT_PLAYER_PROFILE, ...stored }\n          : DEFAULT_PLAYER_PROFILE;\n      },\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000,\n    });\n\n  // Get active challenges\n  const { data: activeChallenges = [] } = useQuery<Challenge[]>({\n    queryKey: [\"gamification\", \"challenges\", userId],\n    queryFn: () => {\n      const userChallenges =\n        GamificationStorageService.getChallenges<Challenge>();\n      return [...SAMPLE_CHALLENGES, ...userChallenges].filter(\n        (c) => !c.isCompleted,\n      );\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get leaderboards\n  const { data: leaderboards = [] } = useQuery<Leaderboard[]>({\n    queryKey: [\"gamification\", \"leaderboards\"],\n    queryFn: async () => {\n      // Simulate leaderboard data\n      return generateSampleLeaderboards();\n    },\n    staleTime: 5 * 60 * 1000,\n    refetchInterval: 10 * 60 * 1000,\n  });\n\n  // Get current season\n  const { data: currentSeason } = useQuery<Season | null>({\n    queryKey: [\"gamification\", \"season\"],\n    queryFn: () => {\n      return {\n        id: \"season-winter-2024\",\n        name: \"Winter Challenge 2024\",\n        description:\n          \"Embrace the cold season with special winter-themed challenges\",\n        theme: \"winter\",\n        startDate: new Date(\"2024-12-01\"),\n        endDate: new Date(\"2024-02-28\"),\n        rewards: generateSeasonalRewards(),\n        challenges: [\"winter-endurance\", \"cold-discipline\"],\n        leaderboards: [\"winter-champions\"],\n        isActive: true,\n      };\n    },\n    staleTime: 60 * 60 * 1000, // 1 hour\n  });\n\n  // Get social features\n  const { data: socialFeatures } = useQuery<SocialGameFeatures>({\n    queryKey: [\"gamification\", \"social\", userId],\n    queryFn: () => {\n      const stored =\n        GamificationStorageService.getSocialFeatures<SocialGameFeatures>();\n      return stored\n        ? stored\n        : {\n            friends: [],\n            pendingRequests: [],\n            recentActivity: [],\n            groups: [],\n            comparisons: [],\n          };\n    },\n    enabled: Boolean(userId) && playerProfile.preferences.allowSocialFeatures,\n    staleTime: 2 * 60 * 1000,\n  });\n\n  // Get experience history\n  const { data: experienceHistory = [] } = useQuery<ExperienceEvent[]>({\n    queryKey: [\"gamification\", \"experience\", userId],\n    queryFn: () => {\n      return GamificationStorageService.getExperienceHistory<ExperienceEvent>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Accept challenge mutation\n  const acceptChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge accepted\", { challengeId, userId });\n\n      // In a real implementation, this would register the user for the challenge\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Complete challenge mutation\n  const completeChallengeMutation = useMutation({\n    mutationFn: async (challengeId: string): Promise<ChallengeCompletion> => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      if (!challenge) throw new Error(\"Challenge not found\");\n\n      logger.info(\"Challenge completed\", { challengeId, userId });\n\n      // Mark challenge as completed\n      const updatedChallenges = activeChallenges.map((c) =>\n        c.id === challengeId\n          ? {\n              ...c,\n              isCompleted: true,\n              progress: { ...c.progress, percentage: 100 },\n            }\n          : c,\n      );\n      GamificationStorageService.setChallenges(updatedChallenges);\n\n      // Calculate rewards\n      const experienceGained = challenge.rewards.reduce(\n        (total, reward) =>\n          reward.type === \"experience\" ? total + reward.value : total,\n        0,\n      );\n\n      // Add experience\n      const levelResult = await addExperienceInternal(\n        experienceGained,\n        ExperienceSource.CHALLENGE_COMPLETE,\n      );\n\n      // Create completion result\n      const completion: ChallengeCompletion = {\n        challengeId,\n        completedAt: new Date(),\n        rewards: challenge.rewards,\n        experience: experienceGained,\n        newBadges: challenge.rewards\n          .filter((r) => r.type === \"badge\")\n          .map((r) => createBadgeFromReward(r)),\n        levelUp: levelResult.leveledUp\n          ? {\n              newLevel: levelResult.newLevel,\n              rewards: [],\n              unlockedFeatures: [],\n            }\n          : undefined,\n      };\n\n      // Update stats\n      const updatedProfile = {\n        ...playerProfile,\n        stats: {\n          ...playerProfile.stats,\n          challengesCompleted: playerProfile.stats.challengesCompleted + 1,\n          totalExperience:\n            playerProfile.stats.totalExperience + experienceGained,\n        },\n      };\n      GamificationStorageService.setPlayerProfile(updatedProfile);\n      queryClient.setQueryData(\n        [\"gamification\", \"profile\", userId],\n        updatedProfile,\n      );\n\n      return completion;\n    },\n  });\n\n  // Add experience mutation\n  const addExperienceMutation = useMutation({\n    mutationFn: async ({\n      amount,\n      source,\n    }: {\n      amount: number;\n      source: ExperienceSource;\n    }): Promise<LevelResult> => {\n      return addExperienceInternal(amount, source);\n    },\n  });\n\n  // Internal add experience function\n  const addExperienceInternal = async (\n    amount: number,\n    source: ExperienceSource,\n  ): Promise<LevelResult> => {\n    const oldLevel = playerProfile.level;\n    const newExperience = playerProfile.experience + amount;\n\n    // Calculate new level\n    let newLevel = oldLevel;\n    for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {\n      if (newExperience >= LEVEL_THRESHOLDS[i]) {\n        newLevel = i + 1;\n      } else {\n        break;\n      }\n    }\n\n    const experienceToNext =\n      newLevel < LEVEL_THRESHOLDS.length\n        ? LEVEL_THRESHOLDS[newLevel] - newExperience\n        : 0;\n\n    // Create experience event\n    const experienceEvent: ExperienceEvent = {\n      id: `exp-${Date.now()}`,\n      source,\n      amount,\n      description: `Gained ${amount} XP from ${source}`,\n      timestamp: new Date(),\n    };\n\n    // Update experience history\n    const updatedHistory = [experienceEvent, ...experienceHistory].slice(\n      0,\n      100,\n    );\n    GamificationStorageService.setExperienceHistory(updatedHistory);\n    queryClient.setQueryData(\n      [\"gamification\", \"experience\", userId],\n      updatedHistory,\n    );\n\n    // Update profile\n    const updatedProfile = {\n      ...playerProfile,\n      level: newLevel,\n      experience: newExperience,\n      experienceToNext,\n      stats: {\n        ...playerProfile.stats,\n        totalExperience: playerProfile.stats.totalExperience + amount,\n      },\n      lastActive: new Date(),\n    };\n\n    GamificationStorageService.setPlayerProfile(updatedProfile);\n    queryClient.setQueryData(\n      [\"gamification\", \"profile\", userId],\n      updatedProfile,\n    );\n\n    logger.info(\"Experience added\", {\n      amount,\n      source,\n      oldLevel,\n      newLevel,\n      userId,\n    });\n\n    return {\n      leveledUp: newLevel > oldLevel,\n      oldLevel,\n      newLevel,\n      experience: amount,\n    };\n  };\n\n  // Check level up\n  const checkLevelUp = useCallback(async (): Promise<LevelUpResult | null> => {\n    const _currentLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level - 1] || 0;\n    const nextLevelThreshold =\n      LEVEL_THRESHOLDS[playerProfile.level] || Infinity;\n\n    if (playerProfile.experience >= nextLevelThreshold) {\n      const newLevel = playerProfile.level + 1;\n      const rewards = generateLevelRewards(newLevel);\n\n      return {\n        newLevel,\n        rewards,\n        newTitle: getPlayerTitle(newLevel),\n        unlockedFeatures: getUnlockedFeatures(newLevel),\n      };\n    }\n\n    return null;\n  }, [playerProfile]);\n\n  // Get leaderboard rank\n  const getLeaderboardRank = useCallback(\n    async (leaderboardId: string): Promise<LeaderboardRank> => {\n      const leaderboard = leaderboards.find((l) => l.id === leaderboardId);\n      if (!leaderboard) throw new Error(\"Leaderboard not found\");\n\n      // Find user's rank (simulated)\n      const userRank =\n        Math.floor(Math.random() * leaderboard.totalParticipants) + 1;\n      const percentile =\n        ((leaderboard.totalParticipants - userRank) /\n          leaderboard.totalParticipants) *\n        100;\n\n      return {\n        category: leaderboard.category,\n        period: leaderboard.period,\n        rank: userRank,\n        totalParticipants: leaderboard.totalParticipants,\n        percentile,\n        value: playerProfile.stats.totalExperience,\n      };\n    },\n    [leaderboards, playerProfile],\n  );\n\n  // Compare with friends\n  const compareWithFriends = useCallback(async (): Promise<\n    FriendComparison[]\n  > => {\n    if (!socialFeatures?.friends) return [];\n\n    return socialFeatures.friends.map((friend) => ({\n      friendId: friend.userId,\n      friendName: friend.displayName,\n      categories: [\n        {\n          category: \"Level\",\n          playerValue: playerProfile.level,\n          friendValue: friend.level,\n          difference: playerProfile.level - friend.level,\n          status:\n            playerProfile.level > friend.level\n              ? \"ahead\"\n              : playerProfile.level < friend.level\n                ? \"behind\"\n                : \"tied\",\n        },\n        {\n          category: \"Experience\",\n          playerValue: playerProfile.experience,\n          friendValue: Math.floor(Math.random() * 10000),\n          difference: 0,\n          status: \"tied\",\n        },\n      ],\n      overallComparison: \"ahead\",\n    }));\n  }, [socialFeatures, playerProfile]);\n\n  // Send challenge to friend\n  const sendChallenge = useCallback(\n    async (friendId: string, challengeId: string) => {\n      logger.info(\"Challenge sent to friend\", {\n        friendId,\n        challengeId,\n        userId,\n      });\n      // In a real implementation, this would create a challenge invitation\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Get seasonal rewards\n  const getSeasonalRewards = useCallback(async (): Promise<\n    SeasonalReward[]\n  > => {\n    return currentSeason?.rewards || [];\n  }, [currentSeason]);\n\n  // Claim seasonal reward\n  const claimSeasonalReward = useCallback(\n    async (rewardId: string) => {\n      logger.info(\"Seasonal reward claimed\", { rewardId, userId });\n      // In a real implementation, this would claim the reward and update user data\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n    [userId],\n  );\n\n  // Computed properties\n  const currentLevel = playerProfile.level;\n  const progressToNext =\n    playerProfile.experienceToNext > 0\n      ? ((playerProfile.experience -\n          (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0)) /\n          ((LEVEL_THRESHOLDS[playerProfile.level] ||\n            playerProfile.experienceToNext) -\n            (LEVEL_THRESHOLDS[playerProfile.level - 1] || 0))) *\n        100\n      : 100;\n\n  const activeChallengeCount = activeChallenges.length;\n  const completedChallengesThisWeek = playerProfile.stats.challengesCompleted; // Simplified\n\n  const rank =\n    leaderboards.length > 0\n      ? leaderboards[0].entries.findIndex((e) => e.userId === userId) + 1 || 0\n      : 0;\n\n  const hasUnclaimedRewards =\n    currentSeason?.rewards.some((r) => !r.claimed) || false;\n\n  return {\n    // Player state\n    playerProfile,\n    activeChallenges,\n    leaderboards,\n    currentSeason,\n    socialFeatures,\n    experienceHistory,\n\n    // Challenge management\n    acceptChallenge: acceptChallengeMutation.mutate,\n    completeChallenge: completeChallengeMutation.mutate,\n    getChallengeProgress: (challengeId: string) => {\n      const challenge = activeChallenges.find((c) => c.id === challengeId);\n      return challenge?.progress;\n    },\n\n    // Experience and leveling\n    addExperience: addExperienceMutation.mutate,\n    checkLevelUp,\n\n    // Leaderboard features\n    getLeaderboardRank,\n    joinLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Joined leaderboard\", { leaderboardId, userId });\n    },\n    leaveLeaderboard: async (leaderboardId: string) => {\n      logger.info(\"Left leaderboard\", { leaderboardId, userId });\n    },\n\n    // Social features\n    compareWithFriends,\n    sendChallenge,\n\n    // Seasonal events\n    getSeasonalRewards,\n    claimSeasonalReward,\n\n    // Loading states\n    isAcceptingChallenge: acceptChallengeMutation.isPending,\n    isCompletingChallenge: completeChallengeMutation.isPending,\n    isAddingExperience: addExperienceMutation.isPending,\n\n    // Results\n    lastChallengeCompletion: completeChallengeMutation.data,\n    lastLevelResult: addExperienceMutation.data,\n\n    // Computed properties\n    currentLevel,\n    progressToNext,\n    activeChallengeCount,\n    completedChallengesThisWeek,\n    rank,\n    hasUnclaimedRewards,\n\n    // Quick stats\n    totalExperience: playerProfile.stats.totalExperience,\n    totalBadges: playerProfile.badges.length,\n    currentStreak: playerProfile.stats.currentStreak,\n\n    // Errors\n    error:\n      acceptChallengeMutation.error ||\n      completeChallengeMutation.error ||\n      addExperienceMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useGoals.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (451). Maximum allowed is 75.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (26). Maximum allowed is 25.",
        "line": 44,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 586,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGoals Hook - Enhanced Goal System\n *\n * Advanced goal system with AI recommendations, collaborative goals, and\n * comprehensive progress analytics.\n */\n\nimport { useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport {\n  EnhancedGoal,\n  CollaborativeGoal,\n  GoalRecommendation,\n  GoalAnalytics,\n  GoalTemplate,\n  CreateGoalRequest,\n  GoalUpdate,\n  OptimizedGoalPlan,\n  CollaborationInvite,\n  GoalInsights,\n  GoalPredictions,\n  CompletionTrends,\n  GoalType,\n  GoalCategory,\n  GoalDifficulty,\n  GoalStatus,\n} from \"../../types/goals\";\nimport { logger } from \"../../utils/logging\";\nimport {\n  getGoalInsights,\n  getPredictiveAnalytics as getPredictiveAnalyticsHelper,\n  getCompletionTrends as getCompletionTrendsHelper,\n} from \"../../utils/goalsHelpers\";\nimport { GoalStorageService } from \"../../services/goalStorage\";\n\n// Enhanced goal state\n\nimport type * as _Types from \"./types/Goals\";\nexport type * from \"./types/Goals\";\nimport { DEFAULT_TEMPLATES } from \"./goals-utils\";\n\n// Complex goal management hook with multiple goal types and collaborative features\n// eslint-disable-next-line max-statements\nexport const useGoals = (userId?: string, relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get personal goals\n  const { data: personalGoals = [] } = useQuery<EnhancedGoal[]>({\n    queryKey: [\"goals\", \"personal\", userId],\n    queryFn: () => {\n      return GoalStorageService.getPersonalGoals<EnhancedGoal>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get collaborative goals\n  const { data: collaborativeGoals = [] } = useQuery<CollaborativeGoal[]>({\n    queryKey: [\"goals\", \"collaborative\", userId, relationshipId],\n    queryFn: () => {\n      return GoalStorageService.getCollaborativeGoals<CollaborativeGoal>();\n    },\n    enabled: Boolean(userId) && Boolean(relationshipId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get goal templates\n  const { data: goalTemplates = DEFAULT_TEMPLATES } = useQuery<GoalTemplate[]>({\n    queryKey: [\"goals\", \"templates\"],\n    queryFn: () => {\n      const stored = GoalStorageService.getGoalTemplates<GoalTemplate>();\n      return stored.length > 0\n        ? [...DEFAULT_TEMPLATES, ...stored]\n        : DEFAULT_TEMPLATES;\n    },\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get AI recommendations\n  const { data: recommendedGoals = [] } = useQuery<GoalRecommendation[]>({\n    queryKey: [\"goals\", \"recommendations\", userId],\n    queryFn: async () => {\n      // Simulate AI recommendation generation\n      await new Promise((resolve) => setTimeout(resolve, 800));\n\n      return generateSmartRecommendations(personalGoals, collaborativeGoals);\n    },\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    refetchInterval: 30 * 60 * 1000, // 30 minutes\n  });\n\n  // Get goal analytics\n  const { data: goalAnalytics } = useQuery<GoalAnalytics>({\n    queryKey: [\"goals\", \"analytics\", userId],\n    queryFn: () => calculateGoalAnalytics(personalGoals, collaborativeGoals),\n    enabled:\n      Boolean(userId) &&\n      (personalGoals.length > 0 || collaborativeGoals.length > 0),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Create goal mutation\n  const createGoalMutation = useMutation({\n    mutationFn: async (request: CreateGoalRequest) => {\n      const newGoal: EnhancedGoal = {\n        id: `goal-${Date.now()}`,\n        type: request.type,\n        category: request.category,\n        title: request.title,\n        description: request.description,\n        target: request.target,\n        progress: {\n          current: 0,\n          target: request.target.value,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones:\n            request.milestones?.map((m) => ({\n              ...m,\n              id: `milestone-${Date.now()}-${Math.random()}`,\n              achieved: false,\n            })) || [],\n          lastUpdated: new Date(),\n        },\n        milestones:\n          request.milestones?.map((m) => ({\n            ...m,\n            id: `milestone-${Date.now()}-${Math.random()}`,\n            achieved: false,\n          })) || [],\n        aiGenerated: false,\n        difficulty: request.difficulty,\n        estimatedCompletion: calculateEstimatedCompletion(\n          request.difficulty,\n          request.target,\n        ),\n        createdAt: new Date(),\n        tags: request.tags || [],\n        isPublic: request.isPublic || false,\n      };\n\n      const updated = [...personalGoals, newGoal];\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal created\", { goalId: newGoal.id, title: newGoal.title });\n      return newGoal;\n    },\n  });\n\n  // Update goal mutation\n  const updateGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      updates,\n    }: {\n      goalId: string;\n      updates: GoalUpdate;\n    }) => {\n      const goalIndex = personalGoals.findIndex((g) => g.id === goalId);\n      if (goalIndex === -1) throw new Error(\"Goal not found\");\n\n      const updatedGoal: EnhancedGoal = {\n        ...personalGoals[goalIndex],\n        ...updates,\n      };\n      const updated = [...personalGoals];\n      updated[goalIndex] = updatedGoal;\n\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal updated\", { goalId, updates });\n      return updatedGoal;\n    },\n  });\n\n  // Delete goal mutation\n  const deleteGoalMutation = useMutation({\n    mutationFn: async (goalId: string) => {\n      const updated = personalGoals.filter((g) => g.id !== goalId);\n      GoalStorageService.setPersonalGoals(updated);\n      queryClient.setQueryData([\"goals\", \"personal\", userId], updated);\n\n      logger.info(\"Goal deleted\", { goalId });\n    },\n  });\n\n  // Generate goal from prompt mutation\n  const generateGoalFromPromptMutation = useMutation({\n    mutationFn: async (prompt: string) => {\n      logger.info(\"Generating goal from prompt\", { prompt });\n\n      // Simulate AI processing\n      await new Promise((resolve) => setTimeout(resolve, 1500));\n\n      const aiGoal: EnhancedGoal = {\n        id: `ai-goal-${Date.now()}`,\n        type: GoalType.DURATION,\n        category: GoalCategory.CHASTITY,\n        title: \"AI-Generated Chastity Goal\",\n        description: `Generated from: \"${prompt}\"`,\n        target: {\n          type: \"duration\",\n          value: 14,\n          unit: \"days\",\n          description: \"14 days of commitment\",\n        },\n        progress: {\n          current: 0,\n          target: 14,\n          percentage: 0,\n          status: GoalStatus.ACTIVE,\n          milestones: [],\n          lastUpdated: new Date(),\n        },\n        milestones: [\n          {\n            id: \"ai-milestone-1\",\n            name: \"First Week\",\n            description: \"Complete 7 days\",\n            target: 7,\n            achieved: false,\n          },\n          {\n            id: \"ai-milestone-2\",\n            name: \"Final Goal\",\n            description: \"Complete 14 days\",\n            target: 14,\n            achieved: false,\n          },\n        ],\n        aiGenerated: true,\n        difficulty: GoalDifficulty.MEDIUM,\n        estimatedCompletion: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n        createdAt: new Date(),\n        tags: [\"ai-generated\"],\n        isPublic: false,\n      };\n\n      return aiGoal;\n    },\n  });\n\n  // Optimize goal plan mutation\n  const optimizeGoalPlanMutation = useMutation({\n    mutationFn: async (goalIds: string[]) => {\n      const goalsToOptimize = personalGoals.filter((g) =>\n        goalIds.includes(g.id),\n      );\n\n      // Simulate optimization processing\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n\n      const optimizedPlan: OptimizedGoalPlan = {\n        goals: goalsToOptimize,\n        timeline: generateTimeline(goalsToOptimize),\n        conflicts: detectConflicts(goalsToOptimize),\n        recommendations: generatePlanRecommendations(goalsToOptimize),\n        estimatedCompletion: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days\n      };\n\n      return optimizedPlan;\n    },\n  });\n\n  // Share goal mutation\n  const shareGoalMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      logger.info(\"Sharing goal\", { goalId, targetUserId });\n      // In a real implementation, this would create a sharing record\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    },\n  });\n\n  // Invite collaborator mutation\n  const inviteCollaboratorMutation = useMutation({\n    mutationFn: async ({\n      goalId,\n      targetUserId,\n    }: {\n      goalId: string;\n      targetUserId: string;\n    }) => {\n      const invite: CollaborationInvite = {\n        id: `invite-${Date.now()}`,\n        goalId,\n        inviterId: userId!,\n        inviteeId: targetUserId,\n        permissions: {\n          canEdit: false,\n          canDelete: false,\n          canInviteOthers: false,\n          canViewProgress: true,\n          canAddMilestones: false,\n        },\n        createdAt: new Date(),\n        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        status: \"pending\",\n      };\n\n      logger.info(\"Collaboration invite sent\", {\n        inviteId: invite.id,\n        goalId,\n        targetUserId,\n      });\n      return invite;\n    },\n  });\n\n  // Helper functions\n  const generateSmartRecommendations = (\n    personal: EnhancedGoal[],\n    _collaborative: CollaborativeGoal[],\n  ): GoalRecommendation[] => {\n    const recommendations: GoalRecommendation[] = [];\n\n    // Analyze completed goals to suggest similar ones\n    const completedGoals = personal.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const activeCategories = new Set(personal.map((g) => g.category));\n\n    // Suggest goals in successful categories\n    completedGoals.forEach((goal) => {\n      if (Math.random() > 0.7) {\n        // 30% chance to recommend\n        recommendations.push({\n          id: `rec-${Date.now()}-${Math.random()}`,\n          type: goal.type,\n          category: goal.category,\n          title: `Advanced ${goal.category} Challenge`,\n          description: `Based on your success with \"${goal.title}\"`,\n          difficulty:\n            goal.difficulty === GoalDifficulty.EASY\n              ? GoalDifficulty.MEDIUM\n              : GoalDifficulty.HARD,\n          estimatedDuration: 30,\n          reasoning: `You successfully completed similar goals in the ${goal.category} category`,\n          confidence: 0.8,\n          similarGoals: [goal.id],\n          successRate: 0.75,\n        });\n      }\n    });\n\n    // Suggest unexplored categories\n    const allCategories = Object.values(GoalCategory);\n    const unexploredCategories = allCategories.filter(\n      (cat) => !activeCategories.has(cat),\n    );\n\n    unexploredCategories.forEach((category) => {\n      if (Math.random() > 0.8) {\n        // 20% chance\n        recommendations.push({\n          id: `exp-${Date.now()}-${Math.random()}`,\n          type: GoalType.MILESTONE,\n          category,\n          title: `Explore ${category}`,\n          description: `Try something new in the ${category} category`,\n          difficulty: GoalDifficulty.EASY,\n          estimatedDuration: 14,\n          reasoning: `Diversifying goal categories can improve overall success`,\n          confidence: 0.6,\n          similarGoals: [],\n          successRate: 0.65,\n        });\n      }\n    });\n\n    return recommendations.slice(0, 5); // Limit to 5 recommendations\n  };\n\n  const calculateGoalAnalytics = (\n    personal: EnhancedGoal[],\n    collaborative: CollaborativeGoal[],\n  ): GoalAnalytics => {\n    const allGoals = [...personal, ...collaborative];\n    const completed = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.COMPLETED,\n    );\n    const active = allGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    );\n\n    const categoryDistribution = Object.values(GoalCategory).reduce(\n      (acc, cat) => {\n        acc[cat] = allGoals.filter((g) => g.category === cat).length;\n        return acc;\n      },\n      {} as Record<GoalCategory, number>,\n    );\n\n    const difficultyDistribution = Object.values(GoalDifficulty).reduce(\n      (acc, diff) => {\n        acc[diff] = allGoals.filter((g) => g.difficulty === diff).length;\n        return acc;\n      },\n      {} as Record<GoalDifficulty, number>,\n    );\n\n    return {\n      totalGoals: allGoals.length,\n      completedGoals: completed.length,\n      activeGoals: active.length,\n      completionRate:\n        allGoals.length > 0 ? (completed.length / allGoals.length) * 100 : 0,\n      averageCompletionTime: calculateAverageCompletionTime(completed),\n      categoryDistribution,\n      difficultyDistribution,\n      monthlyProgress: generateMonthlyProgress(allGoals),\n      streaks: calculateStreaks(completed),\n    };\n  };\n\n  const calculateEstimatedCompletion = (\n    difficulty: GoalDifficulty,\n    target: { value?: number; unit?: string },\n  ): Date => {\n    const baseDays = target.value || 30;\n    const multiplier = {\n      [GoalDifficulty.EASY]: 1,\n      [GoalDifficulty.MEDIUM]: 1.5,\n      [GoalDifficulty.HARD]: 2,\n      [GoalDifficulty.EXTREME]: 3,\n    };\n\n    return new Date(\n      Date.now() + baseDays * multiplier[difficulty] * 24 * 60 * 60 * 1000,\n    );\n  };\n\n  const calculateAverageCompletionTime = (\n    completed: EnhancedGoal[],\n  ): number => {\n    if (completed.length === 0) return 0;\n\n    const totalDays = completed.reduce((acc, goal) => {\n      if (goal.completedAt && goal.startedAt) {\n        return (\n          acc +\n          (goal.completedAt.getTime() - goal.startedAt.getTime()) /\n            (24 * 60 * 60 * 1000)\n        );\n      }\n      return acc;\n    }, 0);\n\n    return totalDays / completed.length;\n  };\n\n  const generateMonthlyProgress = (_goals: EnhancedGoal[]) => {\n    // Simplified monthly progress calculation\n    return Array.from({ length: 6 }, (_, i) => ({\n      month: new Date(\n        Date.now() - i * 30 * 24 * 60 * 60 * 1000,\n      ).toLocaleDateString(\"en-US\", { month: \"short\" }),\n      goalsStarted: Math.floor(Math.random() * 5),\n      goalsCompleted: Math.floor(Math.random() * 3),\n      totalProgress: Math.floor(Math.random() * 100),\n    }));\n  };\n\n  const calculateStreaks = (_completed: EnhancedGoal[]) => {\n    return Object.values(GoalCategory).map((category) => ({\n      category,\n      currentStreak: Math.floor(Math.random() * 10),\n      longestStreak: Math.floor(Math.random() * 20),\n      lastGoalCompleted: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n    }));\n  };\n\n  const generateTimeline = (goals: EnhancedGoal[]) => {\n    return goals.map((goal) => ({\n      date: goal.estimatedCompletion,\n      goals: [goal.id],\n      milestones: goal.milestones.map((m) => m.id),\n      estimatedEffort: 4, // hours\n    }));\n  };\n\n  const detectConflicts = (_goals: EnhancedGoal[]) => {\n    // Simplified conflict detection\n    return [];\n  };\n\n  const generatePlanRecommendations = (_goals: EnhancedGoal[]) => {\n    return [\n      {\n        type: \"reorder\" as const,\n        description: \"Consider starting easier goals first to build momentum\",\n        impact: \"Improved success rate\",\n        effort: \"Low\",\n      },\n    ];\n  };\n\n  // Analytics functions using helpers\n  const getGoalInsightsCallback = useCallback(\n    (): GoalInsights => getGoalInsights(),\n    [],\n  );\n\n  const getPredictiveAnalyticsCallback = useCallback(\n    (): GoalPredictions => getPredictiveAnalyticsHelper(personalGoals),\n    [personalGoals],\n  );\n\n  const getCompletionTrendsCallback = useCallback(\n    (): CompletionTrends => getCompletionTrendsHelper(),\n    [],\n  );\n\n  return {\n    // Goal state\n    personalGoals,\n    collaborativeGoals,\n    recommendedGoals,\n    goalAnalytics,\n    goalTemplates,\n\n    // Goal management\n    createGoal: createGoalMutation.mutate,\n    updateGoal: updateGoalMutation.mutate,\n    deleteGoal: deleteGoalMutation.mutate,\n\n    // AI features\n    getSmartRecommendations: () => recommendedGoals,\n    generateGoalFromPrompt: generateGoalFromPromptMutation.mutate,\n    optimizeGoalPlan: optimizeGoalPlanMutation.mutate,\n\n    // Collaboration\n    shareGoal: shareGoalMutation.mutate,\n    inviteCollaborator: inviteCollaboratorMutation.mutate,\n    acceptCollaboration: async (inviteId: string) => {\n      logger.info(\"Collaboration accepted\", { inviteId });\n    },\n\n    // Analytics\n    getGoalInsights: getGoalInsightsCallback,\n    getPredictiveAnalytics: getPredictiveAnalyticsCallback,\n    getCompletionTrends: getCompletionTrendsCallback,\n\n    // Loading states\n    isCreating: createGoalMutation.isPending,\n    isUpdating: updateGoalMutation.isPending,\n    isDeleting: deleteGoalMutation.isPending,\n    isGenerating: generateGoalFromPromptMutation.isPending,\n    isOptimizing: optimizeGoalPlanMutation.isPending,\n\n    // Computed properties\n    activeGoalsCount: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.ACTIVE,\n    ).length,\n    completionRate: goalAnalytics ? goalAnalytics.completionRate : 0,\n    averageCompletionTime: goalAnalytics\n      ? goalAnalytics.averageCompletionTime\n      : 0,\n    hasCollaborativeGoals: collaborativeGoals.length > 0,\n    needsAttention: personalGoals.filter(\n      (g) => g.progress.status === GoalStatus.BEHIND,\n    ).length,\n\n    // Results\n    lastOptimization: optimizeGoalPlanMutation.data,\n    lastGeneratedGoal: generateGoalFromPromptMutation.data,\n\n    // Errors\n    error:\n      createGoalMutation.error ||\n      updateGoalMutation.error ||\n      deleteGoalMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useLogEventForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useManualEntry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/usePersonalGoals.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'usePersonalGoals' has too many lines (141). Maximum allowed is 75.",
        "line": 50,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 203,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Personal Goals Hook - Extracts goal management from PersonalGoalSection component\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface PersonalGoal {\n  id: string;\n  title: string;\n  description?: string;\n  targetDuration: number; // in seconds\n  currentProgress: number; // in seconds\n  isCompleted: boolean;\n  createdAt: Date;\n  completedAt?: Date;\n  reward?: string;\n}\n\nexport interface CreateGoalInput {\n  title: string;\n  description?: string;\n  targetDuration: number;\n  reward?: string;\n}\n\nexport interface UpdateGoalInput {\n  title?: string;\n  description?: string;\n  targetDuration?: number;\n  reward?: string;\n}\n\nexport interface UsePersonalGoalsReturn {\n  goals: PersonalGoal[];\n  activeGoals: PersonalGoal[];\n  completedGoals: PersonalGoal[];\n  isLoading: boolean;\n  createGoal: (goal: CreateGoalInput) => Promise<PersonalGoal>;\n  updateGoal: (id: string, updates: UpdateGoalInput) => Promise<PersonalGoal>;\n  deleteGoal: (id: string) => Promise<void>;\n  completeGoal: (id: string) => Promise<void>;\n  isCreating: boolean;\n  isUpdating: boolean;\n  isDeleting: boolean;\n  error: Error | null;\n  getGoalProgress: (goalId: string) => number;\n  getGoalProjection: (goalId: string) => Date | null;\n}\n\nexport function usePersonalGoals(): UsePersonalGoalsReturn {\n  const [goals, setGoals] = useState<PersonalGoal[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isCreating, setIsCreating] = useState(false);\n  const [isUpdating, setIsUpdating] = useState(false);\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const activeGoals = goals.filter((g) => !g.isCompleted);\n  const completedGoals = goals.filter((g) => g.isCompleted);\n\n  const createGoal = useCallback(\n    async (goal: CreateGoalInput): Promise<PersonalGoal> => {\n      setIsCreating(true);\n      setError(null);\n      try {\n        const newGoal: PersonalGoal = {\n          id: `goal-${Date.now()}`,\n          title: goal.title,\n          description: goal.description,\n          targetDuration: goal.targetDuration,\n          currentProgress: 0,\n          isCompleted: false,\n          createdAt: new Date(),\n          reward: goal.reward,\n        };\n        setGoals((prev) => [...prev, newGoal]);\n        return newGoal;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to create goal\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsCreating(false);\n      }\n    },\n    [],\n  );\n\n  const updateGoal = useCallback(\n    async (id: string, updates: UpdateGoalInput): Promise<PersonalGoal> => {\n      setIsUpdating(true);\n      setError(null);\n      try {\n        let updatedGoal: PersonalGoal | null = null;\n        setGoals((prev) =>\n          prev.map((g) => {\n            if (g.id === id) {\n              updatedGoal = { ...g, ...updates };\n              return updatedGoal;\n            }\n            return g;\n          }),\n        );\n        if (!updatedGoal) throw new Error(\"Goal not found\");\n        return updatedGoal;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update goal\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [],\n  );\n\n  const deleteGoal = useCallback(async (id: string): Promise<void> => {\n    setIsDeleting(true);\n    setError(null);\n    try {\n      setGoals((prev) => prev.filter((g) => g.id !== id));\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to delete goal\");\n      setError(error);\n      throw error;\n    } finally {\n      setIsDeleting(false);\n    }\n  }, []);\n\n  const completeGoal = useCallback(async (id: string): Promise<void> => {\n    setError(null);\n    try {\n      setGoals((prev) =>\n        prev.map((g) =>\n          g.id === id\n            ? { ...g, isCompleted: true, completedAt: new Date() }\n            : g,\n        ),\n      );\n    } catch (err) {\n      const error =\n        err instanceof Error ? err : new Error(\"Failed to complete goal\");\n      setError(error);\n      throw error;\n    }\n  }, []);\n\n  const getGoalProgress = useCallback(\n    (goalId: string): number => {\n      const goal = goals.find((g) => g.id === goalId);\n      if (!goal || goal.targetDuration === 0) return 0;\n      return (goal.currentProgress / goal.targetDuration) * 100;\n    },\n    [goals],\n  );\n\n  const getGoalProjection = useCallback(\n    (goalId: string): Date | null => {\n      const goal = goals.find((g) => g.id === goalId);\n      if (!goal || goal.currentProgress === 0) return null;\n\n      const remainingDuration = goal.targetDuration - goal.currentProgress;\n      const daysPassed = Math.floor(\n        (Date.now() - goal.createdAt.getTime()) / (1000 * 60 * 60 * 24),\n      );\n      const progressPerDay = goal.currentProgress / daysPassed;\n\n      if (progressPerDay === 0) return null;\n\n      const daysRemaining = Math.ceil(remainingDuration / progressPerDay);\n      const projectedDate = new Date();\n      projectedDate.setDate(projectedDate.getDate() + daysRemaining);\n\n      return projectedDate;\n    },\n    [goals],\n  );\n\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    goals,\n    activeGoals,\n    completedGoals,\n    isLoading,\n    createGoal,\n    updateGoal,\n    deleteGoal,\n    completeGoal,\n    isCreating,\n    isUpdating,\n    isDeleting,\n    error,\n    getGoalProgress,\n    getGoalProjection,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useReporting.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (278). Maximum allowed is 75.",
        "line": 214,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 553,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useReporting Hook - Advanced Reporting & Analytics\n *\n * Comprehensive reporting system with custom reports, data visualization,\n * and export capabilities for detailed analysis.\n */\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { ReportStorageService } from \"../../services/reportStorage\";\n\n// Report types\nexport enum ReportType {\n  SUMMARY = \"summary\",\n  DETAILED = \"detailed\",\n  ANALYTICS = \"analytics\",\n  CUSTOM = \"custom\",\n}\n\n// Export formats\nexport enum ExportFormat {\n  JSON = \"json\",\n  CSV = \"csv\",\n  PDF = \"pdf\",\n  XLSX = \"xlsx\",\n}\n\n// Report template\nexport interface ReportTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: ReportType;\n  parameters: ReportParameter[];\n  defaultParameters: Record<string, string | number | boolean | Date>;\n}\n\n// Report parameter\nexport interface ReportParameter {\n  name: string;\n  type: \"string\" | \"number\" | \"date\" | \"boolean\" | \"select\";\n  required: boolean;\n  options?: string[];\n  default?: string | number | boolean | Date;\n}\n\n// Report parameters\nexport interface ReportParameters {\n  dateRange: {\n    start: Date;\n    end: Date;\n  };\n  includeDetails: boolean;\n  groupBy?: string;\n  filters: Record<string, string | number | boolean | Date>;\n}\n\n// Generated report\nexport interface GeneratedReport {\n  id: string;\n  templateId: string;\n  name: string;\n  parameters: ReportParameters;\n  data: Record<string, unknown> | unknown[];\n  generatedAt: Date;\n  generatedBy: string;\n  size: number;\n}\n\n// Custom report definition\nexport interface CustomReportDefinition {\n  name: string;\n  description: string;\n  dataSource: string;\n  fields: string[];\n  filters: ReportFilter[];\n  grouping?: string[];\n  sorting?: ReportSort[];\n}\n\n// Report filter\nexport interface ReportFilter {\n  field: string;\n  operator: \"equals\" | \"contains\" | \"greater\" | \"less\" | \"between\";\n  value: string | number | boolean | Date;\n}\n\n// Report sort\nexport interface ReportSort {\n  field: string;\n  direction: \"asc\" | \"desc\";\n}\n\n// Custom report\nexport interface CustomReport {\n  id: string;\n  definition: CustomReportDefinition;\n  createdAt: Date;\n  lastRun?: Date;\n}\n\n// Report schedule\nexport interface ReportSchedule {\n  frequency: \"daily\" | \"weekly\" | \"monthly\";\n  time: string;\n  recipients: string[];\n  format: ExportFormat;\n  enabled: boolean;\n}\n\n// Scheduled report\nexport interface ScheduledReport {\n  id: string;\n  reportId: string;\n  schedule: ReportSchedule;\n  nextRun: Date;\n  lastRun?: Date;\n}\n\n// Report export\nexport interface ReportExport {\n  id: string;\n  reportId: string;\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data export\nexport interface DataExport {\n  id: string;\n  dataType: string;\n  filters: DataFilter[];\n  format: ExportFormat;\n  url: string;\n  expiresAt: Date;\n}\n\n// Data filter\nexport interface DataFilter {\n  field: string;\n  value: string | number | boolean | Date;\n}\n\n// Reporting preferences\nexport interface ReportingPreferences {\n  defaultFormat: ExportFormat;\n  autoRefresh: boolean;\n  refreshInterval: number;\n  maxReports: number;\n}\n\n// Default templates\nconst DEFAULT_TEMPLATES: ReportTemplate[] = [\n  {\n    id: \"session-summary\",\n    name: \"Session Summary\",\n    description: \"Summary of chastity sessions over time\",\n    type: ReportType.SUMMARY,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"includeDetails\",\n        type: \"boolean\",\n        required: false,\n        default: false,\n      },\n    ],\n    defaultParameters: {\n      includeDetails: false,\n    },\n  },\n  {\n    id: \"achievement-progress\",\n    name: \"Achievement Progress\",\n    description: \"Progress on achievements and goals\",\n    type: ReportType.ANALYTICS,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"category\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"duration\", \"behavior\", \"goals\"],\n      },\n    ],\n    defaultParameters: {\n      category: \"all\",\n    },\n  },\n  {\n    id: \"behavioral-analysis\",\n    name: \"Behavioral Analysis\",\n    description: \"Analysis of behavioral patterns and events\",\n    type: ReportType.DETAILED,\n    parameters: [\n      { name: \"dateRange\", type: \"date\", required: true },\n      {\n        name: \"eventTypes\",\n        type: \"select\",\n        required: false,\n        options: [\"all\", \"sessions\", \"events\", \"tasks\"],\n      },\n    ],\n    defaultParameters: {\n      eventTypes: \"all\",\n    },\n  },\n];\n\n/**\n * Advanced Reporting Hook\n */\nexport const useReporting = (userId?: string, _relationshipId?: string) => {\n  const queryClient = useQueryClient();\n\n  // Get available templates\n  const { data: availableReports = DEFAULT_TEMPLATES } = useQuery<\n    ReportTemplate[]\n  >({\n    queryKey: [\"reports\", \"templates\"],\n    queryFn: () => DEFAULT_TEMPLATES,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Get custom reports\n  const { data: customReports = [] } = useQuery<CustomReport[]>({\n    queryKey: [\"reports\", \"custom\", userId],\n    queryFn: () => {\n      return ReportStorageService.getCustomReports<CustomReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000,\n  });\n\n  // Get recent reports\n  const { data: recentReports = [] } = useQuery<GeneratedReport[]>({\n    queryKey: [\"reports\", \"recent\", userId],\n    queryFn: () => {\n      return ReportStorageService.getRecentReports<GeneratedReport>();\n    },\n    enabled: Boolean(userId),\n    staleTime: 30 * 1000,\n  });\n\n  // Get preferences\n  const { data: preferences } = useQuery<ReportingPreferences>({\n    queryKey: [\"reports\", \"preferences\", userId],\n    queryFn: () => {\n      const stored =\n        ReportStorageService.getPreferences<ReportingPreferences>();\n      return stored\n        ? stored\n        : {\n            defaultFormat: ExportFormat.JSON,\n            autoRefresh: false,\n            refreshInterval: 300000, // 5 minutes\n            maxReports: 50,\n          };\n    },\n    enabled: Boolean(userId),\n    staleTime: 5 * 60 * 1000,\n  });\n\n  // Generate report mutation\n  const generateReportMutation = useMutation({\n    mutationFn: async ({\n      templateId,\n      parameters,\n    }: {\n      templateId: string;\n      parameters: ReportParameters;\n    }) => {\n      const template = availableReports.find((t) => t.id === templateId);\n      if (!template) throw new Error(\"Template not found\");\n\n      logger.info(\"Generating report\", { templateId, parameters });\n\n      // Simulate report generation\n      const reportData = await generateReportData(templateId, parameters);\n\n      const report: GeneratedReport = {\n        id: `report-${Date.now()}`,\n        templateId,\n        name: template.name,\n        parameters,\n        data: reportData,\n        generatedAt: new Date(),\n        generatedBy: userId || \"anonymous\",\n        size: JSON.stringify(reportData).length,\n      };\n\n      // Store in recent reports\n      const updated = [report, ...recentReports].slice(\n        0,\n        preferences?.maxReports || 50,\n      );\n      ReportStorageService.setRecentReports(updated);\n      queryClient.setQueryData([\"reports\", \"recent\", userId], updated);\n\n      return report;\n    },\n  });\n\n  // Create custom report mutation\n  const createCustomReportMutation = useMutation({\n    mutationFn: async (definition: CustomReportDefinition) => {\n      const customReport: CustomReport = {\n        id: `custom-${Date.now()}`,\n        definition,\n        createdAt: new Date(),\n      };\n\n      const updated = [...customReports, customReport];\n      ReportStorageService.setCustomReports(updated);\n      queryClient.setQueryData([\"reports\", \"custom\", userId], updated);\n\n      logger.info(\"Custom report created\", { reportId: customReport.id });\n      return customReport;\n    },\n  });\n\n  // Schedule report mutation\n  const scheduleReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      schedule,\n    }: {\n      reportId: string;\n      schedule: ReportSchedule;\n    }) => {\n      const scheduledReport: ScheduledReport = {\n        id: `schedule-${Date.now()}`,\n        reportId,\n        schedule,\n        nextRun: calculateNextRun(schedule),\n      };\n\n      logger.info(\"Report scheduled\", {\n        reportId,\n        schedule: scheduledReport.id,\n      });\n      return scheduledReport;\n    },\n  });\n\n  // Export report mutation\n  const exportReportMutation = useMutation({\n    mutationFn: async ({\n      reportId,\n      format,\n    }: {\n      reportId: string;\n      format: ExportFormat;\n    }) => {\n      const report = recentReports.find((r) => r.id === reportId);\n      if (!report) throw new Error(\"Report not found\");\n\n      const exportData = await exportReportData(report, format);\n\n      const exportResult: ReportExport = {\n        id: `export-${Date.now()}`,\n        reportId,\n        format,\n        url: exportData.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n      };\n\n      logger.info(\"Report exported\", {\n        reportId,\n        format,\n        exportId: exportResult.id,\n      });\n      return exportResult;\n    },\n  });\n\n  // Export raw data mutation\n  const exportRawDataMutation = useMutation({\n    mutationFn: async ({\n      dataType,\n      filters,\n      format,\n    }: {\n      dataType: string;\n      filters: DataFilter[];\n      format: ExportFormat;\n    }) => {\n      const rawData = await getRawData(dataType, filters);\n      const exportResult = await exportData(rawData, format);\n\n      const dataExport: DataExport = {\n        id: `data-export-${Date.now()}`,\n        dataType,\n        filters,\n        format,\n        url: exportResult.url,\n        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),\n      };\n\n      logger.info(\"Raw data exported\", {\n        dataType,\n        format,\n        exportId: dataExport.id,\n      });\n      return dataExport;\n    },\n  });\n\n  // Helper functions\n  const generateReportData = async (\n    templateId: string,\n    parameters: ReportParameters,\n  ) => {\n    // In a real implementation, this would query actual data\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    return {\n      summary: {\n        totalSessions: Math.floor(Math.random() * 100),\n        averageDuration: Math.floor(Math.random() * 72),\n        longestSession: Math.floor(Math.random() * 168),\n      },\n      details: parameters.includeDetails ? generateDetailedData() : null,\n      generatedAt: new Date().toISOString(),\n    };\n  };\n\n  const generateDetailedData = () => ({\n    sessions: Array.from({ length: 10 }, (_, i) => ({\n      id: i + 1,\n      startDate: new Date(\n        Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000,\n      ),\n      duration: Math.floor(Math.random() * 72),\n      events: Math.floor(Math.random() * 5),\n    })),\n  });\n\n  const calculateNextRun = (schedule: ReportSchedule): Date => {\n    const now = new Date();\n    const timeParts = schedule.time.split(\":\").map(Number);\n    const hours = timeParts[0] ?? 0;\n    const minutes = timeParts[1] ?? 0;\n\n    const nextRun = new Date(now);\n    nextRun.setHours(hours, minutes, 0, 0);\n\n    if (nextRun <= now) {\n      switch (schedule.frequency) {\n        case \"daily\":\n          nextRun.setDate(nextRun.getDate() + 1);\n          break;\n        case \"weekly\":\n          nextRun.setDate(nextRun.getDate() + 7);\n          break;\n        case \"monthly\":\n          nextRun.setMonth(nextRun.getMonth() + 1);\n          break;\n      }\n    }\n\n    return nextRun;\n  };\n\n  const exportReportData = async (\n    report: GeneratedReport,\n    format: ExportFormat,\n  ) => {\n    // Simulate export processing\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    const blob = new Blob([JSON.stringify(report.data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n\n    return { url };\n  };\n\n  const getRawData = async (dataType: string, filters: DataFilter[]) => {\n    // Simulate data retrieval\n    await new Promise((resolve) => setTimeout(resolve, 800));\n    return { dataType, filters, records: [] };\n  };\n\n  const exportData = async (\n    data: Record<string, unknown> | unknown[],\n    format: ExportFormat,\n  ) => {\n    const blob = new Blob([JSON.stringify(data, null, 2)], {\n      type: getContentType(format),\n    });\n    const url = URL.createObjectURL(blob);\n    return { url };\n  };\n\n  const getContentType = (format: ExportFormat): string => {\n    switch (format) {\n      case ExportFormat.JSON:\n        return \"application/json\";\n      case ExportFormat.CSV:\n        return \"text/csv\";\n      case ExportFormat.PDF:\n        return \"application/pdf\";\n      case ExportFormat.XLSX:\n        return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n      default:\n        return \"application/octet-stream\";\n    }\n  };\n\n  return {\n    // Available reports and templates\n    availableReports,\n    customReports,\n    recentReports,\n    preferences,\n\n    // Actions\n    generateReport: generateReportMutation.mutate,\n    createCustomReport: createCustomReportMutation.mutate,\n    scheduleReport: scheduleReportMutation.mutate,\n    exportReport: exportReportMutation.mutate,\n    exportRawData: exportRawDataMutation.mutate,\n\n    // Loading states\n    isGenerating: generateReportMutation.isPending,\n    isCreatingCustom: createCustomReportMutation.isPending,\n    isScheduling: scheduleReportMutation.isPending,\n    isExporting:\n      exportReportMutation.isPending || exportRawDataMutation.isPending,\n\n    // Results\n    lastGeneratedReport: generateReportMutation.data,\n    lastExport: exportReportMutation.data || exportRawDataMutation.data,\n\n    // Computed properties\n    totalReports: recentReports.length,\n    hasScheduledReports: false, // Would check actual scheduled reports\n    lastReportDate:\n      recentReports.length > 0 ? recentReports[0].generatedAt : null,\n    hasCustomReports: customReports.length > 0,\n\n    // Errors\n    error:\n      generateReportMutation.error ||\n      createCustomReportMutation.error ||\n      scheduleReportMutation.error ||\n      exportReportMutation.error ||\n      exportRawDataMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/features/useRuleEditor.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useRuleEditor' has too many lines (172). Maximum allowed is 75.",
        "line": 75,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Rule Editor Hook\n *\n * Extracts rule management logic from RuleEditor component.\n */\n\nimport { useState, useCallback } from \"react\";\n\nexport interface Rule {\n  id: string;\n  title: string;\n  description: string;\n  enabled: boolean;\n  conditions: Condition[];\n  actions: RuleAction[];\n}\n\nexport interface Condition {\n  type: string;\n  value: unknown;\n}\n\nexport interface RuleAction {\n  type: string;\n  value: unknown;\n}\n\nexport interface CreateRuleInput {\n  title: string;\n  description?: string;\n}\n\nexport interface UpdateRuleInput {\n  title?: string;\n  description?: string;\n  enabled?: boolean;\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  message: string;\n}\n\nexport interface UseRuleEditorReturn {\n  rules: Rule[];\n  currentRule: Rule | null;\n  isLoading: boolean;\n  createRule: (rule: CreateRuleInput) => Promise<Rule>;\n  updateRule: (id: string, updates: UpdateRuleInput) => Promise<Rule>;\n  deleteRule: (id: string) => Promise<void>;\n  toggleRule: (id: string, enabled: boolean) => Promise<void>;\n  setCurrentRule: (rule: Rule | null) => void;\n  resetEditor: () => void;\n  validateRule: (rule: Rule) => ValidationResult;\n  isRuleValid: boolean;\n  validationErrors: string[];\n  testRule: (\n    rule: Rule,\n    testData: Record<string, unknown>,\n  ) => Promise<TestResult>;\n  isTesting: boolean;\n  addCondition: (condition: Condition) => void;\n  removeCondition: (index: number) => void;\n  updateCondition: (index: number, condition: Condition) => void;\n  addAction: (action: RuleAction) => void;\n  removeAction: (index: number) => void;\n  updateAction: (index: number, action: RuleAction) => void;\n}\n\nexport function useRuleEditor(): UseRuleEditorReturn {\n  const [rules, setRules] = useState<Rule[]>([]);\n  const [currentRule, setCurrentRule] = useState<Rule | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isTesting, setIsTesting] = useState(false);\n  const [validationErrors, setValidationErrors] = useState<string[]>([]);\n\n  const createRule = useCallback(\n    async (rule: CreateRuleInput): Promise<Rule> => {\n      const newRule: Rule = {\n        id: `rule-${Date.now()}`,\n        title: rule.title,\n        description: rule.description || \"\",\n        enabled: true,\n        conditions: [],\n        actions: [],\n      };\n      setRules((prev) => [...prev, newRule]);\n      return newRule;\n    },\n    [],\n  );\n\n  const updateRule = useCallback(\n    async (id: string, updates: UpdateRuleInput): Promise<Rule> => {\n      let updatedRule: Rule | null = null;\n      setRules((prev) =>\n        prev.map((r) => {\n          if (r.id === id) {\n            updatedRule = { ...r, ...updates };\n            return updatedRule;\n          }\n          return r;\n        }),\n      );\n      if (!updatedRule) throw new Error(\"Rule not found\");\n      return updatedRule;\n    },\n    [],\n  );\n\n  const deleteRule = useCallback(async (id: string): Promise<void> => {\n    setRules((prev) => prev.filter((r) => r.id !== id));\n  }, []);\n\n  const toggleRule = useCallback(\n    async (id: string, enabled: boolean): Promise<void> => {\n      await updateRule(id, { enabled });\n    },\n    [updateRule],\n  );\n\n  const resetEditor = useCallback(() => {\n    setCurrentRule(null);\n    setValidationErrors([]);\n  }, []);\n\n  const validateRule = useCallback((rule: Rule): ValidationResult => {\n    const errors: string[] = [];\n    if (!rule.title) errors.push(\"Title is required\");\n    if (rule.conditions.length === 0)\n      errors.push(\"At least one condition is required\");\n    if (rule.actions.length === 0)\n      errors.push(\"At least one action is required\");\n    setValidationErrors(errors);\n    return { valid: errors.length === 0, errors };\n  }, []);\n\n  const testRule = useCallback(\n    async (\n      _rule: Rule,\n      _testData: Record<string, unknown>,\n    ): Promise<TestResult> => {\n      setIsTesting(true);\n      try {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        return { passed: true, message: \"Rule test passed\" };\n      } finally {\n        setIsTesting(false);\n      }\n    },\n    [],\n  );\n\n  const addCondition = useCallback(\n    (condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: [...currentRule.conditions, condition],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeCondition = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateCondition = useCallback(\n    (index: number, condition: Condition) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          conditions: currentRule.conditions.map((c, i) =>\n            i === index ? condition : c,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const addAction = useCallback(\n    (action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: [...currentRule.actions, action],\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const removeAction = useCallback(\n    (index: number) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.filter((_, i) => i !== index),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  const updateAction = useCallback(\n    (index: number, action: RuleAction) => {\n      if (currentRule) {\n        setCurrentRule({\n          ...currentRule,\n          actions: currentRule.actions.map((a, i) =>\n            i === index ? action : a,\n          ),\n        });\n      }\n    },\n    [currentRule],\n  );\n\n  // Simulate initial load\n  useState(() => {\n    setTimeout(() => setIsLoading(false), 100);\n  });\n\n  return {\n    rules,\n    currentRule,\n    isLoading,\n    createRule,\n    updateRule,\n    deleteRule,\n    toggleRule,\n    setCurrentRule,\n    resetEditor,\n    validateRule,\n    isRuleValid: validationErrors.length === 0,\n    validationErrors,\n    testRule,\n    isTesting,\n    addCondition,\n    removeCondition,\n    updateCondition,\n    addAction,\n    removeAction,\n    updateAction,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/multi-wearer-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useAdminSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderRewards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (120). Maximum allowed is 75.",
        "line": 33,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 167,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from 'react';\nimport { doc, setDoc, onSnapshot } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} KeyholderPermissions\n * @property {boolean} canModifyDuration\n * @property {boolean} canAssignTasks\n * @property {boolean} canViewHistory\n */\n\n/**\n * @typedef {Object} KeyholderSessionState\n * @property {boolean} isActive\n * @property {string|null} keyholderEmail\n * @property {Date|null} sessionStartTime\n * @property {KeyholderPermissions} permissions\n * @property {number} [requiredDuration]\n */\n\n/**\n * @typedef {Object} KeyholderSessionOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {string} [userEmail]\n */\n\n/**\n * Hook for managing keyholder sessions\n * @param {KeyholderSessionOptions} options\n * @returns {Object}\n */\nexport const useKeyholderSession = ({ userId, isAuthReady }) => {\n  const [sessionState, setSessionState] = useState({\n    isActive: false,\n    keyholderEmail: null,\n    sessionStartTime: null,\n    permissions: {\n      canModifyDuration: false,\n      canAssignTasks: false,\n      canViewHistory: false\n    }\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const startKeyholderSession = useCallback(async (keyholderEmail, permissions = {}) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      const newSessionState = {\n        isActive: true,\n        keyholderEmail,\n        sessionStartTime: new Date(),\n        permissions: {\n          canModifyDuration: permissions.canModifyDuration ?? true,\n          canAssignTasks: permissions.canAssignTasks ?? true,\n          canViewHistory: permissions.canViewHistory ?? true\n        }\n      };\n\n      await setDoc(userDocRef, { keyholderSession: newSessionState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to start keyholder session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const endKeyholderSession = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      const endSessionState = {\n        isActive: false,\n        keyholderEmail: null,\n        sessionStartTime: null,\n        permissions: {\n          canModifyDuration: false,\n          canAssignTasks: false,\n          canViewHistory: false\n        }\n      };\n\n      await setDoc(userDocRef, { keyholderSession: endSessionState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to end keyholder session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const updatePermissions = useCallback(async (newPermissions) => {\n    if (!userId || !isAuthReady || !sessionState.isActive) {\n      setError('No active keyholder session');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { \n        keyholderSession: {\n          ...sessionState,\n          permissions: { ...sessionState.permissions, ...newPermissions }\n        }\n      }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to update permissions');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, sessionState]);\n\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.keyholderSession) {\n            setSessionState({\n              ...data.keyholderSession,\n              sessionStartTime: data.keyholderSession.sessionStartTime?.toDate() || null\n            });\n          }\n        }\n        setError(null);\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [userId, isAuthReady]);\n\n  return {\n    sessionState,\n    isLoading,\n    error,\n    startKeyholderSession,\n    endKeyholderSession,\n    updatePermissions,\n    isKeyholderActive: sessionState.isActive && sessionState.keyholderEmail !== null\n  };\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSession.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useKeyholderSystem.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (265). Maximum allowed is 75.",
        "line": 140,
        "column": 35,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 477,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'refreshData'. Either include it or remove the dependency array.",
        "line": 438,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 441,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]",
            "fix": {
              "range": [13081, 13185],
              "text": "[keyholderRelationships.relationships.asKeyholder.length, refreshData, state.activeRelationships.length]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'endAdminSession'. Either include it or remove the dependency array.",
        "line": 451,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 451,
        "endColumn": 26,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [endAdminSession, state.adminSession]",
            "fix": { "range": [13570, 13590], "text": "[endAdminSession, state.adminSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useKeyholderSystem Hook\n * Unified management interface for all keyholder functionality\n * Acts as the primary entry point for keyholder operations\n */\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { useAuthState } from \"../../contexts\";\nimport { useKeyholderRelationships } from \"../useKeyholderRelationships\";\nimport {\n  KeyholderRelationship,\n  KeyholderPermissions as _KeyholderPermissions,\n} from \"../../types/core\";\nimport { Task } from \"../../types\";\nimport { InviteCode } from \"../../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderSystem\");\n\n// ==================== TYPES ====================\n\nexport interface KeyholderStats {\n  totalSubmissives: number;\n  activeRelationships: number;\n  totalSessions: number;\n  averageSessionDuration: number;\n  totalRewardsGiven: number;\n  totalPunishmentsGiven: number;\n  lastActivity: Date | null;\n}\n\nexport interface KeyholderStatus {\n  isActiveKeyholder: boolean;\n  hasPermissions: boolean;\n  canCreateInvites: boolean;\n  maxRelationships: number;\n  currentRelationships: number;\n}\n\nexport interface AdminSession {\n  id: string;\n  keyholderId: string;\n  relationshipId: string;\n  startTime: Date;\n  expiresAt: Date;\n  permissions: string[];\n  isActive: boolean;\n  lastActivity: Date;\n}\n\nexport interface KeyholderSystemState {\n  // Active relationships where user is keyholder\n  activeRelationships: KeyholderRelationship[];\n  // Current admin session if active\n  adminSession: AdminSession | null;\n  // Overall keyholder status and permissions\n  keyholderStatus: KeyholderStatus;\n  // Quick stats for dashboard\n  stats: KeyholderStats;\n  // Currently selected relationship for operations\n  selectedRelationship: KeyholderRelationship | null;\n  // Loading states\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n}\n\nexport interface InviteOptions {\n  expirationHours?: number;\n  maxUses?: number;\n  customNote?: string;\n}\n\nexport interface BulkOperations {\n  startSessions: (\n    relationshipIds: string[],\n    options?: { duration?: number; message?: string },\n  ) => Promise<void>;\n  stopSessions: (relationshipIds: string[], reason?: string) => Promise<void>;\n  sendMessages: (relationshipIds: string[], message: string) => Promise<void>;\n  assignTasks: (\n    relationshipIds: string[],\n    task: Omit<Task, \"id\" | \"createdAt\">,\n  ) => Promise<void>;\n}\n\nexport interface KeyholderSystemActions {\n  // Relationship management\n  createInviteCode: (options?: InviteOptions) => Promise<string | null>;\n  acceptSubmissive: (\n    inviteCode: string,\n  ) => Promise<KeyholderRelationship | null>;\n  removeSubmissive: (relationshipId: string) => Promise<void>;\n\n  // Session management\n  startAdminSession: (relationshipId: string) => Promise<AdminSession | null>;\n  endAdminSession: () => Promise<void>;\n\n  // Multi-user operations\n  switchActiveRelationship: (relationshipId: string) => void;\n  getBulkOperations: () => BulkOperations;\n\n  // Data management\n  refreshData: () => Promise<void>;\n  resetError: () => void;\n}\n\n// ==================== INITIAL STATE ====================\n\nconst initialKeyholderStatus: KeyholderStatus = {\n  isActiveKeyholder: false,\n  hasPermissions: false,\n  canCreateInvites: false,\n  maxRelationships: 5, // Default limit\n  currentRelationships: 0,\n};\n\nconst initialStats: KeyholderStats = {\n  totalSubmissives: 0,\n  activeRelationships: 0,\n  totalSessions: 0,\n  averageSessionDuration: 0,\n  totalRewardsGiven: 0,\n  totalPunishmentsGiven: 0,\n  lastActivity: null,\n};\n\nconst initialState: KeyholderSystemState = {\n  activeRelationships: [],\n  adminSession: null,\n  keyholderStatus: initialKeyholderStatus,\n  stats: initialStats,\n  selectedRelationship: null,\n  isLoading: false,\n  isInitialized: false,\n  error: null,\n};\n\n// ==================== MAIN HOOK ====================\n\nexport const useKeyholderSystem = (keyholderId?: string) => {\n  const { user } = useAuthState();\n  const keyholderRelationships = useKeyholderRelationships();\n\n  // Use provided keyholderId or fall back to current user\n  const effectiveKeyholderId = keyholderId || user?.uid;\n\n  const [state, setState] = useState<KeyholderSystemState>(initialState);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const computedValues = useMemo(() => {\n    const { activeRelationships, adminSession, keyholderStatus } = state;\n\n    return {\n      hasActiveRelationships: activeRelationships.length > 0,\n      canStartAdminSession: adminSession === null,\n      activeRelationshipCount: activeRelationships.length,\n      hasMaxRelationships:\n        keyholderStatus.currentRelationships >=\n        keyholderStatus.maxRelationships,\n      selectedRelationshipId: state.selectedRelationship?.id || null,\n    };\n  }, [state]);\n\n  // ==================== ACTIONS ====================\n\n  const refreshData = useCallback(async () => {\n    if (!effectiveKeyholderId) return;\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      logger.debug(\"Refreshing keyholder system data\", {\n        keyholderId: effectiveKeyholderId,\n      });\n\n      // Get relationships from the existing hook\n      await keyholderRelationships.loadRelationships();\n\n      const keyholderRelationshipsList =\n        keyholderRelationships.relationships.asKeyholder;\n\n      // Calculate keyholder status and stats\n      const { keyholderStatus, stats } = calculateKeyholderStatusAndStats(\n        keyholderRelationshipsList,\n        keyholderRelationships,\n      );\n\n      setState((prev) => ({\n        ...prev,\n        activeRelationships: keyholderRelationshipsList,\n        keyholderStatus,\n        stats,\n        isLoading: false,\n        isInitialized: true,\n      }));\n\n      logger.info(\"Keyholder system data refreshed\", {\n        relationshipCount: keyholderRelationshipsList.length,\n        activeCount: stats.activeRelationships,\n      });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : \"Failed to refresh keyholder data\";\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: errorMessage,\n      }));\n      logger.error(\"Failed to refresh keyholder system data\", {\n        error: error as Error,\n      });\n    }\n  }, [effectiveKeyholderId, keyholderRelationships]);\n\n  const createInviteCode = useCallback(\n    async (options: InviteOptions = {}): Promise<string | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Creating invite code\", {\n          keyholderId: effectiveKeyholderId,\n          options,\n        });\n\n        const inviteCode = await keyholderRelationships.createInviteCode(\n          options.expirationHours,\n        );\n\n        return await handleInviteCodeCreation(inviteCode, refreshData);\n      } catch (error) {\n        return handleInviteCodeError(error, setState);\n      }\n    },\n    [effectiveKeyholderId, keyholderRelationships, refreshData],\n  );\n\n  const acceptSubmissive = useCallback(\n    async (inviteCode: string): Promise<KeyholderRelationship | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Accepting submissive\", {\n          keyholderId: effectiveKeyholderId,\n          inviteCode,\n        });\n\n        const success =\n          await keyholderRelationships.acceptInviteCode(inviteCode);\n\n        return await handleSubmissiveAcceptance(\n          success,\n          refreshData,\n          state.activeRelationships,\n        );\n      } catch (error) {\n        return handleSubmissiveAcceptanceError(error, setState);\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.activeRelationships,\n    ],\n  );\n\n  const removeSubmissive = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      if (!effectiveKeyholderId) return;\n\n      try {\n        logger.debug(\"Removing submissive\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        await keyholderRelationships.endRelationship(relationshipId);\n\n        // Refresh data to update state\n        await refreshData();\n\n        // Clear selected relationship if it was the removed one\n        if (state.selectedRelationship?.id === relationshipId) {\n          setState((prev) => ({ ...prev, selectedRelationship: null }));\n        }\n      } catch (error) {\n        logger.error(\"Failed to remove submissive\", { error: error as Error });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to remove submissive\",\n        }));\n      }\n    },\n    [\n      effectiveKeyholderId,\n      keyholderRelationships,\n      refreshData,\n      state.selectedRelationship,\n    ],\n  );\n\n  const switchActiveRelationship = useCallback(\n    (relationshipId: string) => {\n      const relationship = state.activeRelationships.find(\n        (rel) => rel.id === relationshipId,\n      );\n      if (relationship) {\n        setState((prev) => ({ ...prev, selectedRelationship: relationship }));\n        logger.debug(\"Switched active relationship\", { relationshipId });\n      }\n    },\n    [state.activeRelationships],\n  );\n\n  // Admin session management (placeholder implementation)\n  const startAdminSession = useCallback(\n    async (relationshipId: string): Promise<AdminSession | null> => {\n      if (!effectiveKeyholderId) return null;\n\n      try {\n        logger.debug(\"Starting admin session\", {\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n        });\n\n        // TODO: Implement actual admin session creation\n        const adminSession: AdminSession = {\n          id: `admin_${Date.now()}`,\n          keyholderId: effectiveKeyholderId,\n          relationshipId,\n          startTime: new Date(),\n          expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes\n          permissions: [\"session_control\", \"task_management\", \"rewards\"], // Default permissions\n          isActive: true,\n          lastActivity: new Date(),\n        };\n\n        setState((prev) => ({ ...prev, adminSession }));\n\n        logger.info(\"Admin session started\", { sessionId: adminSession.id });\n        return adminSession;\n      } catch (error) {\n        logger.error(\"Failed to start admin session\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          error:\n            error instanceof Error\n              ? error.message\n              : \"Failed to start admin session\",\n        }));\n        return null;\n      }\n    },\n    [effectiveKeyholderId],\n  );\n\n  const endAdminSession = useCallback(async (): Promise<void> => {\n    if (!state.adminSession) return;\n\n    try {\n      logger.debug(\"Ending admin session\", {\n        sessionId: state.adminSession.id,\n      });\n\n      // TODO: Implement actual admin session cleanup\n      setState((prev) => ({ ...prev, adminSession: null }));\n\n      logger.info(\"Admin session ended\");\n    } catch (error) {\n      logger.error(\"Failed to end admin session\", { error: error as Error });\n      setState((prev) => ({\n        ...prev,\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to end admin session\",\n      }));\n    }\n  }, [state.adminSession]);\n\n  const getBulkOperations = useCallback((): BulkOperations => {\n    return {\n      startSessions: async (\n        relationshipIds: string[],\n        options?: { duration?: number; message?: string },\n      ) => {\n        logger.debug(\"Bulk starting sessions\", { relationshipIds, options });\n        // TODO: Implement bulk session start\n      },\n      stopSessions: async (relationshipIds: string[], reason?: string) => {\n        logger.debug(\"Bulk stopping sessions\", { relationshipIds, reason });\n        // TODO: Implement bulk session stop\n      },\n      sendMessages: async (relationshipIds: string[], message: string) => {\n        logger.debug(\"Bulk sending messages\", { relationshipIds, message });\n        // TODO: Implement bulk messaging\n      },\n      assignTasks: async (\n        relationshipIds: string[],\n        task: Omit<Task, \"id\" | \"createdAt\">,\n      ) => {\n        logger.debug(\"Bulk assigning tasks\", { relationshipIds, task });\n        // TODO: Implement bulk task assignment\n      },\n    };\n  }, []);\n\n  const resetError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  // ==================== EFFECTS ====================\n\n  // Initialize data when user changes\n  useEffect(() => {\n    if (effectiveKeyholderId && !state.isInitialized) {\n      refreshData();\n    }\n  }, [effectiveKeyholderId, state.isInitialized, refreshData]);\n\n  // Auto-refresh when relationships data changes\n  useEffect(() => {\n    if (\n      keyholderRelationships.relationships.asKeyholder.length !==\n      state.activeRelationships.length\n    ) {\n      refreshData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    keyholderRelationships.relationships.asKeyholder.length,\n    state.activeRelationships.length,\n  ]);\n\n  // Admin session auto-expiry\n  useEffect(() => {\n    if (state.adminSession && state.adminSession.expiresAt < new Date()) {\n      logger.info(\"Admin session expired, ending session\");\n      endAdminSession();\n    }\n    // endAdminSession is stable as it only depends on state.adminSession which is already in deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [state.adminSession]);\n\n  // ==================== RETURN ====================\n\n  const actions: KeyholderSystemActions = {\n    createInviteCode,\n    acceptSubmissive,\n    removeSubmissive,\n    startAdminSession,\n    endAdminSession,\n    switchActiveRelationship,\n    getBulkOperations,\n    refreshData,\n    resetError,\n  };\n\n  return {\n    // State\n    ...state,\n\n    // Computed\n    ...computedValues,\n\n    // Actions\n    ...actions,\n  };\n};\n\nexport type UseKeyholderSystemReturn = ReturnType<typeof useKeyholderSystem>;\n\n// Helper functions for useKeyholderSystem\nfunction calculateKeyholderStatusAndStats(\n  keyholderRelationshipsList: KeyholderRelationship[],\n  keyholderRelationships: Record<string, unknown>,\n): { keyholderStatus: KeyholderStatus; stats: KeyholderStats } {\n  // Calculate keyholder status\n  const keyholderStatus: KeyholderStatus = {\n    isActiveKeyholder: keyholderRelationshipsList.length > 0,\n    hasPermissions: keyholderRelationshipsList.some(\n      (rel) =>\n        rel.permissions && Object.values(rel.permissions).some((perm) => perm),\n    ),\n    canCreateInvites: keyholderRelationships.canCreateInviteCode\n      ? keyholderRelationships.canCreateInviteCode()\n      : false,\n    maxRelationships: 5, // Could be user-specific in the future\n    currentRelationships: keyholderRelationshipsList.length,\n  };\n\n  // Calculate basic stats\n  const stats: KeyholderStats = {\n    totalSubmissives: keyholderRelationshipsList.length,\n    activeRelationships: keyholderRelationshipsList.filter(\n      (rel) => rel.status === \"active\",\n    ).length,\n    totalSessions: 0, // TODO: Calculate from session data\n    averageSessionDuration: 0, // TODO: Calculate from session data\n    totalRewardsGiven: 0, // TODO: Calculate from reward data\n    totalPunishmentsGiven: 0, // TODO: Calculate from punishment data\n    lastActivity: null, // TODO: Calculate from activity data\n  };\n\n  return { keyholderStatus, stats };\n}\n\nasync function handleInviteCodeCreation(\n  inviteCode: InviteCode | null,\n  refreshData: () => Promise<void>,\n): Promise<string | null> {\n  if (inviteCode) {\n    // Refresh data to update state\n    await refreshData();\n    return inviteCode.code;\n  }\n  return null;\n}\n\nfunction handleInviteCodeError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to create invite code\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to create invite code\",\n  }));\n  return null;\n}\n\nasync function handleSubmissiveAcceptance(\n  success: boolean,\n  refreshData: () => Promise<void>,\n  activeRelationships: KeyholderRelationship[],\n): Promise<KeyholderRelationship | null> {\n  if (success) {\n    // Refresh data to get the new relationship\n    await refreshData();\n\n    // Return the newest relationship (should be the one just created)\n    const newestRelationship = activeRelationships.sort(\n      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),\n    )[0];\n\n    return newestRelationship || null;\n  }\n  return null;\n}\n\nfunction handleSubmissiveAcceptanceError(\n  error: unknown,\n  setState: React.Dispatch<React.SetStateAction<KeyholderSystemState>>,\n): null {\n  logger.error(\"Failed to accept submissive\", { error: error as Error });\n  setState((prev) => ({\n    ...prev,\n    error:\n      error instanceof Error ? error.message : \"Failed to accept submissive\",\n  }));\n  return null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useMultiWearer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/keyholder/useSessionControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useHapticFeedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/usePullToRefresh.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (107). Maximum allowed is 75.",
        "line": 28,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 159,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Pull to Refresh Hook\n * Provides pull-to-refresh functionality for mobile devices\n */\nimport { useCallback, useRef, useState, useEffect } from \"react\";\nimport type { React } from \"react\";\nimport { useHapticFeedback } from \"./useHapticFeedback\";\nimport { logger } from \"../../utils/logging\";\n\ninterface PullToRefreshOptions {\n  threshold?: number;\n  maxPullDistance?: number;\n  onRefresh: () => Promise<void> | void;\n  disabled?: boolean;\n}\n\ninterface PullToRefreshReturn {\n  isRefreshing: boolean;\n  isPulling: boolean;\n  pullDistance: number;\n  pullPercentage: number;\n  onTouchStart: (e: React.TouchEvent) => void;\n  onTouchMove: (e: React.TouchEvent) => void;\n  onTouchEnd: (e: React.TouchEvent) => void;\n  onScroll: (e: React.UIEvent) => void;\n}\n\nexport const usePullToRefresh = ({\n  threshold = 80,\n  maxPullDistance = 120,\n  onRefresh,\n  disabled = false,\n}: PullToRefreshOptions): PullToRefreshReturn => {\n  const { light: hapticLight, success: hapticSuccess } = useHapticFeedback();\n\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [isPulling, setIsPulling] = useState(false);\n  const [pullDistance, setPullDistance] = useState(0);\n  const [_scrollTop, setScrollTop] = useState(0);\n\n  const startY = useRef<number>(0);\n  const currentY = useRef<number>(0);\n  const isAtTop = useRef<boolean>(true);\n  const hasTriggeredHaptic = useRef<boolean>(false);\n\n  const pullPercentage = Math.min((pullDistance / threshold) * 100, 100);\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      if (disabled || isRefreshing) return;\n\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      startY.current = touch.clientY;\n      currentY.current = touch.clientY;\n      hasTriggeredHaptic.current = false;\n    },\n    [disabled, isRefreshing],\n  );\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent) => {\n      if (disabled || isRefreshing || !isAtTop.current) return;\n\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      currentY.current = touch.clientY;\n      const deltaY = currentY.current - startY.current;\n\n      if (deltaY > 0) {\n        // Pulling down\n        const distance = Math.min(deltaY * 0.5, maxPullDistance); // Apply resistance\n        setPullDistance(distance);\n        setIsPulling(distance > 10);\n\n        // Haptic feedback when threshold is reached\n        if (distance >= threshold && !hasTriggeredHaptic.current) {\n          hapticLight();\n          hasTriggeredHaptic.current = true;\n        }\n\n        // Prevent default scrolling when pulling\n        if (deltaY > 10) {\n          e.preventDefault();\n        }\n      } else {\n        setPullDistance(0);\n        setIsPulling(false);\n      }\n    },\n    [disabled, isRefreshing, threshold, maxPullDistance, hapticLight],\n  );\n\n  const handleTouchEnd = useCallback(async () => {\n    if (disabled || isRefreshing) return;\n\n    if (pullDistance >= threshold) {\n      setIsRefreshing(true);\n      hapticSuccess();\n\n      try {\n        await onRefresh();\n      } catch (error) {\n        logger.error(\"Pull to refresh failed\", { error }, \"usePullToRefresh\");\n      } finally {\n        setIsRefreshing(false);\n      }\n    }\n\n    setPullDistance(0);\n    setIsPulling(false);\n    hasTriggeredHaptic.current = false;\n  }, [\n    disabled,\n    isRefreshing,\n    pullDistance,\n    threshold,\n    onRefresh,\n    hapticSuccess,\n  ]);\n\n  const handleScroll = useCallback(\n    (e: React.UIEvent) => {\n      const target = e.currentTarget as HTMLElement;\n      const scrollTop = target.scrollTop;\n      setScrollTop(scrollTop);\n      isAtTop.current = scrollTop <= 0;\n\n      // Reset pull state when scrolling away from top\n      if (scrollTop > 0 && isPulling) {\n        setPullDistance(0);\n        setIsPulling(false);\n      }\n    },\n    [isPulling],\n  );\n\n  // Reset states when disabled changes\n  useEffect(() => {\n    if (disabled) {\n      setPullDistance(0);\n      setIsPulling(false);\n      setIsRefreshing(false);\n    }\n  }, [disabled]);\n\n  return {\n    isRefreshing,\n    isPulling,\n    pullDistance,\n    pullPercentage,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd,\n    onScroll: handleScroll,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useTouchGestures.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (94). Maximum allowed is 75.",
        "line": 83,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 205,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Touch Gestures Hook\n * Provides swipe, tap, and other touch interactions for mobile devices\n */\nimport { useCallback, useRef, useState } from \"react\";\nimport type { React } from \"react\";\n\ninterface TouchPoint {\n  x: number;\n  y: number;\n  timestamp: number;\n}\n\ninterface SwipeOptions {\n  minDistance?: number;\n  maxTime?: number;\n  threshold?: number;\n}\n\ninterface UseTouchGesturesReturn {\n  onTouchStart: (e: React.TouchEvent) => void;\n  onTouchMove: (e: React.TouchEvent) => void;\n  onTouchEnd: (e: React.TouchEvent) => void;\n  isSwipeActive: boolean;\n}\n\ninterface TouchGestureHandlers {\n  onSwipeLeft?: () => void;\n  onSwipeRight?: () => void;\n  onSwipeUp?: () => void;\n  onSwipeDown?: () => void;\n  onTap?: () => void;\n  onLongPress?: () => void;\n}\n\n// Helper function to determine if a gesture is a tap\nconst isTapGesture = (\n  deltaX: number,\n  deltaY: number,\n  threshold: number,\n): boolean => {\n  return Math.abs(deltaX) < threshold && Math.abs(deltaY) < threshold;\n};\n\n// Helper function to determine swipe direction and trigger handler\nconst handleSwipeGesture = (\n  deltaX: number,\n  deltaY: number,\n  minDistance: number,\n  handlers: TouchGestureHandlers,\n): void => {\n  const absDeltaX = Math.abs(deltaX);\n  const absDeltaY = Math.abs(deltaY);\n\n  if (absDeltaX > absDeltaY && absDeltaX >= minDistance) {\n    // Horizontal swipe\n    if (deltaX > 0) {\n      handlers.onSwipeRight?.();\n    } else {\n      handlers.onSwipeLeft?.();\n    }\n  } else if (absDeltaY >= minDistance) {\n    // Vertical swipe\n    if (deltaY > 0) {\n      handlers.onSwipeDown?.();\n    } else {\n      handlers.onSwipeUp?.();\n    }\n  }\n};\n\n// Helper function to reset touch state\nconst resetTouchState = (\n  touchStart: React.MutableRefObject<TouchPoint | null>,\n  touchCurrent: React.MutableRefObject<TouchPoint | null>,\n  setIsSwipeActive: (active: boolean) => void,\n): void => {\n  touchStart.current = null;\n  touchCurrent.current = null;\n  setIsSwipeActive(false);\n};\n\nexport const useTouchGestures = (\n  handlers: TouchGestureHandlers,\n  options: SwipeOptions = {},\n): UseTouchGesturesReturn => {\n  const { minDistance = 50, maxTime = 1000, threshold = 30 } = options;\n\n  const touchStart = useRef<TouchPoint | null>(null);\n  const touchCurrent = useRef<TouchPoint | null>(null);\n  const longPressTimer = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const [isSwipeActive, setIsSwipeActive] = useState(false);\n\n  const clearLongPressTimer = useCallback(() => {\n    if (longPressTimer.current) {\n      clearTimeout(longPressTimer.current);\n      longPressTimer.current = null;\n    }\n  }, []);\n\n  const handleTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      const touchPoint: TouchPoint = {\n        x: touch.clientX,\n        y: touch.clientY,\n        timestamp: Date.now(),\n      };\n\n      touchStart.current = touchPoint;\n      touchCurrent.current = touchPoint;\n      setIsSwipeActive(false);\n\n      // Start long press timer\n      if (handlers.onLongPress) {\n        longPressTimer.current = setTimeout(() => {\n          handlers.onLongPress?.();\n        }, 500);\n      }\n\n      // Prevent default to avoid iOS bounce\n      if (e.cancelable) {\n        e.preventDefault();\n      }\n    },\n    [handlers],\n  );\n\n  const handleTouchMove = useCallback(\n    (e: React.TouchEvent) => {\n      const touch = e.touches[0];\n      if (!touch || !touchStart.current) return;\n\n      touchCurrent.current = {\n        x: touch.clientX,\n        y: touch.clientY,\n        timestamp: Date.now(),\n      };\n\n      const deltaX = Math.abs(touch.clientX - touchStart.current.x);\n      const deltaY = Math.abs(touch.clientY - touchStart.current.y);\n\n      // Clear long press if we've moved significantly\n      if (deltaX > threshold || deltaY > threshold) {\n        clearLongPressTimer();\n\n        // Set swipe active if we've moved enough\n        if (deltaX > minDistance || deltaY > minDistance) {\n          setIsSwipeActive(true);\n        }\n      }\n\n      // Prevent scrolling during horizontal swipes\n      if (deltaX > deltaY && deltaX > threshold) {\n        e.preventDefault();\n      }\n    },\n    [minDistance, threshold, clearLongPressTimer],\n  );\n\n  const handleTouchEnd = useCallback(\n    (_e: React.TouchEvent) => {\n      clearLongPressTimer();\n\n      if (!touchStart.current || !touchCurrent.current) {\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      const startPoint = touchStart.current;\n      const endPoint = touchCurrent.current;\n      const deltaTime = endPoint.timestamp - startPoint.timestamp;\n\n      // Check if gesture was too slow\n      if (deltaTime > maxTime) {\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      const deltaX = endPoint.x - startPoint.x;\n      const deltaY = endPoint.y - startPoint.y;\n\n      // Determine if it's a tap (small movement)\n      if (isTapGesture(deltaX, deltaY, threshold)) {\n        handlers.onTap?.();\n        resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n        return;\n      }\n\n      // Handle swipe gestures\n      handleSwipeGesture(deltaX, deltaY, minDistance, handlers);\n      resetTouchState(touchStart, touchCurrent, setIsSwipeActive);\n    },\n    [handlers, maxTime, minDistance, threshold, clearLongPressTimer],\n  );\n\n  return {\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd,\n    isSwipeActive,\n  };\n};\n\n/**\n * Simplified swipe hook for common use cases\n */\nexport const useSwipeGestures = (\n  onSwipeLeft?: () => void,\n  onSwipeRight?: () => void,\n  options?: SwipeOptions,\n) => {\n  return useTouchGestures(\n    {\n      onSwipeLeft,\n      onSwipeRight,\n    },\n    options,\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/mobile/useViewport.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (94). Maximum allowed is 75.",
        "line": 32,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 146,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'updateSafeAreaInsets' and 'updateViewport'. Either include them or remove the dependency array.",
        "line": 124,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 124,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [updateSafeAreaInsets, updateViewport]",
            "fix": { "range": [3158, 3160], "text": "[updateSafeAreaInsets, updateViewport]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Viewport Hook\n * Provides viewport dimensions and mobile-specific viewport utilities\n */\nimport { useState, useEffect, useCallback } from \"react\";\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n  innerWidth: number;\n  innerHeight: number;\n}\n\ninterface ViewportInfo extends ViewportSize {\n  isMobile: boolean;\n  isTablet: boolean;\n  isDesktop: boolean;\n  isLandscape: boolean;\n  isPortrait: boolean;\n  safeAreaInsets: {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n  };\n}\n\n// Breakpoints\nconst MOBILE_BREAKPOINT = 768;\nconst TABLET_BREAKPOINT = 1024;\n\nexport const useViewport = (): ViewportInfo => {\n  const [viewport, setViewport] = useState<ViewportSize>(() => {\n    if (typeof window === \"undefined\") {\n      return {\n        width: 0,\n        height: 0,\n        innerWidth: 0,\n        innerHeight: 0,\n      };\n    }\n\n    return {\n      width: window.screen.width,\n      height: window.screen.height,\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight,\n    };\n  });\n\n  const [safeAreaInsets, setSafeAreaInsets] = useState({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  });\n\n  const updateViewport = useCallback(() => {\n    setViewport({\n      width: window.screen.width,\n      height: window.screen.height,\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight,\n    });\n  }, []);\n\n  const updateSafeAreaInsets = useCallback(() => {\n    if (typeof window === \"undefined\" || !window.getComputedStyle) return;\n\n    const computedStyle = window.getComputedStyle(document.documentElement);\n\n    setSafeAreaInsets({\n      top: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-top)\") || \"0\",\n      ),\n      bottom: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-bottom)\") || \"0\",\n      ),\n      left: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-left)\") || \"0\",\n      ),\n      right: parseInt(\n        computedStyle.getPropertyValue(\"env(safe-area-inset-right)\") || \"0\",\n      ),\n    });\n  }, []);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    updateViewport();\n    updateSafeAreaInsets();\n\n    // Handle resize events with throttling\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const handleResize = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        updateViewport();\n        updateSafeAreaInsets();\n      }, 150);\n    };\n\n    // Handle orientation change\n    const handleOrientationChange = () => {\n      // Delay to account for viewport changes after orientation change\n      setTimeout(() => {\n        updateViewport();\n        updateSafeAreaInsets();\n      }, 500);\n    };\n\n    window.addEventListener(\"resize\", handleResize, { passive: true });\n    window.addEventListener(\"orientationchange\", handleOrientationChange, {\n      passive: true,\n    });\n\n    return () => {\n      clearTimeout(timeoutId);\n      window.removeEventListener(\"resize\", handleResize);\n      window.removeEventListener(\"orientationchange\", handleOrientationChange);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Determine device type based on viewport width\n  const isMobile = viewport.innerWidth < MOBILE_BREAKPOINT;\n  const isTablet =\n    viewport.innerWidth >= MOBILE_BREAKPOINT &&\n    viewport.innerWidth < TABLET_BREAKPOINT;\n  const isDesktop = viewport.innerWidth >= TABLET_BREAKPOINT;\n\n  // Determine orientation\n  const isLandscape = viewport.innerWidth > viewport.innerHeight;\n  const isPortrait = viewport.innerHeight >= viewport.innerWidth;\n\n  return {\n    ...viewport,\n    isMobile,\n    isTablet,\n    isDesktop,\n    isLandscape,\n    isPortrait,\n    safeAreaInsets,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/profile-achievements-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileAchievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfilePrivacy.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileSharing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/useProfileStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/profile/usePublicProfile.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/notification-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/notification-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/presence-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/presence-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/realtime-sync-operations.ts",
    "messages": [
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (10). Maximum allowed is 5.",
        "line": 50,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 50,
        "endColumn": 5
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (8). Maximum allowed is 5.",
        "line": 97,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 97,
        "endColumn": 5
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (8). Maximum allowed is 5.",
        "line": 142,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 142,
        "endColumn": 5
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (11). Maximum allowed is 5.",
        "line": 326,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 326,
        "endColumn": 5
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Realtime sync operation helper functions\n */\nimport React from \"react\";\nimport {\n  RealtimeSyncState,\n  ConnectionStatus,\n  SyncChannel,\n  ChannelType,\n  RealtimeUpdate,\n  Subscription,\n} from \"../../types/realtime\";\nimport {\n  createWebSocketUrl,\n  createSyncChannel,\n  sendWebSocketMessage,\n  updateSyncMetrics,\n  shouldAttemptReconnection,\n  createSubscription,\n  notifySubscribers as _notifySubscribers,\n} from \"./realtimeSyncHelpers\";\n\n// Helper to create sendMessage function\nconst createSendMessage = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n) => {\n  return (message: RealtimeUpdate | Record<string, unknown>) => {\n    sendWebSocketMessage(wsRef.current, message, () => {\n      setSyncState((prev) => ({\n        ...prev,\n        syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageSent\"),\n      }));\n    });\n  };\n};\n\n// Helper to create the connect function\nconst createConnectFunction = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  connectionStartTimeRef: React.MutableRefObject<Date | null>,\n  reconnectAttemptsRef: React.MutableRefObject<number>,\n  maxReconnectAttempts: number,\n  userId: string,\n  handleMessage: (message: Record<string, unknown>) => void,\n  startHeartbeat: () => void,\n  stopHeartbeat: () => void,\n  attemptReconnect: () => void,\n) => {\n  return () => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTING,\n    }));\n\n    try {\n      const wsUrl = createWebSocketUrl(userId);\n      wsRef.current = new WebSocket(wsUrl);\n      connectionStartTimeRef.current = new Date();\n\n      setupWebSocketHandlers(\n        wsRef.current,\n        setSyncState,\n        reconnectAttemptsRef,\n        maxReconnectAttempts,\n        handleMessage,\n        startHeartbeat,\n        stopHeartbeat,\n        attemptReconnect,\n      );\n    } catch {\n      setSyncState((prev) => ({\n        ...prev,\n        connectionStatus: ConnectionStatus.ERROR,\n      }));\n    }\n  };\n};\n\n// Helper to create connection control functions\nconst createConnectionControlFunctions = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  reconnectAttemptsRef: React.MutableRefObject<number>,\n  reconnectTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  maxReconnectAttempts: number,\n  reconnectInterval: number,\n  stopHeartbeat: () => void,\n  connect: () => void,\n) => {\n  const attemptReconnect = () => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      return;\n    }\n\n    reconnectAttemptsRef.current++;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.RECONNECTING,\n    }));\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, reconnectInterval);\n  };\n\n  const disconnect = () => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Intentional disconnect\");\n      wsRef.current = null;\n    }\n\n    stopHeartbeat();\n\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n  };\n\n  return { attemptReconnect, disconnect };\n};\n\n// Helper to setup WebSocket event handlers\nconst setupWebSocketHandlers = (\n  ws: WebSocket,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  reconnectAttemptsRef: React.MutableRefObject<number>,\n  maxReconnectAttempts: number,\n  handleMessage: (message: Record<string, unknown>) => void,\n  startHeartbeat: () => void,\n  stopHeartbeat: () => void,\n  attemptReconnect: () => void,\n) => {\n  ws.onopen = () => {\n    // WebSocket connected\n    reconnectAttemptsRef.current = 0;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTED,\n    }));\n\n    // Start heartbeat\n    startHeartbeat();\n\n    // Rejoin previous channels\n    // Implementation would go here\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      handleMessage(message);\n    } catch {\n      // Failed to parse WebSocket message\n    }\n  };\n\n  ws.onclose = (event) => {\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.DISCONNECTED,\n    }));\n\n    stopHeartbeat();\n\n    if (\n      shouldAttemptReconnection(\n        event,\n        reconnectAttemptsRef.current,\n        maxReconnectAttempts,\n      )\n    ) {\n      attemptReconnect();\n    }\n  };\n\n  ws.onerror = (_error) => {\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.ERROR,\n      syncMetrics: updateSyncMetrics(prev.syncMetrics, \"error\"),\n    }));\n  };\n};\n\n// Helper to create message handlers\nconst createMessageHandlers = (\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n) => {\n  const handleChannelJoined = (message: { channel: SyncChannel }) => {\n    const channel: SyncChannel = message.channel;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: [\n        ...prev.activeChannels.filter((c) => c.id !== channel.id),\n        channel,\n      ],\n    }));\n  };\n\n  const handleChannelLeft = (message: { channelId: string }) => {\n    const channelId = message.channelId;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: prev.activeChannels.filter((c) => c.id !== channelId),\n    }));\n  };\n\n  const handleRealtimeUpdate = (message: { update: RealtimeUpdate }) => {\n    const update: RealtimeUpdate = message.update;\n\n    // Update local data\n    setSyncState((prev) => ({\n      ...prev,\n      realtimeData: {\n        ...prev.realtimeData,\n        [update.type]: update.data,\n      },\n    }));\n\n    // Notify subscribers - using object instead of Map\n    const subscriptionKeys = Object.keys(subscriptionsRef.current);\n    for (let i = 0; i < subscriptionKeys.length; i++) {\n      const key = subscriptionKeys[i];\n      const subscription = subscriptionsRef.current[key];\n      if (subscription.dataType === update.type && subscription.isActive) {\n        try {\n          subscription.callback(update);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    }\n  };\n\n  const handleMessage = (message: Record<string, unknown>) => {\n    setSyncState((prev) => ({\n      ...prev,\n      syncMetrics: updateSyncMetrics(prev.syncMetrics, \"messageReceived\"),\n    }));\n\n    switch (message.type) {\n      case \"channel_joined\":\n        handleChannelJoined(message);\n        break;\n      case \"channel_left\":\n        handleChannelLeft(message);\n        break;\n      case \"realtime_update\":\n        handleRealtimeUpdate(message);\n        break;\n      case \"heartbeat_ack\":\n        // Heartbeat acknowledged\n        break;\n      default:\n      // Unknown message type\n    }\n  };\n\n  return { handleMessage };\n};\n\n// Helper to create heartbeat functions\nconst createHeartbeatFunctions = (\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  heartbeatTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  heartbeatInterval: number,\n  sendMessage: (message: RealtimeUpdate | Record<string, unknown>) => void,\n) => {\n  const startHeartbeat = () => {\n    const sendHeartbeat = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({ type: \"heartbeat\", timestamp: new Date().toISOString() });\n        heartbeatTimeoutRef.current = setTimeout(\n          sendHeartbeat,\n          heartbeatInterval,\n        );\n      }\n    };\n\n    heartbeatTimeoutRef.current = setTimeout(sendHeartbeat, heartbeatInterval);\n  };\n\n  const stopHeartbeat = () => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n  };\n\n  return { startHeartbeat, stopHeartbeat };\n};\n\n// Helper function to create WebSocket connection functions\nexport const createWebSocketFunctions = (\n  userId: string,\n  setSyncState: React.Dispatch<React.SetStateAction<RealtimeSyncState>>,\n  wsRef: React.MutableRefObject<WebSocket | null>,\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n  reconnectAttemptsRef: React.MutableRefObject<number>,\n  reconnectTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  heartbeatTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  connectionStartTimeRef: React.MutableRefObject<Date | null>,\n  maxReconnectAttempts: number,\n  reconnectInterval: number,\n  heartbeatInterval: number,\n) => {\n  const sendMessage = createSendMessage(wsRef, setSyncState);\n\n  const { startHeartbeat, stopHeartbeat } = createHeartbeatFunctions(\n    wsRef,\n    heartbeatTimeoutRef,\n    heartbeatInterval,\n    sendMessage,\n  );\n\n  const { handleMessage } = createMessageHandlers(\n    setSyncState,\n    subscriptionsRef,\n  );\n\n  let connect: () => void;\n\n  const { attemptReconnect, disconnect } = createConnectionControlFunctions(\n    wsRef,\n    setSyncState,\n    reconnectAttemptsRef,\n    reconnectTimeoutRef,\n    maxReconnectAttempts,\n    reconnectInterval,\n    stopHeartbeat,\n    () => connect(),\n  );\n\n  connect = createConnectFunction(\n    wsRef,\n    setSyncState,\n    connectionStartTimeRef,\n    reconnectAttemptsRef,\n    maxReconnectAttempts,\n    userId,\n    handleMessage,\n    startHeartbeat,\n    stopHeartbeat,\n    attemptReconnect,\n  );\n\n  return {\n    connect,\n    disconnect,\n    sendMessage,\n    startHeartbeat,\n    stopHeartbeat,\n  };\n};\n\n// Helper function to create channel management functions\nexport const createChannelFunctions = (\n  userId: string,\n  sendMessage: (message: RealtimeUpdate | Record<string, unknown>) => void,\n) => {\n  const joinChannel = async (channelId: string): Promise<void> => {\n    sendMessage({\n      type: \"join_channel\",\n      channelId,\n      userId,\n    });\n  };\n\n  const leaveChannel = async (channelId: string): Promise<void> => {\n    sendMessage({\n      type: \"leave_channel\",\n      channelId,\n      userId,\n    });\n  };\n\n  const createChannel = async (\n    type: ChannelType,\n    participants: string[],\n  ): Promise<SyncChannel> => {\n    const channel = createSyncChannel(type, userId, participants);\n\n    sendMessage({\n      type: \"create_channel\",\n      channel,\n      userId,\n    });\n\n    return channel;\n  };\n\n  return {\n    joinChannel,\n    leaveChannel,\n    createChannel,\n  };\n};\n\n// Helper function to create subscription functions\nexport const createRealtimeSubscriptionFunctions = (\n  subscriptionsRef: React.MutableRefObject<{ [key: string]: Subscription }>,\n) => {\n  const subscribeToUpdates = (\n    dataType: string,\n    callback: (update: RealtimeUpdate) => void,\n  ): Subscription => {\n    const subscription = createSubscription(dataType, callback);\n    subscriptionsRef.current[subscription.id] = subscription;\n\n    // Return unsubscribe function\n    return {\n      ...subscription,\n      unsubscribe: () => {\n        const sub = subscriptionsRef.current[subscription.id];\n        if (sub) {\n          sub.isActive = false;\n          delete subscriptionsRef.current[subscription.id];\n        }\n      },\n    } as Subscription & { unsubscribe: () => void };\n  };\n\n  const publishUpdate = async (_update: RealtimeUpdate): Promise<void> => {\n    // Implementation would send the update via WebSocket\n  };\n\n  return {\n    subscribeToUpdates,\n    publishUpdate,\n  };\n};\n\n// Helper function to create relationship sync functions\nexport const createRelationshipSyncFunctions = (\n  joinChannel: (channelId: string) => Promise<void>,\n) => {\n  const syncWithKeyholder = async (relationshipId: string): Promise<void> => {\n    const channelId = `relationship_${relationshipId}`;\n    await joinChannel(channelId);\n  };\n\n  const syncSessionData = async (sessionId: string): Promise<void> => {\n    const channelId = `session_${sessionId}`;\n    await joinChannel(channelId);\n  };\n\n  return {\n    syncWithKeyholder,\n    syncSessionData,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/realtime-sync-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/timer-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useLiveTimer.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (357). Maximum allowed is 75.",
        "line": 102,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 555,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updateTimerProgress'. Either include it or remove the dependency array.",
        "line": 509,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 509,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncInterval, updateTimerProgress]",
            "fix": { "range": [13168, 13182], "text": "[syncInterval, updateTimerProgress]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'syncActiveTimers'. Either include it or remove the dependency array.",
        "line": 523,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 523,
        "endColumn": 20,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [syncActiveTimers, syncInterval]",
            "fix": { "range": [13628, 13642], "text": "[syncActiveTimers, syncInterval]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useLiveTimer - Live Timer Synchronization Hook\n *\n * Synchronized timer updates across all devices and users with real-time progress\n * sharing and keyholder monitoring.\n */\nimport { useState, useEffect, useCallback, useRef, useMemo } from \"react\";\nimport {\n  LiveTimerState,\n  LiveTimer,\n  TimerType,\n  TimerStatus,\n  TimerSync,\n  TimerEvent,\n  TimerSubscription,\n} from \"../../types/realtime\";\nimport {\n  validateTimerPermissions,\n  updateTimerInState,\n  calculateTimerProgress,\n  createTimerSubscription,\n  calculateComputedValues,\n} from \"./timer-operations\";\n\ninterface UseLiveTimerOptions {\n  userId: string;\n  relationshipId?: string;\n  syncInterval?: number; // milliseconds\n  accuracyThreshold?: number; // milliseconds\n}\n\n// Helper function to create timer sync record\nconst createTimerSync = async (timerId: string): Promise<TimerSync> => {\n  const now = new Date();\n  return {\n    timerId,\n    lastSync: now,\n    serverTime: await getServerTime(),\n    clientOffset: 0,\n    syncAccuracy: 1.0,\n  };\n};\n\n// Helper function to create new timer\ninterface CreateTimerParams {\n  userId: string;\n  relationshipId?: string;\n  type: TimerType;\n  duration: number;\n  title: string;\n  description?: string;\n  canPause?: boolean;\n  canStop?: boolean;\n  canExtend?: boolean;\n  isKeyholderControlled?: boolean;\n  keyholderUserId?: string;\n  sessionId?: string;\n  taskId?: string;\n}\n\nconst createNewTimer = ({\n  userId,\n  relationshipId,\n  type,\n  duration,\n  title,\n  description,\n  canPause = true,\n  canStop = true,\n  canExtend = false,\n  isKeyholderControlled = false,\n  keyholderUserId,\n  sessionId,\n  taskId,\n}: CreateTimerParams): LiveTimer => {\n  const now = new Date();\n  return {\n    id: `timer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    type,\n    status: TimerStatus.STOPPED,\n    startTime: now,\n    currentTime: now,\n    duration,\n    elapsed: 0,\n    remaining: duration,\n    isPaused: false,\n    totalPauseTime: 0,\n    userId,\n    relationshipId,\n    title,\n    description,\n    canPause,\n    canStop,\n    canExtend,\n    isKeyholderControlled,\n    keyholderUserId,\n    sessionId,\n    taskId,\n  };\n};\n\nexport const useLiveTimer = (options: UseLiveTimerOptions) => {\n  const {\n    userId,\n    relationshipId,\n    syncInterval = 1000, // 1 second\n    accuracyThreshold = 500, // 500ms\n  } = options;\n\n  // Timer state\n  const [timerState, setTimerState] = useState<LiveTimerState>({\n    activeTimers: [],\n    timerSyncs: [],\n    subscriptions: [],\n    events: [],\n  });\n\n  // Refs for intervals and sync\n  const updateIntervalRef = useRef<number | null>(null);\n  const syncIntervalRef = useRef<number | null>(null);\n  const subscriptionsRef = useRef<Map<string, TimerSubscription>>(new Map());\n\n  // Create a new timer\n  const createTimer = useCallback(\n    async (\n      type: TimerType,\n      duration: number, // seconds\n      title: string,\n      options?: {\n        description?: string;\n        canPause?: boolean;\n        canStop?: boolean;\n        canExtend?: boolean;\n        isKeyholderControlled?: boolean;\n        keyholderUserId?: string;\n        sessionId?: string;\n        taskId?: string;\n      },\n    ): Promise<LiveTimer> => {\n      const timer = createNewTimer({\n        userId,\n        relationshipId,\n        type,\n        duration,\n        title,\n        ...options,\n      });\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: [...prev.activeTimers, timer],\n      }));\n\n      // Create sync record\n      const sync = await createTimerSync(timer.id);\n      setTimerState((prev) => ({\n        ...prev,\n        timerSyncs: [...prev.timerSyncs, sync],\n      }));\n\n      // Save to backend\n      await saveTimer(timer);\n\n      return timer;\n    },\n    [userId, relationshipId],\n  );\n\n  // Start a timer\n  const startTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      validateTimerPermissions(timer, userId, \"control\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.RUNNING,\n        startTime: now,\n        currentTime: now,\n        isPaused: false,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      // Log event and sync\n      await logTimerEvent(timerId, \"start\", { startTime: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Pause a timer\n  const pauseTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canPause) {\n        throw new Error(\"Timer cannot be paused\");\n      }\n\n      validateTimerPermissions(timer, userId, \"pause\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.PAUSED,\n        isPaused: true,\n        pausedAt: now,\n        currentTime: now,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"pause\", { pausedAt: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Resume a timer\n  const resumeTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      validateTimerPermissions(timer, userId, \"resume\");\n\n      const now = new Date();\n      const pauseDuration = timer.pausedAt\n        ? now.getTime() - timer.pausedAt.getTime()\n        : 0;\n\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.RUNNING,\n        isPaused: false,\n        pausedAt: undefined,\n        totalPauseTime: timer.totalPauseTime + pauseDuration,\n        currentTime: now,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"resume\", { resumedAt: now, pauseDuration });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Stop a timer\n  const stopTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canStop) {\n        throw new Error(\"Timer cannot be stopped\");\n      }\n\n      validateTimerPermissions(timer, userId, \"stop\");\n\n      const now = new Date();\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        status: TimerStatus.STOPPED,\n        endTime: now,\n        currentTime: now,\n        isPaused: false,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"stop\", { stoppedAt: now });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Extend a timer\n  const extendTimer = useCallback(\n    async (timerId: string, additionalSeconds: number): Promise<void> => {\n      const timer = timerState.activeTimers.find((t) => t.id === timerId);\n      if (!timer) {\n        throw new Error(\"Timer not found\");\n      }\n\n      if (!timer.canExtend) {\n        throw new Error(\"Timer cannot be extended\");\n      }\n\n      validateTimerPermissions(timer, userId, \"extend\");\n\n      const updatedTimer: LiveTimer = {\n        ...timer,\n        duration: timer.duration + additionalSeconds,\n        remaining: timer.remaining + additionalSeconds,\n      };\n\n      setTimerState((prev) => ({\n        ...prev,\n        activeTimers: updateTimerInState(\n          prev.activeTimers,\n          timerId,\n          updatedTimer,\n        ),\n      }));\n\n      await logTimerEvent(timerId, \"extend\", { additionalSeconds });\n      await syncTimer(timerId);\n      notifySubscribers(updatedTimer);\n    },\n    [timerState.activeTimers, userId, notifySubscribers, syncTimer],\n  );\n\n  // Subscribe to timer updates\n  const subscribeToTimer = useCallback(\n    (\n      timerId: string,\n      callback: (timer: LiveTimer) => void,\n      events: string[] = [\"start\", \"pause\", \"resume\", \"stop\", \"update\"],\n    ): TimerSubscription => {\n      return createTimerSubscription(\n        timerId,\n        callback,\n        events,\n        setTimerState,\n        subscriptionsRef,\n      );\n    },\n    [],\n  );\n\n  // Get timer by ID\n  const getTimer = useCallback(\n    (timerId: string): LiveTimer | null => {\n      return timerState.activeTimers.find((t) => t.id === timerId) || null;\n    },\n    [timerState.activeTimers],\n  );\n\n  // Get timers by type\n  const getTimersByType = useCallback(\n    (type: TimerType): LiveTimer[] => {\n      return timerState.activeTimers.filter((t) => t.type === type);\n    },\n    [timerState.activeTimers],\n  );\n\n  // Get running timers\n  const getRunningTimers = useCallback((): LiveTimer[] => {\n    return timerState.activeTimers.filter(\n      (t) => t.status === TimerStatus.RUNNING,\n    );\n  }, [timerState.activeTimers]);\n\n  // Update timer progress\n  const updateTimerProgress = useCallback(() => {\n    const now = new Date();\n\n    setTimerState((prev) => ({\n      ...prev,\n      activeTimers: prev.activeTimers.map((timer) => {\n        const progress = calculateTimerProgress(timer, now);\n        const updatedTimer = { ...timer, ...progress };\n\n        // Check if timer completed\n        if (progress.remaining === 0 && timer.status === TimerStatus.RUNNING) {\n          logTimerEvent(timer.id, \"complete\", { completedAt: now });\n          notifySubscribers(updatedTimer);\n        }\n\n        return updatedTimer;\n      }),\n    }));\n  }, [notifySubscribers]);\n\n  // Sync timer with server\n  const syncTimer = useCallback(\n    async (timerId: string): Promise<void> => {\n      try {\n        const serverTime = await getServerTime();\n        const now = new Date();\n        const clientOffset = now.getTime() - serverTime.getTime();\n\n        setTimerState((prev) => ({\n          ...prev,\n          timerSyncs: prev.timerSyncs.map((sync) =>\n            sync.timerId === timerId\n              ? {\n                  ...sync,\n                  lastSync: now,\n                  serverTime,\n                  clientOffset,\n                  syncAccuracy:\n                    Math.abs(clientOffset) < accuracyThreshold ? 1.0 : 0.5,\n                }\n              : sync,\n          ),\n        }));\n      } catch {\n        // Failed to sync timer\n      }\n    },\n    [accuracyThreshold],\n  );\n\n  // Notify subscribers\n  const notifySubscribers = useCallback((timer: LiveTimer) => {\n    subscriptionsRef.current.forEach((subscription) => {\n      if (subscription.timerId === timer.id && subscription.isActive) {\n        try {\n          subscription.callback(timer);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    });\n  }, []);\n\n  // Helper function to sync active timers with server\n  const syncActiveTimers = useCallback(async () => {\n    const runningTimers = timerState.activeTimers.filter(\n      (t) => t.status === TimerStatus.RUNNING,\n    );\n\n    for (const timer of runningTimers) {\n      try {\n        const serverTime = await getServerTime();\n        const now = new Date();\n        const clientOffset = now.getTime() - serverTime.getTime();\n\n        setTimerState((prev) => ({\n          ...prev,\n          timerSyncs: prev.timerSyncs.map((sync) =>\n            sync.timerId === timer.id\n              ? {\n                  ...sync,\n                  lastSync: now,\n                  serverTime,\n                  clientOffset,\n                  syncAccuracy:\n                    Math.abs(clientOffset) < accuracyThreshold ? 1.0 : 0.5,\n                }\n              : sync,\n          ),\n        }));\n      } catch {\n        // Failed to sync timer\n      }\n    }\n  }, [timerState.activeTimers, accuracyThreshold]);\n\n  // Start update interval\n  useEffect(() => {\n    updateIntervalRef.current = setInterval(updateTimerProgress, syncInterval);\n\n    return () => {\n      if (updateIntervalRef.current) {\n        clearInterval(updateIntervalRef.current);\n      }\n    };\n    // updateTimerProgress is stable (no deps)\n    // syncInterval triggers re-setup of interval when changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [syncInterval]);\n\n  // Start sync interval\n  useEffect(() => {\n    syncIntervalRef.current = setInterval(syncActiveTimers, syncInterval * 30); // Sync every 30 seconds\n\n    return () => {\n      if (syncIntervalRef.current) {\n        clearInterval(syncIntervalRef.current);\n      }\n    };\n    // syncActiveTimers is stable (no deps)\n    // syncInterval triggers re-setup of interval when changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [syncInterval]);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    return calculateComputedValues(timerState.activeTimers);\n  }, [timerState.activeTimers]);\n\n  return {\n    // Timer state\n    activeTimers: timerState.activeTimers,\n    timerSyncs: timerState.timerSyncs,\n    events: timerState.events,\n\n    // Timer management\n    createTimer,\n    startTimer,\n    pauseTimer,\n    resumeTimer,\n    stopTimer,\n    extendTimer,\n\n    // Timer queries\n    getTimer,\n    getTimersByType,\n    getRunningTimers,\n\n    // Subscription management\n    subscribeToTimer,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\n// Helper functions\nasync function getServerTime(): Promise<Date> {\n  // In real implementation, fetch server time from API\n  try {\n    // const response = await fetch('/api/time');\n    // const { timestamp } = await response.json();\n    // return new Date(timestamp);\n    return new Date(); // Fallback to client time\n  } catch {\n    // Fallback to client time\n    return new Date();\n  }\n}\n\nasync function saveTimer(_timer: LiveTimer): Promise<void> {\n  // In real implementation, save to backend\n  // In real implementation, save to backend\n}\n\nasync function logTimerEvent(\n  timerId: string,\n  type: string,\n  data?: Record<string, string | number | boolean | Date>,\n): Promise<void> {\n  const _event: TimerEvent = {\n    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timerId,\n    type: type as TimerEvent[\"type\"],\n    timestamp: new Date(),\n    userId: \"\", // Would be filled from context\n    data,\n  };\n\n  // In real implementation, save to backend\n  // In real implementation, save to backend\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useNotifications.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/usePresence.ts",
    "messages": [
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (6). Maximum allowed is 5.",
        "line": 45,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 45,
        "endColumn": 5
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (11). Maximum allowed is 5.",
        "line": 204,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 204,
        "endColumn": 5
      },
      {
        "ruleId": "max-params",
        "severity": 1,
        "message": "Arrow function has too many parameters (6). Maximum allowed is 5.",
        "line": 282,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 282,
        "endColumn": 5
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'activityTimeoutRef', 'lastActivityRef', and 'setAway'. Either include them or remove the dependency array. If 'setAway' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 90,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 90,
        "endColumn": 58,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]",
            "fix": {
              "range": [2325, 2377],
              "text": "[autoTrackActivity, presenceStatus, activityTimeout, lastActivityRef, activityTimeoutRef, setAway]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setAway', 'setOffline', and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 156,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 156,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setAway, setOffline, setOnline]",
            "fix": { "range": [4292, 4294], "text": "[setAway, setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'setOffline' and 'setOnline'. Either include them or remove the dependency array. If 'setOnline' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 173,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 173,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setOffline, setOnline]",
            "fix": { "range": [4769, 4771], "text": "[setOffline, setOnline]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * usePresence - Online/Offline Status Hook\n *\n * Track and display online/offline presence for users in relationships\n * with activity indicators and status messages.\n */\nimport React, {\n  useState,\n  useEffect,\n  useCallback,\n  useMemo,\n  useRef,\n} from \"react\";\nimport {\n  PresenceState,\n  UserPresence as _UserPresence,\n  PresenceStatus,\n  ActivityContext,\n  PresenceSubscription as _PresenceSubscription,\n} from \"../../types/realtime\";\nimport {\n  createPresenceUpdateFunctions,\n  createSubscriptionFunctions,\n  createQueryFunctions,\n  calculatePresenceComputedValues,\n} from \"./presence-operations\";\n\ninterface UsePresenceOptions {\n  userId: string;\n  updateInterval?: number; // milliseconds\n  activityTimeout?: number; // milliseconds\n  autoTrackActivity?: boolean;\n}\n\n// Helper to setup activity tracking listeners\nconst useActivityTracking = (\n  autoTrackActivity: boolean,\n  presenceStatus: PresenceStatus,\n  activityTimeout: number,\n  setAway: (statusMessage?: string) => void,\n  lastActivityRef: React.MutableRefObject<Date>,\n  activityTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n) => {\n  useEffect(() => {\n    if (!autoTrackActivity) return;\n\n    const trackActivity = () => {\n      lastActivityRef.current = new Date();\n\n      // Reset activity timeout\n      if (activityTimeoutRef.current) {\n        clearTimeout(activityTimeoutRef.current);\n      }\n\n      // Set away status after inactivity\n      activityTimeoutRef.current = setTimeout(() => {\n        if (presenceStatus === PresenceStatus.ONLINE) {\n          setAway(\"Away due to inactivity\");\n        }\n      }, activityTimeout);\n    };\n\n    // Track various activity events\n    const events = [\n      \"mousedown\",\n      \"mousemove\",\n      \"keypress\",\n      \"scroll\",\n      \"touchstart\",\n      \"click\",\n    ];\n\n    events.forEach((event) => {\n      document.addEventListener(event, trackActivity, { passive: true });\n    });\n\n    return () => {\n      events.forEach((event) => {\n        document.removeEventListener(event, trackActivity);\n      });\n\n      if (activityTimeoutRef.current) {\n        clearTimeout(activityTimeoutRef.current);\n      }\n    };\n    // setAway is from presenceUpdateFunctions which is recreated when presenceState changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [autoTrackActivity, presenceStatus, activityTimeout]);\n};\n\n// Helper to handle periodic presence updates\nconst usePeriodicPresenceUpdate = (\n  ownPresence: { status: PresenceStatus },\n  updateInterval: number,\n  presenceIntervalRef: React.MutableRefObject<ReturnType<\n    typeof setInterval\n  > | null>,\n) => {\n  useEffect(() => {\n    const sendPeriodicUpdate = async () => {\n      if (ownPresence.status !== PresenceStatus.OFFLINE) {\n        // In real implementation, send to backend/WebSocket\n        // await sendPresenceUpdate(ownPresence);\n      }\n    };\n\n    presenceIntervalRef.current = setInterval(\n      sendPeriodicUpdate,\n      updateInterval,\n    );\n\n    return () => {\n      if (presenceIntervalRef.current) {\n        clearInterval(presenceIntervalRef.current);\n      }\n    };\n  }, [ownPresence, updateInterval, presenceIntervalRef]);\n};\n\n// Helper to handle online/offline events\nconst useConnectionEvents = (\n  setOnline: (statusMessage?: string) => void,\n  setOffline: (statusMessage?: string) => void,\n  setAway: (statusMessage?: string) => void,\n) => {\n  useEffect(() => {\n    const handleOnline = () => {\n      setOnline(\"Back online\");\n    };\n\n    const handleOffline = () => {\n      setOffline(\"Connection lost\");\n    };\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        setAway(\"Tab inactive\");\n      } else {\n        setOnline(\"Tab active\");\n      }\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n    // setOnline, setOffline, setAway are from presenceUpdateFunctions (stable)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n\n// Helper to initialize presence on mount\nconst usePresenceInitialization = (\n  setOnline: (statusMessage?: string) => void,\n  setOffline: (statusMessage?: string) => void,\n) => {\n  useEffect(() => {\n    setOnline(\"Connected\");\n\n    // Set offline when component unmounts\n    return () => {\n      setOffline(\"Disconnected\");\n    };\n    // setOnline, setOffline are from presenceUpdateFunctions (stable)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n\n// Helper to create initial presence state\nconst createInitialPresenceState = (userId: string): PresenceState => ({\n  userPresences: {},\n  subscriptions: [],\n  ownPresence: {\n    userId,\n    status: PresenceStatus.OFFLINE,\n    lastSeen: new Date(),\n  },\n});\n\n// Helper to setup all presence side effects\nconst usePresenceSideEffects = (\n  autoTrackActivity: boolean,\n  presenceStatus: PresenceStatus,\n  activityTimeout: number,\n  ownPresence: { status: PresenceStatus },\n  updateInterval: number,\n  setOnline: (statusMessage?: string) => void,\n  setOffline: (statusMessage?: string) => void,\n  setAway: (statusMessage?: string) => void,\n  lastActivityRef: React.MutableRefObject<Date>,\n  activityTimeoutRef: React.MutableRefObject<ReturnType<\n    typeof setTimeout\n  > | null>,\n  presenceIntervalRef: React.MutableRefObject<ReturnType<\n    typeof setInterval\n  > | null>,\n) => {\n  useActivityTracking(\n    autoTrackActivity,\n    presenceStatus,\n    activityTimeout,\n    setAway,\n    lastActivityRef,\n    activityTimeoutRef,\n  );\n\n  usePeriodicPresenceUpdate(ownPresence, updateInterval, presenceIntervalRef);\n\n  useConnectionEvents(setOnline, setOffline, setAway);\n\n  usePresenceInitialization(setOnline, setOffline);\n};\n\n// Helper to create and destructure operation functions\nconst usePresenceOperations = (\n  userId: string,\n  presenceState: PresenceState,\n  setPresenceState: React.Dispatch<React.SetStateAction<PresenceState>>,\n) => {\n  const presenceUpdateFunctions = createPresenceUpdateFunctions(\n    userId,\n    presenceState,\n    setPresenceState,\n  );\n\n  const subscriptionFunctions = createSubscriptionFunctions(setPresenceState);\n  const queryFunctions = createQueryFunctions(presenceState);\n\n  const {\n    updateOwnPresence: _updateOwnPresence,\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivity: updateActivityStatus,\n  } = presenceUpdateFunctions;\n\n  const { subscribeToPresence } = subscriptionFunctions;\n  const {\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n  } = queryFunctions;\n\n  return {\n    presenceUpdateFunctions,\n    subscriptionFunctions,\n    queryFunctions,\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivityStatus,\n    subscribeToPresence,\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n  };\n};\n\n// Helper to build return object\nconst buildPresenceReturn = (\n  presenceState: PresenceState,\n  presenceUpdateFunctions: ReturnType<typeof createPresenceUpdateFunctions>,\n  subscriptionFunctions: ReturnType<typeof createSubscriptionFunctions>,\n  queryFunctions: ReturnType<typeof createQueryFunctions>,\n  updateActivity: (activity: ActivityContext) => void,\n  computedValues: ReturnType<typeof calculatePresenceComputedValues>,\n) => {\n  const { setOnline, setOffline, setAway, setBusy, setInSession } =\n    presenceUpdateFunctions;\n  const { subscribeToPresence } = subscriptionFunctions;\n  const {\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n  } = queryFunctions;\n\n  return {\n    // Presence state\n    ownPresence: presenceState.ownPresence,\n    userPresences: presenceState.userPresences,\n\n    // Status management\n    setOnline,\n    setOffline,\n    setAway,\n    setBusy,\n    setInSession,\n    updateActivity,\n\n    // Subscription management\n    subscribeToPresence,\n\n    // Presence queries\n    getUserPresence,\n    getMultipleUserPresence,\n    isUserOnline,\n    isUserInSession,\n    getOnlineCount,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n\nexport const usePresence = (options: UsePresenceOptions) => {\n  const {\n    userId,\n    updateInterval = 30000, // 30 seconds\n    activityTimeout = 300000, // 5 minutes\n    autoTrackActivity = true,\n  } = options;\n\n  // Presence state\n  const [presenceState, setPresenceState] = useState(() =>\n    createInitialPresenceState(userId),\n  );\n\n  // Refs for tracking activity\n  const lastActivityRef = useRef<Date>(new Date());\n  const presenceIntervalRef = useRef<ReturnType<typeof setInterval> | null>(\n    null,\n  );\n  const activityTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // Create operation functions using helpers\n  const operations = usePresenceOperations(\n    userId,\n    presenceState,\n    setPresenceState,\n  );\n  const {\n    presenceUpdateFunctions,\n    subscriptionFunctions,\n    queryFunctions,\n    setOnline,\n    setOffline,\n    setAway,\n    updateActivityStatus,\n  } = operations;\n\n  // Update activity\n  const updateActivity = useCallback(\n    (activity: ActivityContext) => {\n      lastActivityRef.current = new Date();\n      return updateActivityStatus(activity);\n    },\n    [updateActivityStatus],\n  );\n\n  // Setup all side effects\n  usePresenceSideEffects(\n    autoTrackActivity,\n    presenceState.ownPresence.status,\n    activityTimeout,\n    presenceState.ownPresence,\n    updateInterval,\n    setOnline,\n    setOffline,\n    setAway,\n    lastActivityRef,\n    activityTimeoutRef,\n    presenceIntervalRef,\n  );\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    return calculatePresenceComputedValues(\n      presenceState.userPresences,\n      lastActivityRef.current,\n      activityTimeout,\n    );\n  }, [presenceState.userPresences, activityTimeout]);\n\n  return buildPresenceReturn(\n    presenceState,\n    presenceUpdateFunctions,\n    subscriptionFunctions,\n    queryFunctions,\n    updateActivity,\n    computedValues,\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/realtime/useRealtimeSync.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (364). Maximum allowed is 75.",
        "line": 36,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 509,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (29). Maximum allowed is 25.",
        "line": 36,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 509,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'attemptReconnect', 'handleMessage', 'sendMessage', 'startHeartbeat', 'stopHeartbeat', and 'syncState.activeChannels'. Either include them or remove the dependency array.",
        "line": 159,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 159,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, startHeartbeat, syncState.activeChannels, sendMessage, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]",
            "fix": {
              "range": [4253, 4283],
              "text": "[userId, startHeartbeat, syncState.activeChannels, sendMessage, handleMessage, stopHeartbeat, maxReconnectAttempts, attemptReconnect]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'stopHeartbeat'. Either include it or remove the dependency array.",
        "line": 175,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 175,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [stopHeartbeat]",
            "fix": { "range": [4696, 4698], "text": "[stopHeartbeat]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sendMessage'. Either include it or remove the dependency array.",
        "line": 211,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 211,
        "endColumn": 25,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [heartbeatInterval, sendMessage]",
            "fix": { "range": [5778, 5797], "text": "[heartbeatInterval, sendMessage]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has missing dependencies: 'handleChannelJoined', 'handleChannelLeft', and 'handleRealtimeUpdate'. Either include them or remove the dependency array.",
        "line": 264,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 264,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]",
            "fix": {
              "range": [7228, 7230],
              "text": "[handleChannelJoined, handleChannelLeft, handleRealtimeUpdate]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useRealtimeSync - Real-time Data Synchronization Hook\n *\n * Real-time data synchronization across devices and users with WebSocket integration\n * and conflict resolution.\n */\nimport { useState, useEffect, useCallback, useRef, useMemo } from \"react\";\nimport {\n  RealtimeSyncState,\n  ConnectionStatus,\n  SyncChannel,\n  ChannelType,\n  RealtimeUpdate,\n  Subscription,\n  UpdateCallback,\n} from \"../../types/realtime\";\n\ninterface WebSocketMessage {\n  type: string;\n  data?: unknown;\n  channelId?: string;\n  userId?: string;\n  timestamp?: Date;\n}\n\ninterface UseRealtimeSyncOptions {\n  userId: string;\n  autoConnect?: boolean;\n  reconnectInterval?: number; // milliseconds\n  heartbeatInterval?: number; // milliseconds\n  maxReconnectAttempts?: number;\n}\n\n// Complex real-time synchronization hook with WebSocket management\n// eslint-disable-next-line max-statements\nexport const useRealtimeSync = (options: UseRealtimeSyncOptions) => {\n  const {\n    userId,\n    autoConnect = true,\n    reconnectInterval = 5000,\n    heartbeatInterval = 30000,\n    maxReconnectAttempts = 5,\n  } = options;\n\n  // Realtime sync state\n  const [syncState, setSyncState] = useState<RealtimeSyncState>({\n    connectionStatus: ConnectionStatus.DISCONNECTED,\n    activeChannels: [],\n    realtimeData: {},\n    syncMetrics: {\n      lastSuccessfulSync: new Date(),\n      syncErrors: 0,\n      messagesReceived: 0,\n      messagesSent: 0,\n      averageLatency: 0,\n      connectionUptime: 0,\n    },\n  });\n\n  // Refs for WebSocket and subscriptions\n  const wsRef = useRef<WebSocket | null>(null);\n  const subscriptionsRef = useRef<Map<string, Subscription>>(new Map());\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimeoutRef = useRef<number | null>(null);\n  const heartbeatTimeoutRef = useRef<number | null>(null);\n  const connectionStartTimeRef = useRef<Date | null>(null);\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.CONNECTING,\n    }));\n\n    try {\n      // In real implementation, use your WebSocket server URL\n      const wsUrl =\n        process.env.NODE_ENV === \"development\"\n          ? \"ws://localhost:8080/ws\"\n          : \"wss://api.chastityos.com/ws\";\n\n      wsRef.current = new WebSocket(`${wsUrl}?userId=${userId}`);\n      connectionStartTimeRef.current = new Date();\n\n      wsRef.current.onopen = () => {\n        // WebSocket connected\n        reconnectAttemptsRef.current = 0;\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.CONNECTED,\n        }));\n\n        // Start heartbeat\n        startHeartbeat();\n\n        // Rejoin previous channels\n        syncState.activeChannels.forEach((channel) => {\n          sendMessage({\n            type: \"join_channel\",\n            channelId: channel.id,\n            userId,\n          });\n        });\n      };\n\n      wsRef.current.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          handleMessage(message);\n        } catch {\n          // Failed to parse WebSocket message\n        }\n      };\n\n      wsRef.current.onclose = (event) => {\n        // WebSocket disconnected\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.DISCONNECTED,\n        }));\n\n        stopHeartbeat();\n\n        // Attempt reconnection if not intentional disconnect\n        if (\n          event.code !== 1000 &&\n          reconnectAttemptsRef.current < maxReconnectAttempts\n        ) {\n          attemptReconnect();\n        }\n      };\n\n      wsRef.current.onerror = (_error) => {\n        // WebSocket error\n\n        setSyncState((prev) => ({\n          ...prev,\n          connectionStatus: ConnectionStatus.ERROR,\n          syncMetrics: {\n            ...prev.syncMetrics,\n            syncErrors: prev.syncMetrics.syncErrors + 1,\n          },\n        }));\n      };\n    } catch {\n      // Failed to create WebSocket connection\n      setSyncState((prev) => ({\n        ...prev,\n        connectionStatus: ConnectionStatus.ERROR,\n      }));\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, maxReconnectAttempts]);\n\n  // Disconnect WebSocket\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"Intentional disconnect\");\n      wsRef.current = null;\n    }\n\n    stopHeartbeat();\n\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // stopHeartbeat is stable\n\n  // Attempt reconnection\n  const attemptReconnect = useCallback(() => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      // Max reconnection attempts reached\n      return;\n    }\n\n    reconnectAttemptsRef.current++;\n\n    setSyncState((prev) => ({\n      ...prev,\n      connectionStatus: ConnectionStatus.RECONNECTING,\n    }));\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      // Reconnection attempt\n      connect();\n    }, reconnectInterval);\n  }, [connect, maxReconnectAttempts, reconnectInterval]);\n\n  // Start heartbeat\n  const startHeartbeat = useCallback(() => {\n    const sendHeartbeat = () => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({ type: \"heartbeat\", timestamp: new Date().toISOString() });\n        heartbeatTimeoutRef.current = setTimeout(\n          sendHeartbeat,\n          heartbeatInterval,\n        );\n      }\n    };\n\n    heartbeatTimeoutRef.current = setTimeout(sendHeartbeat, heartbeatInterval);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [heartbeatInterval]); // sendMessage is stable\n\n  // Stop heartbeat\n  const stopHeartbeat = useCallback(() => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n  }, []);\n\n  // Send message via WebSocket\n  const sendMessage = useCallback((message: WebSocketMessage) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n\n      setSyncState((prev) => ({\n        ...prev,\n        syncMetrics: {\n          ...prev.syncMetrics,\n          messagesSent: prev.syncMetrics.messagesSent + 1,\n        },\n      }));\n    }\n  }, []);\n\n  // Handle incoming messages\n  const handleMessage = useCallback((message: WebSocketMessage) => {\n    setSyncState((prev) => ({\n      ...prev,\n      syncMetrics: {\n        ...prev.syncMetrics,\n        messagesReceived: prev.syncMetrics.messagesReceived + 1,\n        lastSuccessfulSync: new Date(),\n      },\n    }));\n\n    switch (message.type) {\n      case \"channel_joined\":\n        handleChannelJoined(message);\n        break;\n      case \"channel_left\":\n        handleChannelLeft(message);\n        break;\n      case \"realtime_update\":\n        handleRealtimeUpdate(message);\n        break;\n      case \"heartbeat_ack\":\n        // Heartbeat acknowledged\n        break;\n      default:\n      // Unknown message type\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // handler functions are stable\n\n  // Handle channel joined\n  const handleChannelJoined = useCallback((message: WebSocketMessage) => {\n    const channel: SyncChannel = message.data as SyncChannel;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: [\n        ...prev.activeChannels.filter((c) => c.id !== channel.id),\n        channel,\n      ],\n    }));\n  }, []);\n\n  // Handle channel left\n  const handleChannelLeft = useCallback((message: WebSocketMessage) => {\n    const channelId = (message.data as { channelId: string })?.channelId;\n\n    setSyncState((prev) => ({\n      ...prev,\n      activeChannels: prev.activeChannels.filter((c) => c.id !== channelId),\n    }));\n  }, []);\n\n  // Handle realtime update\n  const handleRealtimeUpdate = useCallback((message: WebSocketMessage) => {\n    const update: RealtimeUpdate = message.data as RealtimeUpdate;\n\n    // Update local data\n    setSyncState((prev) => ({\n      ...prev,\n      realtimeData: {\n        ...prev.realtimeData,\n        [update.type]: update.data,\n      },\n    }));\n\n    // Notify subscribers\n    subscriptionsRef.current.forEach((subscription, _subscriptionId) => {\n      if (subscription.dataType === update.type && subscription.isActive) {\n        try {\n          subscription.callback(update);\n        } catch {\n          // Error in subscription callback\n        }\n      }\n    });\n  }, []);\n\n  // Join a sync channel\n  const joinChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"join_channel\",\n          channelId,\n          userId,\n        });\n      } else {\n        throw new Error(\"WebSocket not connected\");\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Leave a sync channel\n  const leaveChannel = useCallback(\n    async (channelId: string): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"leave_channel\",\n          channelId,\n          userId,\n        });\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Create a new sync channel\n  const createChannel = useCallback(\n    async (type: ChannelType, participants: string[]): Promise<SyncChannel> => {\n      const channel: SyncChannel = {\n        id: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        type,\n        participants: [userId, ...participants],\n        lastActivity: new Date(),\n        isActive: true,\n        encryptionEnabled: type === ChannelType.RELATIONSHIP,\n      };\n\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"create_channel\",\n          channel,\n          userId,\n        });\n      }\n\n      return channel;\n    },\n    [userId, sendMessage],\n  );\n\n  // Subscribe to realtime updates\n  const subscribeToUpdates = useCallback(\n    (dataType: string, callback: UpdateCallback): Subscription => {\n      const subscription: Subscription = {\n        id: `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        dataType,\n        callback,\n        isActive: true,\n        created: new Date(),\n      };\n\n      subscriptionsRef.current.set(subscription.id, subscription);\n\n      // Return unsubscribe function\n      return {\n        ...subscription,\n        unsubscribe: () => {\n          const sub = subscriptionsRef.current.get(subscription.id);\n          if (sub) {\n            sub.isActive = false;\n            subscriptionsRef.current.delete(subscription.id);\n          }\n        },\n      } as Subscription & { unsubscribe: () => void };\n    },\n    [],\n  );\n\n  // Publish a realtime update\n  const publishUpdate = useCallback(\n    async (update: RealtimeUpdate): Promise<void> => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        sendMessage({\n          type: \"publish_update\",\n          update: {\n            ...update,\n            userId,\n            timestamp: new Date(),\n          },\n        });\n      } else {\n        throw new Error(\"WebSocket not connected\");\n      }\n    },\n    [userId, sendMessage],\n  );\n\n  // Sync with keyholder\n  const syncWithKeyholder = useCallback(\n    async (relationshipId: string): Promise<void> => {\n      const channelId = `relationship_${relationshipId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  // Sync session data\n  const syncSessionData = useCallback(\n    async (sessionId: string): Promise<void> => {\n      const channelId = `session_${sessionId}`;\n      await joinChannel(channelId);\n    },\n    [joinChannel],\n  );\n\n  // Auto-connect on mount\n  useEffect(() => {\n    if (autoConnect && userId) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [userId, autoConnect, connect, disconnect]);\n\n  // Update connection uptime\n  useEffect(() => {\n    if (\n      syncState.connectionStatus === ConnectionStatus.CONNECTED &&\n      connectionStartTimeRef.current\n    ) {\n      const updateUptime = () => {\n        setSyncState((prev) => ({\n          ...prev,\n          syncMetrics: {\n            ...prev.syncMetrics,\n            connectionUptime:\n              Date.now() - connectionStartTimeRef.current!.getTime(),\n          },\n        }));\n      };\n\n      const interval = setInterval(updateUptime, 1000);\n      return () => clearInterval(interval);\n    }\n  }, [syncState.connectionStatus]);\n\n  // Computed values\n  const computedValues = useMemo(() => {\n    const isConnected =\n      syncState.connectionStatus === ConnectionStatus.CONNECTED;\n    const channelCount = syncState.activeChannels.length;\n    const lastSyncTime = syncState.syncMetrics.lastSuccessfulSync;\n    const hasActiveSync = syncState.activeChannels.some((c) => c.isActive);\n\n    return {\n      isConnected,\n      channelCount,\n      lastSyncTime,\n      hasActiveSync,\n    };\n  }, [syncState]);\n\n  return {\n    // Connection state\n    connectionStatus: syncState.connectionStatus,\n    activeChannels: syncState.activeChannels,\n    syncMetrics: syncState.syncMetrics,\n\n    // Connection control\n    connect,\n    disconnect,\n\n    // Channel management\n    joinChannel,\n    leaveChannel,\n    createChannel,\n\n    // Real-time data operations\n    subscribeToUpdates,\n    publishUpdate,\n\n    // Relationship-specific sync\n    syncWithKeyholder,\n    syncSessionData,\n\n    // Computed values\n    ...computedValues,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/relationship-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/task-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipEventOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipInvites.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 91,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 91,
        "endColumn": 34,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipList.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadRelationships'. Either include it or remove the dependency array.",
        "line": 82,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 82,
        "endColumn": 14,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadRelationships, userId]",
            "fix": { "range": [2493, 2501], "text": "[loadRelationships, userId]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipPermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTaskOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/relationships/useRelationshipValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useAuditLog.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/usePermissions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/security/useSecuritySettings.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (90). Maximum allowed is 75.",
        "line": 167,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 262,
        "endColumn": 2
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 186,
        "column": 5,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [5621, 5703], "text": " " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "/**\n * useSecuritySettings - Security Configuration Hook\n *\n * Manages comprehensive security settings including session timeouts,\n * IP restrictions, and security policies.\n */\nimport React, { useState, useEffect, useMemo } from \"react\";\nimport {\n  SecuritySettingsState,\n  SessionSecuritySettings,\n  AccessControlSettings,\n  MonitoringSettings,\n  PrivacySecuritySettings,\n  DeviceInfo,\n  SecurityHealthCheck,\n} from \"../../types/security\";\nimport {\n  defaultSessionSettings,\n  defaultAccessSettings,\n  defaultMonitoringSettings,\n  defaultPrivacySettings,\n  fetchSecuritySettings,\n  saveSecuritySettings,\n  calculateSecurityScore,\n  generateSecurityRecommendations,\n  findSecurityIssues,\n  calculateSecurityLevel,\n  mergeWithDefaultSettings,\n  handleAutoSave,\n} from \"../../utils/security/security-settings-utils\";\n\ninterface UseSecuritySettingsOptions {\n  userId: string;\n  autoSave?: boolean;\n  syncInterval?: number; // minutes\n}\n\n// Helper to load security settings\nasync function loadSecuritySettings(\n  userId: string,\n  setSecurityState: React.Dispatch<React.SetStateAction<SecuritySettingsState>>,\n  setError: React.Dispatch<React.SetStateAction<string | null>>,\n  setLoading: React.Dispatch<React.SetStateAction<boolean>>,\n): Promise<void> {\n  try {\n    setLoading(true);\n    setError(null);\n\n    const settings = await fetchSecuritySettings(userId);\n    const mergedSettings = mergeWithDefaultSettings(settings);\n    setSecurityState(mergedSettings);\n  } catch (err) {\n    setError(\n      err instanceof Error ? err.message : \"Failed to load security settings\",\n    );\n  } finally {\n    setLoading(false);\n  }\n}\n\n// Initial security state\nconst initialSecurityState: SecuritySettingsState = {\n  sessionSettings: defaultSessionSettings,\n  accessSettings: defaultAccessSettings,\n  monitoringSettings: defaultMonitoringSettings,\n  privacySettings: defaultPrivacySettings,\n};\n\n// Helper to create a generic settings updater\nfunction createGenericUpdater<T>(\n  key: keyof SecuritySettingsState,\n  params: {\n    userId: string;\n    autoSave: boolean;\n    securityState: SecuritySettingsState;\n    setSecurityState: React.Dispatch<\n      React.SetStateAction<SecuritySettingsState>\n    >;\n    setHasUnsavedChanges: React.Dispatch<React.SetStateAction<boolean>>;\n  },\n) {\n  const {\n    userId,\n    autoSave,\n    securityState,\n    setSecurityState,\n    setHasUnsavedChanges,\n  } = params;\n\n  return async (settings: Partial<T>): Promise<void> => {\n    setSecurityState((prev) => ({\n      ...prev,\n      [key]: { ...prev[key], ...settings },\n    }));\n    setHasUnsavedChanges(true);\n    if (!autoSave) {\n      await saveSecuritySettings(userId, {\n        ...securityState,\n        [key]: { ...securityState[key], ...settings },\n      });\n    }\n  };\n}\n\n// Helper to create settings update callbacks\nfunction createSettingsUpdateCallbacks(params: {\n  userId: string;\n  autoSave: boolean;\n  securityState: SecuritySettingsState;\n  setSecurityState: React.Dispatch<React.SetStateAction<SecuritySettingsState>>;\n  setHasUnsavedChanges: React.Dispatch<React.SetStateAction<boolean>>;\n}) {\n  return {\n    updateSessionSettings: createGenericUpdater<SessionSecuritySettings>(\n      \"sessionSettings\",\n      params,\n    ),\n    updateAccessSettings: createGenericUpdater<AccessControlSettings>(\n      \"accessSettings\",\n      params,\n    ),\n    updateMonitoringSettings: createGenericUpdater<MonitoringSettings>(\n      \"monitoringSettings\",\n      params,\n    ),\n    updatePrivacySettings: createGenericUpdater<PrivacySecuritySettings>(\n      \"privacySettings\",\n      params,\n    ),\n  };\n}\n\n// Helper to create security analysis functions\nfunction createSecurityAnalysis(securityState: SecuritySettingsState) {\n  const issues = findSecurityIssues(securityState);\n  const securityLevel = calculateSecurityLevel(\n    securityState.sessionSettings,\n    securityState.accessSettings,\n  );\n  const recommendations = generateSecurityRecommendations(securityState);\n\n  let status: SecurityHealthCheck[\"status\"] = \"healthy\";\n  if (issues.some((issue) => issue.severity === \"critical\")) {\n    status = \"critical\";\n  } else if (issues.some((issue) => issue.severity === \"high\")) {\n    status = \"critical\";\n  } else if (issues.some((issue) => issue.severity === \"medium\")) {\n    status = \"warning\";\n  }\n\n  return {\n    getSecurityScore: () => calculateSecurityScore(securityState),\n    getSecurityRecommendations: () => recommendations,\n    checkSecurityHealth: (): SecurityHealthCheck => ({\n      status,\n      issues,\n      lastCheck: new Date(),\n      nextCheck: new Date(Date.now() + 24 * 60 * 60 * 1000),\n    }),\n    isSecure: securityLevel >= \"medium\",\n    needsAttention: recommendations.some((r) => r.priority === \"high\"),\n    sessionTimeoutMinutes: securityState.sessionSettings.sessionTimeout,\n    hasStrictSecurity: securityLevel === \"strict\",\n  };\n}\n\nexport const useSecuritySettings = (options: UseSecuritySettingsOptions) => {\n  const { userId, autoSave = true } = options;\n  const [securityState, setSecurityState] = useState(initialSecurityState);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);\n\n  useEffect(() => {\n    if (userId) {\n      loadSecuritySettings(userId, setSecurityState, setError, setLoading);\n    }\n  }, [userId]);\n  useEffect(() => {\n    if (autoSave && hasUnsavedChanges && !loading) {\n      const saveTimer = setTimeout(() => {\n        handleAutoSave(userId, securityState, setHasUnsavedChanges, setError);\n      }, 2000);\n      return () => clearTimeout(saveTimer);\n    }\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [hasUnsavedChanges, autoSave, loading, userId, securityState]);\n\n  const {\n    updateSessionSettings,\n    updateAccessSettings,\n    updateMonitoringSettings,\n    updatePrivacySettings,\n  } = useMemo(\n    () =>\n      createSettingsUpdateCallbacks({\n        userId,\n        autoSave,\n        securityState,\n        setSecurityState,\n        setHasUnsavedChanges,\n      }),\n    [userId, autoSave, securityState],\n  );\n\n  const actions = useMemo(\n    () => ({\n      setSessionTimeout: async (minutes: number) => {\n        if (minutes < 5 || minutes > 480) {\n          throw new Error(\n            \"Session timeout must be between 5 minutes and 8 hours\",\n          );\n        }\n        await updateSessionSettings({ sessionTimeout: minutes });\n      },\n      enableReauthRequirement: async (enabled: boolean) =>\n        updateSessionSettings({ requireReauthForSensitive: enabled }),\n      addTrustedDevice: async (device: DeviceInfo) =>\n        updateAccessSettings({\n          trustedDevices: [\n            ...securityState.accessSettings.trustedDevices,\n            device,\n          ],\n        }),\n      removeTrustedDevice: async (deviceId: string) =>\n        updateAccessSettings({\n          trustedDevices: securityState.accessSettings.trustedDevices.filter(\n            (device) => device.id !== deviceId,\n          ),\n        }),\n      enableSecurityAlerts: async (enabled: boolean) =>\n        updateMonitoringSettings({ enableSecurityAlerts: enabled }),\n    }),\n    [\n      updateSessionSettings,\n      updateAccessSettings,\n      updateMonitoringSettings,\n      securityState.accessSettings.trustedDevices,\n    ],\n  );\n\n  const security = useMemo(\n    () => createSecurityAnalysis(securityState),\n    [securityState],\n  );\n\n  return {\n    sessionSettings: securityState.sessionSettings,\n    accessSettings: securityState.accessSettings,\n    monitoringSettings: securityState.monitoringSettings,\n    privacySettings: securityState.privacySettings,\n    loading,\n    error,\n    hasUnsavedChanges,\n    updateSessionSettings,\n    updateAccessSettings,\n    updateMonitoringSettings,\n    updatePrivacySettings,\n    ...actions,\n    ...security,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/session-goals-templates.ts",
    "messages": [
      {
        "ruleId": "no-restricted-syntax",
        "severity": 2,
        "message": "Hook files should only export hooks (functions starting with 'use') - types and interfaces are allowed",
        "line": 11,
        "column": 14,
        "nodeType": "VariableDeclarator",
        "messageId": "restrictedSyntax",
        "endLine": 42,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Goals Templates\n * Pre-defined goal templates for common objectives\n */\n\nimport type { GoalTemplate } from \"./types/SessionGoals\";\n\n/**\n * Default goal templates available to users\n */\nexport const DEFAULT_GOAL_TEMPLATES: GoalTemplate[] = [\n  {\n    id: \"duration_24h\",\n    name: \"24 Hour Challenge\",\n    description: \"Complete a full 24-hour session without breaks\",\n    category: \"session_length\",\n    defaultTarget: {\n      value: 24,\n      unit: \"hours\",\n      comparison: \"minimum\",\n    },\n    difficulty: \"intermediate\",\n    estimatedDuration: 1440,\n    tags: [\"endurance\", \"milestone\"],\n    isPopular: true,\n  },\n  {\n    id: \"consistency_7day\",\n    name: \"7-Day Consistency\",\n    description: \"Complete daily sessions for 7 consecutive days\",\n    category: \"daily_goals\",\n    defaultTarget: {\n      value: 7,\n      unit: \"days\",\n      comparison: \"exact\",\n    },\n    difficulty: \"beginner\",\n    estimatedDuration: 10080,\n    tags: [\"consistency\", \"habit\"],\n    isPopular: true,\n  },\n];\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/session-goals-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/PauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/SessionGoals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/types/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useCooldownState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseDurationTracking.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updatePauseDuration'. Either include it or remove the dependency array. If 'updatePauseDuration' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 27,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 27,
        "endColumn": 56,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]",
            "fix": {
              "range": [808, 858],
              "text": "[pauseStatus.isPaused, pauseStatus.pauseStartTime, updatePauseDuration]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseResume.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (146). Maximum allowed is 75.",
        "line": 36,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 210,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useCallback, useEffect, useRef } from 'react';\nimport { doc, setDoc } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} PauseEvent\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {string} reason\n * @property {number} [duration]\n */\n\n/**\n * @typedef {Object} PauseResumeState\n * @property {boolean} isPaused\n * @property {Date|null} pauseStartTime\n * @property {number} totalPauseTime\n * @property {PauseEvent[]} pauseEvents\n * @property {Date|null} cooldownEndTime\n */\n\n/**\n * @typedef {Object} PauseResumeOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {boolean} sessionActive\n * @property {Function} [onStateChange]\n */\n\n/**\n * Hook for managing session pause/resume functionality\n * @param {PauseResumeOptions} options\n * @returns {Object}\n */\nexport const usePauseResume = ({ \n  userId, \n  isAuthReady, \n  sessionActive, \n  onStateChange \n}) => {\n  const [pauseState, setPauseState] = useState({\n    isPaused: false,\n    pauseStartTime: null,\n    totalPauseTime: 0,\n    pauseEvents: [],\n    cooldownEndTime: null\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const pauseTimerRef = useRef(null);\n  const cooldownTimerRef = useRef(null);\n\n  const saveStateToFirestore = useCallback(async (newState) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { pauseResumeState: newState }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save pause state');\n    }\n  }, [userId, isAuthReady]);\n\n  const pauseSession = useCallback(async (reason = 'Manual pause') => {\n    if (!sessionActive || pauseState.isPaused) {\n      setError('Cannot pause: session not active or already paused');\n      return;\n    }\n\n    // Check cooldown\n    if (pauseState.cooldownEndTime && new Date() < pauseState.cooldownEndTime) {\n      const remainingTime = Math.ceil((pauseState.cooldownEndTime.getTime() - new Date().getTime()) / 1000);\n      setError(`Pause is on cooldown. Try again in ${remainingTime} seconds.`);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const pauseStartTime = new Date();\n      const newPauseEvent = {\n        id: crypto.randomUUID(),\n        startTime: pauseStartTime,\n        reason\n      };\n\n      const newState = {\n        ...pauseState,\n        isPaused: true,\n        pauseStartTime,\n        pauseEvents: [...pauseState.pauseEvents, newPauseEvent]\n      };\n\n      setPauseState(newState);\n      await saveStateToFirestore(newState);\n      if (onStateChange) onStateChange(newState);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to pause session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionActive, pauseState, saveStateToFirestore, onStateChange]);\n\n  const resumeSession = useCallback(async () => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      setError('Cannot resume: session not paused');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const resumeTime = new Date();\n      const pauseDuration = Math.floor((resumeTime.getTime() - pauseState.pauseStartTime.getTime()) / 1000);\n\n      // Update the last pause event with end time and duration\n      const updatedPauseEvents = [...pauseState.pauseEvents];\n      const lastEventIndex = updatedPauseEvents.length - 1;\n      if (lastEventIndex >= 0) {\n        updatedPauseEvents[lastEventIndex] = {\n          ...updatedPauseEvents[lastEventIndex],\n          endTime: resumeTime,\n          duration: pauseDuration\n        };\n      }\n\n      // Set cooldown (12 hours from now)\n      const cooldownEndTime = new Date(resumeTime.getTime() + (12 * 60 * 60 * 1000));\n\n      const newState = {\n        ...pauseState,\n        isPaused: false,\n        pauseStartTime: null,\n        totalPauseTime: pauseState.totalPauseTime + pauseDuration,\n        pauseEvents: updatedPauseEvents,\n        cooldownEndTime\n      };\n\n      setPauseState(newState);\n      await saveStateToFirestore(newState);\n      if (onStateChange) onStateChange(newState);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to resume session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [pauseState, saveStateToFirestore, onStateChange]);\n\n  const getCurrentPauseDuration = useCallback(() => {\n    if (!pauseState.isPaused || !pauseState.pauseStartTime) {\n      return 0;\n    }\n    return Math.floor((new Date().getTime() - pauseState.pauseStartTime.getTime()) / 1000);\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Timer to update current pause duration\n  useEffect(() => {\n    if (pauseState.isPaused && pauseState.pauseStartTime) {\n      pauseTimerRef.current = setInterval(() => {\n        // Force re-render to update current pause duration in UI\n        setPauseState(prev => ({ ...prev }));\n      }, 1000);\n    } else {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n        pauseTimerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (pauseTimerRef.current) {\n        clearInterval(pauseTimerRef.current);\n      }\n    };\n  }, [pauseState.isPaused, pauseState.pauseStartTime]);\n\n  // Cooldown timer\n  useEffect(() => {\n    if (pauseState.cooldownEndTime && pauseState.cooldownEndTime > new Date()) {\n      const timeUntilCooldownEnd = pauseState.cooldownEndTime.getTime() - new Date().getTime();\n      \n      cooldownTimerRef.current = setTimeout(() => {\n        setPauseState(prev => ({ ...prev, cooldownEndTime: null }));\n      }, timeUntilCooldownEnd);\n    }\n\n    return () => {\n      if (cooldownTimerRef.current) {\n        clearTimeout(cooldownTimerRef.current);\n      }\n    };\n  }, [pauseState.cooldownEndTime]);\n\n  return {\n    pauseState,\n    isLoading,\n    error,\n    pauseSession,\n    resumeSession,\n    getCurrentPauseDuration,\n    canPause: sessionActive && !pauseState.isPaused && (!pauseState.cooldownEndTime || new Date() >= pauseState.cooldownEndTime),\n    canResume: pauseState.isPaused\n  };\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseResume.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (298). Maximum allowed is 75.",
        "line": 60,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 430,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 60,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 430,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'sessionId'. Either include it or remove the dependency array.",
        "line": 139,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 139,
        "endColumn": 61,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]",
            "fix": {
              "range": [4297, 4352],
              "text": "[keyholderOverrides.canOverrideCooldown, sessionId, startCooldown]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'initializeKeyholderOverrides', 'loadCooldownState', 'loadPauseAnalytics', 'loadPauseHistory', and 'loadPauseState'. Either include them or remove the dependency array.",
        "line": 184,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 184,
        "endColumn": 33,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]",
            "fix": {
              "range": [5518, 5545],
              "text": "[sessionId, relationshipId, initializeKeyholderOverrides, loadPauseState, loadCooldownState, loadPauseHistory, loadPauseAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Pause/Resume System Hook (Refactored)\n * Provides advanced pause/resume functionality with keyholder overrides,\n * intelligent cooldown management, and comprehensive analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { PauseCooldownService } from \"../../services/PauseCooldownService\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type {\n  PauseStatus as _PauseStatus,\n  CooldownState as _CooldownState,\n  KeyholderOverrideCapabilities,\n  PauseHistoryEntry as _PauseHistoryEntry,\n  PauseAnalytics,\n  PauseReason,\n  PauseRequestStatus,\n  OverrideRequestStatus,\n  PausePattern,\n  CooldownAnalytics,\n} from \"../../types/pauseResume\";\nimport {\n  calculatePauseFrequency,\n  calculateCooldownDuration,\n  calculatePauseAnalytics,\n  analyzePausePatterns,\n  calculateCooldownEffectiveness,\n} from \"../../utils/pauseAnalytics\";\nimport {\n  calculatePauseDuration,\n  updatePauseHistoryOnResume,\n  updatePauseStatusOnResume,\n  createKeyholderOverrides,\n} from \"../../utils/pauseResumeHelpers\";\nimport { usePauseState } from \"./usePauseState\";\nimport { useCooldownState } from \"./useCooldownState\";\nimport { usePauseDurationTracking } from \"./usePauseDurationTracking\";\n\nconst logger = serviceLogger(\"usePauseResume\");\n\nconst createInitialKeyholderOverrides = (): KeyholderOverrideCapabilities => ({\n  canOverrideCooldown: false,\n  canForcePause: false,\n  canForceResume: false,\n  canModifyCooldownDuration: false,\n  requiresReason: true,\n});\n\nconst createInitialPauseAnalytics = (): PauseAnalytics => ({\n  totalPauses: 0,\n  averagePauseDuration: 0,\n  pauseFrequency: 0,\n  emergencyPauseCount: 0,\n  keyholderInitiatedCount: 0,\n  cooldownViolations: 0,\n  patterns: [],\n});\n\n// Complex pause/resume logic with cooldown management and analytics\n// eslint-disable-next-line max-statements\nexport const usePauseResume = (sessionId: string, relationshipId?: string) => {\n  // Use sub-hooks for state management\n  const {\n    pauseStatus,\n    pauseHistory,\n    setPauseStatus,\n    setPauseHistory,\n    startPause,\n    updatePauseDuration,\n  } = usePauseState(sessionId);\n\n  const { cooldownState, startCooldown, clearCooldown } = useCooldownState();\n\n  const [keyholderOverrides, setKeyholderOverrides] = useState(\n    createInitialKeyholderOverrides,\n  );\n  const [pauseAnalytics, setPauseAnalytics] = useState(\n    createInitialPauseAnalytics,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track pause duration\n  usePauseDurationTracking(pauseStatus, updatePauseDuration);\n\n  // Computed values\n  const canPause = useMemo(\n    () => !pauseStatus.isPaused && !cooldownState.isInCooldown,\n    [pauseStatus.isPaused, cooldownState.isInCooldown],\n  );\n\n  const canResume = useMemo(() => pauseStatus.isPaused, [pauseStatus.isPaused]);\n\n  const timeUntilNextPause = useMemo(() => {\n    if (!cooldownState.nextPauseAvailable) return 0;\n    return Math.max(\n      0,\n      Math.floor(\n        (cooldownState.nextPauseAvailable.getTime() - Date.now()) / 1000,\n      ),\n    );\n  }, [cooldownState.nextPauseAvailable]);\n\n  const hasKeyholderOverride = useMemo(\n    () => keyholderOverrides.canOverrideCooldown,\n    [keyholderOverrides.canOverrideCooldown],\n  );\n\n  const pauseFrequency = useMemo(\n    () => calculatePauseFrequency(pauseHistory),\n    [pauseHistory],\n  );\n\n  // Initialize keyholder overrides\n  const initializeKeyholderOverrides = useCallback(() => {\n    if (relationshipId) {\n      setKeyholderOverrides(createKeyholderOverrides());\n    }\n  }, [relationshipId]);\n\n  // Load data functions\n  const loadPauseState = useCallback(async () => {\n    // Integration with pause state service\n  }, []);\n\n  const loadCooldownState = useCallback(async () => {\n    try {\n      const cooldownInfo = await PauseCooldownService.canUserPause(sessionId);\n      if (cooldownInfo && !cooldownInfo.canPause) {\n        startCooldown(\n          cooldownInfo.cooldownRemaining || 0,\n          keyholderOverrides.canOverrideCooldown,\n        );\n      }\n    } catch (err) {\n      logger.error(\"Failed to load cooldown state\", { error: err });\n    }\n    // sessionId is a stable prop from the component, safe to omit from deps\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [keyholderOverrides.canOverrideCooldown, startCooldown]);\n\n  const loadPauseHistory = useCallback(async () => {\n    // Load pause history from service\n  }, []);\n\n  const loadPauseAnalytics = useCallback(async () => {\n    try {\n      const analytics = calculatePauseAnalytics(pauseHistory);\n      setPauseAnalytics(analytics);\n    } catch (err) {\n      logger.error(\"Failed to load pause analytics\", { error: err });\n    }\n  }, [pauseHistory]);\n\n  // Initialization\n  useEffect(() => {\n    const initializePauseSystem = async () => {\n      if (!sessionId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        initializeKeyholderOverrides();\n        await Promise.all([\n          loadPauseState(),\n          loadCooldownState(),\n          loadPauseHistory(),\n          loadPauseAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize pause system\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize pause system\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializePauseSystem();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId, relationshipId]);\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason: PauseReason): Promise<void> => {\n      if (!canPause) {\n        throw new Error(\"Cannot pause: either already paused or in cooldown\");\n      }\n\n      try {\n        logger.debug(\"Pausing session\", { sessionId, reason });\n        startPause(reason);\n        logger.info(\"Session paused successfully\", { sessionId, reason });\n      } catch (err) {\n        logger.error(\"Failed to pause session\", { error: err });\n        throw err;\n      }\n    },\n    [canPause, sessionId, startPause],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    if (!canResume) {\n      throw new Error(\"Cannot resume: session is not paused\");\n    }\n\n    try {\n      logger.debug(\"Resuming session\", { sessionId });\n\n      const resumeTime = new Date();\n      const duration = calculatePauseDuration(\n        pauseStatus.pauseStartTime,\n        resumeTime,\n      );\n\n      setPauseStatus(updatePauseStatusOnResume(pauseStatus));\n      setPauseHistory((prev) =>\n        updatePauseHistoryOnResume(prev, resumeTime, duration),\n      );\n\n      const cooldownDur = calculateCooldownDuration(pauseAnalytics, duration);\n      startCooldown(cooldownDur, keyholderOverrides.canOverrideCooldown);\n\n      logger.info(\"Session resumed successfully\", {\n        sessionId,\n        pauseDuration: duration,\n      });\n    } catch (err) {\n      logger.error(\"Failed to resume session\", { error: err });\n      throw err;\n    }\n  }, [\n    canResume,\n    sessionId,\n    pauseStatus,\n    pauseAnalytics,\n    keyholderOverrides.canOverrideCooldown,\n    setPauseStatus,\n    setPauseHistory,\n    startCooldown,\n  ]);\n\n  // Emergency pause\n  const requestEmergencyPause = useCallback(\n    async (reason: string): Promise<PauseRequestStatus> => {\n      try {\n        logger.debug(\"Requesting emergency pause\", { sessionId, reason });\n\n        if (cooldownState.isInCooldown) {\n          logger.warn(\"Emergency pause bypassing cooldown\", { sessionId });\n        }\n\n        await pauseSession(\"emergency\");\n\n        return {\n          approved: true,\n          reason: \"Emergency pause approved automatically\",\n          requestId: `emergency_${Date.now()}`,\n          approvedBy: \"emergency_protocol\",\n          approvedAt: new Date(),\n        };\n      } catch (err) {\n        logger.error(\"Failed to request emergency pause\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `emergency_${Date.now()}`,\n        };\n      }\n    },\n    [sessionId, cooldownState.isInCooldown, pauseSession],\n  );\n\n  // Request cooldown override\n  const requestCooldownOverride = useCallback(\n    async (justification: string): Promise<OverrideRequestStatus> => {\n      if (!relationshipId) {\n        return {\n          approved: false,\n          reason: \"Cooldown override requires keyholder relationship\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n\n      try {\n        logger.debug(\"Requesting cooldown override\", {\n          sessionId,\n          justification,\n        });\n\n        return {\n          approved: false,\n          reason: \"Override request sent to keyholder\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      } catch (err) {\n        logger.error(\"Failed to request cooldown override\", { error: err });\n        return {\n          approved: false,\n          reason: err instanceof Error ? err.message : \"Unknown error\",\n          requestId: `override_${Date.now()}`,\n          overrideType: \"cooldown\",\n        };\n      }\n    },\n    [sessionId, relationshipId],\n  );\n\n  // Keyholder force pause\n  const keyholderForcePause = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForcePause) {\n        throw new Error(\"Keyholder does not have force pause permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing pause\", { sessionId, reason });\n        startPause(\"keyholder_request\", \"keyholder\");\n        logger.info(\"Keyholder force pause successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force pause\", { error: err });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForcePause, sessionId, startPause],\n  );\n\n  // Keyholder force resume\n  const keyholderForceResume = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canForceResume) {\n        throw new Error(\"Keyholder does not have force resume permissions\");\n      }\n\n      try {\n        logger.debug(\"Keyholder forcing resume\", { sessionId, reason });\n        await resumeSession();\n        logger.info(\"Keyholder force resume successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder force resume\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canForceResume, sessionId, resumeSession],\n  );\n\n  // Keyholder override cooldown\n  const keyholderOverrideCooldown = useCallback(\n    async (reason: string): Promise<void> => {\n      if (!keyholderOverrides.canOverrideCooldown) {\n        throw new Error(\n          \"Keyholder does not have cooldown override permissions\",\n        );\n      }\n\n      try {\n        logger.debug(\"Keyholder overriding cooldown\", { sessionId, reason });\n        clearCooldown();\n        logger.info(\"Keyholder cooldown override successful\", { sessionId });\n      } catch (err) {\n        logger.error(\"Failed to execute keyholder cooldown override\", {\n          error: err,\n        });\n        throw err;\n      }\n    },\n    [keyholderOverrides.canOverrideCooldown, sessionId, clearCooldown],\n  );\n\n  // Analytics\n  const getPausePatterns = useCallback((): PausePattern[] => {\n    return analyzePausePatterns(pauseHistory);\n  }, [pauseHistory]);\n\n  const getCooldownEffectiveness = useCallback((): CooldownAnalytics => {\n    return {\n      effectiveness: calculateCooldownEffectiveness(\n        pauseHistory,\n        cooldownState,\n      ),\n      averageCooldownDuration: cooldownState.adaptiveDuration,\n      overrideFrequency: 0,\n      adaptiveAdjustments: 0,\n    };\n  }, [pauseHistory, cooldownState]);\n\n  return {\n    // Enhanced state\n    pauseStatus,\n    cooldownState,\n    keyholderOverrides,\n    pauseAnalytics,\n\n    // Basic actions\n    pauseSession,\n    resumeSession,\n\n    // Enhanced actions\n    requestEmergencyPause,\n    requestCooldownOverride,\n\n    // Keyholder actions\n    keyholderForcePause,\n    keyholderForceResume,\n    keyholderOverrideCooldown,\n\n    // Analytics\n    getPausePatterns,\n    getCooldownEffectiveness,\n\n    // Computed values\n    canPause,\n    canResume,\n    timeUntilNextPause,\n    hasKeyholderOverride,\n    pauseFrequency,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/usePauseState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSession.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (192). Maximum allowed is 75.",
        "line": 35,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 254,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback, useRef } from 'react';\nimport { doc, setDoc, onSnapshot, serverTimestamp } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} Session\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} [endTime]\n * @property {boolean} isActive\n * @property {number} [duration]\n * @property {string} [reason]\n */\n\n/**\n * @typedef {Object} SessionState\n * @property {Session|null} currentSession\n * @property {boolean} isSessionActive\n * @property {Date|null} sessionStartTime\n * @property {number} elapsedTime\n */\n\n/**\n * @typedef {Object} SessionOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {Function} [onSessionChange]\n */\n\n/**\n * Hook for managing user sessions\n * @param {SessionOptions} options\n * @returns {Object}\n */\nexport const useSession = ({ userId, isAuthReady, onSessionChange }) => {\n  const [sessionState, setSessionState] = useState({\n    currentSession: null,\n    isSessionActive: false,\n    sessionStartTime: null,\n    elapsedTime: 0\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const timerRef = useRef(null);\n  const unsubscribeRef = useRef(null);\n\n  const saveSessionToFirestore = useCallback(async (sessionData) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { \n        currentSession: sessionData,\n        sessionUpdatedAt: serverTimestamp()\n      }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save session');\n    }\n  }, [userId, isAuthReady]);\n\n  const startSession = useCallback(async () => {\n    if (sessionState.isSessionActive) {\n      setError('Session already active');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const startTime = new Date();\n      const newSession = {\n        id: crypto.randomUUID(),\n        startTime,\n        isActive: true\n      };\n\n      const newState = {\n        currentSession: newSession,\n        isSessionActive: true,\n        sessionStartTime: startTime,\n        elapsedTime: 0\n      };\n\n      setSessionState(newState);\n      await saveSessionToFirestore(newSession);\n      if (onSessionChange) onSessionChange(newSession);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to start session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionState.isSessionActive, saveSessionToFirestore, onSessionChange]);\n\n  const endSession = useCallback(async (reason) => {\n    if (!sessionState.isSessionActive || !sessionState.currentSession) {\n      setError('No active session to end');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const endTime = new Date();\n      const duration = sessionState.sessionStartTime \n        ? Math.floor((endTime.getTime() - sessionState.sessionStartTime.getTime()) / 1000)\n        : 0;\n\n      const endedSession = {\n        ...sessionState.currentSession,\n        endTime,\n        isActive: false,\n        duration,\n        reason\n      };\n\n      const newState = {\n        currentSession: null,\n        isSessionActive: false,\n        sessionStartTime: null,\n        elapsedTime: 0\n      };\n\n      setSessionState(newState);\n      await saveSessionToFirestore(endedSession);\n      if (onSessionChange) onSessionChange(null);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to end session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    sessionState.isSessionActive, \n    sessionState.currentSession, \n    sessionState.sessionStartTime,\n    saveSessionToFirestore, \n    onSessionChange\n  ]);\n\n  const updateSession = useCallback(async (updates) => {\n    if (!sessionState.currentSession) {\n      setError('No active session to update');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const updatedSession = {\n        ...sessionState.currentSession,\n        ...updates\n      };\n\n      setSessionState(prev => ({\n        ...prev,\n        currentSession: updatedSession\n      }));\n\n      await saveSessionToFirestore(updatedSession);\n      if (onSessionChange) onSessionChange(updatedSession);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to update session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionState.currentSession, saveSessionToFirestore, onSessionChange]);\n\n  // Real-time session listener\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.currentSession) {\n            const session = {\n              ...data.currentSession,\n              startTime: data.currentSession.startTime?.toDate(),\n              endTime: data.currentSession.endTime?.toDate()\n            };\n\n            setSessionState(prev => ({\n              ...prev,\n              currentSession: session,\n              isSessionActive: session.isActive,\n              sessionStartTime: session.startTime\n            }));\n          } else {\n            setSessionState({\n              currentSession: null,\n              isSessionActive: false,\n              sessionStartTime: null,\n              elapsedTime: 0\n            });\n          }\n        }\n        setError(null);\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    unsubscribeRef.current = unsubscribe;\n    return () => {\n      if (unsubscribeRef.current) {\n        unsubscribeRef.current();\n      }\n    };\n  }, [userId, isAuthReady]);\n\n  // Timer for elapsed time\n  useEffect(() => {\n    if (sessionState.isSessionActive && sessionState.sessionStartTime) {\n      timerRef.current = setInterval(() => {\n        const elapsed = Math.floor((new Date().getTime() - sessionState.sessionStartTime.getTime()) / 1000);\n        setSessionState(prev => ({\n          ...prev,\n          elapsedTime: elapsed\n        }));\n      }, 1000);\n    } else {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n\n    return () => {\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    };\n  }, [sessionState.isSessionActive, sessionState.sessionStartTime]);\n\n  return {\n    sessionState,\n    isLoading,\n    error,\n    startSession,\n    endSession,\n    updateSession,\n    clearError: useCallback(() => setError(null), [])\n  };\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSession.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (338). Maximum allowed is 75.",
        "line": 134,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 564,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (28). Maximum allowed is 25.",
        "line": 134,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 564,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAnalytics', 'loadCurrentSession', 'loadGoals', and 'loadHistory'. Either include them or remove the dependency array.",
        "line": 268,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 268,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]",
            "fix": {
              "range": [7423, 7447],
              "text": "[userId, relationshipId, loadCurrentSession, loadGoals, loadHistory, loadAnalytics]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Session Management Hook\n * Provides comprehensive session management with keyholder integration,\n * goal tracking, and advanced analytics\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { DBSession, DBGoal } from \"../../types/database\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { KeyholderRelationshipService } from \"../../services/KeyholderRelationshipService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useSession\");\n\n// ==================== INTERFACES ====================\n\nexport interface SessionGoals {\n  personal: DBGoal[];\n  keyholderAssigned: DBGoal[];\n  active: DBGoal[];\n}\n\nexport interface SessionContext {\n  userId: string;\n  relationshipId?: string;\n  sessionType: \"self_managed\" | \"keyholder_managed\" | \"collaborative\";\n  permissions: SessionPermission[];\n}\n\nexport interface KeyholderInfo {\n  id: string;\n  name: string;\n  lastSeen: Date;\n}\n\nexport interface KeyholderSessionControls {\n  canModify: boolean;\n  canOverride: boolean;\n  activeKeyholder: KeyholderInfo;\n  controlHistory: ControlAction[];\n}\n\nexport interface SessionAnalytics {\n  averageSessionLength: number;\n  completionRate: number;\n  goalAchievementRate: number;\n  totalSessions: number;\n  consistencyScore: number;\n}\n\nexport interface SessionInsights {\n  predictedDuration: number;\n  optimalGoalDuration: number;\n  completionProbability: number;\n  riskFactors: string[];\n  recommendations: string[];\n}\n\nexport interface PredictiveAnalytics {\n  nextSessionPrediction: {\n    suggestedDuration: number;\n    successProbability: number;\n    recommendedGoals: string[];\n  };\n  weeklyTrend: {\n    direction: \"improving\" | \"declining\" | \"stable\";\n    confidence: number;\n  };\n}\n\nexport interface SessionHistoryEntry {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  goals: DBGoal[];\n  completedGoals: string[];\n  notes?: string;\n  rating?: number;\n}\n\nexport interface EnhancedSessionState {\n  currentSession: DBSession | null;\n  sessionContext: SessionContext;\n  keyholderControls: KeyholderSessionControls | null;\n  goals: SessionGoals;\n  history: SessionHistoryEntry[];\n  analytics: SessionAnalytics;\n}\n\nexport type SessionPermission =\n  | \"start_session\"\n  | \"end_session\"\n  | \"modify_goals\"\n  | \"pause_session\"\n  | \"self_modify\"\n  | \"override_restrictions\";\n\nexport interface ControlAction {\n  id: string;\n  action: string;\n  timestamp: Date;\n  reason?: string;\n  performedBy: \"keyholder\" | \"submissive\" | \"system\";\n}\n\nexport interface SessionModifications {\n  goalDuration?: number;\n  goals?: Partial<DBGoal>[];\n  notes?: string;\n  endReason?: string;\n}\n\nexport interface ModificationRequest {\n  id: string;\n  type: \"goal_change\" | \"early_end\" | \"time_extension\";\n  requestedBy: string;\n  reason: string;\n  details: Record<string, unknown>;\n  status: \"pending\" | \"approved\" | \"rejected\";\n  createdAt: Date;\n}\n\nexport interface ApprovalStatus {\n  approved: boolean;\n  reason?: string;\n  approvedBy?: string;\n  approvedAt?: Date;\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session management hook with analytics, goals, and keyholder controls\n// eslint-disable-next-line max-statements\nexport const useSession = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [goals, setGoals] = useState<SessionGoals>({\n    personal: [],\n    keyholderAssigned: [],\n    active: [],\n  });\n  const [_history, setHistory] = useState<SessionHistoryEntry[]>([]);\n  const [keyholderControls, setKeyholderControls] =\n    useState<KeyholderSessionControls | null>(null);\n  const [analytics, setAnalytics] = useState<SessionAnalytics>({\n    averageSessionLength: 0,\n    completionRate: 0,\n    goalAchievementRate: 0,\n    totalSessions: 0,\n    consistencyScore: 0,\n  });\n  const [relationship, setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const sessionContext = useMemo((): SessionContext => {\n    if (!userId) {\n      return {\n        userId: \"\",\n        sessionType: \"self_managed\",\n        permissions: [],\n      };\n    }\n\n    return {\n      userId,\n      relationshipId,\n      sessionType: relationshipId\n        ? keyholderControls?.canModify\n          ? \"keyholder_managed\"\n          : \"collaborative\"\n        : \"self_managed\",\n      permissions: derivePermissions(relationship, keyholderControls),\n    };\n  }, [userId, relationshipId, keyholderControls, relationship]);\n\n  const isActive = useMemo(\n    () => currentSession?.endTime == null && currentSession != null,\n    [currentSession],\n  );\n\n  const duration = useMemo(\n    () => (currentSession ? calculateDuration(currentSession) : 0),\n    [currentSession],\n  );\n\n  const goalProgress = useMemo(\n    () => calculateGoalProgress(currentSession, goals),\n    [currentSession, goals],\n  );\n\n  const isUnderKeyholderControl = useMemo(\n    () => !!relationshipId && !!keyholderControls,\n    [relationshipId, keyholderControls],\n  );\n\n  const canSelfModify = useMemo(\n    () =>\n      !keyholderControls?.canModify ||\n      sessionContext.permissions.includes(\"self_modify\"),\n    [keyholderControls, sessionContext.permissions],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeSession = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship if provided\n        if (relationshipId) {\n          const relationships =\n            await KeyholderRelationshipService.getUserRelationships(userId);\n          const activeRelationship =\n            relationships.asSubmissive.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            ) ||\n            relationships.asKeyholder.find(\n              (rel) => rel.id === relationshipId && rel.status === \"active\",\n            );\n\n          setRelationship(activeRelationship || null);\n\n          if (activeRelationship) {\n            setKeyholderControls({\n              canModify:\n                activeRelationship.permissions.canLockSessions || false,\n              canOverride:\n                activeRelationship.permissions.canUnlockSessions || false,\n              activeKeyholder: {\n                id: activeRelationship.keyholderUserId,\n                name: \"Keyholder\", // Would get from user profile\n                lastSeen: new Date(),\n              },\n              controlHistory: [],\n            });\n          }\n        }\n\n        // Load current session, goals, history, and analytics\n        await Promise.all([\n          loadCurrentSession(),\n          loadGoals(),\n          loadHistory(),\n          loadAnalytics(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize session\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeSession();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadCurrentSession = useCallback(async () => {\n    // This would integrate with your existing session service\n    // For now, return mock data structure\n    setCurrentSession(null);\n  }, []); // userId is passed but not used in mock implementation\n\n  const loadGoals = useCallback(async () => {\n    // This would integrate with your existing goals service\n    setGoals({\n      personal: [],\n      keyholderAssigned: [],\n      active: [],\n    });\n  }, []); // userId and relationshipId are passed but not used in mock\n\n  const loadHistory = useCallback(async () => {\n    // This would integrate with your existing history service\n    setHistory([]);\n  }, []); // userId is passed but not used in mock\n\n  const loadAnalytics = useCallback(async () => {\n    // This would integrate with your existing analytics service\n    setAnalytics({\n      averageSessionLength: 0,\n      completionRate: 0,\n      goalAchievementRate: 0,\n      totalSessions: 0,\n      consistencyScore: 0,\n    });\n  }, []); // userId is passed but not used in mock\n\n  // ==================== SESSION LIFECYCLE ====================\n\n  const startSession = useCallback(\n    async (sessionGoals?: SessionGoals): Promise<DBSession> => {\n      if (!userId) throw new Error(\"User ID required to start session\");\n\n      try {\n        logger.debug(\"Starting new session\", {\n          userId,\n          hasGoals: !!sessionGoals,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"start_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to start session\");\n        }\n\n        // Create new session\n        const newSession: DBSession = {\n          id: `session_${Date.now()}`,\n          userId,\n          startTime: new Date(),\n          isPaused: false,\n          accumulatedPauseTime: 0,\n          isHardcoreMode: false,\n          keyholderApprovalRequired:\n            sessionContext.sessionType === \"keyholder_managed\",\n          syncStatus: \"pending\",\n          lastModified: new Date(),\n        };\n\n        // Add goals if provided\n        if (sessionGoals) {\n          await setGoals(sessionGoals);\n        }\n\n        setCurrentSession(newSession);\n        logger.info(\"Session started successfully\", {\n          sessionId: newSession.id,\n        });\n\n        return newSession;\n      } catch (error) {\n        logger.error(\"Failed to start session\", { error });\n        throw error;\n      }\n    },\n    [userId, sessionContext],\n  );\n\n  const stopSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to stop\");\n\n      try {\n        logger.debug(\"Stopping session\", {\n          sessionId: currentSession.id,\n          reason,\n        });\n\n        // Check permissions\n        if (\n          sessionContext.sessionType === \"keyholder_managed\" &&\n          !sessionContext.permissions.includes(\"end_session\")\n        ) {\n          throw new Error(\"Keyholder approval required to end session\");\n        }\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          endTime: new Date(),\n          endReason: reason,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        await loadHistory(); // Refresh history\n        await loadAnalytics(); // Refresh analytics\n\n        logger.info(\"Session stopped successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to stop session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, sessionContext, loadHistory, loadAnalytics],\n  );\n\n  // ==================== ENHANCED CONTROLS ====================\n\n  const modifySession = useCallback(\n    async (modifications: SessionModifications): Promise<void> => {\n      if (!currentSession) throw new Error(\"No active session to modify\");\n\n      if (!canSelfModify) {\n        throw new Error(\"Session modification requires keyholder approval\");\n      }\n\n      try {\n        logger.debug(\"Modifying session\", {\n          sessionId: currentSession.id,\n          modifications,\n        });\n\n        const updatedSession: DBSession = {\n          ...currentSession,\n          ...modifications,\n          lastModified: new Date(),\n        };\n\n        setCurrentSession(updatedSession);\n        logger.info(\"Session modified successfully\", {\n          sessionId: currentSession.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to modify session\", { error });\n        throw error;\n      }\n    },\n    [currentSession, canSelfModify],\n  );\n\n  const setSessionGoals = useCallback(\n    async (sessionGoals: SessionGoals): Promise<void> => {\n      if (!sessionContext.permissions.includes(\"modify_goals\")) {\n        throw new Error(\"Goal modification requires appropriate permissions\");\n      }\n\n      try {\n        logger.debug(\"Setting session goals\", {\n          userId,\n          goalCount: sessionGoals.active.length,\n        });\n        setGoals(sessionGoals);\n        logger.info(\"Session goals updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to set session goals\", { error });\n        throw error;\n      }\n    },\n    [sessionContext.permissions, userId],\n  );\n\n  const requestModification = useCallback(\n    async (request: ModificationRequest): Promise<void> => {\n      if (!relationshipId)\n        throw new Error(\"Modification requests require active relationship\");\n\n      try {\n        logger.debug(\"Creating modification request\", {\n          requestId: request.id,\n          type: request.type,\n        });\n        // This would integrate with your notification/request system\n        logger.info(\"Modification request created successfully\", {\n          requestId: request.id,\n        });\n      } catch (error) {\n        logger.error(\"Failed to create modification request\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const requestKeyholderApproval = useCallback(\n    async (action: string): Promise<ApprovalStatus> => {\n      if (!keyholderControls) {\n        return { approved: true }; // Auto-approve if no keyholder control\n      }\n\n      try {\n        logger.debug(\"Requesting keyholder approval\", {\n          action,\n          keyholderId: keyholderControls.activeKeyholder.id,\n        });\n\n        // This would integrate with your keyholder notification system\n        // For now, return pending status\n        return {\n          approved: false,\n          reason: \"Approval request sent to keyholder\",\n        };\n      } catch (error) {\n        logger.error(\"Failed to request keyholder approval\", { error });\n        throw error;\n      }\n    },\n    [keyholderControls],\n  );\n\n  // ==================== ANALYTICS AND INSIGHTS ====================\n\n  const getSessionInsights = useCallback((): SessionInsights => {\n    return {\n      predictedDuration: analytics.averageSessionLength,\n      optimalGoalDuration: analytics.averageSessionLength * 1.2,\n      completionProbability: analytics.completionRate,\n      riskFactors: [],\n      recommendations: [],\n    };\n  }, [analytics]);\n\n  const getPredictiveAnalytics = useCallback((): PredictiveAnalytics => {\n    return {\n      nextSessionPrediction: {\n        suggestedDuration: analytics.averageSessionLength,\n        successProbability: analytics.completionRate,\n        recommendedGoals: [\"Duration Goal\", \"Consistency Goal\"],\n      },\n      weeklyTrend: {\n        direction: \"stable\",\n        confidence: 0.8,\n      },\n    };\n  }, [analytics]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Enhanced state\n    session: currentSession,\n    context: sessionContext,\n    keyholderControls,\n    goals,\n    analytics,\n\n    // Session lifecycle\n    startSession,\n    stopSession,\n\n    // Enhanced controls\n    modifySession,\n    setGoals: setSessionGoals,\n    requestModification,\n\n    // Keyholder integration\n    requestKeyholderApproval,\n\n    // Analytics and insights\n    getSessionInsights,\n    getPredictiveAnalytics,\n\n    // Computed values\n    isActive,\n    duration,\n    goalProgress,\n    isUnderKeyholderControl,\n    canSelfModify,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction derivePermissions(\n  relationship: KeyholderRelationship | null,\n  controls: KeyholderSessionControls | null,\n): SessionPermission[] {\n  const permissions: SessionPermission[] = [];\n\n  if (!relationship || !controls) {\n    // Self-managed session - all permissions\n    return [\n      \"start_session\",\n      \"end_session\",\n      \"modify_goals\",\n      \"pause_session\",\n      \"self_modify\",\n    ];\n  }\n\n  // Keyholder-managed permissions\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"start_session\");\n  if (relationship.permissions.canUnlockSessions)\n    permissions.push(\"end_session\");\n  if (relationship.permissions.canEditGoals) permissions.push(\"modify_goals\");\n  if (relationship.permissions.canLockSessions)\n    permissions.push(\"pause_session\");\n  // Add basic self-modify permission for submissives\n  permissions.push(\"self_modify\");\n  if (controls.canOverride) permissions.push(\"override_restrictions\");\n\n  return permissions;\n}\n\nfunction calculateDuration(session: DBSession): number {\n  if (!session.startTime) return 0;\n\n  const endTime = session.endTime || new Date();\n  const totalTime = endTime.getTime() - session.startTime.getTime();\n\n  return Math.max(0, Math.floor(totalTime / 1000));\n}\n\nfunction calculateGoalProgress(\n  session: DBSession | null,\n  goals: SessionGoals,\n): number {\n  if (!session || goals.active.length === 0) return 0;\n\n  const completedGoals = goals.active.filter((goal) => goal.isCompleted).length;\n  return Math.floor((completedGoals / goals.active.length) * 100);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionActions.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSessionActions' has too many lines (112). Maximum allowed is 75.",
        "line": 258,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 397,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Actions Hook\n * Provides session control operations (start, end, pause, resume, lock, unlock)\n * Extracts session action logic from ActionButtons component\n */\nimport { useState, useCallback, useMemo } from \"react\";\nimport { useSession } from \"./useSession\";\nimport { usePauseResume } from \"./usePauseResume\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type { DBGoal } from \"../../types/database\";\n\nconst logger = serviceLogger(\"useSessionActions\");\n\n/**\n * Helper function to handle session start\n */\nasync function handleStartSession(\n  canStart: boolean,\n  userId: string,\n  config: SessionConfig | undefined,\n  actions: {\n    startSessionCore: (config: {\n      goalDuration?: number;\n      isHardcoreMode: boolean;\n      keyholderApprovalRequired: boolean;\n      notes?: string;\n    }) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setIsStarting: (value: boolean) => void;\n    setError: (error: Error | null) => void;\n    onSessionStarted?: () => void;\n  },\n): Promise<void> {\n  if (!canStart) {\n    const err = new Error(\"Cannot start session\");\n    actions.handleError(err, \"Start session\");\n    return;\n  }\n\n  actions.setIsStarting(true);\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Starting session\", { userId, config });\n\n    await actions.startSessionCore({\n      goalDuration: config?.goalDuration,\n      isHardcoreMode: config?.isHardcoreMode || false,\n      keyholderApprovalRequired: config?.keyholderApprovalRequired || false,\n      notes: config?.notes,\n    });\n\n    logger.info(\"Session started successfully\", { userId });\n    actions.onSessionStarted?.();\n  } catch (err) {\n    actions.handleError(err, \"Start session\");\n    throw err;\n  } finally {\n    actions.setIsStarting(false);\n  }\n}\n\n/**\n * Helper function to handle session end\n */\nasync function handleEndSession(\n  canEnd: boolean,\n  userId: string,\n  reason: string | undefined,\n  actions: {\n    stopSessionCore: (reason: string) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setIsEnding: (value: boolean) => void;\n    setError: (error: Error | null) => void;\n    onSessionEnded?: () => void;\n  },\n): Promise<void> {\n  if (!canEnd) {\n    const err = new Error(\"Cannot end session\");\n    actions.handleError(err, \"End session\");\n    return;\n  }\n\n  actions.setIsEnding(true);\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Ending session\", { userId, reason });\n\n    await actions.stopSessionCore(reason || \"User ended session\");\n\n    logger.info(\"Session ended successfully\", { userId });\n    actions.onSessionEnded?.();\n  } catch (err) {\n    actions.handleError(err, \"End session\");\n    throw err;\n  } finally {\n    actions.setIsEnding(false);\n  }\n}\n\n/**\n * Helper function to handle session pause\n */\nasync function handlePauseSession(\n  canPause: boolean,\n  userId: string,\n  reason: string | undefined,\n  actions: {\n    pauseSessionCore: (reason: string) => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setError: (error: Error | null) => void;\n    onSessionPaused?: () => void;\n  },\n): Promise<void> {\n  if (!canPause) {\n    const err = new Error(\"Cannot pause session\");\n    actions.handleError(err, \"Pause session\");\n    return;\n  }\n\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Pausing session\", { userId, reason });\n\n    await actions.pauseSessionCore(reason || \"bathroom\");\n\n    logger.info(\"Session paused successfully\", { userId });\n    actions.onSessionPaused?.();\n  } catch (err) {\n    actions.handleError(err, \"Pause session\");\n    throw err;\n  }\n}\n\n/**\n * Helper function to handle session resume\n */\nasync function handleResumeSession(\n  canResume: boolean,\n  userId: string,\n  actions: {\n    resumeSessionCore: () => Promise<void>;\n    handleError: (err: unknown, context: string) => Error;\n    setError: (error: Error | null) => void;\n    onSessionResumed?: () => void;\n  },\n): Promise<void> {\n  if (!canResume) {\n    const err = new Error(\"Cannot resume session\");\n    actions.handleError(err, \"Resume session\");\n    return;\n  }\n\n  actions.setError(null);\n\n  try {\n    logger.debug(\"Resuming session\", { userId });\n\n    await actions.resumeSessionCore();\n\n    logger.info(\"Session resumed successfully\", { userId });\n    actions.onSessionResumed?.();\n  } catch (err) {\n    actions.handleError(err, \"Resume session\");\n    throw err;\n  }\n}\n\n/**\n * Helper hook to calculate session action permissions\n */\nfunction useSessionPermissions(params: {\n  isActive: boolean;\n  canSelfModify: boolean;\n  isStarting: boolean;\n  isEnding: boolean;\n  isPaused: boolean;\n  pauseStatus: { canResume: boolean };\n  cooldownState: { isInCooldown: boolean };\n}) {\n  const canStart = useMemo(() => {\n    return !params.isActive && params.canSelfModify && !params.isStarting;\n  }, [params.isActive, params.canSelfModify, params.isStarting]);\n\n  const canEnd = useMemo(() => {\n    return params.isActive && params.canSelfModify && !params.isEnding;\n  }, [params.isActive, params.canSelfModify, params.isEnding]);\n\n  const canPause = useMemo(() => {\n    return (\n      params.isActive &&\n      !params.isPaused &&\n      params.pauseStatus.canResume &&\n      !params.cooldownState.isInCooldown\n    );\n  }, [\n    params.isActive,\n    params.isPaused,\n    params.pauseStatus.canResume,\n    params.cooldownState.isInCooldown,\n  ]);\n\n  const canResume = useMemo(() => {\n    return params.isActive && params.isPaused && params.pauseStatus.canResume;\n  }, [params.isActive, params.isPaused, params.pauseStatus.canResume]);\n\n  return { canStart, canEnd, canPause, canResume };\n}\n\nexport interface SessionConfig {\n  goalDuration?: number;\n  isHardcoreMode?: boolean;\n  keyholderApprovalRequired?: boolean;\n  goals?: DBGoal[];\n  notes?: string;\n}\n\nexport interface UseSessionActionsReturn {\n  // Actions\n  startSession: (config?: SessionConfig) => Promise<void>;\n  endSession: (reason?: string) => Promise<void>;\n  pauseSession: (reason?: string) => Promise<void>;\n  resumeSession: () => Promise<void>;\n\n  // State\n  isStarting: boolean;\n  isEnding: boolean;\n  isPausing: boolean;\n  isResuming: boolean;\n\n  // Permissions\n  canStart: boolean;\n  canEnd: boolean;\n  canPause: boolean;\n  canResume: boolean;\n\n  // Error handling\n  error: Error | null;\n  clearError: () => void;\n\n  // Current session info\n  isActive: boolean;\n  isPaused: boolean;\n  sessionId: string | null;\n}\n\nexport interface UseSessionActionsOptions {\n  userId: string;\n  onSessionStarted?: () => void;\n  onSessionEnded?: () => void;\n  onSessionPaused?: () => void;\n  onSessionResumed?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport function useSessionActions({\n  userId,\n  onSessionStarted,\n  onSessionEnded,\n  onSessionPaused,\n  onSessionResumed,\n  onError,\n}: UseSessionActionsOptions): UseSessionActionsReturn {\n  const [isStarting, setIsStarting] = useState(false);\n  const [isEnding, setIsEnding] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Use existing session management hooks\n  const {\n    session,\n    isActive,\n    startSession: startSessionCore,\n    stopSession: stopSessionCore,\n    canSelfModify,\n  } = useSession(userId);\n\n  const {\n    pauseStatus,\n    cooldownState,\n    pauseSession: pauseSessionCore,\n    resumeSession: resumeSessionCore,\n  } = usePauseResume(userId, session?.id);\n\n  const isPaused = pauseStatus.isPaused;\n  const isPausing = pauseStatus.pauseCount > 0 && pauseStatus.isPaused;\n  const isResuming = false; // Track this internally if needed\n\n  // Calculate permissions using helper hook\n  const { canStart, canEnd, canPause, canResume } = useSessionPermissions({\n    isActive,\n    canSelfModify,\n    isStarting,\n    isEnding,\n    isPaused,\n    pauseStatus,\n    cooldownState,\n  });\n\n  // Clear error\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Handle errors internally\n  const handleError = useCallback(\n    (err: unknown, context: string) => {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      logger.error(`${context} failed`, { error, userId });\n      onError?.(error);\n      return error;\n    },\n    [userId, onError],\n  );\n\n  // Start session\n  const startSession = useCallback(\n    async (config?: SessionConfig): Promise<void> => {\n      await handleStartSession(canStart, userId, config, {\n        startSessionCore,\n        handleError,\n        setIsStarting,\n        setError,\n        onSessionStarted,\n      });\n    },\n    [canStart, userId, startSessionCore, handleError, onSessionStarted],\n  );\n\n  // End session\n  const endSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      await handleEndSession(canEnd, userId, reason, {\n        stopSessionCore,\n        handleError,\n        setIsEnding,\n        setError,\n        onSessionEnded,\n      });\n    },\n    [canEnd, userId, stopSessionCore, handleError, onSessionEnded],\n  );\n\n  // Pause session\n  const pauseSession = useCallback(\n    async (reason?: string): Promise<void> => {\n      await handlePauseSession(canPause, userId, reason, {\n        pauseSessionCore,\n        handleError,\n        setError,\n        onSessionPaused,\n      });\n    },\n    [canPause, userId, pauseSessionCore, handleError, onSessionPaused],\n  );\n\n  // Resume session\n  const resumeSession = useCallback(async (): Promise<void> => {\n    await handleResumeSession(canResume, userId, {\n      resumeSessionCore,\n      handleError,\n      setError,\n      onSessionResumed,\n    });\n  }, [canResume, userId, resumeSessionCore, handleError, onSessionResumed]);\n\n  return {\n    // Actions\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n\n    // State\n    isStarting,\n    isEnding,\n    isPausing,\n    isResuming,\n\n    // Permissions\n    canStart,\n    canEnd,\n    canPause,\n    canResume,\n\n    // Error handling\n    error,\n    clearError,\n\n    // Current session info\n    isActive,\n    isPaused,\n    sessionId: session?.id || null,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionGoals.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (171). Maximum allowed is 75.",
        "line": 37,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 242,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from 'react';\nimport { doc, setDoc, onSnapshot, collection, addDoc, query, orderBy, getDocs } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} Goal\n * @property {string} id\n * @property {string} title\n * @property {string} description\n * @property {number} targetDuration - in seconds\n * @property {boolean} isCompleted\n * @property {Date} createdAt\n * @property {Date} [completedAt]\n * @property {string} [reward]\n */\n\n/**\n * @typedef {Object} GoalsState\n * @property {Goal[]} goals\n * @property {Goal|null} activeGoal\n * @property {number} progress - percentage\n */\n\n/**\n * @typedef {Object} SessionGoalsOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} currentSessionDuration\n * @property {Function} [onGoalCompleted]\n */\n\n/**\n * Hook for managing session goals\n * @param {SessionGoalsOptions} options\n * @returns {Object}\n */\nexport const useSessionGoals = ({ \n  userId, \n  isAuthReady, \n  currentSessionDuration,\n  onGoalCompleted \n}) => {\n  const [goalsState, setGoalsState] = useState({\n    goals: [],\n    activeGoal: null,\n    progress: 0\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const saveGoalsToFirestore = useCallback(async (goals) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    try {\n      const userDocRef = doc(db, 'users', userId);\n      await setDoc(userDocRef, { goals }, { merge: true });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save goals');\n    }\n  }, [userId, isAuthReady]);\n\n  const addGoal = useCallback(async (goalData) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const newGoal = {\n        ...goalData,\n        id: crypto.randomUUID(),\n        isCompleted: false,\n        createdAt: new Date()\n      };\n\n      const goalsCollection = collection(db, 'users', userId, 'goals');\n      await addDoc(goalsCollection, newGoal);\n\n      setGoalsState(prev => ({\n        ...prev,\n        goals: [...prev.goals, newGoal]\n      }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to add goal');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const completeGoal = useCallback(async (goalId) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const updatedGoals = goalsState.goals.map(goal => \n        goal.id === goalId \n          ? { ...goal, isCompleted: true, completedAt: new Date() }\n          : goal\n      );\n\n      const completedGoal = updatedGoals.find(goal => goal.id === goalId);\n      \n      setGoalsState(prev => ({\n        ...prev,\n        goals: updatedGoals,\n        activeGoal: prev.activeGoal?.id === goalId ? null : prev.activeGoal\n      }));\n\n      await saveGoalsToFirestore(updatedGoals);\n      \n      if (completedGoal && onGoalCompleted) {\n        onGoalCompleted(completedGoal);\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to complete goal');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, goalsState.goals, saveGoalsToFirestore, onGoalCompleted]);\n\n  const setActiveGoal = useCallback(async (goalId) => {\n    const activeGoal = goalId ? goalsState.goals.find(goal => goal.id === goalId) || null : null;\n    \n    setGoalsState(prev => ({\n      ...prev,\n      activeGoal\n    }));\n\n    if (userId && isAuthReady) {\n      try {\n        const userDocRef = doc(db, 'users', userId);\n        await setDoc(userDocRef, { activeGoalId: goalId }, { merge: true });\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to set active goal');\n      }\n    }\n  }, [goalsState.goals, userId, isAuthReady]);\n\n  const fetchGoals = useCallback(async () => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const goalsCollection = collection(db, 'users', userId, 'goals');\n      const q = query(goalsCollection, orderBy('createdAt', 'desc'));\n      const querySnapshot = await getDocs(q);\n      \n      const goals = querySnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id,\n        createdAt: doc.data().createdAt?.toDate() || new Date(),\n        completedAt: doc.data().completedAt?.toDate()\n      }));\n\n      setGoalsState(prev => ({ ...prev, goals }));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch goals');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  // Load goals and active goal on mount\n  useEffect(() => {\n    fetchGoals();\n  }, [fetchGoals]);\n\n  // Listen for active goal updates\n  useEffect(() => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    const userDocRef = doc(db, 'users', userId);\n    const unsubscribe = onSnapshot(userDocRef,\n      (docSnap) => {\n        if (docSnap.exists()) {\n          const data = docSnap.data();\n          if (data.activeGoalId) {\n            const activeGoal = goalsState.goals.find(goal => goal.id === data.activeGoalId);\n            setGoalsState(prev => ({ ...prev, activeGoal: activeGoal || null }));\n          }\n        }\n      },\n      (err) => {\n        setError(err.message);\n      }\n    );\n\n    return () => unsubscribe();\n  }, [userId, isAuthReady, goalsState.goals]);\n\n  // Calculate progress for active goal\n  useEffect(() => {\n    if (goalsState.activeGoal && currentSessionDuration > 0) {\n      const progress = Math.min(\n        (currentSessionDuration / goalsState.activeGoal.targetDuration) * 100,\n        100\n      );\n      \n      setGoalsState(prev => ({ ...prev, progress }));\n\n      // Auto-complete goal if target reached\n      if (progress >= 100 && !goalsState.activeGoal.isCompleted) {\n        completeGoal(goalsState.activeGoal.id);\n      }\n    } else {\n      setGoalsState(prev => ({ ...prev, progress: 0 }));\n    }\n  }, [goalsState.activeGoal, currentSessionDuration, completeGoal]);\n\n  const getNextGoal = useCallback(() => {\n    return goalsState.goals\n      .filter(goal => !goal.isCompleted)\n      .sort((a, b) => a.targetDuration - b.targetDuration)[0] || null;\n  }, [goalsState.goals]);\n\n  return {\n    goalsState,\n    isLoading,\n    error,\n    addGoal,\n    completeGoal,\n    setActiveGoal,\n    getNextGoal,\n    refreshGoals: fetchGoals\n  };\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionGoals.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'GoalDifficulty' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 38,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 17
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (459). Maximum allowed is 75.",
        "line": 43,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 631,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (36). Maximum allowed is 25.",
        "line": 43,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 631,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'loadAchievements', 'loadActiveGoals', 'loadGoalHistory', 'loadGoalTemplates', 'loadKeyholderGoals', and 'loadProgress'. Either include them or remove the dependency array.",
        "line": 120,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 120,
        "endColumn": 30,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]",
            "fix": {
              "range": [3662, 3686],
              "text": "[userId, relationshipId, loadActiveGoals, loadGoalTemplates, loadProgress, loadKeyholderGoals, loadGoalHistory, loadAchievements]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'updateActiveGoalProgress'. Either include it or remove the dependency array.",
        "line": 132,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 132,
        "endColumn": 19,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [activeGoals, updateActiveGoalProgress]",
            "fix": { "range": [4085, 4098], "text": "[activeGoals, updateActiveGoalProgress]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Goals Management Hook\n * Provides comprehensive goal management with keyholder controls,\n * progress tracking, and achievement integration\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  calculateCompletionRate,\n  calculateOverallDifficulty,\n  predictCompletionTime,\n  calculateGoalProgress,\n  checkIfGoalCompleted,\n} from \"./session-goals-utils\";\nimport { DEFAULT_GOAL_TEMPLATES } from \"./session-goals-templates\";\n\nconst logger = serviceLogger(\"useSessionGoals\");\n\n// ==================== INTERFACES ====================\n\nimport type * as _Types from \"./types/SessionGoals\";\nexport type * from \"./types/SessionGoals\";\nimport type {\n  SessionGoal,\n  GoalTemplate,\n  GoalProgress,\n  KeyholderAssignedGoal,\n  GoalHistoryEntry,\n  GoalAchievement,\n  CreateGoalRequest,\n  GoalCompletionStatus,\n  ModificationRequest,\n  GoalSuggestion,\n  GoalCustomization,\n  PredictiveGoalSuggestion,\n  GoalAnalytics,\n  GoalDifficulty,\n} from \"./types/SessionGoals\";\n\n// Complex goal management with templates, progress tracking, and achievements\n// eslint-disable-next-line max-statements\nexport const useSessionGoals = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [activeGoals, setActiveGoals] = useState<SessionGoal[]>([]);\n  const [goalTemplates, setGoalTemplates] = useState<GoalTemplate[]>([]);\n  const [progress, setProgress] = useState<GoalProgress[]>([]);\n  const [keyholderGoals, setKeyholderGoals] = useState<KeyholderAssignedGoal[]>(\n    [],\n  );\n  const [goalHistory, setGoalHistory] = useState<GoalHistoryEntry[]>([]);\n  const [achievements, setAchievements] = useState<GoalAchievement[]>([]);\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalActiveGoals = useMemo(() => activeGoals.length, [activeGoals]);\n\n  const completionRate = useMemo(\n    () => calculateCompletionRate(progress),\n    [progress],\n  );\n\n  const hasRequiredGoals = useMemo(\n    () => activeGoals.some((goal) => goal.isRequired),\n    [activeGoals],\n  );\n\n  const goalDifficulty = useMemo(\n    () => calculateOverallDifficulty(activeGoals),\n    [activeGoals],\n  );\n\n  const estimatedCompletionTime = useMemo(\n    () => predictCompletionTime(activeGoals, progress),\n    [activeGoals, progress],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeGoals = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // This would load keyholder goals and permissions\n        }\n\n        // Load all goal-related data\n        await Promise.all([\n          loadActiveGoals(),\n          loadGoalTemplates(),\n          loadProgress(),\n          loadKeyholderGoals(),\n          loadGoalHistory(),\n          loadAchievements(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize goals\", { error: err });\n        setError(\n          err instanceof Error ? err.message : \"Failed to initialize goals\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeGoals();\n    // Callback functions are stable (wrapped in useCallback below)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [userId, relationshipId]);\n\n  // ==================== PROGRESS TRACKING ====================\n\n  useEffect(() => {\n    const updateProgressInterval = setInterval(() => {\n      updateActiveGoalProgress();\n    }, 30000); // Update every 30 seconds\n\n    return () => clearInterval(updateProgressInterval);\n    // updateActiveGoalProgress is stable (useCallback)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeGoals]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadActiveGoals = useCallback(async () => {\n    try {\n      // This would integrate with your goal database service\n      setActiveGoals([]);\n    } catch (error) {\n      logger.error(\"Failed to load active goals\", { error });\n    }\n  }, []); // userId is passed but not used in mock\n\n  const loadGoalTemplates = useCallback(async () => {\n    try {\n      // Load pre-defined goal templates\n      setGoalTemplates(DEFAULT_GOAL_TEMPLATES);\n    } catch (error) {\n      logger.error(\"Failed to load goal templates\", { error });\n    }\n  }, []);\n\n  const loadProgress = useCallback(async () => {\n    try {\n      // Calculate progress for all active goals\n      const progressData = activeGoals.map((goal) =>\n        calculateGoalProgress(goal),\n      );\n      setProgress(progressData);\n    } catch (error) {\n      logger.error(\"Failed to load goal progress\", { error });\n    }\n  }, [activeGoals]);\n\n  const loadKeyholderGoals = useCallback(async () => {\n    try {\n      if (!relationshipId) {\n        setKeyholderGoals([]);\n        return;\n      }\n      // Load goals assigned by keyholder\n      setKeyholderGoals([]);\n    } catch (error) {\n      logger.error(\"Failed to load keyholder goals\", { error });\n    }\n  }, [relationshipId]);\n\n  const loadGoalHistory = useCallback(async () => {\n    try {\n      // Load historical goal data\n      setGoalHistory([]);\n    } catch (error) {\n      logger.error(\"Failed to load goal history\", { error });\n    }\n  }, []);\n\n  const loadAchievements = useCallback(async () => {\n    try {\n      // Load goal-related achievements\n      setAchievements([]);\n    } catch (error) {\n      logger.error(\"Failed to load achievements\", { error });\n    }\n  }, []);\n\n  // ==================== GOAL MANAGEMENT ====================\n\n  const setGoal = useCallback(\n    async (goalRequest: CreateGoalRequest): Promise<SessionGoal> => {\n      try {\n        logger.debug(\"Creating new goal\", { userId, goalRequest });\n\n        const newGoal: SessionGoal = {\n          id: `goal_${Date.now()}`,\n          type: goalRequest.type,\n          category: goalRequest.category,\n          target: goalRequest.target,\n          current: 0,\n          progress: 0,\n          assignedBy: \"self\",\n          isRequired: goalRequest.isRequired || false,\n          deadline: goalRequest.deadline,\n          priority: goalRequest.priority,\n          status: \"active\",\n          createdAt: new Date(),\n          description: goalRequest.description,\n          tags: goalRequest.tags,\n        };\n\n        setActiveGoals((prev) => [...prev, newGoal]);\n\n        // Add to history\n        const historyEntry: GoalHistoryEntry = {\n          id: `history_${Date.now()}`,\n          goalId: newGoal.id,\n          action: \"created\",\n          timestamp: new Date(),\n          details: { goalRequest },\n          performedBy: \"submissive\",\n        };\n\n        setGoalHistory((prev) => [...prev, historyEntry]);\n\n        logger.info(\"Goal created successfully\", { goalId: newGoal.id });\n        return newGoal;\n      } catch (error) {\n        logger.error(\"Failed to create goal\", { error });\n        throw error;\n      }\n    },\n    [userId],\n  );\n\n  const updateGoal = useCallback(\n    async (goalId: string, updates: Partial<SessionGoal>): Promise<void> => {\n      try {\n        logger.debug(\"Updating goal\", { goalId, updates });\n\n        setActiveGoals((prev) =>\n          prev.map((goal) =>\n            goal.id === goalId\n              ? { ...goal, ...updates, updatedAt: new Date() }\n              : goal,\n          ),\n        );\n\n        // Add to history\n        const historyEntry: GoalHistoryEntry = {\n          id: `history_${Date.now()}`,\n          goalId,\n          action: \"updated\",\n          timestamp: new Date(),\n          details: { updates },\n          performedBy: \"submissive\",\n        };\n\n        setGoalHistory((prev) => [...prev, historyEntry]);\n\n        logger.info(\"Goal updated successfully\", { goalId });\n      } catch (error) {\n        logger.error(\"Failed to update goal\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const removeGoal = useCallback(async (goalId: string): Promise<void> => {\n    try {\n      logger.debug(\"Removing goal\", { goalId });\n\n      setActiveGoals((prev) => prev.filter((goal) => goal.id !== goalId));\n      setProgress((prev) => prev.filter((p) => p.goalId !== goalId));\n\n      // Add to history\n      const historyEntry: GoalHistoryEntry = {\n        id: `history_${Date.now()}`,\n        goalId,\n        action: \"abandoned\",\n        timestamp: new Date(),\n        details: {},\n        performedBy: \"submissive\",\n      };\n\n      setGoalHistory((prev) => [...prev, historyEntry]);\n\n      logger.info(\"Goal removed successfully\", { goalId });\n    } catch (error) {\n      logger.error(\"Failed to remove goal\", { error });\n      throw error;\n    }\n  }, []);\n\n  // ==================== PROGRESS TRACKING ====================\n\n  const updateProgress = useCallback(\n    async (goalId: string, progressValue: number): Promise<void> => {\n      try {\n        logger.debug(\"Updating goal progress\", { goalId, progressValue });\n\n        setProgress((prev) =>\n          prev.map((p) =>\n            p.goalId === goalId\n              ? {\n                  ...p,\n                  currentValue: progressValue,\n                  progressPercentage: Math.min(\n                    100,\n                    (progressValue / p.targetValue) * 100,\n                  ),\n                  lastUpdated: new Date(),\n                }\n              : p,\n          ),\n        );\n\n        // Update the goal's current value\n        setActiveGoals((prev) =>\n          prev.map((goal) =>\n            goal.id === goalId\n              ? {\n                  ...goal,\n                  current: progressValue,\n                  progress: Math.min(\n                    100,\n                    (progressValue / goal.target.value) * 100,\n                  ),\n                }\n              : goal,\n          ),\n        );\n\n        logger.debug(\"Goal progress updated\", { goalId, progressValue });\n      } catch (error) {\n        logger.error(\"Failed to update goal progress\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const checkGoalCompletion = useCallback(async (): Promise<\n    GoalCompletionStatus[]\n  > => {\n    try {\n      const completionStatuses: GoalCompletionStatus[] = [];\n\n      for (const goal of activeGoals) {\n        const goalProgress = progress.find((p) => p.goalId === goal.id);\n        if (!goalProgress) continue;\n\n        const isCompleted = checkIfGoalCompleted(goal, goalProgress);\n        const completionPercentage = goalProgress.progressPercentage;\n\n        completionStatuses.push({\n          goalId: goal.id,\n          isCompleted,\n          completionPercentage,\n          timeRemaining: goalProgress.estimatedCompletion\n            ? Math.max(\n                0,\n                goalProgress.estimatedCompletion.getTime() - Date.now(),\n              ) / 1000\n            : undefined,\n          canComplete: goal.status === \"active\",\n          blockers: [],\n        });\n\n        // If goal is completed, update its status\n        if (isCompleted && goal.status !== \"completed\") {\n          await updateGoal(goal.id, {\n            status: \"completed\",\n            completedAt: new Date(),\n          });\n\n          // Check for achievements\n          await checkForAchievements(goal);\n        }\n      }\n\n      return completionStatuses;\n    } catch (error) {\n      logger.error(\"Failed to check goal completion\", { error });\n      return [];\n    }\n  }, [activeGoals, progress, updateGoal, checkForAchievements]);\n\n  const updateActiveGoalProgress = useCallback(async () => {\n    try {\n      // This would calculate progress based on current session data\n      // For now, just trigger completion check\n      await checkGoalCompletion();\n    } catch (error) {\n      logger.error(\"Failed to update active goal progress\", { error });\n    }\n  }, [checkGoalCompletion]);\n\n  // ==================== KEYHOLDER INTEGRATION ====================\n\n  const acceptKeyholderGoal = useCallback(\n    async (goalId: string): Promise<void> => {\n      try {\n        logger.debug(\"Accepting keyholder goal\", { goalId });\n\n        const keyholderGoal = keyholderGoals.find((g) => g.id === goalId);\n        if (!keyholderGoal) {\n          throw new Error(\"Keyholder goal not found\");\n        }\n\n        // Move from keyholder goals to active goals\n        setActiveGoals((prev) => [\n          ...prev,\n          { ...keyholderGoal, assignedBy: \"keyholder\" },\n        ]);\n        setKeyholderGoals((prev) => prev.filter((g) => g.id !== goalId));\n\n        logger.info(\"Keyholder goal accepted\", { goalId });\n      } catch (error) {\n        logger.error(\"Failed to accept keyholder goal\", { error });\n        throw error;\n      }\n    },\n    [keyholderGoals],\n  );\n\n  const requestGoalModification = useCallback(\n    async (goalId: string, reason: string): Promise<ModificationRequest> => {\n      if (!relationshipId) {\n        throw new Error(\n          \"Goal modification requests require keyholder relationship\",\n        );\n      }\n\n      try {\n        logger.debug(\"Requesting goal modification\", { goalId, reason });\n\n        const request: ModificationRequest = {\n          id: `mod_req_${Date.now()}`,\n          goalId,\n          requestedChanges: {}, // Would be populated with specific changes\n          reason,\n          status: \"pending\",\n          createdAt: new Date(),\n        };\n\n        // This would send the request to the keyholder\n        logger.info(\"Goal modification request created\", {\n          requestId: request.id,\n        });\n        return request;\n      } catch (error) {\n        logger.error(\"Failed to request goal modification\", { error });\n        throw error;\n      }\n    },\n    [relationshipId],\n  );\n\n  // ==================== TEMPLATES AND SUGGESTIONS ====================\n\n  const getSuggestedGoals = useCallback((): GoalSuggestion[] => {\n    try {\n      // Analyze user history and preferences to suggest goals\n      const suggestions: GoalSuggestion[] = goalTemplates\n        .filter((template) => template.isPopular)\n        .map((template) => ({\n          templateId: template.id,\n          name: template.name,\n          description: template.description,\n          reasonForSuggestion: \"Popular template for your experience level\",\n          confidence: 80,\n          basedOn: \"trending\" as const,\n        }));\n\n      return suggestions;\n    } catch (error) {\n      logger.error(\"Failed to get suggested goals\", { error });\n      return [];\n    }\n  }, [goalTemplates]);\n\n  const createGoalFromTemplate = useCallback(\n    async (\n      templateId: string,\n      customizations?: GoalCustomization,\n    ): Promise<SessionGoal> => {\n      try {\n        const template = goalTemplates.find((t) => t.id === templateId);\n        if (!template) {\n          throw new Error(\"Goal template not found\");\n        }\n\n        const goalRequest: CreateGoalRequest = {\n          type: \"duration\", // Map from template\n          category: template.category,\n          target: customizations?.target\n            ? { ...template.defaultTarget, ...customizations.target }\n            : template.defaultTarget,\n          priority: customizations?.priority || \"medium\",\n          deadline: customizations?.deadline,\n          description: customizations?.description || template.description,\n          tags: customizations?.tags || template.tags,\n        };\n\n        return await setGoal(goalRequest);\n      } catch (error) {\n        logger.error(\"Failed to create goal from template\", { error });\n        throw error;\n      }\n    },\n    [goalTemplates, setGoal],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getGoalAnalytics = useCallback((): GoalAnalytics => {\n    const completedGoals = goalHistory.filter((h) => h.action === \"completed\");\n    const totalGoals = goalHistory.filter((h) => h.action === \"created\");\n\n    return {\n      completionRate:\n        totalGoals.length > 0\n          ? (completedGoals.length / totalGoals.length) * 100\n          : 0,\n      averageCompletionTime: 0, // Calculate from history\n      mostSuccessfulCategories: [],\n      challengingCategories: [],\n      streakData: {\n        current: 0,\n        best: 0,\n        type: \"daily_completion\",\n      },\n      improvementTrends: [],\n    };\n  }, [goalHistory]);\n\n  const getPredictiveGoals = useCallback((): PredictiveGoalSuggestion[] => {\n    // AI-powered goal suggestions based on user data\n    return [];\n  }, []);\n\n  const checkForAchievements = useCallback(\n    async (completedGoal: SessionGoal): Promise<void> => {\n      try {\n        // Check if goal completion unlocks any achievements\n        const newAchievements: GoalAchievement[] = [];\n\n        // Example achievement checks\n        if (\n          completedGoal.type === \"duration\" &&\n          completedGoal.target.value >= 24\n        ) {\n          newAchievements.push({\n            id: `achievement_${Date.now()}`,\n            goalId: completedGoal.id,\n            name: \"Endurance Master\",\n            description: \"Completed a 24+ hour goal\",\n            earnedAt: new Date(),\n            category: \"endurance\",\n            points: 100,\n            rarity: \"uncommon\",\n          });\n        }\n\n        if (newAchievements.length > 0) {\n          setAchievements((prev) => [...prev, ...newAchievements]);\n          logger.info(\"New achievements unlocked\", {\n            count: newAchievements.length,\n          });\n        }\n      } catch (error) {\n        logger.error(\"Failed to check for achievements\", { error });\n      }\n    },\n    [],\n  );\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // Goals state\n    activeGoals,\n    goalTemplates,\n    progress,\n    keyholderGoals,\n    achievements,\n\n    // Goal management\n    setGoal,\n    updateGoal,\n    removeGoal,\n\n    // Progress tracking\n    updateProgress,\n    checkGoalCompletion,\n\n    // Keyholder integration\n    acceptKeyholderGoal,\n    requestGoalModification,\n\n    // Templates and suggestions\n    getSuggestedGoals,\n    createGoalFromTemplate,\n\n    // Analytics\n    getGoalAnalytics,\n    getPredictiveGoals,\n\n    // Computed values\n    totalActiveGoals,\n    completionRate,\n    hasRequiredGoals,\n    goalDifficulty,\n    estimatedCompletionTime,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\n\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistory.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (179). Maximum allowed is 75.",
        "line": 38,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 243,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from 'react';\nimport { collection, query, orderBy, limit, startAfter, getDocs, doc, deleteDoc } from 'firebase/firestore';\nimport { db } from '../../firebase';\n\n/**\n * @typedef {Object} HistorySession\n * @property {string} id\n * @property {Date} startTime\n * @property {Date} endTime\n * @property {number} duration\n * @property {string} [reason]\n * @property {Array} [pauseEvents]\n * @property {number} [totalPauseTime]\n * @property {number} [netDuration] - duration minus pause time\n */\n\n/**\n * @typedef {Object} HistoryFilters\n * @property {Object} [dateRange]\n * @property {Date} dateRange.start\n * @property {Date} dateRange.end\n * @property {number} [minDuration]\n * @property {number} [maxDuration]\n */\n\n/**\n * @typedef {Object} SessionHistoryOptions\n * @property {string|null} userId\n * @property {boolean} isAuthReady\n * @property {number} [pageSize=20]\n */\n\n/**\n * Hook for managing session history\n * @param {SessionHistoryOptions} options\n * @returns {Object}\n */\nexport const useSessionHistory = ({ \n  userId, \n  isAuthReady, \n  pageSize = 20 \n}) => {\n  const [sessions, setSessions] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [filters, setFilters] = useState({});\n\n  const fetchSessions = useCallback(async (\n    append = false, \n    lastDoc\n  ) => {\n    if (!userId || !isAuthReady) {\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const historyCollection = collection(db, 'users', userId, 'sessionHistory');\n      let q = query(\n        historyCollection, \n        orderBy('startTime', 'desc'),\n        limit(pageSize)\n      );\n\n      if (lastDoc) {\n        q = query(\n          historyCollection,\n          orderBy('startTime', 'desc'),\n          startAfter(lastDoc),\n          limit(pageSize)\n        );\n      }\n\n      const querySnapshot = await getDocs(q);\n      const newSessions = querySnapshot.docs.map(doc => {\n        const data = doc.data();\n        return {\n          id: doc.id,\n          ...data,\n          startTime: data.startTime?.toDate() || new Date(),\n          endTime: data.endTime?.toDate() || new Date(),\n          pauseEvents: data.pauseEvents?.map((event) => ({\n            ...event,\n            startTime: event.startTime?.toDate(),\n            endTime: event.endTime?.toDate()\n          })) || []\n        };\n      });\n\n      // Apply filters\n      const filteredSessions = newSessions.filter(session => {\n        if (filters.dateRange) {\n          const sessionDate = session.startTime;\n          if (sessionDate < filters.dateRange.start || sessionDate > filters.dateRange.end) {\n            return false;\n          }\n        }\n        \n        if (filters.minDuration && session.duration < filters.minDuration) {\n          return false;\n        }\n        \n        if (filters.maxDuration && session.duration > filters.maxDuration) {\n          return false;\n        }\n        \n        return true;\n      });\n\n      setSessions(prev => append ? [...prev, ...filteredSessions] : filteredSessions);\n      setHasMore(querySnapshot.docs.length === pageSize);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch session history');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady, pageSize, filters]);\n\n  const loadMore = useCallback(() => {\n    if (sessions.length > 0 && hasMore && !isLoading) {\n      const lastSession = sessions[sessions.length - 1];\n      fetchSessions(true, lastSession);\n    }\n  }, [sessions, hasMore, isLoading, fetchSessions]);\n\n  const deleteSession = useCallback(async (sessionId) => {\n    if (!userId || !isAuthReady) {\n      setError('User not authenticated');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const sessionDocRef = doc(db, 'users', userId, 'sessionHistory', sessionId);\n      await deleteDoc(sessionDocRef);\n      \n      setSessions(prev => prev.filter(session => session.id !== sessionId));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to delete session');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, isAuthReady]);\n\n  const updateFilters = useCallback((newFilters) => {\n    setFilters(newFilters);\n    setSessions([]);\n    setHasMore(true);\n  }, []);\n\n  const getStatistics = useCallback(() => {\n    const totalSessions = sessions.length;\n    const totalDuration = sessions.reduce((acc, session) => acc + session.duration, 0);\n    const averageDuration = totalSessions > 0 ? totalDuration / totalSessions : 0;\n    const longestSession = sessions.reduce((max, session) => \n      Math.max(max, session.duration), 0);\n    const shortestSession = sessions.reduce((min, session) => \n      Math.min(min, session.duration), Infinity);\n\n    // Calculate net duration (excluding pause time)\n    const totalNetDuration = sessions.reduce((acc, session) => {\n      const pauseTime = session.totalPauseTime || 0;\n      return acc + (session.duration - pauseTime);\n    }, 0);\n    const averageNetDuration = totalSessions > 0 ? totalNetDuration / totalSessions : 0;\n\n    return {\n      totalSessions,\n      totalDuration,\n      averageDuration,\n      longestSession: longestSession === 0 ? 0 : longestSession,\n      shortestSession: shortestSession === Infinity ? 0 : shortestSession,\n      totalNetDuration,\n      averageNetDuration\n    };\n  }, [sessions]);\n\n  const exportHistory = useCallback(() => {\n    if (sessions.length === 0) {\n      setError('No sessions to export');\n      return;\n    }\n\n    try {\n      const dataToExport = {\n        exportedAt: new Date().toISOString(),\n        userId,\n        sessions: sessions.map(session => ({\n          ...session,\n          startTime: session.startTime.toISOString(),\n          endTime: session.endTime.toISOString(),\n          pauseEvents: session.pauseEvents?.map(event => ({\n            ...event,\n            startTime: event.startTime?.toISOString(),\n            endTime: event.endTime?.toISOString()\n          }))\n        })),\n        statistics: getStatistics()\n      };\n\n      const dataStr = JSON.stringify(dataToExport, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      const url = URL.createObjectURL(dataBlob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `session-history-${new Date().toISOString().slice(0, 10)}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to export history');\n    }\n  }, [sessions, userId, getStatistics]);\n\n  // Initial load\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  return {\n    sessions,\n    isLoading,\n    error,\n    hasMore,\n    filters,\n    loadMore,\n    deleteSession,\n    updateFilters,\n    getStatistics,\n    exportHistory,\n    refresh: useCallback(() => {\n      setSessions([]);\n      setHasMore(true);\n      fetchSessions();\n    }, [fetchSessions])\n  };\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistory.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (518). Maximum allowed is 75.",
        "line": 259,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 892,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines",
        "severity": 2,
        "message": "File has too many lines (744). Maximum allowed is 500.",
        "line": 601,
        "column": 1,
        "nodeType": null,
        "messageId": "exceed",
        "endLine": 893,
        "endColumn": 1
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-statements",
        "severity": 1,
        "message": "Arrow function has too many statements (30). Maximum allowed is 25.",
        "line": 259,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 892,
        "endColumn": 2,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'calculateInsights', 'calculateTrends', 'loadPrivacySettings', and 'loadSessions'. Either include them or remove the dependency array.",
        "line": 383,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 390,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]",
            "fix": {
              "range": [9864, 10040],
              "text": "[userId, relationshipId, privacySettings.shareWithKeyholder, privacySettings.shareRatings, privacySettings.shareNotes, privacySettings.sharePauses, loadSessions, loadPrivacySettings, calculateInsights, calculateTrends]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session History Management Hook\n * Provides comprehensive session history with privacy controls,\n * data visualization support, and keyholder access management\n */\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport type { KeyholderRelationship } from \"../../types/core\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport {\n  createEmptyTrendData,\n  calculateOverallCompletionRate,\n  calculateLongestStreak,\n  calculatePauseFrequency,\n  calculateImprovementTrend,\n  calculateConsistencyScore,\n  calculateSessionLengthTrend,\n  calculateGoalCompletionTrend,\n  calculateConsistencyTrend,\n  calculatePauseFrequencyTrend,\n  calculateOverallProgressTrend,\n} from \"../../utils/sessionHistoryHelpers\";\n\nconst logger = serviceLogger(\"useSessionHistory\");\n\n// ==================== INTERFACES ====================\n\nexport interface HistoricalSession {\n  id: string;\n  startTime: Date;\n  endTime: Date;\n  duration: number; // Total duration in seconds\n  effectiveDuration: number; // Duration minus pauses\n  goals: SessionGoal[];\n  goalCompletion: GoalCompletionRecord[];\n  pauseEvents: PauseEvent[];\n  keyholderInteractions: KeyholderInteraction[];\n  tags: string[];\n  notes: string;\n  rating?: SessionRating;\n  isHardcoreMode: boolean;\n  wasKeyholderControlled: boolean;\n  endReason?: string;\n  emergencyEnd?: boolean;\n}\n\nexport interface SessionGoal {\n  id: string;\n  type: string;\n  target: number;\n  unit: string;\n  completed: boolean;\n  progress: number;\n}\n\nexport interface GoalCompletionRecord {\n  goalId: string;\n  goalName: string;\n  targetValue: number;\n  achievedValue: number;\n  completionPercentage: number;\n  completed: boolean;\n  completedAt?: Date;\n}\n\nexport interface PauseEvent {\n  id: string;\n  startTime: Date;\n  endTime?: Date;\n  duration: number;\n  reason: string;\n  initiatedBy: \"submissive\" | \"keyholder\" | \"emergency\";\n}\n\nexport interface KeyholderInteraction {\n  id: string;\n  type: \"message\" | \"control_action\" | \"approval\" | \"modification\";\n  timestamp: Date;\n  description: string;\n  keyholderName: string;\n}\n\nexport interface SessionRating {\n  overall: number; // 1-5 stars\n  difficulty: number; // 1-5\n  satisfaction: number; // 1-5\n  wouldRepeat: boolean;\n  notes?: string;\n}\n\nexport interface HistoryPrivacySettings {\n  shareWithKeyholder: boolean;\n  shareDuration: boolean;\n  shareGoals: boolean;\n  sharePauses: boolean;\n  shareNotes: boolean;\n  shareRatings: boolean;\n  retentionPeriod: number; // Days to keep history\n  allowExport: boolean;\n  anonymizeOldData: boolean;\n}\n\nexport interface KeyholderHistoryAccess {\n  hasAccess: boolean;\n  accessLevel: \"summary\" | \"detailed\" | \"full\";\n  canViewRatings: boolean;\n  canViewNotes: boolean;\n  canViewPauses: boolean;\n  lastAccessedAt?: Date;\n}\n\nexport interface HistoryInsights {\n  totalSessions: number;\n  totalEffectiveTime: number;\n  averageSessionLength: number;\n  longestSession: HistoricalSession;\n  shortestSession: HistoricalSession;\n  mostRecentSession: HistoricalSession;\n  goalCompletionRate: number;\n  pauseFrequency: number;\n  improvementTrend: \"improving\" | \"stable\" | \"declining\";\n  consistencyScore: number; // 0-100\n  keyholderSatisfactionScore?: number;\n}\n\nexport interface HistoryTrends {\n  sessionLength: TrendData;\n  goalCompletion: TrendData;\n  consistency: TrendData;\n  pauseFrequency: TrendData;\n  overallProgress: TrendData;\n}\n\nexport interface TrendData {\n  direction: \"improving\" | \"stable\" | \"declining\";\n  changePercentage: number;\n  confidence: number; // 0-100\n  timeframe: \"week\" | \"month\" | \"quarter\" | \"year\";\n  dataPoints: TrendPoint[];\n}\n\nexport interface TrendPoint {\n  date: Date;\n  value: number;\n  label?: string;\n}\n\nexport interface SessionHistoryState {\n  sessions: HistoricalSession[];\n  privacySettings: HistoryPrivacySettings;\n  keyholderAccess: KeyholderHistoryAccess;\n  insights: HistoryInsights;\n  trends: HistoryTrends;\n}\n\nexport interface HistorySearchQuery {\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  minDuration?: number;\n  maxDuration?: number;\n  goalTypes?: string[];\n  hasKeyholderControl?: boolean;\n  completedGoals?: boolean;\n  tags?: string[];\n  rating?: {\n    min: number;\n    max: number;\n  };\n  textSearch?: string;\n}\n\nexport interface PersonalDataExport {\n  exportId: string;\n  generatedAt: Date;\n  format: \"json\" | \"csv\" | \"pdf\";\n  data: {\n    sessions: HistoricalSession[];\n    goals: SessionGoal[];\n    settings: HistoryPrivacySettings;\n    analytics: HistoryInsights;\n  };\n  fileSize: number;\n  downloadUrl: string;\n  expiresAt: Date;\n}\n\nexport interface KeyholderHistoryView {\n  allowedSessions: Partial<HistoricalSession>[];\n  summaryStats: {\n    totalSessions: number;\n    averageDuration: number;\n    goalCompletionRate: number;\n    lastSessionDate: Date;\n  };\n  accessLevel: \"summary\" | \"detailed\" | \"full\";\n  restrictions: string[];\n}\n\nexport interface PerformanceTrends {\n  sessionDuration: {\n    average: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n    weeklyChange: number;\n  };\n  goalAchievement: {\n    rate: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n    weeklyChange: number;\n  };\n  consistency: {\n    score: number;\n    streak: number;\n    trend: \"improving\" | \"stable\" | \"declining\";\n  };\n}\n\nexport interface GoalProgressHistory {\n  goalId: string;\n  goalName: string;\n  progressOverTime: {\n    date: Date;\n    progress: number;\n  }[];\n  milestones: {\n    date: Date;\n    description: string;\n    achieved: boolean;\n  }[];\n}\n\nexport interface ComparisonMetrics {\n  thisWeek: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  lastWeek: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  thisMonth: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n  lastMonth: {\n    sessions: number;\n    totalTime: number;\n    goalCompletion: number;\n  };\n}\n\n// ==================== HOOK IMPLEMENTATION ====================\n\n// Complex session history management with privacy controls and analytics\n// eslint-disable-next-line max-statements\nexport const useSessionHistory = (userId: string, relationshipId?: string) => {\n  // ==================== STATE ====================\n\n  const [sessions, setSessions] = useState<HistoricalSession[]>([]);\n  const [privacySettings, setPrivacySettings] =\n    useState<HistoryPrivacySettings>({\n      shareWithKeyholder: false,\n      shareDuration: true,\n      shareGoals: true,\n      sharePauses: false,\n      shareNotes: false,\n      shareRatings: false,\n      retentionPeriod: 365, // 1 year\n      allowExport: true,\n      anonymizeOldData: false,\n    });\n  const [keyholderAccess, setKeyholderAccess] =\n    useState<KeyholderHistoryAccess>({\n      hasAccess: false,\n      accessLevel: \"summary\",\n      canViewRatings: false,\n      canViewNotes: false,\n      canViewPauses: false,\n    });\n  const [insights, setInsights] = useState<HistoryInsights>({\n    totalSessions: 0,\n    totalEffectiveTime: 0,\n    averageSessionLength: 0,\n    longestSession: {} as HistoricalSession,\n    shortestSession: {} as HistoricalSession,\n    mostRecentSession: {} as HistoricalSession,\n    goalCompletionRate: 0,\n    pauseFrequency: 0,\n    improvementTrend: \"stable\",\n    consistencyScore: 0,\n  });\n  const [trends, setTrends] = useState<HistoryTrends>({\n    sessionLength: createEmptyTrendData(),\n    goalCompletion: createEmptyTrendData(),\n    consistency: createEmptyTrendData(),\n    pauseFrequency: createEmptyTrendData(),\n    overallProgress: createEmptyTrendData(),\n  });\n  const [_relationship, _setRelationship] =\n    useState<KeyholderRelationship | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // ==================== COMPUTED VALUES ====================\n\n  const totalSessions = useMemo(() => sessions.length, [sessions]);\n\n  const averageSessionLength = useMemo(\n    () =>\n      sessions.length > 0\n        ? sessions.reduce(\n            (sum, session) => sum + session.effectiveDuration,\n            0,\n          ) / sessions.length\n        : 0,\n    [sessions],\n  );\n\n  const goalCompletionRate = useMemo(\n    () => calculateOverallCompletionRate(sessions),\n    [sessions],\n  );\n\n  const longestStreak = useMemo(\n    () => calculateLongestStreak(sessions),\n    [sessions],\n  );\n\n  const hasPrivacyRestrictions = useMemo(\n    () => !privacySettings.shareWithKeyholder,\n    [privacySettings.shareWithKeyholder],\n  );\n\n  // ==================== INITIALIZATION ====================\n\n  useEffect(() => {\n    const initializeHistory = async () => {\n      if (!userId) return;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        // Load relationship data if available\n        if (relationshipId) {\n          // Set keyholder access based on relationship permissions\n          setKeyholderAccess({\n            hasAccess: privacySettings.shareWithKeyholder,\n            accessLevel: privacySettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: privacySettings.shareRatings,\n            canViewNotes: privacySettings.shareNotes,\n            canViewPauses: privacySettings.sharePauses,\n          });\n        }\n\n        // Load historical data\n        await Promise.all([\n          loadSessions(),\n          loadPrivacySettings(),\n          calculateInsights(),\n          calculateTrends(),\n        ]);\n      } catch (err) {\n        logger.error(\"Failed to initialize session history\", { error: err });\n        setError(\n          err instanceof Error\n            ? err.message\n            : \"Failed to initialize session history\",\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeHistory();\n    // Store actions and stable callbacks should not be in dependency arrays\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    userId,\n    relationshipId,\n    privacySettings.shareWithKeyholder,\n    privacySettings.shareRatings,\n    privacySettings.shareNotes,\n    privacySettings.sharePauses,\n  ]);\n\n  // ==================== DATA LOADING FUNCTIONS ====================\n\n  const loadSessions = useCallback(async () => {\n    try {\n      // This would integrate with your session database service\n      // Load sessions with privacy filtering applied\n      const allSessions: HistoricalSession[] = [];\n\n      // Apply retention policy\n      const retentionDate = new Date();\n      retentionDate.setDate(\n        retentionDate.getDate() - privacySettings.retentionPeriod,\n      );\n\n      const filteredSessions = allSessions.filter(\n        (session) => session.startTime >= retentionDate,\n      );\n\n      setSessions(filteredSessions);\n    } catch (error) {\n      logger.error(\"Failed to load sessions\", { error });\n    }\n  }, [privacySettings.retentionPeriod]);\n\n  const loadPrivacySettings = useCallback(async () => {\n    try {\n      // Load user's privacy preferences from database\n      // For now, use defaults\n    } catch (error) {\n      logger.error(\"Failed to load privacy settings\", { error });\n    }\n  }, []);\n\n  const calculateInsights = useCallback(async () => {\n    try {\n      if (sessions.length === 0) return;\n\n      const totalEffectiveTime = sessions.reduce(\n        (sum, s) => sum + s.effectiveDuration,\n        0,\n      );\n      const sortedByDuration = [...sessions].sort(\n        (a, b) => b.effectiveDuration - a.effectiveDuration,\n      );\n      const sortedByDate = [...sessions].sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n\n      const newInsights: HistoryInsights = {\n        totalSessions: sessions.length,\n        totalEffectiveTime,\n        averageSessionLength: totalEffectiveTime / sessions.length,\n        longestSession: sortedByDuration[0],\n        shortestSession: sortedByDuration[sortedByDuration.length - 1],\n        mostRecentSession: sortedByDate[0],\n        goalCompletionRate: calculateOverallCompletionRate(sessions),\n        pauseFrequency: calculatePauseFrequency(sessions),\n        improvementTrend: calculateImprovementTrend(sessions),\n        consistencyScore: calculateConsistencyScore(sessions),\n      };\n\n      setInsights(newInsights);\n    } catch (error) {\n      logger.error(\"Failed to calculate insights\", { error });\n    }\n  }, [sessions]);\n\n  const calculateTrends = useCallback(async () => {\n    try {\n      const newTrends: HistoryTrends = {\n        sessionLength: calculateSessionLengthTrend(sessions),\n        goalCompletion: calculateGoalCompletionTrend(sessions),\n        consistency: calculateConsistencyTrend(sessions),\n        pauseFrequency: calculatePauseFrequencyTrend(sessions),\n        overallProgress: calculateOverallProgressTrend(sessions),\n      };\n\n      setTrends(newTrends);\n    } catch (error) {\n      logger.error(\"Failed to calculate trends\", { error });\n    }\n  }, [sessions]);\n\n  // ==================== DATA RETRIEVAL ====================\n\n  const getSessionsByDateRange = useCallback(\n    (start: Date, end: Date): HistoricalSession[] => {\n      return sessions.filter(\n        (session) => session.startTime >= start && session.startTime <= end,\n      );\n    },\n    [sessions],\n  );\n\n  const getSessionsByGoal = useCallback(\n    (goalType: string): HistoricalSession[] => {\n      return sessions.filter((session) =>\n        session.goals.some((goal) => goal.type === goalType),\n      );\n    },\n    [sessions],\n  );\n\n  const searchSessions = useCallback(\n    (query: HistorySearchQuery): HistoricalSession[] => {\n      let filteredSessions = [...sessions];\n\n      // Date range filter\n      if (query.dateRange) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.startTime >= query.dateRange!.start &&\n            session.startTime <= query.dateRange!.end,\n        );\n      }\n\n      // Duration filters\n      if (query.minDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration >= query.minDuration!,\n        );\n      }\n\n      if (query.maxDuration) {\n        filteredSessions = filteredSessions.filter(\n          (session) => session.effectiveDuration <= query.maxDuration!,\n        );\n      }\n\n      // Goal type filter\n      if (query.goalTypes && query.goalTypes.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          session.goals.some((goal) => query.goalTypes!.includes(goal.type)),\n        );\n      }\n\n      // Keyholder control filter\n      if (query.hasKeyholderControl !== undefined) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.wasKeyholderControlled === query.hasKeyholderControl,\n        );\n      }\n\n      // Completed goals filter\n      if (query.completedGoals !== undefined) {\n        filteredSessions = filteredSessions.filter((session) => {\n          const hasCompletedGoals = session.goals.some(\n            (goal) => goal.completed,\n          );\n          return hasCompletedGoals === query.completedGoals;\n        });\n      }\n\n      // Tags filter\n      if (query.tags && query.tags.length > 0) {\n        filteredSessions = filteredSessions.filter((session) =>\n          query.tags!.some((tag) => session.tags.includes(tag)),\n        );\n      }\n\n      // Rating filter\n      if (query.rating && query.rating.min && query.rating.max) {\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.rating &&\n            session.rating.overall >= query.rating!.min &&\n            session.rating.overall <= query.rating!.max,\n        );\n      }\n\n      // Text search\n      if (query.textSearch) {\n        const searchTerm = query.textSearch.toLowerCase();\n        filteredSessions = filteredSessions.filter(\n          (session) =>\n            session.notes.toLowerCase().includes(searchTerm) ||\n            session.tags.some((tag) =>\n              tag.toLowerCase().includes(searchTerm),\n            ) ||\n            session.endReason?.toLowerCase().includes(searchTerm),\n        );\n      }\n\n      return filteredSessions;\n    },\n    [sessions],\n  );\n\n  // ==================== PRIVACY MANAGEMENT ====================\n\n  const updatePrivacySettings = useCallback(\n    async (settings: Partial<HistoryPrivacySettings>): Promise<void> => {\n      try {\n        logger.debug(\"Updating privacy settings\", { settings });\n\n        const updatedSettings = { ...privacySettings, ...settings };\n        setPrivacySettings(updatedSettings);\n\n        // Update keyholder access based on new settings\n        if (relationshipId) {\n          setKeyholderAccess((prev) => ({\n            ...prev,\n            hasAccess: updatedSettings.shareWithKeyholder,\n            accessLevel: updatedSettings.shareWithKeyholder\n              ? \"detailed\"\n              : \"summary\",\n            canViewRatings: updatedSettings.shareRatings,\n            canViewNotes: updatedSettings.shareNotes,\n            canViewPauses: updatedSettings.sharePauses,\n          }));\n        }\n\n        // Reload sessions if retention period changed\n        if (\n          settings.retentionPeriod &&\n          settings.retentionPeriod !== privacySettings.retentionPeriod\n        ) {\n          await loadSessions();\n        }\n\n        logger.info(\"Privacy settings updated successfully\");\n      } catch (error) {\n        logger.error(\"Failed to update privacy settings\", { error });\n        throw error;\n      }\n    },\n    [privacySettings, relationshipId, loadSessions],\n  );\n\n  const exportPersonalData =\n    useCallback(async (): Promise<PersonalDataExport> => {\n      try {\n        logger.debug(\"Exporting personal data\", { userId });\n\n        const exportData: PersonalDataExport = {\n          exportId: `export_${Date.now()}`,\n          generatedAt: new Date(),\n          format: \"json\",\n          data: {\n            sessions,\n            goals: sessions.flatMap((s) => s.goals),\n            settings: privacySettings,\n            analytics: insights,\n          },\n          fileSize: 0, // Would be calculated\n          downloadUrl: \"\", // Would be generated\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days\n        };\n\n        logger.info(\"Personal data export created\", {\n          exportId: exportData.exportId,\n        });\n        return exportData;\n      } catch (error) {\n        logger.error(\"Failed to export personal data\", { error });\n        throw error;\n      }\n    }, [sessions, privacySettings, insights, userId]);\n\n  const deleteHistoricalData = useCallback(\n    async (before: Date): Promise<void> => {\n      try {\n        logger.debug(\"Deleting historical data\", { before, userId });\n\n        const sessionsToKeep = sessions.filter(\n          (session) => session.startTime >= before,\n        );\n        const deletedCount = sessions.length - sessionsToKeep.length;\n\n        setSessions(sessionsToKeep);\n\n        // Recalculate insights and trends\n        await Promise.all([calculateInsights(), calculateTrends()]);\n\n        logger.info(\"Historical data deleted\", { deletedCount });\n      } catch (error) {\n        logger.error(\"Failed to delete historical data\", { error });\n        throw error;\n      }\n    },\n    [sessions, calculateInsights, calculateTrends, userId],\n  );\n\n  // ==================== KEYHOLDER ACCESS ====================\n\n  const getKeyholderView = useCallback((): KeyholderHistoryView => {\n    if (!keyholderAccess.hasAccess) {\n      return {\n        allowedSessions: [],\n        summaryStats: {\n          totalSessions: 0,\n          averageDuration: 0,\n          goalCompletionRate: 0,\n          lastSessionDate: new Date(),\n        },\n        accessLevel: \"summary\",\n        restrictions: [\"No access granted by submissive\"],\n      };\n    }\n\n    const allowedSessions = sessions.map((session) => {\n      const filteredSession: Partial<HistoricalSession> = {\n        id: session.id,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        duration: privacySettings.shareDuration ? session.duration : undefined,\n        effectiveDuration: privacySettings.shareDuration\n          ? session.effectiveDuration\n          : undefined,\n        goals: privacySettings.shareGoals ? session.goals : [],\n        pauseEvents: privacySettings.sharePauses ? session.pauseEvents : [],\n        notes: privacySettings.shareNotes ? session.notes : \"\",\n        rating: privacySettings.shareRatings ? session.rating : undefined,\n        keyholderInteractions: session.keyholderInteractions,\n      };\n\n      return filteredSession;\n    });\n\n    return {\n      allowedSessions,\n      summaryStats: {\n        totalSessions: sessions.length,\n        averageDuration: averageSessionLength,\n        goalCompletionRate,\n        lastSessionDate:\n          sessions.length > 0 ? sessions[0].startTime : new Date(),\n      },\n      accessLevel: keyholderAccess.accessLevel,\n      restrictions: [],\n    };\n  }, [\n    keyholderAccess,\n    sessions,\n    privacySettings,\n    averageSessionLength,\n    goalCompletionRate,\n  ]);\n\n  const shareHistoryWithKeyholder = useCallback(\n    async (sessionIds: string[]): Promise<void> => {\n      try {\n        logger.debug(\"Sharing specific sessions with keyholder\", {\n          sessionIds,\n        });\n\n        // This would create a special sharing link or send specific data\n        // For now, just log the action\n        logger.info(\"History shared with keyholder\", {\n          sessionCount: sessionIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to share history with keyholder\", { error });\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // ==================== ANALYTICS ====================\n\n  const getPerformanceTrends = useCallback((): PerformanceTrends => {\n    return {\n      sessionDuration: {\n        average: averageSessionLength,\n        trend: trends.sessionLength.direction,\n        weeklyChange: trends.sessionLength.changePercentage,\n      },\n      goalAchievement: {\n        rate: goalCompletionRate,\n        trend: trends.goalCompletion.direction,\n        weeklyChange: trends.goalCompletion.changePercentage,\n      },\n      consistency: {\n        score: insights.consistencyScore,\n        streak: longestStreak,\n        trend: trends.consistency.direction,\n      },\n    };\n  }, [\n    averageSessionLength,\n    trends,\n    goalCompletionRate,\n    insights.consistencyScore,\n    longestStreak,\n  ]);\n\n  const getGoalProgressHistory = useCallback((): GoalProgressHistory[] => {\n    const goalProgressMap = new Map<string, GoalProgressHistory>();\n\n    sessions.forEach((session) => {\n      session.goals.forEach((goal) => {\n        if (!goalProgressMap.has(goal.id)) {\n          goalProgressMap.set(goal.id, {\n            goalId: goal.id,\n            goalName: goal.type,\n            progressOverTime: [],\n            milestones: [],\n          });\n        }\n\n        const progressHistory = goalProgressMap.get(goal.id)!;\n        progressHistory.progressOverTime.push({\n          date: session.startTime,\n          progress: goal.progress,\n        });\n      });\n    });\n\n    return Array.from(goalProgressMap.values());\n  }, [sessions]);\n\n  const getComparisonMetrics = useCallback((): ComparisonMetrics => {\n    const now = new Date();\n    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);\n    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n    const twoMonthsAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);\n\n    const thisWeekSessions = getSessionsByDateRange(weekAgo, now);\n    const lastWeekSessions = getSessionsByDateRange(twoWeeksAgo, weekAgo);\n    const thisMonthSessions = getSessionsByDateRange(monthAgo, now);\n    const lastMonthSessions = getSessionsByDateRange(twoMonthsAgo, monthAgo);\n\n    return {\n      thisWeek: {\n        sessions: thisWeekSessions.length,\n        totalTime: thisWeekSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(thisWeekSessions),\n      },\n      lastWeek: {\n        sessions: lastWeekSessions.length,\n        totalTime: lastWeekSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(lastWeekSessions),\n      },\n      thisMonth: {\n        sessions: thisMonthSessions.length,\n        totalTime: thisMonthSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(thisMonthSessions),\n      },\n      lastMonth: {\n        sessions: lastMonthSessions.length,\n        totalTime: lastMonthSessions.reduce(\n          (sum, s) => sum + s.effectiveDuration,\n          0,\n        ),\n        goalCompletion: calculateOverallCompletionRate(lastMonthSessions),\n      },\n    };\n  }, [getSessionsByDateRange]);\n\n  // ==================== RETURN HOOK INTERFACE ====================\n\n  return {\n    // History data\n    sessions,\n    insights,\n    trends,\n    privacySettings,\n\n    // Data retrieval\n    getSessionsByDateRange,\n    getSessionsByGoal,\n    searchSessions,\n\n    // Privacy management\n    updatePrivacySettings,\n    exportPersonalData,\n    deleteHistoricalData,\n\n    // Keyholder access\n    getKeyholderView,\n    shareHistoryWithKeyholder,\n\n    // Analytics\n    getPerformanceTrends,\n    getGoalProgressHistory,\n    getComparisonMetrics,\n\n    // Computed values\n    totalSessions,\n    averageSessionLength,\n    goalCompletionRate,\n    longestStreak,\n    hasPrivacyRestrictions,\n\n    // Loading states\n    isLoading,\n    error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionHistoryQueries.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/session/useSessionLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useHealthCheck.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (271). Maximum allowed is 75.",
        "line": 79,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 425,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useHealthCheck Hook - System Health Monitoring\n *\n * Monitor overall system health, service availability, and provide early warning\n * for potential issues.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { HealthCheckStorageService } from \"../../services/healthCheckStorage\";\n\n// Health status enum\nexport enum HealthStatus {\n  HEALTHY = \"healthy\",\n  WARNING = \"warning\",\n  CRITICAL = \"critical\",\n  UNKNOWN = \"unknown\",\n}\n\n// Service status\nexport interface ServiceStatus {\n  name: string;\n  status: HealthStatus;\n  responseTime: number;\n  lastChecked: Date;\n  error?: string;\n  uptime: number;\n}\n\n// System metrics\nexport interface SystemMetrics {\n  memoryUsage: number;\n  cpuUsage: number;\n  storageUsage: number;\n  networkLatency: number;\n  errorRate: number;\n  activeConnections: number;\n}\n\n// Health check result\nexport interface HealthCheckResult {\n  overall: HealthStatus;\n  services: ServiceStatus[];\n  metrics: SystemMetrics;\n  alerts: HealthAlert[];\n  lastUpdated: Date;\n  checkDuration: number;\n}\n\n// Health alert\nexport interface HealthAlert {\n  id: string;\n  type: \"warning\" | \"error\" | \"info\";\n  message: string;\n  service?: string;\n  timestamp: Date;\n  acknowledged: boolean;\n}\n\n// Health check configuration\ninterface HealthCheckConfig {\n  checkInterval: number;\n  timeout: number;\n  retryAttempts: number;\n  services: string[];\n}\n\nconst DEFAULT_CONFIG: HealthCheckConfig = {\n  checkInterval: 30000, // 30 seconds\n  timeout: 5000, // 5 seconds\n  retryAttempts: 3,\n  services: [\"firebase\", \"storage\", \"network\"],\n};\n\n/**\n * System Health Check Hook\n */\nexport const useHealthCheck = (config: Partial<HealthCheckConfig> = {}) => {\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\n  const [alerts, setAlerts] = useState<HealthAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Check service health\n  const checkServiceHealth = useCallback(\n    async (serviceName: string): Promise<ServiceStatus> => {\n      const startTime = Date.now();\n      let status: HealthStatus = HealthStatus.UNKNOWN;\n      let error: string | undefined;\n      let responseTime = 0;\n\n      try {\n        switch (serviceName) {\n          case \"firebase\":\n            // Check Firebase connectivity\n            status = await checkFirebaseHealth();\n            break;\n          case \"storage\":\n            status = await checkStorageHealth();\n            break;\n          case \"network\":\n            status = await checkNetworkHealth();\n            break;\n          default:\n            status = HealthStatus.UNKNOWN;\n        }\n\n        responseTime = Date.now() - startTime;\n      } catch (err) {\n        status = HealthStatus.CRITICAL;\n        error = err instanceof Error ? err.message : \"Unknown error\";\n        responseTime = Date.now() - startTime;\n        logger.error(`Health check failed for ${serviceName}`, { error: err });\n      }\n\n      return {\n        name: serviceName,\n        status,\n        responseTime,\n        lastChecked: new Date(),\n        error,\n        uptime: calculateUptime(serviceName),\n      };\n    },\n    [],\n  );\n\n  // Check Firebase health\n  const checkFirebaseHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Simple connectivity test - try to access Firebase\n      if (\n        typeof window !== \"undefined\" &&\n        (window as Window & { firebase?: unknown }).firebase\n      ) {\n        return HealthStatus.HEALTHY;\n      }\n      return HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check storage health\n  const checkStorageHealth = async (): Promise<HealthStatus> => {\n    try {\n      // Test localStorage availability using the service\n      const isHealthy = HealthCheckStorageService.testLocalStorage();\n      return isHealthy ? HealthStatus.HEALTHY : HealthStatus.WARNING;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Check network health\n  const checkNetworkHealth = async (): Promise<HealthStatus> => {\n    if (!navigator.onLine) {\n      return HealthStatus.CRITICAL;\n    }\n\n    try {\n      const startTime = Date.now();\n      const response = await fetch(\"/favicon.ico\", {\n        method: \"HEAD\",\n        cache: \"no-cache\",\n      });\n      const responseTime = Date.now() - startTime;\n\n      if (response.ok && responseTime < 2000) {\n        return HealthStatus.HEALTHY;\n      } else if (response.ok && responseTime < 5000) {\n        return HealthStatus.WARNING;\n      }\n      return HealthStatus.CRITICAL;\n    } catch {\n      return HealthStatus.CRITICAL;\n    }\n  };\n\n  // Calculate service uptime (simplified)\n  const calculateUptime = (_serviceName: string): number => {\n    // In a real implementation, this would track actual uptime\n    // For now, return a mock value\n    return Math.random() * 100;\n  };\n\n  // Get system metrics\n  const getSystemMetrics = useCallback(async (): Promise<SystemMetrics> => {\n    const metrics: SystemMetrics = {\n      memoryUsage: 0,\n      cpuUsage: 0,\n      storageUsage: 0,\n      networkLatency: 0,\n      errorRate: 0,\n      activeConnections: 1,\n    };\n\n    try {\n      // Memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: { usedJSHeapSize: number; totalJSHeapSize: number };\n          }\n        ).memory;\n        if (memory) {\n          metrics.memoryUsage =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Storage usage\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        if (estimate.usage && estimate.quota) {\n          metrics.storageUsage = (estimate.usage / estimate.quota) * 100;\n        }\n      }\n\n      // Network latency (simplified)\n      const startTime = Date.now();\n      await fetch(\"/favicon.ico\", { method: \"HEAD\", cache: \"no-cache\" });\n      metrics.networkLatency = Date.now() - startTime;\n    } catch (error) {\n      logger.warn(\"Failed to get some system metrics\", error);\n    }\n\n    return metrics;\n  }, []);\n\n  // Determine overall health status\n  const calculateOverallHealth = useCallback(\n    (services: ServiceStatus[]): HealthStatus => {\n      const statuses = services.map((s) => s.status);\n\n      if (statuses.includes(HealthStatus.CRITICAL)) {\n        return HealthStatus.CRITICAL;\n      }\n\n      if (statuses.includes(HealthStatus.WARNING)) {\n        return HealthStatus.WARNING;\n      }\n\n      if (statuses.every((s) => s === HealthStatus.HEALTHY)) {\n        return HealthStatus.HEALTHY;\n      }\n\n      return HealthStatus.UNKNOWN;\n    },\n    [],\n  );\n\n  // Generate alerts based on health status\n  const generateAlerts = useCallback(\n    (services: ServiceStatus[], metrics: SystemMetrics): HealthAlert[] => {\n      const newAlerts: HealthAlert[] = [];\n\n      // Service alerts\n      services.forEach((service) => {\n        if (service.status === HealthStatus.CRITICAL) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"error\",\n            message: `Service ${service.name} is critical: ${service.error || \"Unknown error\"}`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        } else if (service.status === HealthStatus.WARNING) {\n          newAlerts.push({\n            id: `service-${service.name}-${Date.now()}`,\n            type: \"warning\",\n            message: `Service ${service.name} is experiencing issues`,\n            service: service.name,\n            timestamp: new Date(),\n            acknowledged: false,\n          });\n        }\n      });\n\n      // Metrics alerts\n      if (metrics.memoryUsage > 90) {\n        newAlerts.push({\n          id: `memory-${Date.now()}`,\n          type: \"warning\",\n          message: `High memory usage: ${metrics.memoryUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.storageUsage > 90) {\n        newAlerts.push({\n          id: `storage-${Date.now()}`,\n          type: \"warning\",\n          message: `High storage usage: ${metrics.storageUsage.toFixed(1)}%`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      if (metrics.networkLatency > 5000) {\n        newAlerts.push({\n          id: `network-${Date.now()}`,\n          type: \"warning\",\n          message: `High network latency: ${metrics.networkLatency}ms`,\n          timestamp: new Date(),\n          acknowledged: false,\n        });\n      }\n\n      return newAlerts;\n    },\n    [],\n  );\n\n  // Main health check query\n  const {\n    data: healthStatus,\n    isLoading,\n    error,\n    refetch,\n  } = useQuery<HealthCheckResult>({\n    queryKey: [\"system\", \"health\"],\n    queryFn: async () => {\n      const startTime = Date.now();\n\n      // Check all services\n      const serviceChecks = await Promise.all(\n        fullConfig.services.map((service) => checkServiceHealth(service)),\n      );\n\n      // Get system metrics\n      const metrics = await getSystemMetrics();\n\n      // Calculate overall health\n      const overall = calculateOverallHealth(serviceChecks);\n\n      // Generate alerts\n      const newAlerts = generateAlerts(serviceChecks, metrics);\n\n      const result: HealthCheckResult = {\n        overall,\n        services: serviceChecks,\n        metrics,\n        alerts: newAlerts,\n        lastUpdated: new Date(),\n        checkDuration: Date.now() - startTime,\n      };\n\n      // Update alerts state\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n\n      return result;\n    },\n    refetchInterval: isMonitoring ? fullConfig.checkInterval : false,\n    retry: fullConfig.retryAttempts,\n    staleTime: fullConfig.checkInterval / 2,\n  });\n\n  // Acknowledge alert\n  const acknowledgeAlert = useCallback((alertId: string) => {\n    setAlerts((prev) =>\n      prev.map((alert) =>\n        alert.id === alertId ? { ...alert, acknowledged: true } : alert,\n      ),\n    );\n    logger.info(\"Health alert acknowledged\", { alertId });\n  }, []);\n\n  // Clear acknowledged alerts\n  const clearAcknowledgedAlerts = useCallback(() => {\n    setAlerts((prev) => prev.filter((alert) => !alert.acknowledged));\n    logger.info(\"Acknowledged alerts cleared\");\n  }, []);\n\n  // Start/stop monitoring\n  const toggleMonitoring = useCallback((enabled: boolean) => {\n    setIsMonitoring(enabled);\n    logger.info(`Health monitoring ${enabled ? \"started\" : \"stopped\"}`);\n  }, []);\n\n  // Force health check\n  const forceCheck = useCallback(() => {\n    refetch();\n    logger.info(\"Manual health check triggered\");\n  }, [refetch]);\n\n  return {\n    // Health status\n    healthStatus,\n    isLoading,\n    error,\n\n    // Alerts\n    alerts: alerts.filter((alert) => !alert.acknowledged),\n    acknowledgedAlerts: alerts.filter((alert) => alert.acknowledged),\n    allAlerts: alerts,\n\n    // Controls\n    acknowledgeAlert,\n    clearAcknowledgedAlerts,\n    toggleMonitoring,\n    forceCheck,\n\n    // State\n    isMonitoring,\n\n    // Computed properties\n    isHealthy: healthStatus?.overall === HealthStatus.HEALTHY,\n    hasWarnings: healthStatus?.overall === HealthStatus.WARNING,\n    isCritical: healthStatus?.overall === HealthStatus.CRITICAL,\n    hasUnacknowledgedAlerts: alerts.some((alert) => !alert.acknowledged),\n    uptime:\n      healthStatus?.services.reduce((acc, service) => acc + service.uptime, 0) /\n      (healthStatus?.services.length || 1),\n    averageResponseTime:\n      healthStatus?.services.reduce(\n        (acc, service) => acc + service.responseTime,\n        0,\n      ) / (healthStatus?.services.length || 1),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useMigration.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (282). Maximum allowed is 75.",
        "line": 87,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 443,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useMigration Hook - Data Migration Management\n *\n * Handle data migrations, schema updates, and legacy data conversion with\n * progress tracking and rollback capabilities.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\nimport { MigrationStorageService } from \"../../services/migrationStorage\";\n\n// Migration status\nexport enum MigrationStatus {\n  PENDING = \"pending\",\n  RUNNING = \"running\",\n  COMPLETED = \"completed\",\n  FAILED = \"failed\",\n  ROLLED_BACK = \"rolled_back\",\n}\n\n// Migration definition\nexport interface Migration {\n  id: string;\n  version: string;\n  name: string;\n  description: string;\n  status: MigrationStatus;\n  createdAt: Date;\n  startedAt?: Date;\n  completedAt?: Date;\n  progress: number;\n  error?: string;\n  rollbackAvailable: boolean;\n}\n\n// Migration batch\nexport interface MigrationBatch {\n  id: string;\n  migrations: Migration[];\n  status: MigrationStatus;\n  totalProgress: number;\n  startedAt?: Date;\n  completedAt?: Date;\n}\n\n// Migration result\nexport interface MigrationResult {\n  success: boolean;\n  migrationsRun: number;\n  errors: string[];\n  warnings: string[];\n  duration: number;\n}\n\n// Sample migrations (in a real app, these would be defined elsewhere)\nconst AVAILABLE_MIGRATIONS: Omit<\n  Migration,\n  \"status\" | \"progress\" | \"createdAt\"\n>[] = [\n  {\n    id: \"v4.0.0-theme-system\",\n    version: \"4.0.0\",\n    name: \"Theme System Migration\",\n    description: \"Migrate existing theme preferences to new theme system\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-enhanced-goals\",\n    version: \"4.0.0\",\n    name: \"Enhanced Goals Migration\",\n    description: \"Convert legacy goals to enhanced goal format\",\n    rollbackAvailable: true,\n  },\n  {\n    id: \"v4.0.0-gamification\",\n    version: \"4.0.0\",\n    name: \"Gamification System Migration\",\n    description: \"Initialize gamification data from existing achievements\",\n    rollbackAvailable: false,\n  },\n];\n\n/**\n * Data Migration Hook\n */\nexport const useMigration = () => {\n  const queryClient = useQueryClient();\n  const [isRunning, setIsRunning] = useState(false);\n\n  // Get migration state\n  const { data: migrationState } = useQuery({\n    queryKey: [\"migration\", \"state\"],\n    queryFn: () => {\n      const stored = MigrationStorageService.getMigrationState();\n      if (stored) {\n        return stored;\n      }\n\n      // Initialize migration state\n      const initialMigrations: Migration[] = AVAILABLE_MIGRATIONS.map(\n        (migration) => ({\n          ...migration,\n          status: MigrationStatus.PENDING,\n          progress: 0,\n          createdAt: new Date(),\n        }),\n      );\n\n      return {\n        migrations: initialMigrations,\n        lastRun: null,\n        currentVersion: \"3.0.0\",\n      };\n    },\n    staleTime: Infinity,\n  });\n\n  // Get pending migrations\n  const pendingMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.PENDING,\n    ) || [];\n\n  // Get completed migrations\n  const completedMigrations =\n    migrationState?.migrations?.filter(\n      (m: Migration) => m.status === MigrationStatus.COMPLETED,\n    ) || [];\n\n  // Create backup before migration\n  const createBackup = useCallback(\n    async (migrationId: string) => {\n      try {\n        const backup = {\n          id: `backup-${migrationId}-${Date.now()}`,\n          migrationId,\n          timestamp: new Date(),\n          data: {\n            // Backup all localStorage via service\n            localStorage: MigrationStorageService.getAllLocalStorage(),\n            version: migrationState?.currentVersion,\n          },\n        };\n\n        const existingBackups =\n          MigrationStorageService.getMigrationBackups<typeof backup>();\n\n        const updatedBackups = [...existingBackups, backup];\n        MigrationStorageService.setMigrationBackups(updatedBackups);\n\n        logger.info(\"Migration backup created\", {\n          migrationId,\n          backupId: backup.id,\n        });\n        return backup.id;\n      } catch (error) {\n        logger.error(\"Failed to create migration backup\", {\n          migrationId,\n          error,\n        });\n        throw error;\n      }\n    },\n    [migrationState],\n  );\n\n  // Migration implementations\n  const migrateThemeSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(25);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      // Convert old theme settings\n      const oldTheme = MigrationStorageService.getLegacyItem(\"theme\");\n      if (oldTheme) {\n        MigrationStorageService.setLegacyItem(\n          \"chastity-theme-current\",\n          JSON.stringify(\n            oldTheme === \"dark\" ? \"default-dark\" : \"default-light\",\n          ),\n        );\n      }\n\n      onProgress(75);\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateEnhancedGoals = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(30);\n      await new Promise((resolve) => setTimeout(resolve, 300));\n\n      // Convert legacy goals (simplified)\n      const legacyGoals =\n        MigrationStorageService.getLegacyItem(\"personal-goals\");\n      if (legacyGoals) {\n        // Transform format here\n        onProgress(70);\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      }\n\n      onProgress(100);\n    },\n    [],\n  );\n\n  const migrateGamificationSystem = useCallback(\n    async (onProgress: (progress: number) => void) => {\n      onProgress(20);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n\n      // Initialize gamification data\n      onProgress(60);\n      await new Promise((resolve) => setTimeout(resolve, 400));\n      onProgress(100);\n    },\n    [],\n  );\n\n  // Execute migration logic\n  const executeMigrationLogic = useCallback(\n    async (migrationId: string, onProgress: (progress: number) => void) => {\n      switch (migrationId) {\n        case \"v4.0.0-theme-system\":\n          await migrateThemeSystem(onProgress);\n          break;\n        case \"v4.0.0-enhanced-goals\":\n          await migrateEnhancedGoals(onProgress);\n          break;\n        case \"v4.0.0-gamification\":\n          await migrateGamificationSystem(onProgress);\n          break;\n        default:\n          throw new Error(`Unknown migration: ${migrationId}`);\n      }\n    },\n    [migrateThemeSystem, migrateEnhancedGoals, migrateGamificationSystem],\n  );\n\n  // Execute single migration\n  const executeMigration = useCallback(\n    async (migration: Migration): Promise<void> => {\n      logger.info(\"Starting migration\", { migrationId: migration.id });\n\n      // Update migration status\n      const updatedMigrations = migrationState.migrations.map((m: Migration) =>\n        m.id === migration.id\n          ? {\n              ...m,\n              status: MigrationStatus.RUNNING,\n              startedAt: new Date(),\n              progress: 0,\n            }\n          : m,\n      );\n\n      const newState = { ...migrationState, migrations: updatedMigrations };\n      MigrationStorageService.setMigrationState(newState);\n      queryClient.setQueryData([\"migration\", \"state\"], newState);\n\n      try {\n        // Create backup if rollback is available\n        if (migration.rollbackAvailable) {\n          await createBackup(migration.id);\n        }\n\n        // Execute migration logic based on ID\n        await executeMigrationLogic(migration.id, (progress: number) => {\n          // Update progress\n          const progressUpdatedMigrations = migrationState.migrations.map(\n            (m: Migration) => (m.id === migration.id ? { ...m, progress } : m),\n          );\n\n          const progressState = {\n            ...migrationState,\n            migrations: progressUpdatedMigrations,\n          };\n          MigrationStorageService.setMigrationState(progressState);\n          queryClient.setQueryData([\"migration\", \"state\"], progressState);\n        });\n\n        // Mark as completed\n        const completedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.COMPLETED,\n                  completedAt: new Date(),\n                  progress: 100,\n                }\n              : m,\n        );\n\n        const completedState = {\n          ...migrationState,\n          migrations: completedMigrations,\n        };\n        MigrationStorageService.setMigrationState(completedState);\n        queryClient.setQueryData([\"migration\", \"state\"], completedState);\n\n        logger.info(\"Migration completed\", { migrationId: migration.id });\n      } catch (error) {\n        // Mark as failed\n        const failedMigrations = migrationState.migrations.map(\n          (m: Migration) =>\n            m.id === migration.id\n              ? {\n                  ...m,\n                  status: MigrationStatus.FAILED,\n                  error:\n                    error instanceof Error ? error.message : \"Unknown error\",\n                }\n              : m,\n        );\n\n        const failedState = { ...migrationState, migrations: failedMigrations };\n        MigrationStorageService.setMigrationState(failedState);\n        queryClient.setQueryData([\"migration\", \"state\"], failedState);\n\n        logger.error(\"Migration failed\", { migrationId: migration.id, error });\n        throw error;\n      }\n    },\n    [migrationState, queryClient, createBackup, executeMigrationLogic],\n  );\n\n  // Run migrations mutation\n  const runMigrationsMutation = useMutation({\n    mutationFn: async (migrationIds?: string[]) => {\n      setIsRunning(true);\n      const startTime = Date.now();\n      const result: MigrationResult = {\n        success: true,\n        migrationsRun: 0,\n        errors: [],\n        warnings: [],\n        duration: 0,\n      };\n\n      try {\n        const migrationsToRun = migrationIds\n          ? migrationState.migrations.filter((m: Migration) =>\n              migrationIds.includes(m.id),\n            )\n          : pendingMigrations;\n\n        for (const migration of migrationsToRun) {\n          try {\n            await executeMigration(migration);\n            result.migrationsRun++;\n          } catch (error) {\n            result.success = false;\n            result.errors.push(\n              `${migration.name}: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n            );\n          }\n        }\n\n        result.duration = Date.now() - startTime;\n        return result;\n      } finally {\n        setIsRunning(false);\n      }\n    },\n  });\n\n  // Rollback migration mutation\n  const rollbackMigrationMutation = useMutation({\n    mutationFn: async (migrationId: string) => {\n      const migration = migrationState.migrations.find(\n        (m: Migration) => m.id === migrationId,\n      );\n      if (!migration) throw new Error(\"Migration not found\");\n      if (!migration.rollbackAvailable)\n        throw new Error(\"Rollback not available for this migration\");\n\n      logger.info(\"Rolling back migration\", { migrationId });\n\n      // Find and restore backup\n      const backups = MigrationStorageService.getMigrationBackups<{\n        migrationId: string;\n        data: { localStorage: Record<string, string> };\n      }>();\n      const backup = backups.find((b) => b.migrationId === migrationId);\n\n      if (!backup) throw new Error(\"Backup not found\");\n\n      // Restore data from backup\n      Object.entries(backup.data.localStorage).forEach(([key, value]) => {\n        MigrationStorageService.setLegacyItem(key, value);\n      });\n\n      // Update migration status\n      const rolledBackMigrations = migrationState.migrations.map(\n        (m: Migration) =>\n          m.id === migrationId\n            ? { ...m, status: MigrationStatus.ROLLED_BACK }\n            : m,\n      );\n\n      const rolledBackState = {\n        ...migrationState,\n        migrations: rolledBackMigrations,\n      };\n      MigrationStorageService.setMigrationState(rolledBackState);\n      queryClient.setQueryData([\"migration\", \"state\"], rolledBackState);\n\n      logger.info(\"Migration rolled back\", { migrationId });\n    },\n  });\n\n  return {\n    // Migration state\n    migrations: migrationState?.migrations || [],\n    pendingMigrations,\n    completedMigrations,\n    isRunning,\n\n    // Actions\n    runMigrations: runMigrationsMutation.mutate,\n    rollbackMigration: rollbackMigrationMutation.mutate,\n\n    // Status\n    hasPendingMigrations: pendingMigrations.length > 0,\n    hasFailedMigrations:\n      migrationState?.migrations?.some(\n        (m: Migration) => m.status === MigrationStatus.FAILED,\n      ) || false,\n\n    // Loading states\n    isRunningMigrations: runMigrationsMutation.isPending,\n    isRollingBack: rollbackMigrationMutation.isPending,\n\n    // Results\n    lastResult: runMigrationsMutation.data,\n    error: runMigrationsMutation.error || rollbackMigrationMutation.error,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/useOfflineStatus.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (280). Maximum allowed is 75.",
        "line": 64,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 407,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (78). Maximum allowed is 75.",
        "line": 289,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 377,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has missing dependencies: 'addNetworkEvent', 'getNetworkInfo', and 'getNetworkQuality'. Either include them or remove the dependency array.",
        "line": 377,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 377,
        "endColumn": 75,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]",
            "fix": {
              "range": [10907, 10976],
              "text": "[handleOnline, handleOffline, offlineStatus, queryClient, lastOnline, getNetworkInfo, getNetworkQuality, addNetworkEvent]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useOfflineStatus Hook - Network Status Monitoring\n *\n * Monitor network connectivity and provide offline capabilities with intelligent\n * sync when connection is restored.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Network quality enum\nexport enum NetworkQuality {\n  EXCELLENT = \"excellent\",\n  GOOD = \"good\",\n  FAIR = \"fair\",\n  POOR = \"poor\",\n  OFFLINE = \"offline\",\n}\n\n// Connection type\nexport enum ConnectionType {\n  WIFI = \"wifi\",\n  CELLULAR = \"cellular\",\n  ETHERNET = \"ethernet\",\n  BLUETOOTH = \"bluetooth\",\n  UNKNOWN = \"unknown\",\n}\n\n// Offline status interface\nexport interface OfflineStatus {\n  isOnline: boolean;\n  isOffline: boolean;\n  networkQuality: NetworkQuality;\n  connectionType: ConnectionType;\n  downlink: number;\n  rtt: number;\n  effectiveType: string;\n  lastOnline: Date | null;\n  offlineDuration: number;\n  hasPendingSync: boolean;\n  syncQueueSize: number;\n}\n\n// Offline capabilities\nexport interface OfflineCapabilities {\n  canReadCache: boolean;\n  canWriteCache: boolean;\n  canQueueOperations: boolean;\n  estimatedStorageUsage: number;\n  maxStorageLimit: number;\n}\n\n// Network event\nexport interface NetworkEvent {\n  type: \"online\" | \"offline\" | \"quality-change\";\n  timestamp: Date;\n  details?: Record<string, string | number | boolean>;\n}\n\n/**\n * Network Status Hook\n */\nexport const useOfflineStatus = () => {\n  const queryClient = useQueryClient();\n  const [networkEvents, setNetworkEvents] = useState<NetworkEvent[]>([]);\n  const [syncQueue, setSyncQueue] = useState<Record<string, unknown>[]>([]);\n  const [lastOnline, setLastOnline] = useState<Date | null>(null);\n\n  // Get network information if available\n  const getNetworkInfo = useCallback(() => {\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n\n    return {\n      downlink: connection?.downlink || 0,\n      rtt: connection?.rtt || 0,\n      effectiveType: connection?.effectiveType || \"unknown\",\n      type: connection?.type || ConnectionType.UNKNOWN,\n    };\n  }, []);\n\n  // Determine network quality\n  const getNetworkQuality = useCallback(\n    (downlink: number, rtt: number): NetworkQuality => {\n      if (!navigator.onLine) return NetworkQuality.OFFLINE;\n\n      if (downlink >= 10 && rtt < 100) return NetworkQuality.EXCELLENT;\n      if (downlink >= 5 && rtt < 200) return NetworkQuality.GOOD;\n      if (downlink >= 1.5 && rtt < 500) return NetworkQuality.FAIR;\n      return NetworkQuality.POOR;\n    },\n    [],\n  );\n\n  // Current offline status query\n  const { data: offlineStatus } = useQuery<OfflineStatus>({\n    queryKey: [\"network\", \"status\"],\n    queryFn: () => {\n      const networkInfo = getNetworkInfo();\n      const quality = getNetworkQuality(networkInfo.downlink, networkInfo.rtt);\n      const now = new Date();\n\n      const offlineDuration =\n        lastOnline && !navigator.onLine\n          ? now.getTime() - lastOnline.getTime()\n          : 0;\n\n      return {\n        isOnline: navigator.onLine,\n        isOffline: !navigator.onLine,\n        networkQuality: quality,\n        connectionType: networkInfo.type,\n        downlink: networkInfo.downlink,\n        rtt: networkInfo.rtt,\n        effectiveType: networkInfo.effectiveType,\n        lastOnline,\n        offlineDuration,\n        hasPendingSync: syncQueue.length > 0,\n        syncQueueSize: syncQueue.length,\n      };\n    },\n    refetchInterval: 5000, // Check every 5 seconds\n    staleTime: 1000,\n  });\n\n  // Offline capabilities query\n  const { data: capabilities } = useQuery<OfflineCapabilities>({\n    queryKey: [\"network\", \"capabilities\"],\n    queryFn: async () => {\n      let storageUsage = 0;\n      let storageLimit = 0;\n\n      if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n        try {\n          const estimate = await navigator.storage.estimate();\n          storageUsage = estimate.usage || 0;\n          storageLimit = estimate.quota || 0;\n        } catch (error) {\n          logger.warn(\"Could not estimate storage\", error);\n        }\n      }\n\n      return {\n        canReadCache: \"caches\" in window,\n        canWriteCache: \"caches\" in window && navigator.onLine,\n        canQueueOperations: true,\n        estimatedStorageUsage: storageUsage,\n        maxStorageLimit: storageLimit,\n      };\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Add network event\n  const addNetworkEvent = useCallback(\n    (\n      type: NetworkEvent[\"type\"],\n      details?: Record<string, string | number | boolean>,\n    ) => {\n      const event: NetworkEvent = {\n        type,\n        timestamp: new Date(),\n        details,\n      };\n\n      setNetworkEvents((prev) => [...prev.slice(-49), event]); // Keep last 50 events\n      logger.info(`Network event: ${type}`, details);\n    },\n    [],\n  );\n\n  // Handle online event\n  const handleOnline = useCallback(() => {\n    setLastOnline(new Date());\n    addNetworkEvent(\"online\", {\n      wasOffline: !navigator.onLine,\n      syncQueueSize: syncQueue.length,\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n\n    // Process sync queue when back online\n    if (syncQueue.length > 0) {\n      processSyncQueue();\n    }\n  }, [syncQueue, addNetworkEvent, queryClient, processSyncQueue]);\n\n  // Handle offline event\n  const handleOffline = useCallback(() => {\n    addNetworkEvent(\"offline\", {\n      lastOnline: lastOnline?.toISOString(),\n      networkInfo: getNetworkInfo(),\n    });\n\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n  }, [lastOnline, addNetworkEvent, getNetworkInfo, queryClient]);\n\n  // Process sync queue\n  const processSyncQueue = useCallback(async () => {\n    if (!navigator.onLine || syncQueue.length === 0) return;\n\n    logger.info(\"Processing sync queue\", { queueSize: syncQueue.length });\n\n    const processedItems: Record<string, unknown>[] = [];\n\n    for (const item of syncQueue) {\n      try {\n        // Here you would implement actual sync logic\n        // For now, we'll just simulate processing\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        processedItems.push(item);\n        logger.debug(\"Sync item processed\", { item });\n      } catch (error) {\n        logger.error(\"Failed to sync item\", { item, error });\n        break; // Stop processing on error\n      }\n    }\n\n    // Remove processed items from queue\n    setSyncQueue((prev) =>\n      prev.filter((item) => !processedItems.includes(item)),\n    );\n\n    if (processedItems.length > 0) {\n      queryClient.invalidateQueries({ queryKey: [\"network\"] });\n      logger.info(\"Sync queue processed\", {\n        processedCount: processedItems.length,\n        remainingCount: syncQueue.length - processedItems.length,\n      });\n    }\n  }, [syncQueue, queryClient]);\n\n  // Add item to sync queue\n  const queueForSync = useCallback((item: Record<string, unknown>) => {\n    setSyncQueue((prev) => [...prev, { ...item, queuedAt: new Date() }]);\n    logger.debug(\"Item queued for sync\", { item });\n  }, []);\n\n  // Clear sync queue\n  const clearSyncQueue = useCallback(() => {\n    setSyncQueue([]);\n    queryClient.invalidateQueries({ queryKey: [\"network\"] });\n    logger.info(\"Sync queue cleared\");\n  }, [queryClient]);\n\n  // Retry sync\n  const retrySync = useCallback(() => {\n    if (navigator.onLine) {\n      processSyncQueue();\n    } else {\n      logger.warn(\"Cannot retry sync while offline\");\n    }\n  }, [processSyncQueue]);\n\n  // Monitor connection changes\n  useEffect(() => {\n    const handleConnectionChange = () => {\n      const networkInfo = getNetworkInfo();\n      const newQuality = getNetworkQuality(\n        networkInfo.downlink,\n        networkInfo.rtt,\n      );\n\n      if (offlineStatus && newQuality !== offlineStatus.networkQuality) {\n        addNetworkEvent(\"quality-change\", {\n          oldQuality: offlineStatus.networkQuality,\n          newQuality,\n          networkInfo,\n        });\n      }\n\n      queryClient.invalidateQueries({ queryKey: [\"network\", \"status\"] });\n    };\n\n    // Listen for online/offline events\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes if supported\n    const nav = navigator as Navigator & {\n      connection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      mozConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n      webkitConnection?: {\n        downlink?: number;\n        rtt?: number;\n        effectiveType?: string;\n        type?: string;\n        addEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n        removeEventListener?: (\n          type: string,\n          listener: (event: Event) => void,\n        ) => void;\n      };\n    };\n    const connection =\n      nav.connection || nav.mozConnection || nav.webkitConnection;\n    if (connection) {\n      connection.addEventListener(\"change\", handleConnectionChange);\n    }\n\n    // Set initial online status\n    if (navigator.onLine && !lastOnline) {\n      setLastOnline(new Date());\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      if (connection) {\n        connection.removeEventListener(\"change\", handleConnectionChange);\n      }\n    };\n    // addNetworkEvent, getNetworkInfo, getNetworkQuality are stable (no/stable deps)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleOnline, handleOffline, offlineStatus, queryClient, lastOnline]);\n\n  return {\n    // Status\n    ...offlineStatus,\n    capabilities,\n\n    // Events\n    networkEvents,\n\n    // Sync management\n    queueForSync,\n    clearSyncQueue,\n    retrySync,\n    processSyncQueue,\n\n    // Computed properties\n    connectionStrength: offlineStatus?.networkQuality || NetworkQuality.OFFLINE,\n    canPerformOperations: offlineStatus?.isOnline || false,\n    needsSync: (offlineStatus?.syncQueueSize || 0) > 0,\n\n    // Helper methods\n    isGoodConnection:\n      offlineStatus?.networkQuality === NetworkQuality.EXCELLENT ||\n      offlineStatus?.networkQuality === NetworkQuality.GOOD,\n    isPoorConnection: offlineStatus?.networkQuality === NetworkQuality.POOR,\n    hasRecentEvents:\n      networkEvents.filter((e) => Date.now() - e.timestamp.getTime() < 60000)\n        .length > 0,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/system/usePerformance.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (248). Maximum allowed is 75.",
        "line": 78,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 382,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async method 'queryFn' has too many lines (80). Maximum allowed is 75.",
        "line": 85,
        "column": 14,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 173,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * usePerformance Hook - Performance Monitoring\n *\n * Monitor application performance metrics, identify bottlenecks, and provide\n * optimization recommendations.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { logger } from \"../../utils/logging\";\n\n// Performance metric types\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  lcp: number; // Largest Contentful Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout Shift\n\n  // Loading performance\n  domContentLoaded: number;\n  loadComplete: number;\n  firstPaint: number;\n  firstContentfulPaint: number;\n\n  // Memory usage\n  memoryUsed: number;\n  memoryTotal: number;\n  memoryUsagePercent: number;\n\n  // Network\n  networkType: string;\n  effectiveType: string;\n  downlink: number;\n  rtt: number;\n\n  // Custom metrics\n  componentRenderTime: number;\n  apiResponseTime: number;\n\n  timestamp: Date;\n}\n\n// Performance alert\nexport interface PerformanceAlert {\n  id: string;\n  type: \"warning\" | \"critical\";\n  metric: keyof PerformanceMetrics;\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: Date;\n}\n\n// Performance recommendation\nexport interface PerformanceRecommendation {\n  id: string;\n  category: \"loading\" | \"runtime\" | \"memory\" | \"network\";\n  priority: \"low\" | \"medium\" | \"high\";\n  title: string;\n  description: string;\n  impact: string;\n  effort: string;\n}\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  lcp: { good: 2500, poor: 4000 },\n  fid: { good: 100, poor: 300 },\n  cls: { good: 0.1, poor: 0.25 },\n  memoryUsagePercent: { good: 70, poor: 90 },\n  loadComplete: { good: 3000, poor: 6000 },\n  apiResponseTime: { good: 500, poor: 2000 },\n};\n\n/**\n * Performance Monitoring Hook\n */\nexport const usePerformance = () => {\n  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);\n  const [isMonitoring, setIsMonitoring] = useState(true);\n\n  // Get current performance metrics\n  const { data: metrics, isLoading } = useQuery<PerformanceMetrics>({\n    queryKey: [\"performance\", \"metrics\"],\n    queryFn: async () => {\n      const perfMetrics: PerformanceMetrics = {\n        lcp: 0,\n        fid: 0,\n        cls: 0,\n        domContentLoaded: 0,\n        loadComplete: 0,\n        firstPaint: 0,\n        firstContentfulPaint: 0,\n        memoryUsed: 0,\n        memoryTotal: 0,\n        memoryUsagePercent: 0,\n        networkType: \"unknown\",\n        effectiveType: \"unknown\",\n        downlink: 0,\n        rtt: 0,\n        componentRenderTime: 0,\n        apiResponseTime: 0,\n        timestamp: new Date(),\n      };\n\n      // Get performance timing\n      if (performance.timing) {\n        const timing = performance.timing;\n        perfMetrics.domContentLoaded =\n          timing.domContentLoadedEventEnd - timing.navigationStart;\n        perfMetrics.loadComplete = timing.loadEventEnd - timing.navigationStart;\n      }\n\n      // Get paint timing\n      const paintEntries = performance.getEntriesByType(\"paint\");\n      paintEntries.forEach((entry) => {\n        if (entry.name === \"first-paint\") {\n          perfMetrics.firstPaint = entry.startTime;\n        } else if (entry.name === \"first-contentful-paint\") {\n          perfMetrics.firstContentfulPaint = entry.startTime;\n        }\n      });\n\n      // Get memory usage\n      if (\"memory\" in performance) {\n        const memory = (\n          performance as Performance & {\n            memory?: {\n              usedJSHeapSize: number;\n              totalJSHeapSize: number;\n            };\n          }\n        ).memory;\n        if (memory) {\n          perfMetrics.memoryUsed = memory.usedJSHeapSize;\n          perfMetrics.memoryTotal = memory.totalJSHeapSize;\n          perfMetrics.memoryUsagePercent =\n            (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;\n        }\n      }\n\n      // Get network information\n      const nav = navigator as Navigator & {\n        connection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        mozConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n        webkitConnection?: {\n          type?: string;\n          effectiveType?: string;\n          downlink?: number;\n          rtt?: number;\n        };\n      };\n      const connection =\n        nav.connection || nav.mozConnection || nav.webkitConnection;\n      if (connection) {\n        perfMetrics.networkType = connection.type || \"unknown\";\n        perfMetrics.effectiveType = connection.effectiveType || \"unknown\";\n        perfMetrics.downlink = connection.downlink || 0;\n        perfMetrics.rtt = connection.rtt || 0;\n      }\n\n      return perfMetrics;\n    },\n    refetchInterval: isMonitoring ? 10000 : false, // Every 10 seconds\n    staleTime: 5000,\n  });\n\n  // Generate performance recommendations\n  const { data: recommendations = [] } = useQuery<PerformanceRecommendation[]>({\n    queryKey: [\"performance\", \"recommendations\", metrics],\n    queryFn: () => {\n      if (!metrics) return [];\n\n      const recs: PerformanceRecommendation[] = [];\n\n      // Loading performance recommendations\n      if (metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.poor) {\n        recs.push({\n          id: \"slow-loading\",\n          category: \"loading\",\n          priority: \"high\",\n          title: \"Slow Page Loading\",\n          description: \"Page load time exceeds recommended thresholds\",\n          impact: \"High - affects user experience and engagement\",\n          effort: \"Medium - requires code splitting and optimization\",\n        });\n      }\n\n      // Memory usage recommendations\n      if (\n        metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.poor\n      ) {\n        recs.push({\n          id: \"high-memory\",\n          category: \"memory\",\n          priority: \"high\",\n          title: \"High Memory Usage\",\n          description: \"Application is using excessive memory\",\n          impact: \"High - can cause crashes and slowdowns\",\n          effort: \"High - requires memory leak investigation\",\n        });\n      }\n\n      // Network recommendations\n      if (metrics.rtt > 500) {\n        recs.push({\n          id: \"high-latency\",\n          category: \"network\",\n          priority: \"medium\",\n          title: \"High Network Latency\",\n          description: \"Network requests are slow\",\n          impact: \"Medium - affects data loading\",\n          effort: \"Low - implement caching strategies\",\n        });\n      }\n\n      return recs;\n    },\n    enabled: Boolean(metrics),\n    staleTime: 60000, // 1 minute\n  });\n\n  // Check for performance issues and generate alerts\n  const checkPerformanceAlerts = useCallback(\n    (currentMetrics: PerformanceMetrics) => {\n      const newAlerts: PerformanceAlert[] = [];\n\n      // Check each threshold\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          newAlerts.push({\n            id: `${key}-critical-${Date.now()}`,\n            type: \"critical\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.poor,\n            message: `${key.toUpperCase()} is critically high: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        } else if (value > thresholds.good) {\n          newAlerts.push({\n            id: `${key}-warning-${Date.now()}`,\n            type: \"warning\",\n            metric: key as keyof PerformanceMetrics,\n            value,\n            threshold: thresholds.good,\n            message: `${key.toUpperCase()} exceeds good threshold: ${value.toFixed(2)}ms`,\n            timestamp: new Date(),\n          });\n        }\n      });\n\n      if (newAlerts.length > 0) {\n        setAlerts((prev) => [...prev.slice(-19), ...newAlerts]); // Keep last 20 alerts\n      }\n    },\n    [],\n  );\n\n  // Monitor performance changes\n  useEffect(() => {\n    if (metrics && isMonitoring) {\n      checkPerformanceAlerts(metrics);\n    }\n  }, [metrics, isMonitoring, checkPerformanceAlerts]);\n\n  // Measure component render time\n  const measureRenderTime = useCallback(\n    (componentName: string, renderFn: () => void) => {\n      const startTime = performance.now();\n      renderFn();\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      logger.debug(\n        `Component ${componentName} render time: ${renderTime.toFixed(2)}ms`,\n      );\n      return renderTime;\n    },\n    [],\n  );\n\n  // Measure API response time\n  const measureApiTime = useCallback(\n    async <T>(apiCall: () => Promise<T>): Promise<T> => {\n      const startTime = performance.now();\n      try {\n        const result = await apiCall();\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.debug(`API response time: ${responseTime.toFixed(2)}ms`);\n        return { result, responseTime };\n      } catch (error) {\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n\n        logger.warn(`API error after ${responseTime.toFixed(2)}ms`, error);\n        throw error;\n      }\n    },\n    [],\n  );\n\n  // Clear old alerts\n  const clearOldAlerts = useCallback(() => {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    setAlerts((prev) => prev.filter((alert) => alert.timestamp > oneHourAgo));\n  }, []);\n\n  // Performance score calculation\n  const performanceScore = useCallback(\n    (currentMetrics: PerformanceMetrics): number => {\n      if (!currentMetrics) return 0;\n\n      let score = 100;\n\n      // Deduct points for poor metrics\n      Object.entries(PERFORMANCE_THRESHOLDS).forEach(([key, thresholds]) => {\n        const value = currentMetrics[key as keyof PerformanceMetrics] as number;\n\n        if (value > thresholds.poor) {\n          score -= 30;\n        } else if (value > thresholds.good) {\n          score -= 15;\n        }\n      });\n\n      return Math.max(0, score);\n    },\n    [],\n  );\n\n  return {\n    // Current metrics\n    metrics,\n    isLoading,\n\n    // Performance insights\n    performanceScore: metrics ? performanceScore(metrics) : 0,\n    recommendations,\n    alerts,\n\n    // Controls\n    isMonitoring,\n    setIsMonitoring,\n    clearOldAlerts,\n\n    // Measurement tools\n    measureRenderTime,\n    measureApiTime,\n\n    // Computed properties\n    isPerformant: metrics ? performanceScore(metrics) > 80 : false,\n    hasIssues: alerts.length > 0,\n    criticalIssues: alerts.filter((a) => a.type === \"critical\").length,\n    warningIssues: alerts.filter((a) => a.type === \"warning\").length,\n\n    // Quick checks\n    isSlowLoading: metrics?.loadComplete\n      ? metrics.loadComplete > PERFORMANCE_THRESHOLDS.loadComplete.good\n      : false,\n    isHighMemory: metrics?.memoryUsagePercent\n      ? metrics.memoryUsagePercent >\n        PERFORMANCE_THRESHOLDS.memoryUsagePercent.good\n      : false,\n    isSlowNetwork: metrics?.rtt ? metrics.rtt > 500 : false,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/task-filter-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/task-sort-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useCountdownTimer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskAssignment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskCRUD.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useTaskCRUD' has too many lines (97). Maximum allowed is 75.",
        "line": 18,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 131,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Hook for task CRUD operations\n */\nimport { useCallback, useRef, useEffect } from \"react\";\nimport { Task, TaskStatus, TaskPriority } from \"@/types/core\";\nimport { Timestamp } from \"firebase/firestore\";\nimport { CreateTaskInput, UpdateTaskInput } from \"./useTaskManagement\";\n\ninterface TaskCRUDParams {\n  tasks: Task[];\n  setTasks: (tasks: Task[] | ((prev: Task[]) => Task[])) => void;\n  setError: (error: Error | null) => void;\n  setIsCreating: (isCreating: boolean) => void;\n  setIsUpdating: (isUpdating: boolean) => void;\n  setIsDeleting: (isDeleting: boolean) => void;\n}\n\nexport function useTaskCRUD({\n  tasks,\n  setTasks,\n  setError,\n  setIsCreating,\n  setIsUpdating,\n  setIsDeleting,\n}: TaskCRUDParams) {\n  // Use a ref to always have access to the latest tasks\n  const tasksRef = useRef(tasks);\n  useEffect(() => {\n    tasksRef.current = tasks;\n  }, [tasks]);\n\n  // Create a new task\n  const createTask = useCallback(\n    async (task: CreateTaskInput): Promise<Task> => {\n      setIsCreating(true);\n      setError(null);\n\n      try {\n        // Mock implementation - in production, this would call Firebase/API\n        const newTask: Task = {\n          id: `task-${Date.now()}`,\n          userId: \"current-user-id\", // Would come from auth context\n          title: task.title,\n          description: task.description,\n          category: task.category,\n          status: TaskStatus.PENDING,\n          priority: task.priority ?? TaskPriority.MEDIUM,\n          assignedBy: task.assignedBy ?? \"submissive\",\n          createdAt: Timestamp.fromDate(new Date()),\n          dueDate: task.dueDate ? Timestamp.fromDate(task.dueDate) : undefined,\n          isRecurring: false,\n        };\n\n        setTasks((prev) => {\n          const newTasks = [...prev, newTask];\n          tasksRef.current = newTasks; // Update ref immediately\n          return newTasks;\n        });\n        return newTask;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to create task\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsCreating(false);\n      }\n    },\n    [setTasks, setError, setIsCreating],\n  );\n\n  // Update an existing task\n  const updateTask = useCallback(\n    async (id: string, updates: UpdateTaskInput): Promise<Task> => {\n      setIsUpdating(true);\n      setError(null);\n\n      try {\n        const currentTasks = tasksRef.current;\n        const taskIndex = currentTasks.findIndex((t) => t.id === id);\n\n        if (taskIndex === -1) {\n          throw new Error(`Task with id ${id} not found`);\n        }\n\n        const updatedTask = { ...currentTasks[taskIndex], ...updates };\n        const newTasks = [...currentTasks];\n        newTasks[taskIndex] = updatedTask;\n\n        setTasks(newTasks);\n        tasksRef.current = newTasks; // Update ref immediately\n\n        return updatedTask;\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to update task\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsUpdating(false);\n      }\n    },\n    [setTasks, setError, setIsUpdating],\n  );\n\n  // Delete a task\n  const deleteTask = useCallback(\n    async (id: string): Promise<void> => {\n      setIsDeleting(true);\n      setError(null);\n\n      try {\n        setTasks((prev) => {\n          const newTasks = prev.filter((t) => t.id !== id);\n          tasksRef.current = newTasks; // Update ref immediately\n          return newTasks;\n        });\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(\"Failed to delete task\");\n        setError(error);\n        throw error;\n      } finally {\n        setIsDeleting(false);\n      }\n    },\n    [setTasks, setError, setIsDeleting],\n  );\n\n  return { createTask, updateTask, deleteTask };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskItem.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (96). Maximum allowed is 75.",
        "line": 24,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 135,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from \"react\";\nimport type { DBTask, TaskStatus } from \"../../types/database\";\nimport {\n  FaCheckCircle,\n  FaTimesCircle,\n  FaTrophy,\n  FaClock,\n} from \"../../utils/iconImport\";\n\n// Task status configuration type\ninterface TaskStatusConfig {\n  icon: React.ReactNode;\n  text: string;\n  borderColor: string;\n}\n\n// Task priority styles type\ninterface TaskPriorityStyles {\n  bgColor: string;\n  textColor: string;\n}\n\n// Custom hook for task item logic\nexport const useTaskItem = (\n  task: DBTask,\n  onSubmit: (taskId: string, note: string) => void,\n) => {\n  const [note, setNote] = useState(\"\");\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Task status configuration logic\n  const getStatusConfig = (status: TaskStatus): TaskStatusConfig => {\n    switch (status) {\n      case \"pending\":\n        return {\n          icon: <FaClock className=\"text-nightly-aquamarine\" />,\n          text: \"Pending\",\n          borderColor: \"border-nightly-aquamarine\",\n        };\n      case \"submitted\":\n        return {\n          icon: <FaClock className=\"text-yellow-400\" />,\n          text: \"Submitted\",\n          borderColor: \"border-yellow-400\",\n        };\n      case \"approved\":\n        return {\n          icon: <FaCheckCircle className=\"text-green-400\" />,\n          text: \"Approved\",\n          borderColor: \"border-green-400\",\n        };\n      case \"rejected\":\n        return {\n          icon: <FaTimesCircle className=\"text-red-400\" />,\n          text: \"Rejected\",\n          borderColor: \"border-red-400\",\n        };\n      case \"completed\":\n        return {\n          icon: <FaTrophy className=\"text-nightly-lavender-floral\" />,\n          text: \"Completed\",\n          borderColor: \"border-nightly-lavender-floral\",\n        };\n      default:\n        return {\n          icon: <FaClock className=\"text-gray-400\" />,\n          text: \"Unknown\",\n          borderColor: \"border-gray-400\",\n        };\n    }\n  };\n\n  // Priority styling logic\n  const getPriorityStyles = (priority: string): TaskPriorityStyles => {\n    switch (priority) {\n      case \"critical\":\n        return {\n          bgColor: \"bg-red-500/20\",\n          textColor: \"text-red-300\",\n        };\n      case \"high\":\n        return {\n          bgColor: \"bg-orange-500/20\",\n          textColor: \"text-orange-300\",\n        };\n      case \"medium\":\n        return {\n          bgColor: \"bg-yellow-500/20\",\n          textColor: \"text-yellow-300\",\n        };\n      default:\n        return {\n          bgColor: \"bg-gray-500/20\",\n          textColor: \"text-gray-300\",\n        };\n    }\n  };\n\n  // Submit handler logic\n  const handleSubmit = async () => {\n    setIsSubmitting(true);\n    try {\n      await onSubmit(task.id, note);\n      setNote(\"\");\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Derived values\n  const statusConfig = getStatusConfig(task.status);\n  const priorityStyles = task.priority\n    ? getPriorityStyles(task.priority)\n    : null;\n  const isOverdue = task.dueDate && new Date() > task.dueDate;\n\n  return {\n    // State\n    note,\n    isSubmitting,\n\n    // Actions\n    setNote,\n    handleSubmit,\n\n    // Computed values\n    statusConfig,\n    priorityStyles,\n    isOverdue: Boolean(isOverdue),\n\n    // Helper functions (exposed for flexibility)\n    getStatusConfig,\n    getPriorityStyles,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tasks/useTaskManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useEmergencyUnlockModal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/usePauseResumeControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/tracker/useTrackerStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/ui/useTheme.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 369,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 369,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [10161, 10191],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setThemeMutation'. Either include it or remove the dependency array.",
        "line": 396,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 396,
        "endColumn": 36,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [preferences, currentTheme.id, setThemeMutation]",
            "fix": {
              "range": [11075, 11105],
              "text": "[preferences, currentTheme.id, setThemeMutation]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievementGallery.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (95). Maximum allowed is 75.",
        "line": 27,
        "column": 38,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 147,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Custom hook for Achievement Gallery state and logic\n */\n\nimport { useState, useMemo } from \"react\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  AchievementDifficulty,\n} from \"../types\";\nimport { AchievementCategory } from \"../types/achievements\";\nimport { getCategoryName } from \"./achievement-gallery-utils\";\n\ninterface AchievementWithProgress {\n  achievement: DBAchievement;\n  userAchievement?: DBUserAchievement;\n  progress: {\n    currentValue: number;\n    targetValue: number;\n    percentage: number;\n    isCompleted: boolean;\n  } | null;\n  isEarned: boolean;\n  isVisible: boolean;\n}\n\nexport const useAchievementGallery = (\n  achievementsWithProgress: AchievementWithProgress[],\n) => {\n  const [selectedCategory, setSelectedCategory] = useState<\n    AchievementCategory | \"all\"\n  >(\"all\");\n  const [selectedDifficulty, setSelectedDifficulty] = useState<\n    AchievementDifficulty | \"all\"\n  >(\"all\");\n  const [showOnlyEarned, setShowOnlyEarned] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  // Calculate stats\n  const stats = useMemo(() => {\n    const totalEarned = achievementsWithProgress.filter(\n      (a) => a.isEarned,\n    ).length;\n    const totalVisible = achievementsWithProgress.filter(\n      (a) => !a.achievement.isHidden,\n    ).length;\n    const totalPoints = achievementsWithProgress\n      .filter((a) => a.isEarned)\n      .reduce((sum, a) => sum + a.achievement.points, 0);\n\n    return {\n      totalEarned,\n      totalVisible,\n      totalPoints,\n      completionPercentage:\n        totalVisible > 0 ? (totalEarned / totalVisible) * 100 : 0,\n    };\n  }, [achievementsWithProgress]);\n\n  // Filter achievements\n  const filteredAchievements = useMemo(() => {\n    return achievementsWithProgress.filter((item) => {\n      const { achievement, isEarned } = item;\n\n      // Category filter\n      if (\n        selectedCategory !== \"all\" &&\n        achievement.category !== selectedCategory\n      ) {\n        return false;\n      }\n\n      // Difficulty filter\n      if (\n        selectedDifficulty !== \"all\" &&\n        achievement.difficulty !== selectedDifficulty\n      ) {\n        return false;\n      }\n\n      // Earned filter\n      if (showOnlyEarned && !isEarned) {\n        return false;\n      }\n\n      // Search filter\n      if (\n        searchTerm &&\n        !achievement.name.toLowerCase().includes(searchTerm.toLowerCase()) &&\n        !achievement.description\n          .toLowerCase()\n          .includes(searchTerm.toLowerCase())\n      ) {\n        return false;\n      }\n\n      // Hide hidden achievements if not earned\n      if (achievement.isHidden && !isEarned) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [\n    achievementsWithProgress,\n    selectedCategory,\n    selectedDifficulty,\n    showOnlyEarned,\n    searchTerm,\n  ]);\n\n  // Group by category\n  const groupedAchievements = useMemo(() => {\n    const groups: Record<string, AchievementWithProgress[]> = {};\n\n    filteredAchievements.forEach((item) => {\n      const categoryName = getCategoryName(\n        item.achievement.category as AchievementCategory,\n      );\n      if (!groups[categoryName]) {\n        groups[categoryName] = [];\n      }\n      groups[categoryName].push(item);\n    });\n\n    return groups;\n  }, [filteredAchievements]);\n\n  return {\n    // State\n    selectedCategory,\n    selectedDifficulty,\n    showOnlyEarned,\n    searchTerm,\n\n    // Setters\n    setSelectedCategory,\n    setSelectedDifficulty,\n    setShowOnlyEarned,\n    setSearchTerm,\n\n    // Computed values\n    stats,\n    filteredAchievements,\n    groupedAchievements,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useAchievements.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (225). Maximum allowed is 75.",
        "line": 25,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 345,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useAchievements Hook\n * React hook for managing achievements and progress\n */\n\nimport { useEffect, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService, achievementEngine } from \"../services\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  AchievementCategory,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<AchievementCategory, number>;\n  recentAchievements: DBUserAchievement[];\n}\n\nexport const useAchievements = (userId?: string) => {\n  const queryClient = useQueryClient();\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get all available achievements\n   */\n  const { data: allAchievements = [], isLoading: isLoadingAchievements } =\n    useQuery({\n      queryKey: [\"achievements\"],\n      queryFn: () => achievementDBService.getAllAchievements(),\n      enabled: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n\n  /**\n   * Get user's earned achievements\n   */\n  const { data: userAchievements = [], isLoading: isLoadingUserAchievements } =\n    useQuery({\n      queryKey: [\"achievements\", \"user\", userId],\n      queryFn: () => achievementDBService.getUserAchievements(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  const { data: visibleAchievements = [] } = useQuery({\n    queryKey: [\"achievements\", \"visible\", userId],\n    queryFn: () => achievementDBService.getUserVisibleAchievements(userId!),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's achievement progress\n   */\n  const { data: achievementProgress = [], isLoading: isLoadingProgress } =\n    useQuery({\n      queryKey: [\"achievements\", \"progress\", userId],\n      queryFn: () => achievementDBService.getUserAchievementProgress(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get unread notifications\n   */\n  const { data: unreadNotifications = [], isLoading: isLoadingNotifications } =\n    useQuery({\n      queryKey: [\"achievements\", \"notifications\", userId],\n      queryFn: () => achievementDBService.getUserUnreadNotifications(userId!),\n      enabled: Boolean(userId),\n      refetchInterval: 30 * 1000, // Check every 30 seconds\n    });\n\n  /**\n   * Get achievement statistics\n   */\n  const { data: achievementStats, isLoading: isLoadingStats } = useQuery({\n    queryKey: [\"achievements\", \"stats\", userId],\n    queryFn: async (): Promise<AchievementStats> => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const [stats, achievements] = await Promise.all([\n        achievementDBService.getUserAchievementStats(userId),\n        achievementDBService.getUserAchievements(userId),\n      ]);\n\n      // Get recent achievements (last 5)\n      const recentAchievements = achievements\n        .sort(\n          (a: DBUserAchievement, b: DBUserAchievement) =>\n            b.earnedAt.getTime() - a.earnedAt.getTime(),\n        )\n        .slice(0, 5);\n\n      return {\n        ...stats,\n        recentAchievements,\n      };\n    },\n    enabled: Boolean(userId),\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Toggle achievement visibility\n   */\n  const toggleVisibilityMutation = useMutation({\n    mutationFn: ({ achievementId }: { achievementId: string }) =>\n      achievementDBService.toggleAchievementVisibility(userId!, achievementId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"visible\", userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"user\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Mark notification as read\n   */\n  const markNotificationReadMutation = useMutation({\n    mutationFn: (notificationId: string) =>\n      achievementDBService.markNotificationRead(notificationId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"notifications\", userId],\n      });\n    },\n    onError: (error: Error) => {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Perform full achievement check\n   */\n  const performFullCheckMutation = useMutation({\n    mutationFn: () => achievementEngine.performFullCheck(userId!),\n    onSuccess: () => {\n      // Invalidate all achievement-related queries\n      queryClient.invalidateQueries({ queryKey: [\"achievements\"] });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  // ==================== HELPER FUNCTIONS ====================\n\n  /**\n   * Get achievement by ID\n   */\n  const getAchievementById = useCallback(\n    (achievementId: string): DBAchievement | undefined => {\n      return allAchievements.find((a: DBAchievement) => a.id === achievementId);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Check if user has specific achievement\n   */\n  const hasAchievement = useCallback(\n    (achievementId: string): boolean => {\n      return userAchievements.some(\n        (ua: DBUserAchievement) => ua.achievementId === achievementId,\n      );\n    },\n    [userAchievements],\n  );\n\n  /**\n   * Get progress for specific achievement\n   */\n  const getProgressForAchievement = useCallback(\n    (achievementId: string): DBAchievementProgress | undefined => {\n      return achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievementId,\n      );\n    },\n    [achievementProgress],\n  );\n\n  /**\n   * Get achievements by category\n   */\n  const getAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBAchievement[] => {\n      return allAchievements.filter(\n        (a: DBAchievement) => a.category === category,\n      );\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Get user's achievements by category\n   */\n  const getUserAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBUserAchievement[] => {\n      const categoryAchievementIds = allAchievements\n        .filter((a: DBAchievement) => a.category === category)\n        .map((a: DBAchievement) => a.id);\n\n      return userAchievements.filter((ua: DBUserAchievement) =>\n        categoryAchievementIds.includes(ua.achievementId),\n      );\n    },\n    [allAchievements, userAchievements],\n  );\n\n  /**\n   * Get achievements with progress information\n   */\n  const getAchievementsWithProgress = useCallback(() => {\n    return allAchievements.map((achievement: DBAchievement) => {\n      const userAchievement = userAchievements.find(\n        (ua: DBUserAchievement) => ua.achievementId === achievement.id,\n      );\n      const progress = achievementProgress.find(\n        (ap: DBAchievementProgress) => ap.achievementId === achievement.id,\n      );\n\n      return {\n        achievement,\n        userAchievement,\n        progress: progress\n          ? {\n              currentValue: progress.currentValue,\n              targetValue: progress.targetValue,\n              percentage: Math.min(\n                (progress.currentValue / progress.targetValue) * 100,\n                100,\n              ),\n              isCompleted: progress.isCompleted,\n            }\n          : null,\n        isEarned: Boolean(userAchievement),\n        isVisible: userAchievement?.isVisible ?? true,\n      };\n    });\n  }, [allAchievements, userAchievements, achievementProgress]);\n\n  // ==================== ACTIONS ====================\n\n  const toggleAchievementVisibility = useCallback(\n    (achievementId: string) => {\n      if (!userId) return;\n      toggleVisibilityMutation.mutate({ achievementId });\n    },\n    [userId, toggleVisibilityMutation],\n  );\n\n  const markNotificationRead = useCallback(\n    (notificationId: string) => {\n      markNotificationReadMutation.mutate(notificationId);\n    },\n    [markNotificationReadMutation],\n  );\n\n  const performFullCheck = useCallback(() => {\n    if (!userId) return;\n    performFullCheckMutation.mutate();\n  }, [userId, performFullCheckMutation]);\n\n  // ==================== EFFECTS ====================\n\n  /**\n   * Initialize achievement engine on mount\n   */\n  useEffect(() => {\n    achievementEngine.initialize().catch((error) => {\n      logger.error(\n        \"Failed to initialize achievement engine\",\n        error,\n        \"useAchievements\",\n      );\n    });\n  }, []);\n\n  // ==================== RETURN ====================\n\n  return {\n    // Data\n    allAchievements,\n    userAchievements,\n    visibleAchievements,\n    achievementProgress,\n    unreadNotifications,\n    achievementStats,\n\n    // Loading states\n    isLoading: isLoadingAchievements || isLoadingUserAchievements,\n    isLoadingProgress,\n    isLoadingNotifications,\n    isLoadingStats,\n\n    // Helper functions\n    getAchievementById,\n    hasAchievement,\n    getProgressForAchievement,\n    getAchievementsByCategory,\n    getUserAchievementsByCategory,\n    getAchievementsWithProgress,\n\n    // Actions\n    toggleAchievementVisibility,\n    markNotificationRead,\n    performFullCheck,\n\n    // Mutation states\n    isTogglingVisibility: toggleVisibilityMutation.isPending,\n    isMarkingRead: markNotificationReadMutation.isPending,\n    isPerformingCheck: performFullCheckMutation.isPending,\n  };\n};\n\n/**\n * Hook for achievement notifications (can be used globally)\n */\nexport const useAchievementNotifications = (userId?: string) => {\n  const { unreadNotifications, markNotificationRead, isLoadingNotifications } =\n    useAchievements(userId);\n\n  return {\n    notifications: unreadNotifications,\n    isLoading: isLoadingNotifications,\n    markAsRead: markNotificationRead,\n    hasUnread: unreadNotifications.length > 0,\n    unreadCount: unreadNotifications.length,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useKeyholderRelationships.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 35,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 52,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "zustand-safe-patterns/zustand-no-store-actions-in-deps",
        "severity": 2,
        "message": "Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.",
        "line": 478,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "noStoreActionsInDeps",
        "endLine": 478,
        "endColumn": 77,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useLeaderboards.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (82). Maximum allowed is 75.",
        "line": 145,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 238,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useLeaderboards Hook\n * React hook for managing leaderboard data and user participation\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService } from \"../services\";\nimport {\n  LeaderboardCategory,\n  LeaderboardPeriod,\n  DBLeaderboardEntry,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface LeaderboardEntry {\n  id: string;\n  displayName: string;\n  value: number;\n  rank: number;\n  isCurrentUser: boolean;\n}\n\nexport interface UserRankInfo {\n  rank: number;\n  value: number;\n  totalParticipants: number;\n}\n\nexport interface LeaderboardPrivacySettings {\n  participateInGlobal: boolean;\n  participateInMonthly: boolean;\n  shareSessionTime: boolean;\n  shareStreakData: boolean;\n  shareAchievements: boolean;\n  displayName: \"real\" | \"username\" | \"anonymous\";\n  showOnPublicProfile: boolean;\n}\n\n// Default privacy settings for opting in\nconst DEFAULT_OPT_IN_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: true,\n  participateInMonthly: true,\n  shareSessionTime: true,\n  shareStreakData: true,\n  shareAchievements: true,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n// Default privacy settings for opting out\nconst DEFAULT_OPT_OUT_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: false,\n  participateInMonthly: false,\n  shareSessionTime: false,\n  shareStreakData: false,\n  shareAchievements: false,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n// Initial privacy settings state\nconst INITIAL_PRIVACY_SETTINGS: LeaderboardPrivacySettings = {\n  participateInGlobal: false,\n  participateInMonthly: false,\n  shareSessionTime: false,\n  shareStreakData: false,\n  shareAchievements: true,\n  displayName: \"anonymous\",\n  showOnPublicProfile: false,\n};\n\n/**\n * Generate display name based on privacy settings\n */\nfunction getDisplayName(\n  entry: DBLeaderboardEntry,\n  currentUserId?: string,\n): string {\n  if (entry.userId === currentUserId) {\n    return \"You\";\n  }\n\n  switch (entry.displayNameType) {\n    case \"real\":\n      return entry.displayName || \"Unknown User\";\n    case \"username\":\n      return entry.displayName || `User_${entry.userId.slice(-6)}`;\n    case \"anonymous\":\n    default:\n      return `ChastityUser_${entry.userId.slice(-4)}`;\n  }\n}\n\n/**\n * Process raw leaderboard data into displayable format\n */\nfunction processLeaderboardData(\n  rawData: DBLeaderboardEntry[],\n  userId?: string,\n): LeaderboardEntry[] {\n  return rawData.map((entry, index) => ({\n    id: entry.id,\n    displayName: getDisplayName(entry, userId),\n    value: entry.value,\n    rank: index + 1,\n    isCurrentUser: entry.userId === userId,\n  }));\n}\n\n/**\n * Create mutation callbacks for privacy settings updates\n */\nfunction createPrivacyMutationCallbacks(\n  setPrivacySettings: (settings: LeaderboardPrivacySettings) => void,\n  queryClient: ReturnType<typeof useQueryClient>,\n  actionName: string,\n) {\n  return {\n    onSuccess: (data: LeaderboardPrivacySettings) => {\n      setPrivacySettings(data);\n      queryClient.invalidateQueries({ queryKey: [\"leaderboards\"] });\n      logger.info(actionName, \"useLeaderboards\");\n    },\n    onError: (error: Error) => {\n      logger.error(`Failed: ${actionName}`, error, \"useLeaderboards\");\n    },\n  };\n}\n\n/**\n * Create opt-in/opt-out mutation function\n */\nfunction createPrivacyUpdateMutation(\n  userId: string | undefined,\n  settings: LeaderboardPrivacySettings,\n) {\n  return async () => {\n    if (!userId) throw new Error(\"User ID required\");\n    await achievementDBService.updateLeaderboardPrivacy(userId, settings);\n    return settings;\n  };\n}\n\nexport const useLeaderboards = (\n  userId?: string,\n  category: LeaderboardCategory = LeaderboardCategory.ACHIEVEMENT_POINTS,\n  period: LeaderboardPeriod = LeaderboardPeriod.ALL_TIME,\n) => {\n  const queryClient = useQueryClient();\n  const [privacySettings, setPrivacySettings] =\n    useState<LeaderboardPrivacySettings>(INITIAL_PRIVACY_SETTINGS);\n\n  // Get leaderboard data for a specific category and period\n  const {\n    data: rawLeaderboardData = [],\n    isLoading: isLoadingLeaderboard,\n    error: leaderboardError,\n  } = useQuery({\n    queryKey: [\"leaderboards\", category, period],\n    queryFn: () => achievementDBService.getLeaderboard(category, period),\n    enabled: true,\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  // Get user's rank in the leaderboard\n  const { data: userRank, isLoading: isLoadingUserRank } = useQuery({\n    queryKey: [\"leaderboards\", \"rank\", userId, category, period],\n    queryFn: () =>\n      achievementDBService.getUserLeaderboardRank(userId!, category, period),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  // Get user's leaderboard privacy settings\n  const { data: userPrivacySettings } = useQuery({\n    queryKey: [\"leaderboards\", \"privacy\", userId],\n    queryFn: () => achievementDBService.getLeaderboardPrivacy(userId!),\n    enabled: Boolean(userId),\n  });\n\n  useEffect(() => {\n    if (userPrivacySettings) {\n      setPrivacySettings(userPrivacySettings);\n    }\n  }, [userPrivacySettings]);\n\n  const optInMutation = useMutation({\n    mutationFn: createPrivacyUpdateMutation(userId, DEFAULT_OPT_IN_SETTINGS),\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"User opted into leaderboards\",\n    ),\n  });\n\n  const optOutMutation = useMutation({\n    mutationFn: createPrivacyUpdateMutation(userId, DEFAULT_OPT_OUT_SETTINGS),\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"User opted out of leaderboards\",\n    ),\n  });\n\n  const updatePrivacyMutation = useMutation({\n    mutationFn: async (settings: Partial<LeaderboardPrivacySettings>) => {\n      if (!userId) throw new Error(\"User ID required\");\n      const newSettings = { ...privacySettings, ...settings };\n      await achievementDBService.updateLeaderboardPrivacy(userId, newSettings);\n      return newSettings;\n    },\n    ...createPrivacyMutationCallbacks(\n      setPrivacySettings,\n      queryClient,\n      \"Updated leaderboard privacy settings\",\n    ),\n  });\n\n  const leaderboardData = processLeaderboardData(rawLeaderboardData, userId);\n\n  return {\n    leaderboardData,\n    userRank,\n    privacySettings,\n    isLoading: isLoadingLeaderboard || isLoadingUserRank,\n    error: leaderboardError,\n    optInToLeaderboards: optInMutation.mutateAsync,\n    optOutFromLeaderboards: optOutMutation.mutateAsync,\n    updateLeaderboardPrivacy: updatePrivacyMutation.mutateAsync,\n    isOptedIn:\n      privacySettings.participateInGlobal ||\n      privacySettings.participateInMonthly,\n    isOptingIn: optInMutation.isPending,\n    isOptingOut: optOutMutation.isPending,\n    isUpdatingPrivacy: updatePrivacyMutation.isPending,\n  };\n};\n\n// Named export only - hook files should only export hooks starting with 'use'\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/usePauseState.ts",
    "messages": [
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 64,
        "column": 5,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [1798, 1880], "text": " " }
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 92,
        "column": 5,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [2613, 2695], "text": " " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport {\n  PauseCooldownService,\n  PauseState,\n} from \"../services/PauseCooldownService\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"usePauseState\");\n\ninterface UsePauseStateProps {\n  userId: string;\n  sessionId?: string;\n  refreshInterval?: number; // milliseconds\n}\n\ninterface UsePauseStateReturn {\n  pauseState: PauseState | null;\n  isLoading: boolean;\n  error: string | null;\n  refreshPauseState: () => Promise<void>;\n  canPause: boolean;\n}\n\nexport const usePauseState = ({\n  userId,\n  sessionId: _sessionId,\n  refreshInterval = 30000, // 30 seconds\n}: UsePauseStateProps): UsePauseStateReturn => {\n  const [pauseState, setPauseState] = useState<PauseState | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const refreshPauseState = useCallback(async () => {\n    if (!userId) return;\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const state = await PauseCooldownService.canUserPause(userId);\n      setPauseState(state);\n      logger.debug(\"Pause state refreshed\", { userId, state });\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to check pause state\";\n      setError(errorMessage);\n      logger.error(\"Failed to refresh pause state\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId]);\n\n  // Initial load\n  useEffect(() => {\n    refreshPauseState();\n  }, [refreshPauseState]);\n\n  // Auto-refresh for cooldown countdown\n  useEffect(() => {\n    if (!pauseState || pauseState.canPause) return;\n\n    const interval = setInterval(refreshPauseState, refreshInterval);\n    return () => clearInterval(interval);\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [pauseState, refreshInterval, refreshPauseState]);\n\n  // Real-time cooldown countdown\n  useEffect(() => {\n    if (!pauseState || pauseState.canPause || !pauseState.cooldownRemaining)\n      return;\n\n    const interval = setInterval(() => {\n      setPauseState((prev) => {\n        if (!prev || prev.canPause || !prev.cooldownRemaining) return prev;\n\n        const newCooldown = Math.max(0, prev.cooldownRemaining - 1);\n\n        if (newCooldown === 0) {\n          // Cooldown expired, refresh from server\n          refreshPauseState();\n          return prev;\n        }\n\n        return {\n          ...prev,\n          cooldownRemaining: newCooldown,\n        };\n      });\n    }, 1000);\n\n    return () => clearInterval(interval);\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [pauseState, refreshPauseState]);\n\n  return {\n    pauseState,\n    isLoading,\n    error,\n    refreshPauseState,\n    canPause: pauseState?.canPause ?? false,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRelationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useRulesPage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionPersistence.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSessionPersistence' has too many lines (133). Maximum allowed is 75.",
        "line": 38,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 202,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Session Persistence Hook\n * Provides React integration for session persistence functionality\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { sessionPersistenceService } from \"../services\";\nimport type {\n  SessionRestorationResult,\n  SessionPersistenceState,\n} from \"../services/SessionPersistenceService\";\nimport type { DBSession } from \"../types/database\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"useSessionPersistence\");\n\nexport interface UseSessionPersistenceOptions {\n  userId?: string;\n  autoInitialize?: boolean;\n}\n\nexport interface UseSessionPersistenceReturn {\n  isInitializing: boolean;\n  restorationResult: SessionRestorationResult | null;\n  error: string | null;\n  isSessionRestored: boolean;\n\n  // Actions\n  initializeSession: (userId: string) => Promise<SessionRestorationResult>;\n  backupSession: (session: DBSession) => Promise<void>;\n  startHeartbeat: (sessionId: string) => void;\n  stopHeartbeat: () => void;\n  detectAndRecover: (userId: string) => Promise<SessionRestorationResult>;\n\n  // State getters\n  getBackupState: () => SessionPersistenceState | null;\n}\n\nexport function useSessionPersistence(\n  options: UseSessionPersistenceOptions = {},\n): UseSessionPersistenceReturn {\n  const { userId, autoInitialize = true } = options;\n\n  const [isInitializing, setIsInitializing] = useState(false);\n  const [restorationResult, setRestorationResult] =\n    useState<SessionRestorationResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [isSessionRestored, setIsSessionRestored] = useState(false);\n\n  // Initialize session persistence when userId is available\n  const initializeSession = useCallback(\n    async (targetUserId: string): Promise<SessionRestorationResult> => {\n      try {\n        setIsInitializing(true);\n        setError(null);\n\n        logger.debug(\"Initializing session persistence\", {\n          userId: targetUserId,\n        });\n\n        const result =\n          await sessionPersistenceService.initializeSessionState(targetUserId);\n        setRestorationResult(result);\n        setIsSessionRestored(result.wasRestored);\n\n        if (!result.success && result.error) {\n          setError(result.error);\n        }\n\n        logger.debug(\"Session persistence initialized\", {\n          userId: targetUserId,\n          wasRestored: result.wasRestored,\n          success: result.success,\n        });\n\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        logger.error(\"Failed to initialize session persistence\", {\n          error: err as Error,\n          userId: targetUserId,\n        });\n\n        return {\n          success: false,\n          error: errorMessage,\n          wasRestored: false,\n        };\n      } finally {\n        setIsInitializing(false);\n      }\n    },\n    [],\n  );\n\n  // Backup session state\n  const backupSession = useCallback(\n    async (session: DBSession): Promise<void> => {\n      try {\n        await sessionPersistenceService.backupSessionState(session);\n        logger.debug(\"Session backed up\", { sessionId: session.id });\n      } catch (err) {\n        logger.error(\"Failed to backup session\", {\n          error: err as Error,\n          sessionId: session.id,\n        });\n        throw err;\n      }\n    },\n    [],\n  );\n\n  // Start heartbeat\n  const startHeartbeat = useCallback((sessionId: string): void => {\n    sessionPersistenceService.startHeartbeat(sessionId);\n    logger.debug(\"Heartbeat started\", { sessionId });\n  }, []);\n\n  // Stop heartbeat\n  const stopHeartbeat = useCallback((): void => {\n    sessionPersistenceService.stopHeartbeat();\n    logger.debug(\"Heartbeat stopped\");\n  }, []);\n\n  // Detect and recover from interruptions\n  const detectAndRecover = useCallback(\n    async (targetUserId: string): Promise<SessionRestorationResult> => {\n      try {\n        logger.debug(\"Detecting and recovering session\", {\n          userId: targetUserId,\n        });\n\n        const result =\n          await sessionPersistenceService.detectAndRecover(targetUserId);\n\n        if (result.wasRestored) {\n          setRestorationResult(result);\n          setIsSessionRestored(true);\n        }\n\n        return result;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        logger.error(\"Failed to detect and recover session\", {\n          error: err as Error,\n          userId: targetUserId,\n        });\n\n        return {\n          success: false,\n          error: errorMessage,\n          wasRestored: false,\n        };\n      }\n    },\n    [],\n  );\n\n  // Get current backup state\n  const getBackupState = useCallback((): SessionPersistenceState | null => {\n    return sessionPersistenceService.getBackupState();\n  }, []);\n\n  // Auto-initialize when userId is provided\n  useEffect(() => {\n    if (autoInitialize && userId && !isInitializing && !restorationResult) {\n      initializeSession(userId);\n    }\n  }, [\n    userId,\n    autoInitialize,\n    isInitializing,\n    restorationResult,\n    initializeSession,\n  ]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopHeartbeat();\n    };\n  }, [stopHeartbeat]);\n\n  return {\n    isInitializing,\n    restorationResult,\n    error,\n    isSessionRestored,\n\n    // Actions\n    initializeSession,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n    detectAndRecover,\n\n    // State getters\n    getBackupState,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSessionTimer.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useSessionTimer' has too many lines (89). Maximum allowed is 75.",
        "line": 42,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 151,
        "endColumn": 2
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 81,
        "column": 42,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [2485, 2562], "text": " " }
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Function 'useMultiSessionTimer' has too many lines (94). Maximum allowed is 75.",
        "line": 166,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 271,
        "endColumn": 2
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 201,
        "column": 53,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [6065, 6142], "text": " " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 2,
    "source": "/**\n * Session Timer Hook\n * Provides real-time timer updates for active chastity sessions\n */\nimport { useState, useEffect, useMemo, useRef } from \"react\";\nimport type { DBSession } from \"../types/database\";\nimport { TimerService } from \"../services/TimerService\";\n\nexport interface SessionTimerData {\n  // Core timer values\n  effectiveTime: number; // Time in seconds excluding pauses\n  totalElapsedTime: number; // Total time including pauses\n  currentPauseDuration: number; // Current pause duration if paused\n\n  // Formatted strings\n  effectiveTimeFormatted: string;\n  totalElapsedTimeFormatted: string;\n  currentPauseDurationFormatted: string;\n\n  // Goal-related data\n  goalProgress: number; // Percentage (0-100)\n  remainingGoalTime: number; // Seconds remaining to goal\n  remainingGoalTimeFormatted: string;\n  isGoalCompleted: boolean;\n\n  // State flags\n  isActive: boolean; // Session exists and not ended\n  isPaused: boolean;\n\n  // Current time reference\n  currentTime: Date;\n}\n\nexport interface UseSessionTimerOptions {\n  updateInterval?: number; // Milliseconds, default 1000\n  enabled?: boolean; // Enable/disable timer updates, default true\n}\n\n/**\n * Hook for real-time session timer with live updates\n */\nexport function useSessionTimer(\n  session: DBSession | null | undefined,\n  options: UseSessionTimerOptions = {},\n): SessionTimerData {\n  const { updateInterval = 1000, enabled = true } = options;\n\n  const [currentTime, setCurrentTime] = useState(() => new Date());\n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Track session state changes manually to avoid zustand warnings\n  const sessionId = session?.id;\n  const sessionEndTime = session?.endTime;\n  const isSessionActive = enabled && sessionId && !sessionEndTime;\n\n  // Update current time every second\n  useEffect(() => {\n    if (!isSessionActive) {\n      // Clear interval if timer is disabled or session is not active\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n      return;\n    }\n\n    const updateCurrentTime = () => {\n      setCurrentTime(new Date());\n    };\n\n    // Set up interval\n    intervalRef.current = setInterval(updateCurrentTime, updateInterval);\n\n    // Cleanup on unmount or dependency change\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [isSessionActive, updateInterval]); // eslint-disable-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n\n  // Memoized calculations to prevent unnecessary recalculations\n  const timerData = useMemo((): SessionTimerData => {\n    // Default values when no session or session ended\n    const defaultData: SessionTimerData = {\n      effectiveTime: 0,\n      totalElapsedTime: 0,\n      currentPauseDuration: 0,\n      effectiveTimeFormatted: \"0s\",\n      totalElapsedTimeFormatted: \"0s\",\n      currentPauseDurationFormatted: \"0s\",\n      goalProgress: 0,\n      remainingGoalTime: 0,\n      remainingGoalTimeFormatted: \"0s\",\n      isGoalCompleted: false,\n      isActive: false,\n      isPaused: false,\n      currentTime,\n    };\n\n    if (!session || session.endTime) {\n      return defaultData;\n    }\n\n    // Calculate timer values\n    const effectiveTime = TimerService.calculateEffectiveTime(\n      session,\n      currentTime,\n    );\n    const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n      session,\n      currentTime,\n    );\n    const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n      session,\n      currentTime,\n    );\n\n    // Calculate goal-related data\n    const goalProgress = TimerService.calculateGoalProgress(\n      session,\n      currentTime,\n    );\n    const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n      session,\n      currentTime,\n    );\n    const isGoalCompleted = TimerService.isGoalCompleted(session, currentTime);\n\n    return {\n      effectiveTime,\n      totalElapsedTime,\n      currentPauseDuration,\n      effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n      totalElapsedTimeFormatted: TimerService.formatDuration(totalElapsedTime),\n      currentPauseDurationFormatted:\n        TimerService.formatDuration(currentPauseDuration),\n      goalProgress,\n      remainingGoalTime,\n      remainingGoalTimeFormatted:\n        TimerService.formatDuration(remainingGoalTime),\n      isGoalCompleted,\n      isActive: true,\n      isPaused: session.isPaused,\n      currentTime,\n    };\n  }, [session, currentTime]);\n\n  return timerData;\n}\n\n/**\n * Hook for getting a snapshot of timer data without live updates\n * Useful for components that don't need real-time updates\n */\nexport function useSessionTimerSnapshot(\n  session: DBSession | null | undefined,\n): SessionTimerData {\n  return useSessionTimer(session, { enabled: false });\n}\n\n/**\n * Hook for multiple sessions timer data (useful for dashboards)\n */\nexport function useMultiSessionTimer(\n  sessions: (DBSession | null | undefined)[],\n  options: UseSessionTimerOptions = {},\n): SessionTimerData[] {\n  const [currentTime, setCurrentTime] = useState(() => new Date());\n  const { updateInterval = 1000, enabled = true } = options;\n  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n\n  // Check if we have any active sessions\n  const hasActiveSessions = useMemo(() => {\n    return sessions.some((session) => session && !session.endTime);\n  }, [sessions]);\n\n  // Update current time for all sessions\n  useEffect(() => {\n    if (!enabled || !hasActiveSessions) {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n      return;\n    }\n\n    const updateCurrentTime = () => {\n      setCurrentTime(new Date());\n    };\n\n    intervalRef.current = setInterval(updateCurrentTime, updateInterval);\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [enabled, hasActiveSessions, updateInterval]); // eslint-disable-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n\n  // Calculate timer data for each session\n  const timerDataArray = useMemo(() => {\n    return sessions.map((session) => {\n      if (!session || session.endTime) {\n        return {\n          effectiveTime: 0,\n          totalElapsedTime: 0,\n          currentPauseDuration: 0,\n          effectiveTimeFormatted: \"0s\",\n          totalElapsedTimeFormatted: \"0s\",\n          currentPauseDurationFormatted: \"0s\",\n          goalProgress: 0,\n          remainingGoalTime: 0,\n          remainingGoalTimeFormatted: \"0s\",\n          isGoalCompleted: false,\n          isActive: false,\n          isPaused: false,\n          currentTime,\n        };\n      }\n\n      const effectiveTime = TimerService.calculateEffectiveTime(\n        session,\n        currentTime,\n      );\n      const totalElapsedTime = TimerService.calculateTotalElapsedTime(\n        session,\n        currentTime,\n      );\n      const currentPauseDuration = TimerService.calculateCurrentPauseDuration(\n        session,\n        currentTime,\n      );\n      const goalProgress = TimerService.calculateGoalProgress(\n        session,\n        currentTime,\n      );\n      const remainingGoalTime = TimerService.calculateRemainingGoalTime(\n        session,\n        currentTime,\n      );\n      const isGoalCompleted = TimerService.isGoalCompleted(\n        session,\n        currentTime,\n      );\n\n      return {\n        effectiveTime,\n        totalElapsedTime,\n        currentPauseDuration,\n        effectiveTimeFormatted: TimerService.formatDuration(effectiveTime),\n        totalElapsedTimeFormatted:\n          TimerService.formatDuration(totalElapsedTime),\n        currentPauseDurationFormatted:\n          TimerService.formatDuration(currentPauseDuration),\n        goalProgress,\n        remainingGoalTime,\n        remainingGoalTimeFormatted:\n          TimerService.formatDuration(remainingGoalTime),\n        isGoalCompleted,\n        isActive: true,\n        isPaused: session.isPaused,\n        currentTime,\n      };\n    });\n  }, [sessions, currentTime]);\n\n  return timerDataArray;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSpecialChallenges.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (195). Maximum allowed is 75.",
        "line": 27,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 268,
        "endColumn": 2
      },
      {
        "ruleId": null,
        "message": "Unused eslint-disable directive (no problems were reported from 'zustand-safe-patterns/zustand-no-store-actions-in-deps').",
        "line": 236,
        "column": 5,
        "severity": 1,
        "nodeType": null,
        "fix": { "range": [6628, 6710], "text": " " }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 1,
    "source": "import { useState, useEffect, useCallback } from \"react\";\nimport { goalDBService } from \"@/services/database/GoalDBService\";\nimport type { DBGoal } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { useAchievementIntegration } from \"@/constants/challengeAchievements\";\n\nconst logger = serviceLogger(\"useSpecialChallenges\");\n\nexport interface SpecialChallengeStatus {\n  locktober: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n  noNutNovember: {\n    available: boolean;\n    active: boolean;\n    completed: boolean;\n    goal?: DBGoal;\n  };\n}\n\n/**\n * Hook for managing special challenge goals (Locktober, No Nut November)\n */\nexport const useSpecialChallenges = (userId: string | null) => {\n  const [challengeStatus, setChallengeStatus] =\n    useState<SpecialChallengeStatus>({\n      locktober: { available: false, active: false, completed: false },\n      noNutNovember: { available: false, active: false, completed: false },\n    });\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const { checkForChallengeAchievements } = useAchievementIntegration();\n\n  /**\n   * Check if challenges are available based on current date\n   */\n  const checkChallengeAvailability = useCallback(() => {\n    const currentDate = new Date();\n    const currentMonth = currentDate.getMonth(); // 0-based\n\n    return {\n      locktober: currentMonth === 9, // October\n      noNutNovember: currentMonth === 10, // November\n    };\n  }, []);\n\n  /**\n   * Load challenge status for the user\n   */\n  const loadChallengeStatus = useCallback(async () => {\n    if (!userId) {\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const availability = checkChallengeAvailability();\n      const specialGoals = await goalDBService.getSpecialChallengeGoals(userId);\n      const currentYear = new Date().getFullYear();\n\n      // Find current year's goals\n      const locktoberGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"locktober\" &&\n          goal.challengeYear === currentYear,\n      );\n      const noNutGoal = specialGoals.find(\n        (goal) =>\n          goal.challengeType === \"no_nut_november\" &&\n          goal.challengeYear === currentYear,\n      );\n\n      setChallengeStatus({\n        locktober: {\n          available: availability.locktober,\n          active: !!locktoberGoal && !locktoberGoal.isCompleted,\n          completed: !!locktoberGoal?.isCompleted,\n          goal: locktoberGoal,\n        },\n        noNutNovember: {\n          available: availability.noNutNovember,\n          active: !!noNutGoal && !noNutGoal.isCompleted,\n          completed: !!noNutGoal?.isCompleted,\n          goal: noNutGoal,\n        },\n      });\n\n      logger.debug(\"Loaded challenge status\", {\n        userId,\n        hasLocktober: !!locktoberGoal,\n        hasNoNut: !!noNutGoal,\n      });\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Unknown error\";\n      setError(errorMessage);\n      logger.error(\"Failed to load challenge status\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, checkChallengeAvailability]);\n\n  /**\n   * Join a special challenge\n   */\n  const joinChallenge = useCallback(\n    async (challengeType: \"locktober\" | \"no_nut_november\") => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        setError(null);\n        const goal = await goalDBService.getOrCreateChallengeGoal(\n          userId,\n          challengeType,\n        );\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"User joined challenge\", {\n          userId,\n          challengeType,\n          goalId: goal.id,\n        });\n        return goal;\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to join challenge\";\n        setError(errorMessage);\n        logger.error(\"Failed to join challenge\", {\n          error: err,\n          userId,\n          challengeType,\n        });\n        throw err;\n      }\n    },\n    [userId, loadChallengeStatus],\n  );\n\n  /**\n   * Update challenge progress\n   */\n  const updateChallengeProgress = useCallback(\n    async (\n      challengeType: \"locktober\" | \"no_nut_november\",\n      progressValue: number,\n    ) => {\n      if (!userId) {\n        throw new Error(\"User not authenticated\");\n      }\n\n      try {\n        const challengeMap = {\n          locktober: challengeStatus.locktober,\n          no_nut_november: challengeStatus.noNutNovember,\n        };\n        const challenge =\n          challengeMap[challengeType as keyof typeof challengeMap];\n        if (!challenge.goal) {\n          throw new Error(\"Challenge goal not found\");\n        }\n\n        await goalDBService.updateGoalProgress(\n          challenge.goal.id,\n          progressValue,\n        );\n\n        // Check if challenge was completed and trigger achievements\n        const updatedGoal = await goalDBService.findById(challenge.goal.id);\n        if (updatedGoal?.isCompleted) {\n          await checkForChallengeAchievements({\n            challengeType: updatedGoal.challengeType,\n            challengeYear: updatedGoal.challengeYear,\n            isCompleted: updatedGoal.isCompleted,\n          });\n        }\n\n        // Refresh status\n        await loadChallengeStatus();\n\n        logger.info(\"Updated challenge progress\", {\n          userId,\n          challengeType,\n          progressValue,\n          goalId: challenge.goal.id,\n        });\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Failed to update progress\";\n        setError(errorMessage);\n        logger.error(\"Failed to update challenge progress\", {\n          error: err,\n          userId,\n          challengeType,\n          progressValue,\n        });\n        throw err;\n      }\n    },\n    [\n      userId,\n      challengeStatus,\n      loadChallengeStatus,\n      checkForChallengeAchievements,\n    ],\n  );\n\n  /**\n   * Get progress percentage for a challenge\n   */\n  const getChallengeProgress = useCallback(\n    (challengeType: \"locktober\" | \"no_nut_november\") => {\n      const challenge = challengeStatus[challengeType];\n      if (!challenge.goal) return 0;\n\n      return Math.min(\n        100,\n        (challenge.goal.currentValue / challenge.goal.targetValue) * 100,\n      );\n    },\n    [challengeStatus],\n  );\n\n  // Load challenge status on mount and when userId changes\n  useEffect(() => {\n    loadChallengeStatus();\n    // eslint-disable-next-line zustand-safe-patterns/zustand-no-store-actions-in-deps\n  }, [userId, checkChallengeAvailability, loadChallengeStatus]);\n\n  // Refresh status every hour to check for date changes\n  useEffect(() => {\n    const interval = setInterval(\n      () => {\n        const availability = checkChallengeAvailability();\n        setChallengeStatus((prev) => ({\n          ...prev,\n          locktober: { ...prev.locktober, available: availability.locktober },\n          noNutNovember: {\n            ...prev.noNutNovember,\n            available: availability.noNutNovember,\n          },\n        }));\n      },\n      60 * 60 * 1000,\n    ); // Check every hour\n\n    return () => clearInterval(interval);\n  }, [checkChallengeAvailability]);\n\n  return {\n    challengeStatus,\n    isLoading,\n    error,\n    joinChallenge,\n    updateChallengeProgress,\n    getChallengeProgress,\n    refreshStatus: loadChallengeStatus,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useSync.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (99). Maximum allowed is 75.",
        "line": 27,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 154,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useSync Hook\n * Manages synchronization state and conflict resolution\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { SyncResult, ConflictInfo, SyncOptions } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSync\");\n\ninterface UseSyncState {\n  isSyncing: boolean;\n  lastSyncResult: SyncResult | null;\n  pendingConflicts: ConflictInfo[];\n  error: Error | null;\n}\n\ninterface UseSyncActions {\n  sync: (userId: string, options?: SyncOptions) => Promise<SyncResult>;\n  resolveConflicts: (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => Promise<void>;\n  clearError: () => void;\n}\n\nexport const useSync = (): UseSyncState & UseSyncActions => {\n  const [state, setState] = useState<UseSyncState>({\n    isSyncing: false,\n    lastSyncResult: null,\n    pendingConflicts: [],\n    error: null,\n  });\n\n  // Check for pending conflicts on mount\n  useEffect(() => {\n    const checkPendingConflicts = () => {\n      const conflicts = firebaseSync.getPendingConflicts();\n      setState((prev) => ({ ...prev, pendingConflicts: conflicts }));\n    };\n\n    checkPendingConflicts();\n\n    // Check periodically for conflicts\n    const interval = setInterval(checkPendingConflicts, 30000); // Every 30 seconds\n\n    return () => clearInterval(interval);\n  }, []);\n\n  const sync = useCallback(\n    async (userId: string, options?: SyncOptions): Promise<SyncResult> => {\n      setState((prev) => ({ ...prev, isSyncing: true, error: null }));\n\n      try {\n        logger.info(\"Starting sync\", { userId, options });\n        const result = await firebaseSync.syncUserData(userId, options);\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          lastSyncResult: result,\n          pendingConflicts:\n            result.conflicts.length > 0\n              ? result.conflicts\n              : prev.pendingConflicts,\n        }));\n\n        logger.info(\"Sync completed\", {\n          success: result.success,\n          conflicts: result.conflicts.length,\n        });\n\n        return result;\n      } catch (error) {\n        const err = error as Error;\n        logger.error(\"Sync failed\", { error: err });\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          error: err,\n        }));\n\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const resolveConflicts = useCallback(\n    async (resolutions: Record<string, \"local\" | \"remote\">): Promise<void> => {\n      try {\n        logger.info(\"Resolving conflicts\", {\n          resolutionCount: Object.keys(resolutions).length,\n        });\n\n        // Apply resolutions (implementation would depend on specific conflict resolution logic)\n        const resolvedIds: string[] = [];\n\n        for (const [conflictKey, resolution] of Object.entries(resolutions)) {\n          // conflictKey format: \"collection-documentId-index\" or similar\n          const conflict = state.pendingConflicts.find(\n            (c) =>\n              `${c.collection}-${c.documentId}` ===\n              conflictKey.split(\"-\").slice(0, 2).join(\"-\"),\n          );\n\n          if (conflict) {\n            // Apply the chosen resolution\n            const dataToApply =\n              resolution === \"local\" ? conflict.localData : conflict.remoteData;\n\n            // Update both local and remote with chosen data\n            await firebaseSync.applyRemoteChanges(conflict.collection, [\n              dataToApply,\n            ]);\n\n            resolvedIds.push(`${conflict.collection}-${conflict.documentId}`);\n          }\n        }\n\n        // Clear resolved conflicts\n        firebaseSync.clearResolvedConflicts(resolvedIds);\n\n        setState((prev) => ({\n          ...prev,\n          pendingConflicts: prev.pendingConflicts.filter(\n            (c) => !resolvedIds.includes(`${c.collection}-${c.documentId}`),\n          ),\n        }));\n\n        logger.info(\"Conflicts resolved\", {\n          resolvedCount: resolvedIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n        setState((prev) => ({ ...prev, error: error as Error }));\n        throw error;\n      }\n    },\n    [state.pendingConflicts],\n  );\n\n  const clearError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  return {\n    ...state,\n    sync,\n    resolveConflicts,\n    clearError,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/hooks/useTrackerHandlers.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'setCurrentSession'. Either include it or remove the dependency array. If 'setCurrentSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 77,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 77,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [setCurrentSession]",
            "fix": { "range": [2443, 2445], "text": "[setCurrentSession]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'backupSession'. Either include it or remove the dependency array. If 'backupSession' changes too often, find the parent component that defines it and wrap that definition in useCallback.",
        "line": 88,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 88,
        "endColumn": 44,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [backupSession, currentSession, isSessionInitialized]",
            "fix": {
              "range": [2846, 2884],
              "text": "[backupSession, currentSession, isSessionInitialized]"
            }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/AchievementPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/ChastityTracking.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (162). Maximum allowed is 75.",
        "line": 226,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 414,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from \"react\";\nimport { RestoreSessionPrompt } from \"../components/tracker/RestoreSessionPrompt\";\nimport { SessionLoader } from \"../components/tracker/SessionLoader\";\nimport { SessionRecoveryModal } from \"../components/tracker/SessionRecoveryModal\";\nimport { TrackerStats } from \"../components/tracker/TrackerStats\";\nimport { ActionButtons } from \"../components/tracker/ActionButtons\";\nimport { PauseResumeButtons } from \"../components/tracker/PauseResumeButtons\";\n// TODO: CooldownTimer temporarily disabled due to service import restrictions\n// import { CooldownTimer } from \"../components/tracker/CooldownTimer\";\nimport { ReasonModals } from \"../components/tracker/ReasonModals\";\nimport { TrackerHeader } from \"../components/tracker/TrackerHeader\";\nimport { useSessionPersistence } from \"../hooks/useSessionPersistence\";\nimport { useAuth } from \"../hooks/api/useAuth\";\nimport { useTrackerHandlers } from \"../hooks/useTrackerHandlers\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession } from \"../types/database\";\nimport type { SessionRestorationResult } from \"../services/SessionPersistenceService\";\nimport type { User } from \"../types/auth\";\n\n// Helper function to handle session restoration\nconst createSessionRestorationHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    startHeartbeat: (sessionId: string) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n  ) =>\n  (result: SessionRestorationResult) => {\n    logger.info(\"Session restoration completed\", {\n      wasRestored: result.wasRestored,\n      sessionId: result.session?.id,\n    });\n\n    if (result.session) {\n      setCurrentSession(result.session);\n      startHeartbeat(result.session.id);\n\n      // If session had validation issues but was recovered, show recovery modal\n      if (result.error && result.session) {\n        setCorruptedSession(result.session);\n        setShowSessionRecovery(true);\n      }\n    }\n  };\n\n// Helper function to handle session recovery\nconst createSessionRecoveryHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    backupSession: (session: DBSession) => Promise<void>,\n    startHeartbeat: (sessionId: string) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n  ) =>\n  async (session: DBSession) => {\n    logger.info(\"Session recovery initiated\", { sessionId: session.id });\n    try {\n      await backupSession(session);\n      setCurrentSession(session);\n      startHeartbeat(session.id);\n      setShowSessionRecovery(false);\n      setCorruptedSession(null);\n      logger.info(\"Session recovery completed\", { sessionId: session.id });\n    } catch (error) {\n      logger.error(\"Session recovery failed\", { error: error as Error });\n    }\n  };\n\n// Helper function to handle session discard\nconst createSessionDiscardHandler =\n  (\n    setCurrentSession: (session: DBSession | null) => void,\n    setShowSessionRecovery: (show: boolean) => void,\n    setCorruptedSession: (session: DBSession | null) => void,\n    stopHeartbeat: () => void,\n  ) =>\n  () => {\n    setCurrentSession(null);\n    setShowSessionRecovery(false);\n    setCorruptedSession(null);\n    stopHeartbeat();\n    logger.info(\"Corrupted session discarded\");\n  };\n\n// Session Persistence Error Component\nconst SessionPersistenceError: React.FC<{ error: string }> = ({ error }) => (\n  <div className=\"mx-4 mb-4 p-3 bg-red-900/50 border border-red-500 rounded-lg\">\n    <p className=\"text-sm text-red-200\">\n      <strong>Session Error:</strong> {error}\n    </p>\n  </div>\n);\n\n// Cooldown Display Component\nconst CooldownDisplay: React.FC<{\n  pauseState: { cooldownRemaining?: number } | null;\n}> = ({ pauseState }) => {\n  if (!pauseState?.cooldownRemaining) return null;\n\n  return (\n    <div className=\"mx-4 text-center\">\n      <div className=\"text-yellow-600\">\n        Cooldown: {pauseState.cooldownRemaining}s remaining\n      </div>\n    </div>\n  );\n};\n\n// Debug Panel Component\ninterface PauseState {\n  canPause: boolean;\n  cooldownRemaining?: number;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n}\n\nconst DebugPanel: React.FC<{\n  pauseState: PauseState | null;\n  pauseStateLoading: boolean;\n  pauseStateError: string | null;\n}> = ({ pauseState, pauseStateLoading, pauseStateError }) => {\n  if (process.env.NODE_ENV !== \"development\") return null;\n\n  return (\n    <div className=\"mt-8 p-4 bg-gray-800 rounded-lg text-xs\">\n      <h4 className=\"text-yellow-400 font-bold mb-2\">Debug: Pause State</h4>\n      <pre className=\"text-gray-300\">\n        {JSON.stringify(\n          {\n            canPause: pauseState?.canPause,\n            cooldownRemaining: pauseState?.cooldownRemaining,\n            lastPauseTime: pauseState?.lastPauseTime,\n            nextPauseAvailable: pauseState?.nextPauseAvailable,\n            isLoading: pauseStateLoading,\n            error: pauseStateError,\n          },\n          null,\n          2,\n        )}\n      </pre>\n    </div>\n  );\n};\n\n// Custom hook for session state management\nconst useSessionState = () => {\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [showSessionRecovery, setShowSessionRecovery] = useState(false);\n  const [isSessionInitialized, setIsSessionInitialized] = useState(false);\n  const [corruptedSession, setCorruptedSession] = useState<DBSession | null>(\n    null,\n  );\n\n  return {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  };\n};\n\n// Custom hook for mock data (temporary until real implementation)\nconst useMockData = (user: User | null) => {\n  // Mock pause state data for now\n  const pauseState: PauseState = {\n    canPause: true,\n    cooldownRemaining: undefined,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n  };\n  const pauseStateLoading = false;\n  const pauseStateError = null;\n  const refreshPauseState = () => {};\n\n  // Mock session data - replace with real session management\n  const mockSessionData = {\n    isCageOn: true,\n    isPaused: false,\n    remainingGoalTime: 3600,\n    keyholderName: \"Keyholder\",\n    savedSubmissivesName: \"Submissive\",\n    requiredKeyholderDurationSeconds: 7200,\n    mainChastityDisplayTime: 3600,\n    topBoxLabel: \"Total Locked Time\",\n    topBoxTime: \"1d 2h 3m\",\n    livePauseDuration: 0,\n    accumulatedPauseTimeThisSession: 0,\n    timeCageOff: 0,\n    totalChastityTime: 86400,\n    totalTimeCageOff: 0,\n    showRestoreSessionPrompt: false,\n    pauseCooldownMessage: null,\n    denialCooldownActive: false,\n    hasPendingReleaseRequest: false,\n    isGoalActive: true,\n    isHardcoreGoal: false,\n    showReasonModal: false,\n    showPauseReasonModal: false,\n    useRealTimeTimer: false, // Feature flag for real-time timer\n    sessionId: \"mock-session-123\",\n    userId: user?.uid || \"mock-user-123\",\n  };\n\n  // Override pause state for demo - show that pause is available\n  const mockPauseState = {\n    canPause: true,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n    cooldownRemaining: undefined,\n  };\n\n  return {\n    pauseState,\n    pauseStateLoading,\n    pauseStateError,\n    refreshPauseState,\n    ...mockSessionData,\n    mockPauseState,\n  };\n};\n\nconst TrackerPage: React.FC = () => {\n  // Authentication state\n  const { user, isLoading: authLoading } = useAuth();\n\n  // Session persistence state\n  const {\n    isInitializing,\n    error: persistenceError,\n    backupSession,\n    startHeartbeat,\n    stopHeartbeat,\n  } = useSessionPersistence({\n    userId: user?.uid,\n    autoInitialize: true,\n  });\n\n  // Session state management\n  const {\n    currentSession,\n    setCurrentSession,\n    showSessionRecovery,\n    setShowSessionRecovery,\n    isSessionInitialized,\n    setIsSessionInitialized,\n    corruptedSession,\n    setCorruptedSession,\n  } = useSessionState();\n\n  // Mock data (replace with real hooks)\n  const mockData = useMockData(user);\n\n  // Use tracker handlers hook for event handlers and effects\n  const {\n    handleSessionInitialized,\n    handleEmergencyUnlock,\n    handlePause,\n    handleResume,\n  } = useTrackerHandlers({\n    setCurrentSession,\n    setIsSessionInitialized,\n    startHeartbeat,\n    stopHeartbeat,\n    backupSession,\n    mockData: {\n      sessionId: mockData.sessionId,\n      userId: mockData.userId,\n      refreshPauseState: mockData.refreshPauseState,\n    },\n    currentSession,\n    isSessionInitialized,\n  });\n\n  // Create handlers using helper functions\n  const handleSessionRestored = createSessionRestorationHandler(\n    setCurrentSession,\n    startHeartbeat,\n    setCorruptedSession,\n    setShowSessionRecovery,\n  );\n\n  const handleRecoverSession = createSessionRecoveryHandler(\n    setCurrentSession,\n    backupSession,\n    startHeartbeat,\n    setShowSessionRecovery,\n    setCorruptedSession,\n  );\n\n  const handleDiscardSession = createSessionDiscardHandler(\n    setCurrentSession,\n    setShowSessionRecovery,\n    setCorruptedSession,\n    stopHeartbeat,\n  );\n\n  // Helper to compute TrackerStats props based on timer mode\n  const getTrackerStatsProps = () => {\n    const baseProps = {\n      topBoxLabel: mockData.topBoxLabel,\n      timeCageOff: mockData.timeCageOff,\n      isCageOn: mockData.isCageOn,\n      totalChastityTime: mockData.totalChastityTime,\n      totalTimeCageOff: mockData.totalTimeCageOff,\n      isPaused: mockData.isPaused,\n    };\n\n    if (mockData.useRealTimeTimer) {\n      return {\n        ...baseProps,\n        currentSession,\n        mainChastityDisplayTime: undefined,\n        topBoxTime: undefined,\n        livePauseDuration: undefined,\n        accumulatedPauseTimeThisSession: undefined,\n      };\n    }\n\n    return {\n      ...baseProps,\n      currentSession: undefined,\n      mainChastityDisplayTime: mockData.mainChastityDisplayTime,\n      topBoxTime: mockData.topBoxTime,\n      livePauseDuration: mockData.livePauseDuration,\n      accumulatedPauseTimeThisSession: mockData.accumulatedPauseTimeThisSession,\n    };\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Session Persistence Loading */}\n      {(authLoading || isInitializing) && user?.uid && (\n        <SessionLoader\n          userId={user.uid}\n          onSessionRestored={handleSessionRestored}\n          onInitialized={handleSessionInitialized}\n        />\n      )}\n\n      {/* Session Recovery Modal */}\n      {showSessionRecovery && corruptedSession && (\n        <SessionRecoveryModal\n          corruptedSession={corruptedSession}\n          onRecover={handleRecoverSession}\n          onDiscard={handleDiscardSession}\n        />\n      )}\n\n      {/* Session Persistence Error */}\n      {persistenceError && <SessionPersistenceError error={persistenceError} />}\n\n      {mockData.showRestoreSessionPrompt && (\n        <RestoreSessionPrompt onConfirm={() => {}} onDiscard={() => {}} />\n      )}\n\n      <TrackerHeader\n        remainingGoalTime={mockData.remainingGoalTime}\n        keyholderName={mockData.keyholderName}\n        savedSubmissivesName={mockData.savedSubmissivesName}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        isCageOn={mockData.isCageOn}\n        denialCooldownActive={mockData.denialCooldownActive}\n        pauseCooldownMessage={mockData.pauseCooldownMessage}\n      />\n\n      <TrackerStats {...getTrackerStatsProps()} />\n\n      {/* Enhanced Pause Controls with 4-hour cooldown */}\n      {mockData.isCageOn && currentSession && (\n        <>\n          <CooldownDisplay pauseState={mockData.pauseState} />\n          <PauseResumeButtons\n            sessionId={currentSession.id}\n            userId={user?.uid || \"\"}\n            isPaused={mockData.isPaused}\n            pauseState={mockData.mockPauseState} // Use mock state to show functionality\n            onPause={handlePause}\n            onResume={handleResume}\n          />\n        </>\n      )}\n\n      <ActionButtons\n        isCageOn={mockData.isCageOn}\n        isGoalActive={mockData.isGoalActive}\n        isHardcoreGoal={mockData.isHardcoreGoal}\n        requiredKeyholderDurationSeconds={\n          mockData.requiredKeyholderDurationSeconds\n        }\n        hasPendingReleaseRequest={mockData.hasPendingReleaseRequest}\n        sessionId={mockData.sessionId}\n        userId={mockData.userId}\n        onEmergencyUnlock={handleEmergencyUnlock}\n      />\n\n      <ReasonModals\n        showReasonModal={mockData.showReasonModal}\n        showPauseReasonModal={mockData.showPauseReasonModal}\n      />\n\n      <DebugPanel\n        pauseState={mockData.pauseState}\n        pauseStateLoading={mockData.pauseStateLoading}\n        pauseStateError={mockData.pauseStateError}\n      />\n    </div>\n  );\n};\n\nexport default TrackerPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/Dashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/FullReportPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/KeyholderPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/LogEventPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/MobileShowcase.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/PublicProfilePage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RelationshipsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RewardsPunishmentsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/RulesPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsMainPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/SettingsPage.tsx",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (89). Maximum allowed is 75.",
        "line": 473,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 569,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { settingsDBService } from \"../services/database\";\nimport type { DBSettings } from \"../types/database\";\nimport { logger } from \"../utils/logging\";\nimport {\n  FaUser,\n  FaPalette,\n  FaGlobe,\n  FaBullseye,\n  FaCog,\n  FaDatabase,\n  FaDownload,\n  FaUpload,\n  FaTrash,\n  FaSpinner,\n  FaShieldAlt,\n} from \"../utils/iconImport\";\nimport { ToggleSwitch } from \"../components/settings/ToggleSwitch\";\nimport { ResetModal } from \"../components/settings/ResetModal\";\nimport { SecuritySettings } from \"../components/settings/SecuritySettings\";\nimport { DataControls } from \"../components/settings/DataControls\";\n\ntype SettingsTab =\n  | \"account\"\n  | \"display\"\n  | \"profile\"\n  | \"privacy\"\n  | \"goals\"\n  | \"sessions\"\n  | \"data\";\n\n// Account Settings Section\nconst AccountSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaUser className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Account Information\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Display Name\n          </label>\n          <input\n            type=\"text\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter display name\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Email\n          </label>\n          <input\n            type=\"email\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter email address\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Two-Factor Authentication\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Add extra security to your account\n            </div>\n          </div>\n          <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded transition-colors\">\n            Setup 2FA\n          </button>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Save Changes\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Display Settings Section\nconst DisplaySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaPalette className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Display Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Theme\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"dark\">Dark</option>\n            <option value=\"light\">Light</option>\n            <option value=\"auto\">Auto</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Language\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"en\">English</option>\n            <option value=\"es\">Spanish</option>\n            <option value=\"fr\">French</option>\n            <option value=\"de\">German</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Timezone\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"America/New_York\">Eastern Time</option>\n            <option value=\"America/Chicago\">Central Time</option>\n            <option value=\"America/Denver\">Mountain Time</option>\n            <option value=\"America/Los_Angeles\">Pacific Time</option>\n          </select>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Notifications\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Receive app notifications\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Public Profile Section\nconst ProfileSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaGlobe className=\"text-nightly-spring-green\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Public Profile\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Public Profile\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Make your profile visible to others\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Share Statistics\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Allow others to see your progress stats\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Bio\n          </label>\n          <textarea\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={3}\n            placeholder=\"Tell others about yourself...\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Profile URL\n          </label>\n          <div className=\"flex\">\n            <span className=\"bg-white/5 border border-white/10 border-r-0 rounded-l px-3 py-3 text-nightly-celadon text-sm\">\n              chastityos.com/profile/\n            </span>\n            <input\n              type=\"text\"\n              className=\"flex-1 bg-white/5 border border-white/10 rounded-r p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n              placeholder=\"your-username\"\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Privacy Settings Section\nconst PrivacySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaShieldAlt className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Privacy & Security\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <ToggleSwitch\n          label=\"Data Collection\"\n          description=\"Allow collection of usage analytics\"\n          checked={true}\n        />\n        <ToggleSwitch\n          label=\"Data Sharing\"\n          description=\"Share anonymous usage data to improve the app\"\n        />\n        <ToggleSwitch\n          label=\"Account Discoverable\"\n          description=\"Allow others to find your account by username\"\n          checked={true}\n        />\n        <ToggleSwitch\n          label=\"Show Activity Status\"\n          description=\"Let others see when you're active\"\n        />\n      </div>\n    </div>\n\n    <SecuritySettings />\n    <DataControls />\n  </div>\n);\n\n// Goals Section\nconst GoalsSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaBullseye className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Personal Goals\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Default Session Goal (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Goal Reminders\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Get notified about goal progress\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Create New Goal\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Session Settings Section\nconst SessionSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaCog className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Session Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Allow Emergency Unlock\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Enable emergency unlock feature\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Emergency Unlock Cooldown (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Require Keyholder Approval\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Sessions need keyholder approval to end\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Hardcore Mode\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Disable pause and emergency unlock\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-red-500\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Data Management Section\nconst DataSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings: _settings,\n}) => {\n  const [showResetModal, setShowResetModal] = useState(false);\n  const [resetStatus, setResetStatus] = useState<\n    \"idle\" | \"pending\" | \"success\" | \"error\"\n  >(\"idle\");\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <div className=\"flex items-center gap-3 mb-4\">\n          <FaDatabase className=\"text-nightly-spring-green\" />\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n            Data Management\n          </h3>\n        </div>\n\n        <div className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaDownload />\n              Export Data\n            </button>\n\n            <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaUpload />\n              Import Data\n            </button>\n          </div>\n\n          <div className=\"border-t border-white/10 pt-4\">\n            <div className=\"bg-red-500/10 border border-red-500/20 rounded-lg p-4\">\n              <h4 className=\"text-red-400 font-medium mb-2\">Danger Zone</h4>\n              <p className=\"text-nightly-celadon text-sm mb-4\">\n                Reset all data will permanently delete all your sessions, tasks,\n                goals, and settings. This action cannot be undone.\n              </p>\n              <button\n                onClick={() => setShowResetModal(true)}\n                className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n              >\n                <FaTrash />\n                Reset All Data\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Reset Modal */}\n      <ResetModal\n        show={showResetModal}\n        status={resetStatus}\n        onConfirm={() => {\n          setResetStatus(\"pending\");\n          setTimeout(() => {\n            setResetStatus(\"success\");\n            setTimeout(() => {\n              window.location.reload();\n            }, 2000);\n          }, 2000);\n        }}\n        onCancel={() => {\n          setShowResetModal(false);\n          setResetStatus(\"idle\");\n        }}\n      />\n    </div>\n  );\n};\n\nconst SettingsPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [settings, setSettings] = useState<DBSettings | null>(null);\n  const [activeTab, setActiveTab] = useState<SettingsTab>(\"account\");\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchSettings = async () => {\n      if (!user) return;\n\n      try {\n        setLoading(true);\n        // Try to get user settings\n        const userSettings = await settingsDBService.findByUserId(user.uid);\n        setSettings(userSettings[0] || null);\n      } catch (error) {\n        logger.error(\"Error fetching settings:\", error, \"SettingsPage\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchSettings();\n  }, [user]);\n\n  const tabs = [\n    { id: \"account\" as SettingsTab, label: \"Account\", icon: FaUser },\n    { id: \"display\" as SettingsTab, label: \"Display\", icon: FaPalette },\n    { id: \"profile\" as SettingsTab, label: \"Profile\", icon: FaGlobe },\n    { id: \"privacy\" as SettingsTab, label: \"Privacy\", icon: FaShieldAlt },\n    { id: \"goals\" as SettingsTab, label: \"Goals\", icon: FaBullseye },\n    { id: \"sessions\" as SettingsTab, label: \"Sessions\", icon: FaCog },\n    { id: \"data\" as SettingsTab, label: \"Data\", icon: FaDatabase },\n  ];\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"account\":\n        return <AccountSection settings={settings} />;\n      case \"display\":\n        return <DisplaySection settings={settings} />;\n      case \"profile\":\n        return <ProfileSection settings={settings} />;\n      case \"privacy\":\n        return <PrivacySection settings={settings} />;\n      case \"goals\":\n        return <GoalsSection settings={settings} />;\n      case \"sessions\":\n        return <SessionSection settings={settings} />;\n      case \"data\":\n        return <DataSection settings={settings} />;\n      default:\n        return <AccountSection settings={settings} />;\n    }\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      <div className=\"flex flex-col lg:flex-row\">\n        {/* Tab Navigation */}\n        <nav className=\"lg:w-64 p-4 border-b lg:border-b-0 lg:border-r border-white/10\">\n          <div className=\"space-y-2\">\n            {tabs.map((tab) => {\n              const Icon = tab.icon;\n              return (\n                <button\n                  key={tab.id}\n                  onClick={() => setActiveTab(tab.id)}\n                  className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg font-medium transition-colors ${\n                    activeTab === tab.id\n                      ? \"bg-nightly-aquamarine text-black\"\n                      : \"text-nightly-celadon hover:bg-white/10 hover:text-nightly-honeydew\"\n                  }`}\n                >\n                  <Icon />\n                  {tab.label}\n                </button>\n              );\n            })}\n          </div>\n        </nav>\n\n        {/* Content */}\n        <main className=\"flex-1 p-4 lg:p-6\">\n          {loading ? (\n            <div className=\"text-center py-8\">\n              <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n              <div className=\"text-nightly-celadon\">Loading settings...</div>\n            </div>\n          ) : (\n            <div className=\"max-w-4xl\">{renderTabContent()}</div>\n          )}\n        </main>\n      </div>\n    </div>\n  );\n};\n\nexport default SettingsPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/TasksPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ButtonVariantsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/HapticFeedbackDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/InputExamplesDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/PullToRefreshDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ShowcaseHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/SwipeableCardDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/ToastDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/pages/showcase/TouchTargetsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/AchievementIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/EffectiveTimeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/KeyholderRelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseCooldownService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/PauseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/SessionPersistenceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/TimerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/api/session-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/auth/auth-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/cache-config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/AchievementDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/BaseDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EmergencyService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/EventDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/GoalDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/KeyholderRelationshipDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/MigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/PerformanceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/RelationshipChastityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SessionDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/SettingsDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/TaskDBService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementBadgeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementLeaderboardService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementNotificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/AchievementStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/achievements/index.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 86,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 86,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2887, 2890], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2887, 2890], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 90,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 90,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3075, 3078], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3075, 3078], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3262, 3265], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3262, 3265], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityEventService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastitySessionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/ChastityTaskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipCoreService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/RelationshipPermissionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationship-chastity/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipInviteService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipRoleService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipSearchService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipStatusService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/RelationshipValidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/database/relationships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/feedbackService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/firebase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/gamificationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/goalStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/healthCheckStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migration/DataMigrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/migrationStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/reportStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/ChastityDB.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/storage/dexie.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/AchievementDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/ConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/EventDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseListeners.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/FirebaseSyncCore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/OfflineQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/RelationshipDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SessionDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/SyncConflictResolver.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/TaskDataSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/UserSettingsSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/connectionStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/sync/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/services/themeStorage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/formStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/keyholderStore.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (105). Maximum allowed is 75.",
        "line": 186,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 313,
        "endColumn": 7
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Keyholder Store\n * UI state management for keyholder mode functionality\n * Zustand store - handles keyholder UI state only\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport { sha256 } from \"@/utils/helpers/hash\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"KeyholderStore\");\n\n// Helper functions for password operations\nconst handlePasswordCheck = async (\n  passwordAttempt: string,\n  storedHash: string,\n  set: (state: Partial<KeyholderState>) => void,\n  get: () => KeyholderState,\n) => {\n  const state = get();\n\n  if (state.isCheckingPassword) {\n    logger.debug(\"Password check already in progress\");\n    return;\n  }\n\n  set({ isCheckingPassword: true, keyholderMessage: \"\" });\n\n  try {\n    logger.debug(\"Checking keyholder password\");\n\n    if (!storedHash) {\n      const message = \"Error: No keyholder password is set in the database.\";\n      set({\n        keyholderMessage: message,\n        isCheckingPassword: false,\n      });\n      logger.warn(\"No keyholder password hash found\");\n      return;\n    }\n\n    const attemptHash = await sha256(passwordAttempt);\n\n    if (attemptHash === storedHash) {\n      set({\n        isKeyholderModeUnlocked: true,\n        keyholderMessage: \"Controls are now unlocked.\",\n        isPasswordDialogOpen: false,\n        passwordAttempt: \"\",\n        isCheckingPassword: false,\n      });\n      logger.info(\"Keyholder password correct, mode unlocked\");\n    } else {\n      set({\n        keyholderMessage: \"Incorrect password. Please try again.\",\n        passwordAttempt: \"\",\n        isCheckingPassword: false,\n      });\n      logger.warn(\"Incorrect keyholder password attempt\");\n    }\n  } catch (error) {\n    const message = \"Failed to check password. Please try again.\";\n    set({\n      keyholderMessage: message,\n      isCheckingPassword: false,\n    });\n    logger.error(\"Error checking keyholder password\", {\n      error: error as Error,\n    });\n  }\n};\n\nconst handlePasswordSet = async (\n  newPassword: string,\n  onSave: (hash: string) => Promise<void>,\n  set: (state: Partial<KeyholderState>) => void,\n  get: () => KeyholderState,\n) => {\n  const state = get();\n\n  if (state.isSavingPassword) {\n    logger.debug(\"Password save already in progress\");\n    return;\n  }\n\n  if (!newPassword || newPassword.length < 6) {\n    set({\n      keyholderMessage: \"Password must be at least 6 characters long.\",\n    });\n    return;\n  }\n\n  set({ isSavingPassword: true, keyholderMessage: \"\" });\n\n  try {\n    logger.debug(\"Setting permanent keyholder password\");\n\n    const newHash = await sha256(newPassword);\n    await onSave(newHash);\n\n    set({\n      keyholderMessage: \"Permanent password has been updated successfully!\",\n      newPassword: \"\",\n      confirmPassword: \"\",\n      isPasswordSettingMode: false,\n      isPasswordDialogOpen: false,\n      isSavingPassword: false,\n    });\n\n    logger.info(\"Permanent keyholder password updated successfully\");\n  } catch (error) {\n    const message = \"Failed to update password. Please try again.\";\n    set({\n      keyholderMessage: message,\n      isSavingPassword: false,\n    });\n    logger.error(\"Error setting permanent password\", {\n      error: error as Error,\n    });\n  }\n};\n\nexport interface KeyholderState {\n  // UI State\n  isKeyholderModeUnlocked: boolean;\n  keyholderMessage: string;\n  isPasswordDialogOpen: boolean;\n  isPasswordSettingMode: boolean;\n\n  // Form State\n  passwordAttempt: string;\n  newPassword: string;\n  confirmPassword: string;\n\n  // Loading States\n  isCheckingPassword: boolean;\n  isSavingPassword: boolean;\n}\n\nexport interface KeyholderActions {\n  // Password Management\n  checkPassword: (passwordAttempt: string, storedHash: string) => Promise<void>;\n  setTempPassword: (keyholderName: string) => Promise<string>;\n  setPermanentPassword: (\n    newPassword: string,\n    onSave: (hash: string) => Promise<void>,\n  ) => Promise<void>;\n\n  // UI Actions\n  unlockKeyholderMode: () => void;\n  lockKeyholderControls: () => void;\n  setMessage: (message: string) => void;\n  clearMessage: () => void;\n\n  // Dialog Management\n  openPasswordDialog: () => void;\n  closePasswordDialog: () => void;\n  setPasswordSettingMode: (isSettingMode: boolean) => void;\n\n  // Form Actions\n  setPasswordAttempt: (password: string) => void;\n  setNewPassword: (password: string) => void;\n  setConfirmPassword: (password: string) => void;\n  clearForm: () => void;\n\n  // Reset\n  resetStore: () => void;\n}\n\nexport interface KeyholderStore extends KeyholderState, KeyholderActions {}\n\nconst initialState: KeyholderState = {\n  isKeyholderModeUnlocked: false,\n  keyholderMessage: \"\",\n  isPasswordDialogOpen: false,\n  isPasswordSettingMode: false,\n  passwordAttempt: \"\",\n  newPassword: \"\",\n  confirmPassword: \"\",\n  isCheckingPassword: false,\n  isSavingPassword: false,\n};\n\nexport const useKeyholderStore = create<KeyholderStore>()(\n  devtools(\n    (set, get) => ({\n      ...initialState,\n\n      // Password Management\n      checkPassword: async (passwordAttempt: string, storedHash: string) => {\n        await handlePasswordCheck(passwordAttempt, storedHash, set, get);\n      },\n\n      setTempPassword: async (keyholderName: string): Promise<string> => {\n        try {\n          logger.debug(\"Generating temporary keyholder password\", {\n            keyholderName,\n          });\n\n          const tempPassword = Math.random()\n            .toString(36)\n            .substring(2, 8)\n            .toUpperCase();\n          const message = `Your keyholder password is: ${tempPassword}. This is now the permanent password unless you set a custom one.`;\n\n          set({ keyholderMessage: message });\n\n          logger.info(\"Temporary keyholder password generated\");\n          return tempPassword;\n        } catch (error) {\n          const message = \"Failed to generate temporary password.\";\n          set({ keyholderMessage: message });\n          logger.error(\"Error generating temporary password\", {\n            error: error as Error,\n          });\n          throw error;\n        }\n      },\n\n      setPermanentPassword: async (\n        newPassword: string,\n        onSave: (hash: string) => Promise<void>,\n      ) => {\n        await handlePasswordSet(newPassword, onSave, set, get);\n      },\n\n      // UI Actions\n      unlockKeyholderMode: () => {\n        set({\n          isKeyholderModeUnlocked: true,\n          keyholderMessage: \"Controls are now unlocked.\",\n          isPasswordDialogOpen: false,\n        });\n        logger.info(\"Keyholder mode unlocked manually\");\n      },\n\n      lockKeyholderControls: () => {\n        set({\n          isKeyholderModeUnlocked: false,\n          keyholderMessage: \"\",\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n        logger.info(\"Keyholder controls locked\");\n      },\n\n      setMessage: (message: string) => {\n        set({ keyholderMessage: message });\n      },\n\n      clearMessage: () => {\n        set({ keyholderMessage: \"\" });\n      },\n\n      // Dialog Management\n      openPasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: true,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n        });\n      },\n\n      closePasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          isPasswordSettingMode: false,\n        });\n      },\n\n      setPasswordSettingMode: (isSettingMode: boolean) => {\n        set({\n          isPasswordSettingMode: isSettingMode,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n      },\n\n      // Form Actions\n      setPasswordAttempt: (password: string) => {\n        set({ passwordAttempt: password });\n      },\n\n      setNewPassword: (password: string) => {\n        set({ newPassword: password });\n      },\n\n      setConfirmPassword: (password: string) => {\n        set({ confirmPassword: password });\n      },\n\n      clearForm: () => {\n        set({\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          keyholderMessage: \"\",\n        });\n      },\n\n      // Reset\n      resetStore: () => {\n        set(initialState);\n        logger.debug(\"Keyholder store reset to initial state\");\n      },\n    }),\n    {\n      name: \"keyholder-store\",\n      // Only enable devtools in development\n      enabled:\n        import.meta.env.MODE === \"development\" ||\n        import.meta.env.MODE === \"nightly\",\n    },\n  ),\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/modalStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/navigationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/notificationStore.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (102). Maximum allowed is 75.",
        "line": 101,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 226,
        "endColumn": 7
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Notification Store - Temporary UI Feedback\n * Manages toast messages, alerts, and temporary UI feedback\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\nexport interface Notification {\n  id: string;\n  type: \"success\" | \"error\" | \"warning\" | \"info\";\n  priority: \"low\" | \"medium\" | \"high\" | \"urgent\";\n  title?: string;\n  message: string;\n  duration?: number; // in milliseconds, 0 means persistent\n  dismissible?: boolean;\n  requireInteraction?: boolean; // for urgent priority\n  position?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"top-center\"\n    | \"bottom-center\";\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  icon?: string; // optional custom icon\n  metadata?: Record<string, unknown>; // extensible metadata\n  timestamp: Date;\n}\n\nexport interface NotificationState {\n  // Notifications list\n  notifications: Notification[];\n\n  // Configuration\n  pauseOnHover?: boolean;\n\n  // Actions\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\">,\n  ) => string;\n  removeNotification: (id: string) => void;\n  clearAllNotifications: () => void;\n  updateNotification: (id: string, updates: Partial<Notification>) => void;\n\n  // Convenience methods\n  showSuccess: (message: string, title?: string, duration?: number) => string;\n  showError: (message: string, title?: string, duration?: number) => string;\n  showWarning: (message: string, title?: string, duration?: number) => string;\n  showInfo: (message: string, title?: string, duration?: number) => string;\n\n  // Reset function for testing\n  resetStore: () => void;\n}\n\n// Additional type exports for compatibility with index.ts\nexport interface NotificationActions {\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\">,\n  ) => string;\n  removeNotification: (id: string) => void;\n  clearAllNotifications: () => void;\n  showSuccess: (message: string, title?: string, duration?: number) => string;\n  showError: (message: string, title?: string, duration?: number) => string;\n  showWarning: (message: string, title?: string, duration?: number) => string;\n  showInfo: (message: string, title?: string, duration?: number) => string;\n}\n\nexport type NotificationStore = NotificationState;\nexport type NotificationType = \"success\" | \"error\" | \"warning\" | \"info\";\nexport type NotificationPriority = \"low\" | \"medium\" | \"high\" | \"urgent\";\nexport type NotificationAction = {\n  label: string;\n  onClick: () => void;\n};\n\n// Default durations for different notification priorities\nconst DEFAULT_DURATIONS = {\n  low: 3000,\n  medium: 5000,\n  high: 7000,\n  urgent: 0, // Persistent - requires interaction\n};\n\n// Fallback durations by type (legacy support)\nconst TYPE_DURATIONS = {\n  success: 4000,\n  error: 0, // Persistent for errors\n  warning: 6000,\n  info: 4000,\n};\n\nconst initialState = {\n  notifications: [],\n};\n\nexport const useNotificationStore = create<NotificationState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      ...initialState,\n      pauseOnHover: true,\n\n      // Actions\n      addNotification: (notification) => {\n        const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        \n        // Determine priority from type if not specified\n        const priority = notification.priority || (\n          notification.type === 'error' ? 'high' : \n          notification.type === 'warning' ? 'medium' : 'low'\n        );\n        \n        // Set duration based on priority, with fallback to type\n        const duration = notification.duration !== undefined \n          ? notification.duration \n          : DEFAULT_DURATIONS[priority] || TYPE_DURATIONS[notification.type];\n        \n        // Urgent priority requires interaction\n        const requireInteraction = priority === 'urgent' || notification.requireInteraction;\n        \n        const newNotification: Notification = {\n          id,\n          timestamp: new Date(),\n          priority,\n          duration,\n          dismissible: true,\n          requireInteraction,\n          ...notification,\n        };\n\n        set(\n          (state) => ({\n            notifications: [...state.notifications, newNotification],\n          }),\n          false,\n          `addNotification:${notification.type}:${priority}`,\n        );\n\n        // Auto-remove notification after duration if specified and not requiring interaction\n        if (newNotification.duration && newNotification.duration > 0 && !newNotification.requireInteraction) {\n          setTimeout(() => {\n            useNotificationStore.getState().removeNotification(id);\n          }, newNotification.duration);\n        }\n\n        return id;\n      },\n\n      removeNotification: (id: string) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.filter((n) => n.id !== id),\n          }),\n          false,\n          `removeNotification:${id}`,\n        ),\n\n      clearAllNotifications: () =>\n        set({ notifications: [] }, false, \"clearAllNotifications\"),\n\n      updateNotification: (id: string, updates: Partial<Notification>) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.map((n) =>\n              n.id === id ? { ...n, ...updates } : n,\n            ),\n          }),\n          false,\n          `updateNotification:${id}`,\n        ),\n\n      // Convenience methods\n      showSuccess: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"success\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showError: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"error\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showWarning: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"warning\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      showInfo: (message: string, title?: string, duration?: number) => {\n        const notificationData: Omit<Notification, \"id\" | \"timestamp\"> = {\n          type: \"info\",\n          message,\n          title,\n        };\n        if (duration !== undefined) {\n          notificationData.duration = duration;\n        }\n        return get().addNotification(notificationData);\n      },\n\n      // Reset function for testing\n      resetStore: () => set(initialState, false, \"resetStore\"),\n    }),\n    {\n      name: \"notification-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useNotifications = () =>\n  useNotificationStore((state) => state.notifications);\n\nexport const useNotificationActions = () =>\n  useNotificationStore((state) => ({\n    addNotification: state.addNotification,\n    removeNotification: state.removeNotification,\n    clearAllNotifications: state.clearAllNotifications,\n    showSuccess: state.showSuccess,\n    showError: state.showError,\n    showWarning: state.showWarning,\n    showInfo: state.showInfo,\n  }));\n\n// Utility hooks for common notification patterns\nexport const useErrorHandler = () => {\n  const { showError } = useNotificationActions();\n\n  const handleError = (error: Error | string, title = \"Error\") => {\n    const message = typeof error === \"string\" ? error : error.message;\n    return showError(message, title);\n  };\n\n  return { handleError };\n};\n\nexport const useSuccessHandler = () => {\n  const { showSuccess } = useNotificationActions();\n\n  const handleSuccess = (message: string, title = \"Success\") => {\n    return showSuccess(message, title);\n  };\n\n  return { handleSuccess };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/themeStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/stores/uiPreferencesStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test-setup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 33,
        "column": 6,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 33,
        "endColumn": 9,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [808, 811], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [808, 811], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 55,
        "column": 8,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 55,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1425, 1428], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1425, 1428], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 62,
        "column": 8,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 62,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1621, 1624], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1621, 1624], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Test Setup Configuration\n * Global setup for Vitest test environment\n */\nimport { expect, afterEach, vi } from \"vitest\";\nimport { cleanup } from \"@testing-library/react\";\n\n// Extend Vitest's expect with testing library matchers\n// @ts-expect-error - vitest globals\nglobal.expect = expect;\n\n// Cleanup after each test case\nafterEach(() => {\n  cleanup();\n});\n\n// Mock Firebase to prevent actual network calls during tests\nvi.mock(\"./services/firebase\", () => ({\n  getFirestore: vi.fn(() => ({})),\n  getAuth: vi.fn(() => ({})),\n  initializeApp: vi.fn(() => ({})),\n}));\n\n// Mock console methods for clean test output\nglobalThis.console = {\n  ...console,\n  // Suppress console.log in tests unless explicitly needed\n  log: vi.fn(),\n  debug: vi.fn(),\n  info: vi.fn(),\n  warn: vi.fn(),\n  error: vi.fn(),\n} as any;\n\n// Mock window.matchMedia for responsive component tests\nObject.defineProperty(window, \"matchMedia\", {\n  writable: true,\n  value: vi.fn().mockImplementation((query) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(), // deprecated\n    removeListener: vi.fn(), // deprecated\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\n// Mock IntersectionObserver for UI component tests\nglobalThis.IntersectionObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n})) as any;\n\n// Mock ResizeObserver for responsive component tests\nglobalThis.ResizeObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n})) as any;\n\n// Mock localStorage\nconst localStorageMock = {\n  getItem: vi.fn(),\n  setItem: vi.fn(),\n  removeItem: vi.fn(),\n  clear: vi.fn(),\n  length: 0,\n  key: vi.fn(),\n};\n\nObject.defineProperty(window, \"localStorage\", {\n  value: localStorageMock,\n});\n\n// Mock sessionStorage\nObject.defineProperty(window, \"sessionStorage\", {\n  value: localStorageMock,\n});\n\n// Mock IndexedDB for Dexie tests\nconst indexedDBMock = {\n  open: vi.fn(),\n  deleteDatabase: vi.fn(),\n  cmp: vi.fn(),\n};\n\nObject.defineProperty(window, \"indexedDB\", {\n  value: indexedDBMock,\n});\n\n// Mock crypto.randomUUID for ID generation\nObject.defineProperty(globalThis, \"crypto\", {\n  value: {\n    randomUUID: vi.fn(\n      () => \"mock-uuid-\" + Math.random().toString(36).substr(2, 9),\n    ),\n  },\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test/setup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 72,
        "column": 8,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 72,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1701, 1704], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1701, 1704], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 79,
        "column": 8,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 79,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1857, 1860], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1857, 1860], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 127,
        "column": 6,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 127,
        "endColumn": 9,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3294, 3297], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3294, 3297], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 133,
        "column": 6,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 133,
        "endColumn": 9,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3438, 3441], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3438, 3441], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Vitest Test Setup\n * Global test configuration and mocks\n */\n\nimport { afterEach, vi } from \"vitest\";\nimport { cleanup } from \"@testing-library/react\";\nimport \"@testing-library/jest-dom\";\n\n// Runs a cleanup after each test case (e.g. clearing jsdom)\nafterEach(() => {\n  cleanup();\n});\n\n// Mock Firebase\nvi.mock(\"../firebase\", () => ({\n  db: {\n    collection: vi.fn(),\n    doc: vi.fn(),\n    getDoc: vi.fn(),\n    setDoc: vi.fn(),\n    updateDoc: vi.fn(),\n    deleteDoc: vi.fn(),\n    onSnapshot: vi.fn(),\n    writeBatch: vi.fn(),\n    serverTimestamp: vi.fn(() => new Date()),\n  },\n  auth: {\n    currentUser: null,\n    onAuthStateChanged: vi.fn(),\n    signInAnonymously: vi.fn(),\n  },\n  storage: {\n    ref: vi.fn(),\n    uploadBytes: vi.fn(),\n    getDownloadURL: vi.fn(),\n  },\n}));\n\n// Mock environment variables\nObject.defineProperty(import.meta, \"env\", {\n  value: {\n    VITE_FIREBASE_API_KEY: \"test-api-key\",\n    VITE_FIREBASE_AUTH_DOMAIN: \"test-auth-domain\",\n    VITE_FIREBASE_PROJECT_ID: \"test-project-id\",\n    VITE_FIREBASE_STORAGE_BUCKET: \"test-storage-bucket\",\n    VITE_FIREBASE_MESSAGING_SENDER_ID: \"test-sender-id\",\n    VITE_FIREBASE_APP_ID: \"test-app-id\",\n  },\n});\n\n// Mock window.matchMedia\nObject.defineProperty(window, \"matchMedia\", {\n  writable: true,\n  value: vi.fn().mockImplementation((query) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(), // deprecated\n    removeListener: vi.fn(), // deprecated\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\n// Mock ResizeObserver\nglobalThis.ResizeObserver = vi.fn(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n})) as any;\n\n// Mock IntersectionObserver\nglobalThis.IntersectionObserver = vi.fn(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n})) as any;\n\n// Mock crypto for hash functions\nObject.defineProperty(globalThis, \"crypto\", {\n  value: {\n    subtle: {\n      digest: vi\n        .fn()\n        .mockImplementation(async (algorithm: string, data: ArrayBuffer) => {\n          // Create a deterministic hash based on input data for testing\n          const input = new Uint8Array(data);\n          const hash = new ArrayBuffer(32);\n          const view = new Uint8Array(hash);\n\n          // Simple deterministic hash: sum all input bytes and use as seed\n          let seed = 0;\n          for (let i = 0; i < input.length; i++) {\n            seed += input[i];\n          }\n\n          // Fill hash buffer with deterministic pattern based on seed\n          for (let i = 0; i < 32; i++) {\n            view[i] = (seed + i * 7) % 256;\n          }\n          return hash;\n        }),\n    },\n    randomUUID: vi.fn().mockImplementation(() => {\n      // Generate a mock UUID v4\n      const chars = \"0123456789abcdef\";\n      const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(\n        /[xy]/g,\n        (c) => {\n          const r = Math.floor(Math.random() * 16);\n          const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n          return chars[v];\n        },\n      );\n      return uuid;\n    }),\n  },\n});\n\n// Mock TextEncoder/TextDecoder\nglobalThis.TextEncoder = class TextEncoder {\n  encode(input: string) {\n    return new Uint8Array(input.split(\"\").map((char) => char.charCodeAt(0)));\n  }\n} as any;\n\nglobalThis.TextDecoder = class TextDecoder {\n  decode(input: Uint8Array) {\n    return String.fromCharCode(...Array.from(input));\n  }\n} as any;\n\n// Mock HTMLCanvasElement.getContext\nHTMLCanvasElement.prototype.getContext = vi.fn();\n\n// Mock service worker\nObject.defineProperty(navigator, \"serviceWorker\", {\n  value: {\n    register: vi.fn().mockResolvedValue({\n      installing: null,\n      waiting: null,\n      active: null,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    }),\n    ready: Promise.resolve({\n      installing: null,\n      waiting: null,\n      active: null,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    }),\n  },\n});\n\n// Global test utilities\nglobalThis.console = {\n  ...console,\n  // Suppress console.log in tests unless explicitly needed\n  log: vi.fn(),\n  info: vi.fn(),\n  warn: vi.fn(),\n  error: vi.fn(),\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/test/utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/account-linking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/achievements.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/core.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/database.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/events.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/feedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/goals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/pauseResume.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/realtime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/relationships.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/security.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/types/theme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/dataSyncHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/date.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/formatting/time.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/goalsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/hash.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/sessionHistory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/statistics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/helpers/string.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/iconImport.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/logging.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseAnalytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/pauseResumeHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/realtime/notification-helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/audit-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/security/security-settings-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/sessionHistoryHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/statisticsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/systemInfo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/utils/toastBridge.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 69,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 69,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [2679, 2733], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 89,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 89,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [3187, 3230], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "debug" },
            "desc": "Remove the console.debug()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 117,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 117,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [3880, 3944], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 126,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 126,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4232, 4298], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 135,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 135,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [4580, 4645], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 144,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 144,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [4933, 4999], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 153,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 153,
        "endColumn": 17,
        "suggestions": [
          {
            "fix": { "range": [5278, 5341], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "info" },
            "desc": "Remove the console.info()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 162,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 162,
        "endColumn": 18,
        "suggestions": [
          {
            "fix": { "range": [5626, 5692], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 171,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 171,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [5917, 5983], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 2,
        "message": "Unexpected console statement.",
        "line": 180,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 180,
        "endColumn": 19,
        "suggestions": [
          {
            "fix": { "range": [6191, 6251], "text": "" },
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/src/vite-env.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/thef4tdaddy/Git/chastityOS/App/vitest.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
