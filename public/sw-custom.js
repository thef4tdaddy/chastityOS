/**
 * Custom Service Worker
 * Extends Workbox with background sync for offline queue processing
 * Part of Background Sync implementation (#392)
 */

// Import Workbox libraries for precaching
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST || []);

// Cleanup old caches
cleanupOutdatedCaches();

// Take control of all pages immediately
clientsClaim();

// Listen for SKIP_WAITING message to activate immediately
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Background sync event handler with retry logic
self.addEventListener("sync", (event) => {
  if (event.tag === "offline-queue-sync") {
    event.waitUntil(processOfflineQueue());
  }
});

/**
 * Process the offline queue when back online
 * Implements exponential backoff retry logic
 */
async function processOfflineQueue() {
  try {
    // Open IndexedDB and get pending operations
    const db = await openDatabase();
    const operations = await getQueuedOperations(db);

    if (operations.length === 0) {
      console.log("[SW] No queued operations to process");
      return;
    }

    console.log(`[SW] Processing ${operations.length} queued operations`);

    // Notify the client that sync has started
    await notifyClients({
      type: "SYNC_STARTED",
      count: operations.length,
    });

    // Process each operation with retry logic
    let processedCount = 0;
    let failedCount = 0;

    for (const operation of operations) {
      try {
        // Check if operation should be retried
        const shouldRetry = checkRetryEligibility(operation);
        
        if (!shouldRetry) {
          console.log(`[SW] Skipping operation ${operation.id} - max retries exceeded`);
          continue;
        }

        await processOperation(operation);
        processedCount++;
      } catch (error) {
        console.error("[SW] Failed to process operation:", error);
        failedCount++;
        
        // Increment retry count
        await incrementRetryCount(db, operation);
      }
    }

    // Notify the client that sync is complete
    await notifyClients({
      type: "SYNC_COMPLETE",
      processed: processedCount,
      failed: failedCount,
    });

    console.log(
      `[SW] Sync complete: ${processedCount} processed, ${failedCount} failed`,
    );
  } catch (error) {
    console.error("[SW] Error processing offline queue:", error);
    
    // Notify client of error
    await notifyClients({
      type: "SYNC_ERROR",
      error: error.message || "Unknown error",
    });
  }
}

/**
 * Check if an operation is eligible for retry
 * Implements exponential backoff logic
 */
function checkRetryEligibility(operation) {
  const MAX_RETRIES = 3;
  const BASE_DELAY = 1000; // 1 second
  const retryCount = operation.retryCount || 0;

  // Check max retries
  if (retryCount >= MAX_RETRIES) {
    return false;
  }

  // Check if enough time has passed (exponential backoff)
  if (operation.lastRetryAt) {
    const delay = BASE_DELAY * Math.pow(2, retryCount);
    const timeSinceLastRetry = Date.now() - new Date(operation.lastRetryAt).getTime();
    
    if (timeSinceLastRetry < delay) {
      console.log(`[SW] Operation ${operation.id} not ready for retry - waiting ${delay}ms`);
      return false;
    }
  }

  return true;
}

/**
 * Open the IndexedDB database
 */
async function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("ChastityOS", 1);

    request.onsuccess = () => {
      resolve(request.result);
    };

    request.onerror = () => {
      reject(request.error);
    };
  });
}

/**
 * Get queued operations from IndexedDB
 */
async function getQueuedOperations(db) {
  return new Promise((resolve, reject) => {
    try {
      const transaction = db.transaction(["offlineQueue"], "readonly");
      const store = transaction.objectStore("offlineQueue");
      const request = store.getAll();

      request.onsuccess = () => {
        resolve(request.result || []);
      };

      request.onerror = () => {
        reject(request.error);
      };
    } catch (error) {
      // If offlineQueue doesn't exist, return empty array
      console.warn("[SW] offlineQueue object store not found:", error);
      resolve([]);
    }
  });
}

/**
 * Increment retry count for an operation
 */
async function incrementRetryCount(db, operation) {
  return new Promise((resolve, reject) => {
    try {
      const transaction = db.transaction(["offlineQueue"], "readwrite");
      const store = transaction.objectStore("offlineQueue");
      
      const updatedOperation = {
        ...operation,
        retryCount: (operation.retryCount || 0) + 1,
        lastRetryAt: new Date(),
      };
      
      const request = store.put(updatedOperation);

      request.onsuccess = () => {
        resolve();
      };

      request.onerror = () => {
        reject(request.error);
      };
    } catch (error) {
      console.error("[SW] Error incrementing retry count:", error);
      resolve(); // Don't fail the entire process
    }
  });
}

/**
 * Process a single operation
 * Note: This will notify the client to handle the actual processing
 * since the service worker cannot directly access Firebase
 */
async function processOperation(operation) {
  // Notify the client to process this operation
  await notifyClients({
    type: "PROCESS_OPERATION",
    operation: operation,
  });
  
  // Wait a bit for the client to process
  await new Promise(resolve => setTimeout(resolve, 1000));
}

/**
 * Notify all clients about sync status
 */
async function notifyClients(message) {
  const clients = await self.clients.matchAll();
  clients.forEach((client) => {
    client.postMessage(message);
  });
}
