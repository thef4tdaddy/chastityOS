[{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/build/vite.config.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (165). Maximum allowed is 75.","line":13,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":195,"endColumn":2},{"ruleId":"no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":30,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineConfig, loadEnv } from \"vite\";\nimport tsconfigPaths from \"vite-tsconfig-paths\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"@tailwindcss/vite\";\nimport { sentryVitePlugin } from \"@sentry/vite-plugin\";\nimport { VitePWA } from \"vite-plugin-pwa\";\nimport { visualizer } from \"rollup-plugin-visualizer\";\nimport viteCompression from \"vite-plugin-compression\";\nimport { execSync } from \"child_process\";\nimport { readFileSync } from \"fs\";\nimport { fileURLToPath, URL } from \"node:url\";\n\nexport default defineConfig(({ mode }) => {\n  // Load variables from the correct .env file for the current mode\n  // The third argument ('') ensures all variables are loaded, not just VITE_ prefixed ones.\n  const env = loadEnv(mode, process.cwd(), \"\");\n\n  const __dirname = fileURLToPath(new URL(\".\", import.meta.url));\n  const packageJson = JSON.parse(\n    readFileSync(\n      fileURLToPath(new URL(\"../../package.json\", import.meta.url)),\n      \"utf8\",\n    ),\n  );\n  const appVersion = packageJson.version;\n\n  let gitHash = \"dev\";\n  try {\n    gitHash = execSync(\"git rev-parse --short HEAD\").toString().trim();\n  } catch (_e) {\n    console.warn(\n      '[vite.config.js] Git hash not available. Using \"dev\" instead.',\n    );\n  }\n\n  // Use the loaded VITE_APP_VARIANT for the release version\n  const releaseVersion = `chastityOS-${env.VITE_APP_VARIANT || \"unknown\"}-${gitHash}`;\n\n  // Nightly builds: keep console logs, source maps, less compression\n  // Production builds: remove console logs, optimize for performance\n  const isNightly = mode === \"nightly\";\n  const isProduction = mode === \"production\";\n\n  return {\n    // --- THIS IS THE KEY FIX ---\n    // The 'define' option will find and replace these keys with their values\n    // in your client-side code at build time.\n    define: {\n      \"import.meta.env.VITE_APP_VARIANT\": JSON.stringify(env.VITE_APP_VARIANT),\n      \"import.meta.env.VITE_SENTRY_PROJECT\": JSON.stringify(\n        env.VITE_SENTRY_PROJECT,\n      ),\n      // We don't need to define VITE_SENTRY_DSN here again if main.jsx is already reading it,\n      // but being explicit helps prevent issues.\n      \"import.meta.env.VITE_SENTRY_DSN\": JSON.stringify(env.VITE_SENTRY_DSN),\n      \"import.meta.env.VITE_APP_VERSION\": JSON.stringify(appVersion),\n    },\n    plugins: [\n      react(),\n      tsconfigPaths(),\n      tailwindcss(),\n      visualizer({\n        filename: \"./dist/bundle-report.html\",\n        open: !isProduction, // Only open in nightly builds\n        gzipSize: true,\n        brotliSize: true,\n      }),\n      // Only compress in production builds\n      ...(isProduction\n        ? [\n            viteCompression({\n              algorithm: \"brotliCompress\",\n            }),\n          ]\n        : []),\n      VitePWA({\n        registerType: \"autoUpdate\",\n        manifest: {\n          name: \"ChastityOS\",\n          short_name: \"ChastityOS\",\n          start_url: \"/\",\n          display: \"standalone\",\n          background_color: \"#000000\",\n          theme_color: \"#000000\",\n          icons: [\n            {\n              src: \"/icons/icon-192x192.png\",\n              sizes: \"192x192\",\n              type: \"image/png\",\n              purpose: \"any\",\n            },\n            {\n              src: \"/icons/icon-512x512.png\",\n              sizes: \"512x512\",\n              type: \"image/png\",\n              purpose: \"any maskable\",\n            },\n          ],\n          screenshots: [\n            {\n              src: \"/screenshots/screenshot-desktop-1.png\",\n              sizes: \"1280x720\",\n              type: \"image/png\",\n            },\n            {\n              src: \"/screenshots/screenshot-desktop-1.png\",\n              sizes: \"1280x720\",\n              type: \"image/png\",\n              form_factor: \"wide\",\n            },\n            {\n              src: \"/screenshots/screenshot-mobile-1.png\",\n              sizes: \"540x1027\",\n              type: \"image/png\",\n              form_factor: \"narrow\",\n            },\n          ],\n        },\n        workbox: {\n          runtimeCaching: [\n            {\n              urlPattern: ({ request }) => request.destination === \"document\",\n              handler: \"NetworkFirst\",\n            },\n            {\n              urlPattern: ({ request }) =>\n                [\"style\", \"script\", \"worker\"].includes(request.destination),\n              handler: \"StaleWhileRevalidate\",\n            },\n            {\n              urlPattern: ({ request }) => request.destination === \"image\",\n              handler: \"CacheFirst\",\n            },\n          ],\n        },\n        devOptions: {\n          enabled: mode !== \"development\",\n        },\n      }),\n      // The Sentry plugin runs in Node.js, so it can use 'env' directly.\n      // Your client-side code cannot, which is why the 'define' block is needed.\n      sentryVitePlugin({\n        org: env.SENTRY_ORG,\n        project: env.SENTRY_PROJECT,\n        authToken: env.SENTRY_AUTH_TOKEN,\n        release: releaseVersion,\n        include: \"./dist\",\n        urlPrefix: \"~/\",\n        deploy: {\n          env: env.VITE_APP_VARIANT, // Use the loaded env variable\n        },\n        telemetry: false,\n      }),\n    ],\n    server: {\n      headers: {\n        \"Cross-Origin-Opener-Policy\": \"same-origin-allow-popups\",\n      },\n    },\n    build: {\n      sourcemap: true,\n      minify: isProduction ? \"terser\" : \"esbuild\",\n      rollupOptions: {\n        output: {\n          manualChunks(id) {\n            if (id.includes(\"node_modules\")) {\n              return \"vendor\";\n            }\n          },\n        },\n      },\n      ...(isProduction && {\n        terserOptions: {\n          compress: {\n            drop_console: true,\n            drop_debugger: true,\n          },\n        },\n      }),\n    },\n    test: {\n      globals: true,\n      environment: \"jsdom\",\n      setupFiles: \"./src/tests/setup.js\",\n    },\n    esbuild: {\n      ...(isNightly && {\n        drop: [], // Keep console logs and debugger in nightly builds\n      }),\n      ...(isProduction && {\n        drop: [\"console\", \"debugger\"], // Remove console logs and debugger in production\n      }),\n    },\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/deployment/vercel.build.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/linting/commitlint.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/configs/linting/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/Root.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/Navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementDashboard.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (184). Maximum allowed is 75.","line":20,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":216,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1264,1267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1264,1267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1272,1275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1272,1275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Dashboard Component\n * Overview of user's achievement progress and recent unlocks\n */\n\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n  FaTrophy,\n  FaFire,\n  FaBullseye,\n  FaClock,\n  FaStar,\n  FaArrowRight,\n} from \"../../utils/iconImport\";\nimport { useAchievements } from \"../../hooks/useAchievements\";\nimport { useAuthState } from \"../../contexts\";\nimport { AchievementCategory } from \"../../types\";\n\nexport const AchievementDashboard: React.FC = () => {\n  const { user } = useAuthState();\n  const {\n    achievementStats,\n    userAchievements,\n    unreadNotifications,\n    allAchievements,\n    getAchievementsByCategory,\n    isLoading,\n  } = useAchievements(user?.uid);\n\n  if (isLoading || !achievementStats) {\n    return (\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <div className=\"animate-pulse\">\n          <div className=\"h-6 bg-gray-300 rounded w-1/3 mb-4\"></div>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            {[...Array(4)].map((_, i) => (\n              <div key={i} className=\"h-20 bg-gray-300 rounded\"></div>\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const recentAchievements = userAchievements\n    .sort((a: any, b: any) => b.earnedAt.getTime() - a.earnedAt.getTime())\n    .slice(0, 3);\n\n  const categories: AchievementCategory[] = [\n    \"session_milestones\",\n    \"consistency_badges\",\n    \"streak_achievements\",\n    \"goal_based\",\n    \"task_completion\",\n    \"special_achievements\",\n  ];\n\n  const categoryProgress = categories.map((category) => {\n    const categoryAchievements = getAchievementsByCategory(category);\n    const earned = achievementStats.categoryCounts[category] || 0;\n    const total = categoryAchievements.length;\n    const percentage = total > 0 ? (earned / total) * 100 : 0;\n\n    return {\n      category,\n      earned,\n      total,\n      percentage,\n      name: getCategoryDisplayName(category),\n      icon: getCategoryIcon(category),\n    };\n  });\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center space-x-3\">\n          <FaTrophy className=\"text-2xl text-nightly-lavender-floral\" />\n          <h2 className=\"text-2xl font-bold text-nightly-honeydew\">\n            Achievements\n          </h2>\n        </div>\n        <Link\n          to=\"/achievements\"\n          className=\"flex items-center space-x-2 text-nightly-aquamarine hover:text-nightly-lavender-floral transition-colors\"\n        >\n          <span>View All</span>\n          <FaArrowRight />\n        </Link>\n      </div>\n\n      {/* Stats Cards */}\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        <div className=\"bg-gradient-to-br from-nightly-aquamarine/20 to-nightly-aquamarine/10 rounded-lg p-4 border border-nightly-aquamarine/30\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm text-nightly-celadon\">Total Earned</p>\n              <p className=\"text-2xl font-bold text-nightly-honeydew\">\n                {achievementStats.totalEarned}\n              </p>\n            </div>\n            <FaTrophy className=\"text-2xl text-nightly-aquamarine\" />\n          </div>\n        </div>\n\n        <div className=\"bg-gradient-to-br from-nightly-lavender-floral/20 to-nightly-lavender-floral/10 rounded-lg p-4 border border-nightly-lavender-floral/30\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm text-nightly-celadon\">Total Points</p>\n              <p className=\"text-2xl font-bold text-nightly-honeydew\">\n                {achievementStats.totalPoints}\n              </p>\n            </div>\n            <FaStar className=\"text-2xl text-nightly-lavender-floral\" />\n          </div>\n        </div>\n\n        <div className=\"bg-gradient-to-br from-nightly-spring-green/20 to-nightly-spring-green/10 rounded-lg p-4 border border-nightly-spring-green/30\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm text-nightly-celadon\">Completion</p>\n              <p className=\"text-2xl font-bold text-nightly-honeydew\">\n                {achievementStats.completionPercentage.toFixed(0)}%\n              </p>\n            </div>\n            <FaBullseye className=\"text-2xl text-nightly-spring-green\" />\n          </div>\n        </div>\n\n        <div className=\"bg-gradient-to-br from-red-500/20 to-red-500/10 rounded-lg p-4 border border-red-500/30\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <p className=\"text-sm text-nightly-celadon\">New Unlocks</p>\n              <p className=\"text-2xl font-bold text-nightly-honeydew\">\n                {unreadNotifications.length}\n              </p>\n            </div>\n            <FaFire className=\"text-2xl text-red-400\" />\n          </div>\n        </div>\n      </div>\n\n      {/* Recent Achievements */}\n      {recentAchievements.length > 0 && (\n        <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-4\">\n            Recent Achievements\n          </h3>\n          <div className=\"space-y-3\">\n            {recentAchievements.map((userAchievement) => {\n              const achievement = allAchievements.find(\n                (a) => a.id === userAchievement.achievementId,\n              );\n              if (!achievement) return null;\n\n              return (\n                <div\n                  key={userAchievement.id}\n                  className=\"flex items-center space-x-3 p-3 bg-white/5 rounded-lg\"\n                >\n                  <div className=\"text-2xl\">{achievement.icon}</div>\n                  <div className=\"flex-1\">\n                    <h4 className=\"font-semibold text-nightly-honeydew\">\n                      {achievement.name}\n                    </h4>\n                    <p className=\"text-sm text-nightly-celadon\">\n                      {achievement.description}\n                    </p>\n                    <div className=\"flex items-center space-x-2 mt-1\">\n                      <span className=\"text-xs bg-yellow-500/20 text-yellow-300 px-2 py-1 rounded\">\n                        +{achievement.points} points\n                      </span>\n                      <span className=\"text-xs text-nightly-celadon\">\n                        {formatDate(userAchievement.earnedAt)}\n                      </span>\n                    </div>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      )}\n\n      {/* Category Progress */}\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-4\">\n          Progress by Category\n        </h3>\n        <div className=\"space-y-4\">\n          {categoryProgress.map((category) => (\n            <div key={category.category} className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  {category.icon}\n                  <span className=\"text-nightly-celadon\">{category.name}</span>\n                </div>\n                <span className=\"text-sm text-nightly-celadon\">\n                  {category.earned} / {category.total}\n                </span>\n              </div>\n              <div className=\"w-full bg-gray-700 rounded-full h-2\">\n                <div\n                  className=\"bg-gradient-to-r from-nightly-aquamarine to-nightly-lavender-floral h-2 rounded-full transition-all duration-300\"\n                  style={{ width: `${category.percentage}%` }}\n                />\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nfunction getCategoryDisplayName(category: AchievementCategory): string {\n  switch (category) {\n    case \"session_milestones\":\n      return \"Session Milestones\";\n    case \"consistency_badges\":\n      return \"Consistency\";\n    case \"streak_achievements\":\n      return \"Streaks\";\n    case \"goal_based\":\n      return \"Goals\";\n    case \"task_completion\":\n      return \"Tasks\";\n    case \"special_achievements\":\n      return \"Special\";\n    default:\n      return \"Unknown\";\n  }\n}\n\nfunction getCategoryIcon(category: AchievementCategory) {\n  switch (category) {\n    case \"session_milestones\":\n      return <FaClock className=\"text-nightly-aquamarine\" />;\n    case \"consistency_badges\":\n      return <FaBullseye className=\"text-nightly-lavender-floral\" />;\n    case \"streak_achievements\":\n      return <FaFire className=\"text-red-400\" />;\n    case \"goal_based\":\n      return <FaTrophy className=\"text-yellow-400\" />;\n    case \"task_completion\":\n      return <FaStar className=\"text-green-400\" />;\n    case \"special_achievements\":\n      return <FaStar className=\"text-purple-400\" />;\n    default:\n      return <FaTrophy className=\"text-gray-400\" />;\n  }\n}\n\nfunction formatDate(date: Date): string {\n  const now = new Date();\n  const diffInMs = now.getTime() - date.getTime();\n  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n\n  if (diffInDays === 0) {\n    return \"Today\";\n  } else if (diffInDays === 1) {\n    return \"Yesterday\";\n  } else if (diffInDays < 7) {\n    return `${diffInDays} days ago`;\n  } else {\n    return date.toLocaleDateString();\n  }\n}\n\nexport default AchievementDashboard;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementGallery.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (198). Maximum allowed is 75.","line":76,"column":70,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":301,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Gallery Component\n * Displays all achievements with progress and earned status\n */\n\nimport React, { useState, useMemo } from \"react\";\nimport {\n  FaTrophy,\n  FaLock,\n  FaEyeSlash,\n  FaEye,\n  FaSearch,\n} from \"../../utils/iconImport\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  AchievementCategory,\n  AchievementDifficulty,\n} from \"../../types\";\n\ninterface AchievementWithProgress {\n  achievement: DBAchievement;\n  userAchievement?: DBUserAchievement;\n  progress: {\n    currentValue: number;\n    targetValue: number;\n    percentage: number;\n    isCompleted: boolean;\n  } | null;\n  isEarned: boolean;\n  isVisible: boolean;\n}\n\ninterface AchievementGalleryProps {\n  achievementsWithProgress: AchievementWithProgress[];\n  onToggleVisibility?: (achievementId: string) => void;\n  isOwnGallery?: boolean;\n}\n\nconst getDifficultyColor = (difficulty: AchievementDifficulty): string => {\n  switch (difficulty) {\n    case AchievementDifficulty.COMMON:\n      return \"border-gray-400 bg-gray-50\";\n    case AchievementDifficulty.UNCOMMON:\n      return \"border-green-400 bg-green-50\";\n    case AchievementDifficulty.RARE:\n      return \"border-blue-400 bg-blue-50\";\n    case AchievementDifficulty.EPIC:\n      return \"border-purple-400 bg-purple-50\";\n    case AchievementDifficulty.LEGENDARY:\n      return \"border-yellow-400 bg-yellow-50\";\n    default:\n      return \"border-gray-400 bg-gray-50\";\n  }\n};\n\nconst getCategoryName = (category: AchievementCategory): string => {\n  switch (category) {\n    case AchievementCategory.SESSION_MILESTONES:\n      return \"Session Milestones\";\n    case AchievementCategory.CONSISTENCY_BADGES:\n      return \"Consistency Badges\";\n    case AchievementCategory.STREAK_ACHIEVEMENTS:\n      return \"Streak Achievements\";\n    case AchievementCategory.GOAL_BASED:\n      return \"Goal-Based\";\n    case AchievementCategory.TASK_COMPLETION:\n      return \"Task Completion\";\n    case AchievementCategory.SPECIAL_ACHIEVEMENTS:\n      return \"Special Achievements\";\n    default:\n      return \"Unknown\";\n  }\n};\n\nexport const AchievementGallery: React.FC<AchievementGalleryProps> = ({\n  achievementsWithProgress,\n  onToggleVisibility,\n  isOwnGallery = false,\n}) => {\n  const [selectedCategory, setSelectedCategory] = useState<\n    AchievementCategory | \"all\"\n  >(\"all\");\n  const [selectedDifficulty, setSelectedDifficulty] = useState<\n    AchievementDifficulty | \"all\"\n  >(\"all\");\n  const [showOnlyEarned, setShowOnlyEarned] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  // Filter achievements\n  const filteredAchievements = useMemo(() => {\n    return achievementsWithProgress.filter((item) => {\n      const { achievement, isEarned } = item;\n\n      // Category filter\n      if (\n        selectedCategory !== \"all\" &&\n        achievement.category !== selectedCategory\n      ) {\n        return false;\n      }\n\n      // Difficulty filter\n      if (\n        selectedDifficulty !== \"all\" &&\n        achievement.difficulty !== selectedDifficulty\n      ) {\n        return false;\n      }\n\n      // Earned filter\n      if (showOnlyEarned && !isEarned) {\n        return false;\n      }\n\n      // Search filter\n      if (\n        searchTerm &&\n        !achievement.name.toLowerCase().includes(searchTerm.toLowerCase()) &&\n        !achievement.description\n          .toLowerCase()\n          .includes(searchTerm.toLowerCase())\n      ) {\n        return false;\n      }\n\n      // Hide hidden achievements if not earned\n      if (achievement.isHidden && !isEarned) {\n        return false;\n      }\n\n      return true;\n    });\n  }, [\n    achievementsWithProgress,\n    selectedCategory,\n    selectedDifficulty,\n    showOnlyEarned,\n    searchTerm,\n  ]);\n\n  // Group by category\n  const groupedAchievements = useMemo(() => {\n    const groups: Record<string, AchievementWithProgress[]> = {};\n\n    filteredAchievements.forEach((item) => {\n      const categoryName = getCategoryName(item.achievement.category);\n      if (!groups[categoryName]) {\n        groups[categoryName] = [];\n      }\n      groups[categoryName].push(item);\n    });\n\n    return groups;\n  }, [filteredAchievements]);\n\n  const stats = useMemo(() => {\n    const totalEarned = achievementsWithProgress.filter(\n      (a) => a.isEarned,\n    ).length;\n    const totalVisible = achievementsWithProgress.filter(\n      (a) => !a.achievement.isHidden,\n    ).length;\n    const totalPoints = achievementsWithProgress\n      .filter((a) => a.isEarned)\n      .reduce((sum, a) => sum + a.achievement.points, 0);\n\n    return {\n      totalEarned,\n      totalVisible,\n      totalPoints,\n      completionPercentage:\n        totalVisible > 0 ? (totalEarned / totalVisible) * 100 : 0,\n    };\n  }, [achievementsWithProgress]);\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Stats Header */}\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-4\">\n        <div className=\"flex items-center justify-between mb-4\">\n          <h2 className=\"text-2xl font-bold text-nightly-honeydew\">\n            Achievement Gallery\n          </h2>\n          <div className=\"flex items-center space-x-4 text-sm\">\n            <span className=\"text-nightly-celadon\">\n              {stats.totalEarned} / {stats.totalVisible} Earned\n            </span>\n            <span className=\"text-nightly-aquamarine font-semibold\">\n              {stats.totalPoints} Points\n            </span>\n            <span className=\"text-nightly-lavender-floral\">\n              {stats.completionPercentage.toFixed(1)}% Complete\n            </span>\n          </div>\n        </div>\n\n        {/* Progress Bar */}\n        <div className=\"w-full bg-gray-700 rounded-full h-2\">\n          <div\n            className=\"bg-gradient-to-r from-nightly-aquamarine to-nightly-lavender-floral h-2 rounded-full transition-all duration-300\"\n            style={{ width: `${stats.completionPercentage}%` }}\n          />\n        </div>\n      </div>\n\n      {/* Filters */}\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-4\">\n        <div className=\"flex flex-wrap gap-4 items-center\">\n          {/* Search */}\n          <div className=\"relative flex-1 min-w-[200px]\">\n            <FaSearch className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400\" />\n            <input\n              type=\"text\"\n              placeholder=\"Search achievements...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"w-full pl-10 pr-4 py-2 bg-white/10 border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-nightly-aquamarine\"\n            />\n          </div>\n\n          {/* Category Filter */}\n          <select\n            value={selectedCategory}\n            onChange={(e) =>\n              setSelectedCategory(e.target.value as AchievementCategory | \"all\")\n            }\n            className=\"px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-nightly-aquamarine\"\n          >\n            <option value=\"all\">All Categories</option>\n            {Object.values(AchievementCategory).map((category) => (\n              <option key={category} value={category}>\n                {getCategoryName(category)}\n              </option>\n            ))}\n          </select>\n\n          {/* Difficulty Filter */}\n          <select\n            value={selectedDifficulty}\n            onChange={(e) =>\n              setSelectedDifficulty(\n                e.target.value as AchievementDifficulty | \"all\",\n              )\n            }\n            className=\"px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-nightly-aquamarine\"\n          >\n            <option value=\"all\">All Difficulties</option>\n            {Object.values(AchievementDifficulty).map((difficulty) => (\n              <option key={difficulty} value={difficulty}>\n                {difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}\n              </option>\n            ))}\n          </select>\n\n          {/* Earned Filter */}\n          <label className=\"flex items-center space-x-2 text-nightly-celadon\">\n            <input\n              type=\"checkbox\"\n              checked={showOnlyEarned}\n              onChange={(e) => setShowOnlyEarned(e.target.checked)}\n              className=\"rounded border-white/20 bg-white/10 text-nightly-aquamarine focus:ring-nightly-aquamarine\"\n            />\n            <span>Earned Only</span>\n          </label>\n        </div>\n      </div>\n\n      {/* Achievement Groups */}\n      <div className=\"space-y-6\">\n        {Object.entries(groupedAchievements).map(\n          ([categoryName, achievements]) => (\n            <div key={categoryName} className=\"space-y-4\">\n              <h3 className=\"text-xl font-semibold text-nightly-honeydew border-b border-white/20 pb-2\">\n                {categoryName} ({achievements.length})\n              </h3>\n\n              <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n                {achievements.map((item) => (\n                  <AchievementCard\n                    key={item.achievement.id}\n                    item={item}\n                    onToggleVisibility={onToggleVisibility}\n                    isOwnGallery={isOwnGallery}\n                  />\n                ))}\n              </div>\n            </div>\n          ),\n        )}\n      </div>\n\n      {filteredAchievements.length === 0 && (\n        <div className=\"text-center py-12 text-nightly-celadon\">\n          <FaTrophy className=\"mx-auto text-4xl mb-4 opacity-50\" />\n          <p>No achievements found matching your filters.</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\ninterface AchievementCardProps {\n  item: AchievementWithProgress;\n  onToggleVisibility?: (achievementId: string) => void;\n  isOwnGallery: boolean;\n}\n\n// Helper function to get card styling classes\nconst getCardClasses = (\n  achievement: DBAchievement,\n  isEarned: boolean,\n): string => {\n  const baseClasses =\n    \"relative p-4 rounded-lg border-2 transition-all duration-200\";\n  const earnedClasses = isEarned\n    ? `${getDifficultyColor(achievement.difficulty)} shadow-lg`\n    : \"border-gray-600 bg-gray-800/50\";\n  const opacityClass = !isEarned ? \"opacity-75\" : \"\";\n\n  return `${baseClasses} ${earnedClasses} ${opacityClass}`;\n};\n\n// Helper function to get text styling classes\nconst getTextClasses = (\n  type: \"title\" | \"description\",\n  isEarned: boolean,\n): string => {\n  if (type === \"title\") {\n    return `font-bold ${isEarned ? \"text-gray-800\" : \"text-nightly-honeydew\"}`;\n  }\n  return `text-sm mt-1 ${isEarned ? \"text-gray-600\" : \"text-nightly-celadon\"}`;\n};\n\n// Helper function to get badge styling classes\nconst getBadgeClasses = (\n  type: \"points\" | \"difficulty\",\n  isEarned: boolean,\n): string => {\n  const baseClasses = \"text-xs px-2 py-1 rounded font-semibold\";\n  const colorClasses = isEarned\n    ? type === \"points\"\n      ? \"bg-yellow-200 text-yellow-800\"\n      : \"bg-blue-200 text-blue-800\"\n    : \"bg-gray-700 text-gray-300\";\n  const extraClasses = type === \"difficulty\" ? \"capitalize\" : \"\";\n\n  return `${baseClasses} ${colorClasses} ${extraClasses}`;\n};\n\n// Helper function to render visibility toggle\nconst renderVisibilityToggle = (\n  achievement: DBAchievement,\n  isEarned: boolean,\n  isVisible: boolean,\n  isOwnGallery: boolean,\n  onToggleVisibility?: (achievementId: string) => void,\n) => {\n  if (!isOwnGallery || !isEarned || !onToggleVisibility) {\n    return null;\n  }\n\n  return (\n    <button\n      onClick={() => onToggleVisibility(achievement.id)}\n      className=\"absolute top-2 right-2 p-1 rounded text-gray-400 hover:text-white transition-colors\"\n    >\n      {isVisible ? <FaEye /> : <FaEyeSlash />}\n    </button>\n  );\n};\n\n// Helper function to render progress bar\nconst renderProgressBar = (\n  progress: AchievementWithProgress[\"progress\"],\n  isEarned: boolean,\n) => {\n  if (!progress || isEarned) {\n    return null;\n  }\n\n  return (\n    <div className=\"mt-3\">\n      <div className=\"flex justify-between text-xs text-nightly-celadon mb-1\">\n        <span>Progress</span>\n        <span>\n          {progress.currentValue} / {progress.targetValue}\n        </span>\n      </div>\n      <div className=\"w-full bg-gray-700 rounded-full h-2\">\n        <div\n          className=\"bg-gradient-to-r from-nightly-aquamarine to-nightly-lavender-floral h-2 rounded-full transition-all duration-300\"\n          style={{ width: `${Math.min(progress.percentage, 100)}%` }}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Helper function to render hidden achievement indicator\nconst renderHiddenIndicator = (\n  achievement: DBAchievement,\n  isEarned: boolean,\n) => {\n  if (!achievement.isHidden || isEarned) {\n    return null;\n  }\n\n  return (\n    <div className=\"flex items-center space-x-1 mt-2 text-xs text-gray-500\">\n      <FaLock />\n      <span>Hidden Achievement</span>\n    </div>\n  );\n};\n\nconst AchievementCard: React.FC<AchievementCardProps> = ({\n  item,\n  onToggleVisibility,\n  isOwnGallery,\n}) => {\n  const { achievement, progress, isEarned, isVisible } = item;\n\n  return (\n    <div className={getCardClasses(achievement, isEarned)}>\n      {renderVisibilityToggle(\n        achievement,\n        isEarned,\n        isVisible,\n        isOwnGallery,\n        onToggleVisibility,\n      )}\n\n      {/* Achievement Icon */}\n      <div className=\"flex items-start space-x-3\">\n        <div className=\"text-3xl\">{achievement.icon}</div>\n        <div className=\"flex-1\">\n          {/* Achievement Name */}\n          <h4 className={getTextClasses(\"title\", isEarned)}>\n            {achievement.name}\n          </h4>\n\n          {/* Achievement Description */}\n          <p className={getTextClasses(\"description\", isEarned)}>\n            {achievement.description}\n          </p>\n\n          {/* Points and Difficulty */}\n          <div className=\"flex items-center justify-between mt-3\">\n            <div className=\"flex items-center space-x-2\">\n              <span className={getBadgeClasses(\"points\", isEarned)}>\n                {achievement.points} pts\n              </span>\n              <span className={getBadgeClasses(\"difficulty\", isEarned)}>\n                {achievement.difficulty}\n              </span>\n            </div>\n\n            {isEarned && (\n              <FaTrophy\n                className=\"text-yellow-600\"\n                title=\"Achievement Earned!\"\n              />\n            )}\n          </div>\n\n          {renderProgressBar(progress, isEarned)}\n          {renderHiddenIndicator(achievement, isEarned)}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AchievementGallery;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementNotification.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/AchievementPrivacySettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/LeaderboardView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/ConflictResolutionModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (161). Maximum allowed is 75.","line":29,"column":75,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":202,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (91). Maximum allowed is 75.","line":78,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":173,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Conflict Resolution Modal\n * User interface for resolving data sync conflicts\n */\nimport React, { useState } from \"react\";\nimport type { ConflictInfo } from \"@/types/database\";\n\ninterface ConflictResolutionProps {\n  conflicts: ConflictInfo[];\n  onResolve: (resolutions: Record<string, \"local\" | \"remote\">) => void;\n  onCancel: () => void;\n  isOpen: boolean;\n}\n\nconst formatTimestamp = (date: Date): string => {\n  return new Intl.DateTimeFormat(\"en-US\", {\n    dateStyle: \"short\",\n    timeStyle: \"short\",\n  }).format(date);\n};\n\nconst formatValue = (value: unknown): string => {\n  if (value === null || value === undefined) return \"Not set\";\n  if (typeof value === \"boolean\") return value ? \"Yes\" : \"No\";\n  if (typeof value === \"object\") return JSON.stringify(value, null, 2);\n  return String(value);\n};\n\nexport const ConflictResolutionModal: React.FC<ConflictResolutionProps> = ({\n  conflicts,\n  onResolve,\n  onCancel,\n  isOpen,\n}) => {\n  const [resolutions, setResolutions] = useState<\n    Record<string, \"local\" | \"remote\">\n  >({});\n\n  if (!isOpen || conflicts.length === 0) {\n    return null;\n  }\n\n  const handleResolve = () => {\n    if (Object.keys(resolutions).length === conflicts.length) {\n      onResolve(resolutions);\n    }\n  };\n\n  const handleResolutionChange = (\n    conflictId: string,\n    resolution: \"local\" | \"remote\",\n  ) => {\n    setResolutions((prev) => ({\n      ...prev,\n      [conflictId]: resolution,\n    }));\n  };\n\n  const getDeviceLabel = (isLocal: boolean): string => {\n    return isLocal ? \"This Device\" : \"Other Device\";\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-gray-800 border border-purple-700 rounded-lg shadow-xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden\">\n        <div className=\"p-6 border-b border-purple-700\">\n          <h2 className=\"text-xl font-semibold text-purple-300\">\n            Data Sync Conflicts Detected\n          </h2>\n          <p className=\"text-gray-400 mt-2\">\n            Your data was modified on multiple devices. Please choose which\n            version to keep for each conflict:\n          </p>\n        </div>\n\n        <div className=\"p-6 overflow-y-auto max-h-[60vh]\">\n          <div className=\"space-y-6\">\n            {conflicts.map((conflict, index) => {\n              const conflictId = `${conflict.collection}-${conflict.documentId}-${index}`;\n              const localTimestamp = new Date(\n                conflict.localData.lastModified as string,\n              );\n              const remoteTimestamp = new Date(\n                conflict.remoteData.lastModified as string,\n              );\n\n              return (\n                <div\n                  key={conflictId}\n                  className=\"border border-gray-700 rounded-lg p-4\"\n                >\n                  <h3 className=\"text-lg font-medium text-purple-200 mb-3\">\n                    {conflict.collection.charAt(0).toUpperCase() +\n                      conflict.collection.slice(1)}{\" \"}\n                    Conflict\n                  </h3>\n\n                  <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                    {/* Local Version */}\n                    <label className=\"cursor-pointer\">\n                      <input\n                        type=\"radio\"\n                        name={conflictId}\n                        value=\"local\"\n                        checked={resolutions[conflictId] === \"local\"}\n                        onChange={() =>\n                          handleResolutionChange(conflictId, \"local\")\n                        }\n                        className=\"sr-only\"\n                      />\n                      <div\n                        className={`border-2 rounded-lg p-4 transition-colors ${\n                          resolutions[conflictId] === \"local\"\n                            ? \"border-purple-500 bg-purple-500/10\"\n                            : \"border-gray-600 hover:border-purple-400\"\n                        }`}\n                      >\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"font-medium text-purple-300\">\n                            {getDeviceLabel(true)}\n                          </span>\n                          <span className=\"text-sm text-gray-400\">\n                            {formatTimestamp(localTimestamp)}\n                          </span>\n                        </div>\n\n                        <div className=\"bg-gray-900 rounded p-3 text-sm\">\n                          <pre className=\"whitespace-pre-wrap text-gray-300 overflow-x-auto\">\n                            {formatValue(conflict.localData)}\n                          </pre>\n                        </div>\n                      </div>\n                    </label>\n\n                    {/* Remote Version */}\n                    <label className=\"cursor-pointer\">\n                      <input\n                        type=\"radio\"\n                        name={conflictId}\n                        value=\"remote\"\n                        checked={resolutions[conflictId] === \"remote\"}\n                        onChange={() =>\n                          handleResolutionChange(conflictId, \"remote\")\n                        }\n                        className=\"sr-only\"\n                      />\n                      <div\n                        className={`border-2 rounded-lg p-4 transition-colors ${\n                          resolutions[conflictId] === \"remote\"\n                            ? \"border-purple-500 bg-purple-500/10\"\n                            : \"border-gray-600 hover:border-purple-400\"\n                        }`}\n                      >\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"font-medium text-purple-300\">\n                            {getDeviceLabel(false)}\n                          </span>\n                          <span className=\"text-sm text-gray-400\">\n                            {formatTimestamp(remoteTimestamp)}\n                          </span>\n                        </div>\n\n                        <div className=\"bg-gray-900 rounded p-3 text-sm\">\n                          <pre className=\"whitespace-pre-wrap text-gray-300 overflow-x-auto\">\n                            {formatValue(conflict.remoteData)}\n                          </pre>\n                        </div>\n                      </div>\n                    </label>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n\n        <div className=\"p-6 border-t border-purple-700 flex justify-between items-center\">\n          <div className=\"text-sm text-gray-400\">\n            {Object.keys(resolutions).length} of {conflicts.length} conflicts\n            resolved\n          </div>\n\n          <div className=\"flex space-x-3\">\n            <button\n              onClick={onCancel}\n              className=\"px-4 py-2 text-gray-400 hover:text-white transition-colors\"\n            >\n              Cancel\n            </button>\n            <button\n              onClick={handleResolve}\n              disabled={Object.keys(resolutions).length !== conflicts.length}\n              className=\"px-6 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded-lg transition-colors\"\n            >\n              Resolve Conflicts\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/DexieDemo.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (220). Maximum allowed is 75.","line":11,"column":36,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":256,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dexie Demo Component\n * Demonstrates offline-first functionality with Dexie\n */\nimport React, { useState, useEffect } from \"react\";\nimport { useDexieSync } from \"@/hooks/useDexieSync\";\nimport { useOfflineDemo } from \"@/hooks/useOfflineDemo\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport type { DBTask } from \"@/types/database\";\n\nexport const DexieDemo: React.FC = () => {\n  const { user } = useAuth();\n  const {\n    createWithSync,\n    updateWithSync,\n    deleteWithSync,\n    findByUserId,\n    isOnline,\n    syncStatus,\n    triggerSync,\n  } = useDexieSync();\n\n  const { simulateOffline, simulateOnline, forceOffline } = useOfflineDemo();\n\n  const [tasks, setTasks] = useState<DBTask[]>([]);\n  const [newTaskText, setNewTaskText] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load tasks on mount\n  useEffect(() => {\n    const loadTasks = async () => {\n      if (!user?.uid) return;\n\n      try {\n        setLoading(true);\n        const userTasks = await findByUserId(\"tasks\", user.uid);\n        setTasks(userTasks as DBTask[]);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : \"Failed to load tasks\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadTasks();\n  }, [user?.uid, findByUserId]);\n\n  const handleAddTask = async () => {\n    if (!user?.uid || !newTaskText.trim()) return;\n\n    try {\n      setError(null);\n      const taskData = {\n        id: crypto.randomUUID(),\n        userId: user.uid,\n        text: newTaskText.trim(),\n        description: \"Demo task created via Dexie\",\n        status: \"pending\" as const,\n        priority: \"medium\" as const,\n        assignedBy: \"submissive\" as const,\n        createdAt: new Date(),\n      };\n\n      await createWithSync(\"tasks\", taskData);\n\n      // Reload tasks to show the new one\n      const updatedTasks = await findByUserId(\"tasks\", user.uid);\n      setTasks(updatedTasks as DBTask[]);\n      setNewTaskText(\"\");\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to create task\");\n    }\n  };\n\n  const handleUpdateTask = async (taskId: string, status: DBTask[\"status\"]) => {\n    try {\n      setError(null);\n      await updateWithSync(\"tasks\", taskId, { status });\n\n      // Update local state\n      setTasks((prev) =>\n        prev.map((task) => (task.id === taskId ? { ...task, status } : task)),\n      );\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to update task\");\n    }\n  };\n\n  const handleDeleteTask = async (taskId: string) => {\n    try {\n      setError(null);\n      await deleteWithSync(\"tasks\", taskId);\n\n      // Remove from local state\n      setTasks((prev) => prev.filter((task) => task.id !== taskId));\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Failed to delete task\");\n    }\n  };\n\n  const handleManualSync = async () => {\n    try {\n      setError(null);\n      await triggerSync();\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"Sync failed\");\n    }\n  };\n\n  if (!user) {\n    return (\n      <div className=\"p-4 bg-gray-800 rounded-lg\">\n        <p className=\"text-gray-400\">Please log in to use the Dexie demo</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6 bg-gray-800 rounded-lg border border-gray-700\">\n      <h2 className=\"text-xl font-bold mb-2 text-white\">\n         Dexie Offline Demo\n      </h2>\n      <p className=\"text-sm text-gray-400 mb-4\">\n        Test offline functionality: Tasks are saved locally first, then synced\n        to Firebase when online. Try creating tasks while \"offline\" to see them\n        queue for sync!\n      </p>\n\n      {/* Status indicators */}\n      <div className=\"flex items-center justify-between mb-4\">\n        <div className=\"flex items-center space-x-4 text-sm\">\n          <span\n            className={`px-2 py-1 rounded ${isOnline ? \"bg-green-900 text-green-300\" : \"bg-red-900 text-red-300\"}`}\n          >\n            {isOnline ? \" Online\" : \" Offline\"}\n          </span>\n          <span\n            className={`px-2 py-1 rounded ${\n              syncStatus === \"synced\"\n                ? \"bg-green-900 text-green-300\"\n                : syncStatus === \"pending\"\n                  ? \"bg-yellow-900 text-yellow-300\"\n                  : \"bg-gray-700 text-gray-300\"\n            }`}\n          >\n            Sync: {syncStatus || \"unknown\"}\n          </span>\n        </div>\n\n        {/* Offline simulation buttons */}\n        <div className=\"flex space-x-2\">\n          <button\n            onClick={simulateOffline}\n            disabled={forceOffline}\n            className=\"px-2 py-1 bg-red-700 hover:bg-red-600 disabled:bg-gray-600 text-white text-xs rounded\"\n          >\n            Simulate Offline\n          </button>\n          <button\n            onClick={simulateOnline}\n            disabled={!forceOffline}\n            className=\"px-2 py-1 bg-green-700 hover:bg-green-600 disabled:bg-gray-600 text-white text-xs rounded\"\n          >\n            Go Online\n          </button>\n        </div>\n      </div>\n\n      {error && (\n        <div className=\"mb-4 p-3 bg-red-900/50 border border-red-700 rounded text-red-300 text-sm\">\n          {error}\n        </div>\n      )}\n\n      {/* Add new task */}\n      <div className=\"mb-6\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            value={newTaskText}\n            onChange={(e) => setNewTaskText(e.target.value)}\n            placeholder=\"Enter a task description...\"\n            className=\"flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400\"\n            onKeyPress={(e) => e.key === \"Enter\" && handleAddTask()}\n          />\n          <button\n            onClick={handleAddTask}\n            disabled={!newTaskText.trim() || loading}\n            className=\"px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white rounded transition-colors\"\n          >\n            Add Task\n          </button>\n        </div>\n        <p className=\"text-xs text-gray-400 mt-1\">\n          This will save to IndexedDB first, then sync to Firebase when online\n        </p>\n      </div>\n\n      {/* Tasks list */}\n      <div className=\"space-y-2 mb-4\">\n        {loading ? (\n          <p className=\"text-gray-400\">Loading tasks...</p>\n        ) : tasks.length === 0 ? (\n          <p className=\"text-gray-400\">No tasks yet. Add one above!</p>\n        ) : (\n          tasks.map((task) => (\n            <div\n              key={task.id}\n              className=\"flex items-center justify-between p-3 bg-gray-700 rounded\"\n            >\n              <div className=\"flex-1\">\n                <p className=\"text-white\">{task.text}</p>\n                <p className=\"text-xs text-gray-400\">\n                  Status: {task.status}  Created:{\" \"}\n                  {task.createdAt.toLocaleString()}\n                </p>\n              </div>\n              <div className=\"flex space-x-2\">\n                {task.status === \"pending\" && (\n                  <button\n                    onClick={() => handleUpdateTask(task.id, \"completed\")}\n                    className=\"px-2 py-1 bg-green-600 hover:bg-green-700 text-white text-xs rounded\"\n                  >\n                    Complete\n                  </button>\n                )}\n                <button\n                  onClick={() => handleDeleteTask(task.id)}\n                  className=\"px-2 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded\"\n                >\n                  Delete\n                </button>\n              </div>\n            </div>\n          ))\n        )}\n      </div>\n\n      {/* Manual sync button */}\n      <div className=\"flex justify-between items-center\">\n        <p className=\"text-xs text-gray-400\">\n          Tasks: {tasks.length}  Pending sync:{\" \"}\n          {tasks.filter((t) => t.syncStatus === \"pending\").length}\n        </p>\n        <button\n          onClick={handleManualSync}\n          disabled={!isOnline}\n          className=\"px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white text-xs rounded\"\n        >\n          Manual Sync\n        </button>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/SyncStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/common/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/DashboardHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/DashboardMain.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/dashboard/FeatureCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/database/DatabaseDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/examples/IntegratedTaskManager.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (92). Maximum allowed is 75.","line":19,"column":76,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":124,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_handleCreateTask' is assigned a value but never used.","line":37,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":61,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integrated Task Manager - Architecture Example\n *\n * This component demonstrates the complete new architecture:\n * - TanStack Query for server state (tasks)\n * - Zustand for UI state (modals, notifications, forms)\n * - Clean separation of concerns\n * - Optimistic updates with offline support\n */\nimport React from \"react\";\nimport { useTasksQuery, useTaskMutations } from \"../../hooks/api\";\nimport { useNotificationActions, useFormManager } from \"../../stores\";\nimport { FaTasks } from \"react-icons/fa\";\n\ninterface IntegratedTaskManagerProps {\n  userId: string;\n}\n\nexport const IntegratedTaskManager: React.FC<IntegratedTaskManagerProps> = ({\n  userId,\n}) => {\n  // Server state via TanStack Query\n  const { error } = useTasksQuery(userId);\n  const { createTask } = useTaskMutations();\n\n  // UI state via Zustand stores\n  const { showSuccess, showError } = useNotificationActions();\n\n  // Form state for new task form\n  const newTaskForm = useFormManager(\"newTaskForm\", {\n    title: \"\",\n    description: \"\",\n    deadline: \"\",\n    priority: \"medium\",\n  });\n\n  const _handleCreateTask = async () => {\n    const isValid = newTaskForm.validateForm(\"newTaskForm\", {\n      title: (value) => (!value?.trim() ? \"Title is required\" : undefined),\n      description: (value) =>\n        !value?.trim() ? \"Description is required\" : undefined,\n    });\n\n    if (!isValid) return;\n\n    try {\n      newTaskForm.setSubmitting(\"newTaskForm\", true);\n\n      await createTask.mutateAsync({\n        userId,\n        title: newTaskForm.getFieldValue(\"newTaskForm\", \"title\"),\n        description: newTaskForm.getFieldValue(\"newTaskForm\", \"description\"),\n        deadline: newTaskForm.getFieldValue(\"newTaskForm\", \"deadline\")\n          ? new Date(newTaskForm.getFieldValue(\"newTaskForm\", \"deadline\"))\n          : undefined,\n      });\n\n      // Reset form and show success\n      newTaskForm.resetForm(\"newTaskForm\");\n      showSuccess(\"Task created successfully!\");\n    } catch (error) {\n      showError(\"Failed to create task. Please try again.\");\n    } finally {\n      newTaskForm.setSubmitting(\"newTaskForm\", false);\n    }\n  };\n\n  if (error) {\n    return (\n      <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n        <h3 className=\"font-bold\">Error Loading Tasks</h3>\n        <p>Failed to load tasks. Please refresh the page or try again later.</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-4xl mx-auto p-6\">\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between mb-6\">\n          <div className=\"flex items-center gap-3\">\n            <FaTasks className=\"text-2xl text-nightly-lavender-floral\" />\n            <h2 className=\"text-2xl font-bold text-nightly-honeydew\">\n              Integrated Task Manager\n            </h2>\n          </div>\n          <div className=\"text-sm text-nightly-celadon\">\n            Architecture Demo: TanStack Query + Zustand\n          </div>\n        </div>\n\n        {/* Architecture Info */}\n        <div className=\"mt-8 p-4 bg-blue-500/10 border border-blue-500/20 rounded-lg\">\n          <h4 className=\"text-sm font-semibold text-blue-300 mb-2\">\n             Architecture Demonstration Complete\n          </h4>\n          <div className=\"text-xs text-blue-200 space-y-1\">\n            <p>\n               <strong>Server State:</strong> Tasks managed by TanStack Query\n              with Dexie backend\n            </p>\n            <p>\n               <strong>UI State:</strong> Forms, modals, notifications managed\n              by Zustand stores\n            </p>\n            <p>\n               <strong>Sync:</strong> Optimistic updates with Firebase\n              background sync\n            </p>\n            <p>\n               <strong>Offline:</strong> Full offline support with conflict\n              resolution\n            </p>\n            <p>\n               <strong>Performance:</strong> Smart caching and selective\n              re-renders\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/FeedbackFAB.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (86). Maximum allowed is 75.","line":11,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":107,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/feedback/FeedbackFAB.tsx\n\nimport React, { useState } from \"react\";\nimport { FaPlus, FaBug, FaLightbulb, FaComment } from \"../../utils/iconImport\";\nimport FeedbackModal from \"./FeedbackModal\";\n// TODO: Replace with proper hook - components shouldn't import services directly\n// import { FeedbackService } from \"../../services/feedbackService\";\nimport type { FeedbackType, FeedbackData } from \"../../types/feedback\";\nimport { logger } from \"../../utils/logging\";\n\nconst FeedbackFAB: React.FC = () => {\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [showModal, setShowModal] = useState(false);\n  const [feedbackType, setFeedbackType] = useState<FeedbackType | null>(null);\n\n  const openFeedback = (type: FeedbackType) => {\n    setFeedbackType(type);\n    setShowModal(true);\n    setIsExpanded(false);\n  };\n\n  const handleFeedbackSubmit = async (feedback: FeedbackData) => {\n    try {\n      // TODO: Replace with proper hook - components shouldn't call services directly\n      // await FeedbackService.submitFeedback(feedback);\n      logger.info(\n        \"Feedback submission temporarily disabled - needs hook implementation\",\n        feedback,\n      );\n    } catch (error) {\n      logger.error(\"Failed to submit feedback\", error);\n      // Error handling - could show a toast notification\n      throw error;\n    }\n  };\n\n  return (\n    <>\n      {/* Main FAB */}\n      <div className=\"fixed bottom-6 right-6 z-40\">\n        <div\n          className={`transition-all duration-300 ${isExpanded ? \"space-y-3\" : \"space-y-0\"}`}\n        >\n          {/* Expanded Options */}\n          {isExpanded && (\n            <div className=\"space-y-3\">\n              <button\n                onClick={() => openFeedback(\"bug\")}\n                className=\"flex items-center gap-2 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-full shadow-lg transition-all transform translate-y-0 opacity-100\"\n              >\n                <FaBug />\n                <span className=\"text-sm font-medium\">Report Bug</span>\n              </button>\n\n              <button\n                onClick={() => openFeedback(\"feature\")}\n                className=\"flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg transition-all transform translate-y-0 opacity-100\"\n              >\n                <FaLightbulb />\n                <span className=\"text-sm font-medium\">Suggest Feature</span>\n              </button>\n\n              <button\n                onClick={() => openFeedback(\"general\")}\n                className=\"flex items-center gap-2 bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-full shadow-lg transition-all transform translate-y-0 opacity-100\"\n              >\n                <FaComment />\n                <span className=\"text-sm font-medium\">General Feedback</span>\n              </button>\n            </div>\n          )}\n\n          {/* Main Button */}\n          <button\n            onClick={() => setIsExpanded(!isExpanded)}\n            className={`w-14 h-14 bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow-lg flex items-center justify-center transition-all ${\n              isExpanded ? \"rotate-45\" : \"rotate-0\"\n            }`}\n            aria-label=\"Open feedback options\"\n          >\n            <FaPlus className=\"text-xl\" />\n          </button>\n        </div>\n      </div>\n\n      {/* Backdrop for closing when expanded */}\n      {isExpanded && (\n        <div\n          className=\"fixed inset-0 z-30\"\n          onClick={() => setIsExpanded(false)}\n        />\n      )}\n\n      {/* Feedback Modal */}\n      {showModal && (\n        <FeedbackModal\n          type={feedbackType}\n          onClose={() => {\n            setShowModal(false);\n            setFeedbackType(null);\n          }}\n          onSubmit={handleFeedbackSubmit}\n        />\n      )}\n    </>\n  );\n};\n\nexport default FeedbackFAB;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/FeedbackModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (78). Maximum allowed is 75.","line":411,"column":53,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":496,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/feedback/FeedbackModal.tsx\n\nimport React, { useState } from \"react\";\nimport {\n  FaBug,\n  FaLightbulb,\n  FaComment,\n  FaTimes,\n  FaPaperPlane,\n} from \"../../utils/iconImport\";\nimport type {\n  FeedbackModalProps,\n  FeedbackData,\n  FeedbackType,\n} from \"../../types/feedback\";\nimport { collectSystemInfo } from \"../../utils/systemInfo\";\nimport { logger } from \"../../utils/logging\";\n\n// Form field components\ninterface FormFieldProps {\n  label: string;\n  required?: boolean;\n  children: React.ReactNode;\n}\n\nconst FormField: React.FC<FormFieldProps> = ({ label, required, children }) => (\n  <div>\n    <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n      {label} {required && <span className=\"text-red-400\">*</span>}\n    </label>\n    {children}\n  </div>\n);\n\ninterface TextInputProps {\n  value: string;\n  onChange: (value: string) => void;\n  placeholder: string;\n  disabled?: boolean;\n  required?: boolean;\n}\n\nconst TextInput: React.FC<TextInputProps> = ({\n  value,\n  onChange,\n  placeholder,\n  disabled,\n  required,\n}) => (\n  <input\n    type=\"text\"\n    value={value}\n    onChange={(e) => onChange(e.target.value)}\n    className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n    placeholder={placeholder}\n    required={required}\n    disabled={disabled}\n  />\n);\n\ninterface TextAreaProps {\n  value: string;\n  onChange: (value: string) => void;\n  placeholder: string;\n  rows?: number;\n  disabled?: boolean;\n  required?: boolean;\n}\n\nconst TextArea: React.FC<TextAreaProps> = ({\n  value,\n  onChange,\n  placeholder,\n  rows = 4,\n  disabled,\n  required,\n}) => (\n  <textarea\n    value={value}\n    onChange={(e) => onChange(e.target.value)}\n    className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-white placeholder-gray-400 resize-none focus:outline-none focus:ring-2 focus:ring-blue-500\"\n    rows={rows}\n    placeholder={placeholder}\n    required={required}\n    disabled={disabled}\n  />\n);\n\n// Priority selector component\ninterface PrioritySelectorProps {\n  value: string;\n  onChange: (value: string) => void;\n  disabled?: boolean;\n}\n\nconst PrioritySelector: React.FC<PrioritySelectorProps> = ({\n  value,\n  onChange,\n  disabled,\n}) => (\n  <select\n    value={value}\n    onChange={(e) => onChange(e.target.value)}\n    className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500\"\n    disabled={disabled}\n  >\n    <option value=\"low\">Low - Minor inconvenience</option>\n    <option value=\"medium\">Medium - Affects functionality</option>\n    <option value=\"high\">High - Prevents core features</option>\n  </select>\n);\n\n// Bug-specific fields component\ninterface BugFieldsProps {\n  formData: {\n    steps: string;\n    expected: string;\n    actual: string;\n    priority: string;\n  };\n  onUpdateField: (field: string, value: string) => void;\n  disabled: boolean;\n}\n\nconst BugFields: React.FC<BugFieldsProps> = ({\n  formData,\n  onUpdateField,\n  disabled,\n}) => (\n  <>\n    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n      <FormField label=\"Steps to Reproduce\">\n        <TextArea\n          value={formData.steps}\n          onChange={(value) => onUpdateField(\"steps\", value)}\n          placeholder=\"1. Go to...&#10;2. Click on...&#10;3. See error\"\n          rows={3}\n          disabled={disabled}\n        />\n      </FormField>\n\n      <FormField label=\"Priority\">\n        <PrioritySelector\n          value={formData.priority}\n          onChange={(value) => onUpdateField(\"priority\", value)}\n          disabled={disabled}\n        />\n      </FormField>\n    </div>\n\n    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n      <FormField label=\"Expected Behavior\">\n        <TextArea\n          value={formData.expected}\n          onChange={(value) => onUpdateField(\"expected\", value)}\n          placeholder=\"What should have happened?\"\n          rows={2}\n          disabled={disabled}\n        />\n      </FormField>\n\n      <FormField label=\"Actual Behavior\">\n        <TextArea\n          value={formData.actual}\n          onChange={(value) => onUpdateField(\"actual\", value)}\n          placeholder=\"What actually happened?\"\n          rows={2}\n          disabled={disabled}\n        />\n      </FormField>\n    </div>\n  </>\n);\n\n// Helper functions extracted from main component\nconst getModalTitle = (type: FeedbackType): string => {\n  switch (type) {\n    case \"bug\":\n      return \"Report a Bug\";\n    case \"feature\":\n      return \"Suggest a Feature\";\n    case \"general\":\n      return \"General Feedback\";\n    default:\n      return \"Feedback\";\n  }\n};\n\nconst getModalIcon = (type: FeedbackType): React.ReactElement => {\n  switch (type) {\n    case \"bug\":\n      return <FaBug className=\"text-red-400\" />;\n    case \"feature\":\n      return <FaLightbulb className=\"text-blue-400\" />;\n    case \"general\":\n      return <FaComment className=\"text-green-400\" />;\n    default:\n      return <FaComment className=\"text-green-400\" />;\n  }\n};\n\nconst getTitlePlaceholder = (type: FeedbackType): string => {\n  switch (type) {\n    case \"bug\":\n      return \"Brief description of the bug\";\n    case \"feature\":\n      return \"Short title for your feature request\";\n    case \"general\":\n      return \"Summary of your feedback\";\n    default:\n      return \"Brief title\";\n  }\n};\n\nconst getDescriptionPlaceholder = (type: FeedbackType): string => {\n  switch (type) {\n    case \"bug\":\n      return \"Describe what happened and what you expected to happen\";\n    case \"feature\":\n      return \"Describe your feature idea and how it would help\";\n    case \"general\":\n      return \"Share your thoughts and suggestions\";\n    default:\n      return \"Describe your feedback\";\n  }\n};\n\nconst getTitleLabel = (type: FeedbackType): string => {\n  switch (type) {\n    case \"bug\":\n      return \"Bug Summary\";\n    case \"feature\":\n      return \"Feature Title\";\n    default:\n      return \"Feedback Title\";\n  }\n};\n\n// Form content component\ninterface FeedbackFormProps {\n  type: FeedbackType;\n  formData: {\n    title: string;\n    description: string;\n    steps: string;\n    expected: string;\n    actual: string;\n    priority: string;\n    contactEmail: string;\n    includeSystemInfo: boolean;\n  };\n  updateField: (field: string, value: string | boolean | File | null) => void;\n  isSubmitting: boolean;\n  onSubmit: (e: React.FormEvent) => void;\n  onClose: () => void;\n}\n\n// Form actions component (toggle and buttons)\ninterface FormActionsProps {\n  type: FeedbackType;\n  formData: { includeSystemInfo: boolean };\n  updateField: (field: string, value: boolean | File | null) => void;\n  isSubmitting: boolean;\n  onClose: () => void;\n}\n\nconst FormActions: React.FC<FormActionsProps> = ({\n  type,\n  formData,\n  updateField,\n  isSubmitting,\n  onClose,\n}) => (\n  <>\n    {/* System Info Toggle */}\n    <div className=\"flex items-center justify-between\">\n      <div>\n        <div className=\"text-sm font-medium text-gray-300\">\n          Include System Information\n        </div>\n        <div className=\"text-xs text-gray-500\">\n          Helps us debug technical issues\n        </div>\n      </div>\n      <label className=\"relative inline-flex items-center cursor-pointer\">\n        <input\n          type=\"checkbox\"\n          checked={formData.includeSystemInfo}\n          onChange={(e) => updateField(\"includeSystemInfo\", e.target.checked)}\n          className=\"sr-only peer\"\n          disabled={isSubmitting}\n        />\n        <div className=\"w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600\"></div>\n      </label>\n    </div>\n\n    {/* Submit Buttons */}\n    <div className=\"flex gap-3 pt-4\">\n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className=\"bg-blue-600 hover:bg-blue-700 disabled:bg-blue-800 disabled:opacity-50 text-white px-6 py-3 rounded font-medium transition-colors flex items-center gap-2\"\n      >\n        <FaPaperPlane />\n        {getSubmitButtonText(type, isSubmitting)}\n      </button>\n      <button\n        type=\"button\"\n        onClick={onClose}\n        disabled={isSubmitting}\n        className=\"bg-white/10 hover:bg-white/20 disabled:bg-white/5 text-gray-300 px-6 py-3 rounded font-medium transition-colors\"\n      >\n        Cancel\n      </button>\n    </div>\n  </>\n);\n\nconst FeedbackForm: React.FC<FeedbackFormProps> = ({\n  type,\n  formData,\n  updateField,\n  isSubmitting,\n  onSubmit,\n  onClose,\n}) => (\n  <form\n    onSubmit={onSubmit}\n    className=\"p-6 overflow-y-auto max-h-[70vh] space-y-4\"\n  >\n    {/* Title */}\n    <FormField label={getTitleLabel(type)} required>\n      <TextInput\n        value={formData.title}\n        onChange={(value) => updateField(\"title\", value)}\n        placeholder={getTitlePlaceholder(type)}\n        disabled={isSubmitting}\n        required\n      />\n    </FormField>\n\n    {/* Description */}\n    <FormField label=\"Description\" required>\n      <TextArea\n        value={formData.description}\n        onChange={(value) => updateField(\"description\", value)}\n        placeholder={getDescriptionPlaceholder(type)}\n        disabled={isSubmitting}\n        required\n      />\n    </FormField>\n\n    {/* Bug-specific fields */}\n    {type === \"bug\" && (\n      <BugFields\n        formData={formData}\n        onUpdateField={updateField}\n        disabled={isSubmitting}\n      />\n    )}\n\n    {/* Screenshot Upload */}\n    <FormField label=\"Screenshot (Optional)\">\n      <input\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={(e) => updateField(\"screenshot\", e.target.files?.[0] || null)}\n        className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-white file:mr-4 file:rounded file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-white hover:file:bg-blue-700\"\n        disabled={isSubmitting}\n      />\n    </FormField>\n\n    {/* Contact Email */}\n    <FormField label=\"Contact Email (Optional)\">\n      <input\n        type=\"email\"\n        value={formData.contactEmail}\n        onChange={(e) => updateField(\"contactEmail\", e.target.value)}\n        className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n        placeholder=\"your@email.com (if you want updates)\"\n        disabled={isSubmitting}\n      />\n    </FormField>\n\n    <FormActions\n      type={type}\n      formData={formData}\n      updateField={updateField}\n      isSubmitting={isSubmitting}\n      onClose={onClose}\n    />\n  </form>\n);\n\nconst getSubmitButtonText = (\n  type: FeedbackType,\n  isSubmitting: boolean,\n): string => {\n  if (isSubmitting) return \"Submitting...\";\n\n  switch (type) {\n    case \"bug\":\n      return \"Submit Bug Report\";\n    case \"feature\":\n      return \"Submit Feature Request\";\n    default:\n      return \"Submit Feedback\";\n  }\n};\n\nconst FeedbackModal: React.FC<FeedbackModalProps> = ({\n  type,\n  onClose,\n  onSubmit,\n}) => {\n  const [formData, setFormData] = useState({\n    title: \"\",\n    description: \"\",\n    steps: \"\", // For bug reports\n    expected: \"\", // For bug reports\n    actual: \"\", // For bug reports\n    priority: \"medium\" as \"low\" | \"medium\" | \"high\",\n    category: \"\",\n    contactEmail: \"\",\n    includeSystemInfo: true,\n    screenshot: null as File | null,\n  });\n\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  if (!type) return null;\n\n  const updateField = (\n    field: string,\n    value: string | boolean | File | null,\n  ) => {\n    setFormData((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsSubmitting(true);\n\n    try {\n      const feedbackData: FeedbackData = {\n        type,\n        ...formData,\n        systemInfo: formData.includeSystemInfo\n          ? await collectSystemInfo()\n          : null,\n        timestamp: new Date(),\n        userAgent: navigator.userAgent,\n        url: window.location.pathname,\n      };\n\n      await onSubmit(feedbackData);\n      onClose();\n    } catch (error) {\n      logger.error(\"Failed to submit feedback\", error);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4\">\n      <div className=\"bg-gradient-to-br from-gray-900 to-gray-800 max-w-2xl w-full max-h-[90vh] rounded-lg border border-gray-600 overflow-hidden\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between p-6 border-b border-gray-600\">\n          <div className=\"flex items-center gap-3\">\n            {getModalIcon(type)}\n            <h2 className=\"text-xl font-bold text-white\">\n              {getModalTitle(type)}\n            </h2>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"p-2 hover:bg-white/10 rounded-lg transition-colors\"\n            disabled={isSubmitting}\n          >\n            <FaTimes className=\"text-gray-400\" />\n          </button>\n        </div>\n\n        <FeedbackForm\n          type={type}\n          formData={formData}\n          updateField={updateField}\n          isSubmitting={isSubmitting}\n          onSubmit={handleSubmit}\n          onClose={onClose}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default FeedbackModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/feedback/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AcceptInviteCodeSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinking.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (107). Maximum allowed is 75.","line":23,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":145,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Linking Component\n * Manages keyholder-submissive relationship creation and management\n */\nimport React from \"react\";\nimport { useKeyholderRelationships } from \"../../hooks/useKeyholderRelationships\";\nimport { getAccountLinkingState } from \"./AccountLinkingHelpers\";\nimport { AccountLinkingLoading } from \"./AccountLinkingLoading\";\nimport { AccountLinkingHeader } from \"./AccountLinkingHeader\";\nimport { LinkingMessageDisplay } from \"./LinkingMessageDisplay\";\nimport { RelationshipSummary } from \"./RelationshipSummary\";\nimport { ActiveKeyholderDisplay } from \"./ActiveKeyholderDisplay\";\nimport { InviteCodeCreationSection } from \"./InviteCodeCreationSection\";\nimport { ActiveInviteCodesDisplay } from \"./ActiveInviteCodesDisplay\";\nimport { AcceptInviteCodeSection } from \"./AcceptInviteCodeSection\";\nimport { SubmissiveRelationshipsDisplay } from \"./SubmissiveRelationshipsDisplay\";\nimport { AccountLinkingHelp } from \"./AccountLinkingHelp\";\n\ninterface AccountLinkingProps {\n  className?: string;\n}\n\nexport const AccountLinking: React.FC<AccountLinkingProps> = ({\n  className = \"\",\n}) => {\n  const {\n    relationships,\n    activeKeyholder,\n    activeInviteCodes,\n    relationshipSummary,\n    isLoading,\n    isCreatingInvite,\n    isAcceptingInvite,\n    inviteCodeInput,\n    keyholderNameInput,\n    message,\n    messageType,\n    createInviteCode,\n    acceptInviteCode,\n    revokeInviteCode,\n    endRelationship,\n    setInviteCodeInput,\n    setKeyholderNameInput,\n    clearMessage,\n    validateInviteCode,\n  } = useKeyholderRelationships();\n\n  // Helper functions to reduce complexity\n  const handleCreateInvite = async () => {\n    await createInviteCode(24); // 24 hour expiration\n  };\n\n  const handleAcceptInvite = async () => {\n    if (!validateInviteCode(inviteCodeInput)) {\n      return;\n    }\n    await acceptInviteCode(inviteCodeInput, keyholderNameInput);\n  };\n\n  const copyToClipboard = async (text: string) => {\n    try {\n      await navigator.clipboard.writeText(text);\n    } catch {\n      // Fallback for older browsers\n      const textArea = document.createElement(\"textarea\");\n      textArea.value = text;\n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      document.execCommand(\"copy\");\n      document.body.removeChild(textArea);\n    }\n  };\n\n  const linkingState = getAccountLinkingState(\n    relationships,\n    activeKeyholder,\n    activeInviteCodes,\n    message,\n    messageType,\n  );\n\n  if (isLoading) {\n    return <AccountLinkingLoading className={className} />;\n  }\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      {/* Header */}\n      <AccountLinkingHeader />\n\n      {/* Messages */}\n      <LinkingMessageDisplay\n        message={message}\n        messageType={messageType}\n        onClearMessage={clearMessage}\n      />\n\n      {/* Relationship Summary */}\n      <RelationshipSummary relationshipSummary={relationshipSummary} />\n\n      {/* Active Keyholder Relationship */}\n      {activeKeyholder && (\n        <ActiveKeyholderDisplay\n          activeKeyholder={activeKeyholder}\n          onEndRelationship={endRelationship}\n        />\n      )}\n\n      {/* Create Invite Code Section */}\n      <InviteCodeCreationSection\n        shouldShow={!linkingState.hasActiveKeyholder}\n        isCreatingInvite={isCreatingInvite}\n        onCreateInvite={handleCreateInvite}\n      />\n\n      {/* Active Invite Codes */}\n      <ActiveInviteCodesDisplay\n        activeInviteCodes={activeInviteCodes}\n        onCopyCode={copyToClipboard}\n        onRevokeCode={revokeInviteCode}\n      />\n\n      {/* Accept Invite Code Section */}\n      <AcceptInviteCodeSection\n        inviteCodeInput={inviteCodeInput}\n        keyholderNameInput={keyholderNameInput}\n        isAcceptingInvite={isAcceptingInvite}\n        onSetInviteCodeInput={setInviteCodeInput}\n        onSetKeyholderNameInput={setKeyholderNameInput}\n        onAcceptInvite={handleAcceptInvite}\n        validateInviteCode={validateInviteCode}\n      />\n\n      {/* Submissive Relationships */}\n      <SubmissiveRelationshipsDisplay\n        relationships={relationships.asKeyholder}\n        onEndRelationship={endRelationship}\n      />\n\n      {/* Help Section */}\n      <AccountLinkingHelp />\n    </div>\n  );\n};\n\nexport default AccountLinking;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingDemo.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5063,5066],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5063,5066],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (229). Maximum allowed is 75.","line":287,"column":70,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":528,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":472,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":472,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15525,15528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15525,15528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Demo component for Account Linking UI\n * Shows the interface with mock data for demonstration\n */\nimport React, { useState } from \"react\";\nimport {\n  FaKey,\n  FaLink,\n  FaUser,\n  FaUserShield,\n  FaCopy,\n  FaTrash,\n  FaExclamationTriangle,\n} from \"react-icons/fa\";\nimport { formatDistanceToNow } from \"date-fns\";\n\n// Mock data for demonstration\nconst mockInviteCodes = [\n  {\n    id: \"invite-1\",\n    code: \"ABC123\",\n    submissiveUserId: \"demo-user-123\",\n    submissiveName: \"Demo User\",\n    createdAt: new Date(Date.now() - 1000 * 60 * 30), // 30 minutes ago\n    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 23.5), // 23.5 hours from now\n    isUsed: false,\n  },\n  {\n    id: \"invite-2\",\n    code: \"XYZ789\",\n    submissiveUserId: \"demo-user-123\",\n    submissiveName: \"Demo User\",\n    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 2), // 2 hours ago\n    expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 22), // 22 hours from now\n    isUsed: false,\n  },\n];\n\nconst mockActiveKeyholder = {\n  id: \"rel-1\",\n  submissiveUserId: \"demo-user-123\",\n  keyholderUserId: \"keyholder-456\",\n  status: \"active\" as const,\n  permissions: {\n    canLockSessions: true,\n    canUnlockSessions: false,\n    canCreateTasks: true,\n    canApproveTasks: true,\n    canViewFullHistory: true,\n    canEditGoals: false,\n    canSetRules: false,\n  },\n  createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7), // 1 week ago\n  acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7), // 1 week ago\n};\n\nconst mockRelationshipSummary = {\n  hasActiveKeyholder: true,\n  hasSubmissives: false,\n  activeKeyholderCount: 1,\n  submissiveCount: 0,\n};\n\ninterface AccountLinkingDemoProps {\n  className?: string;\n  scenario?:\n    | \"submissive-with-keyholder\"\n    | \"submissive-no-keyholder\"\n    | \"keyholder-with-submissives\";\n}\n\n// Utility functions to reduce complexity\nconst getScenarioData = (scenario: string) => {\n  const activeKeyholder =\n    scenario === \"submissive-with-keyholder\" ? mockActiveKeyholder : null;\n  const activeInviteCodes =\n    scenario === \"submissive-no-keyholder\" ? mockInviteCodes : [];\n\n  const relationshipSummary =\n    scenario === \"submissive-with-keyholder\"\n      ? mockRelationshipSummary\n      : scenario === \"keyholder-with-submissives\"\n        ? {\n            ...mockRelationshipSummary,\n            hasActiveKeyholder: false,\n            hasSubmissives: true,\n            submissiveCount: 2,\n          }\n        : {\n            ...mockRelationshipSummary,\n            hasActiveKeyholder: false,\n            hasSubmissives: false,\n            activeKeyholderCount: 0,\n          };\n\n  const relationships =\n    scenario === \"keyholder-with-submissives\"\n      ? {\n          asSubmissive: [],\n          asKeyholder: [\n            {\n              id: \"rel-2\",\n              submissiveUserId: \"sub-1\",\n              keyholderUserId: \"demo-user-123\",\n              status: \"active\" as const,\n              permissions: mockActiveKeyholder.permissions,\n              createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3),\n              acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3),\n            },\n            {\n              id: \"rel-3\",\n              submissiveUserId: \"sub-2\",\n              keyholderUserId: \"demo-user-123\",\n              status: \"active\" as const,\n              permissions: mockActiveKeyholder.permissions,\n              createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 5),\n              acceptedAt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 5),\n            },\n          ],\n        }\n      : { asSubmissive: [], asKeyholder: [] };\n\n  return {\n    activeKeyholder,\n    activeInviteCodes,\n    relationshipSummary,\n    relationships,\n  };\n};\n\n// Custom hook for message handling\nconst useMessageState = () => {\n  const [message, setMessage] = useState(\"\");\n  const [messageType, setMessageType] = useState<\"success\" | \"error\" | \"info\">(\n    \"info\",\n  );\n\n  const showMessage = (\n    text: string,\n    type: \"success\" | \"error\" | \"info\" = \"info\",\n  ) => {\n    setMessage(text);\n    setMessageType(type);\n  };\n\n  const clearMessage = () => {\n    setMessage(\"\");\n    setMessageType(\"info\");\n  };\n\n  return { message, messageType, showMessage, clearMessage };\n};\n\n// Render helper functions to reduce complexity\nconst renderMessageDisplay = (\n  message: string,\n  messageType: string,\n  clearMessage: () => void,\n) => {\n  if (!message) return null;\n  return (\n    <div\n      className={`p-3 rounded-lg border ${\n        messageType === \"success\"\n          ? \"bg-green-900/50 border-green-500 text-green-300\"\n          : messageType === \"error\"\n            ? \"bg-red-900/50 border-red-500 text-red-300\"\n            : \"bg-blue-900/50 border-blue-500 text-blue-300\"\n      }`}\n    >\n      <div className=\"flex justify-between items-start\">\n        <p className=\"text-sm\">{message}</p>\n        <button\n          onClick={clearMessage}\n          className=\"text-current opacity-70 hover:opacity-100 ml-2\"\n        >\n          \n        </button>\n      </div>\n    </div>\n  );\n};\n\nconst renderActiveKeyholder = (\n  activeKeyholder: any,\n  showPermissions: string | null,\n  setShowPermissions: (id: string | null) => void,\n) => {\n  if (!activeKeyholder) return null;\n  return (\n    <div className=\"bg-gradient-to-r from-purple-900/50 to-pink-900/50 rounded-lg p-4 border border-purple-500\">\n      <div className=\"flex items-center justify-between mb-2\">\n        <h3 className=\"font-semibold text-purple-300 flex items-center\">\n          <FaKey className=\"mr-2\" />\n          Your Keyholder\n        </h3>\n        <button\n          onClick={() =>\n            setShowPermissions(\n              showPermissions === activeKeyholder.id\n                ? null\n                : activeKeyholder.id,\n            )\n          }\n          className=\"text-purple-400 hover:text-purple-300 text-sm\"\n        >\n          {showPermissions === activeKeyholder.id ? \"Hide\" : \"View\"} Permissions\n        </button>\n      </div>\n      <div className=\"text-sm text-gray-300 mb-3\">\n        <p>\n          Connected:{\" \"}\n          {formatDistanceToNow(\n            activeKeyholder.acceptedAt || activeKeyholder.createdAt,\n          )}{\" \"}\n          ago\n        </p>\n        <p>\n          Status: <span className=\"text-green-400\">Active</span>\n        </p>\n      </div>\n      {showPermissions === activeKeyholder.id && (\n        <div className=\"mt-3 p-3 bg-gray-700 rounded border\">\n          <h4 className=\"font-medium text-purple-300 mb-2\">\n            Keyholder Permissions\n          </h4>\n          <div className=\"grid grid-cols-2 gap-2 text-xs\">\n            {Object.entries(activeKeyholder.permissions).map(([key, value]) => (\n              <div key={key} className=\"flex items-center\">\n                <span className={value ? \"text-green-400\" : \"text-red-400\"}>\n                  {value ? \"\" : \"\"}\n                </span>\n                <span className=\"ml-2 text-gray-300\">\n                  {key\n                    .replace(/([A-Z])/g, \" $1\")\n                    .replace(/^./, (str) => str.toUpperCase())}\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n      <div className=\"mt-3 flex gap-2\">\n        <button className=\"text-red-400 hover:text-red-300 text-sm px-3 py-1 border border-red-500 rounded hover:bg-red-900/30 transition-colors\">\n          End Relationship\n        </button>\n      </div>\n    </div>\n  );\n};\n\nconst renderCreateInviteSection = (\n  hasActiveKeyholder: boolean,\n  showCreateInvite: boolean,\n  setShowCreateInvite: (show: boolean) => void,\n  handleCreateInvite: () => void,\n) => {\n  if (hasActiveKeyholder) return null;\n  return (\n    <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n      <div className=\"flex items-center justify-between mb-3\">\n        <h3 className=\"font-semibold text-purple-300\">Create Invite Code</h3>\n        <button\n          onClick={() => setShowCreateInvite(!showCreateInvite)}\n          className=\"text-purple-400 hover:text-purple-300 text-sm\"\n        >\n          {showCreateInvite ? \"Cancel\" : \"Create Code\"}\n        </button>\n      </div>\n      {showCreateInvite && (\n        <div className=\"space-y-3\">\n          <p className=\"text-sm text-gray-400\">\n            Generate an invite code for a keyholder to link to your account.\n          </p>\n          <button\n            onClick={handleCreateInvite}\n            className=\"w-full bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded transition-colors\"\n          >\n            Generate Invite Code\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport const AccountLinkingDemo: React.FC<AccountLinkingDemoProps> = ({\n  className = \"\",\n  scenario = \"submissive-no-keyholder\",\n}) => {\n  const [showCreateInvite, setShowCreateInvite] = useState(false);\n  const [showAcceptInvite, setShowAcceptInvite] = useState(false);\n  const [showPermissions, setShowPermissions] = useState<string | null>(null);\n  const [inviteCodeInput, setInviteCodeInput] = useState(\"\");\n  const [keyholderNameInput, setKeyholderNameInput] = useState(\"\");\n\n  const { message, messageType, showMessage, clearMessage } = useMessageState();\n  const {\n    activeKeyholder,\n    activeInviteCodes,\n    relationshipSummary,\n    relationships,\n  } = getScenarioData(scenario);\n\n  const handleCreateInvite = () => {\n    showMessage(\"Invite code created: DEF456\", \"success\");\n    setShowCreateInvite(false);\n  };\n\n  const handleAcceptInvite = () => {\n    if (inviteCodeInput.length === 6) {\n      showMessage(\"Successfully linked with submissive!\", \"success\");\n      setShowAcceptInvite(false);\n      setInviteCodeInput(\"\");\n      setKeyholderNameInput(\"\");\n    }\n  };\n\n  const copyToClipboard = (text: string) => {\n    navigator.clipboard?.writeText(text);\n    showMessage(`Copied ${text} to clipboard`, \"success\");\n  };\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      {/* Header */}\n      <div className=\"text-center\">\n        <h2 className=\"text-2xl font-bold text-purple-300 mb-2\">\n          <FaLink className=\"inline mr-2\" />\n          Account Linking\n        </h2>\n        <p className=\"text-purple-400 text-sm\">\n          Connect with keyholders or submissives for enhanced control and\n          oversight\n        </p>\n      </div>\n\n      {/* Messages */}\n      {renderMessageDisplay(message, messageType, clearMessage)}\n\n      {/* Relationship Summary */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n        <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n          <div className=\"flex items-center mb-2\">\n            <FaUser className=\"text-purple-400 mr-2\" />\n            <h3 className=\"font-semibold text-purple-300\">As Submissive</h3>\n          </div>\n          {relationshipSummary.hasActiveKeyholder ? (\n            <div className=\"text-green-400 text-sm\">\n               Linked with keyholder\n            </div>\n          ) : (\n            <div className=\"text-gray-400 text-sm\">No active keyholder</div>\n          )}\n        </div>\n        <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n          <div className=\"flex items-center mb-2\">\n            <FaUserShield className=\"text-purple-400 mr-2\" />\n            <h3 className=\"font-semibold text-purple-300\">As Keyholder</h3>\n          </div>\n          <div className=\"text-sm text-gray-300\">\n            {relationshipSummary.submissiveCount} submissive(s)\n          </div>\n        </div>\n      </div>\n\n      {/* Active Keyholder Relationship */}\n      {renderActiveKeyholder(\n        activeKeyholder,\n        showPermissions,\n        setShowPermissions,\n      )}\n\n      {/* Create Invite Code Section */}\n      {renderCreateInviteSection(\n        relationshipSummary.hasActiveKeyholder,\n        showCreateInvite,\n        setShowCreateInvite,\n        handleCreateInvite,\n      )}\n\n      {/* Active Invite Codes */}\n      {activeInviteCodes.length > 0 && (\n        <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n          <h3 className=\"font-semibold text-purple-300 mb-3\">\n            Active Invite Codes\n          </h3>\n          <div className=\"space-y-2\">\n            {activeInviteCodes.map((invite) => (\n              <div\n                key={invite.id}\n                className=\"flex items-center justify-between p-2 bg-gray-700 rounded\"\n              >\n                <div>\n                  <div className=\"font-mono text-lg text-green-400\">\n                    {invite.code}\n                  </div>\n                  <div className=\"text-xs text-gray-400\">\n                    Expires: {formatDistanceToNow(invite.expiresAt)} from now\n                  </div>\n                </div>\n                <div className=\"flex gap-2\">\n                  <button\n                    onClick={() => copyToClipboard(invite.code)}\n                    className=\"text-purple-400 hover:text-purple-300 p-1\"\n                    title=\"Copy code\"\n                  >\n                    <FaCopy />\n                  </button>\n                  <button\n                    className=\"text-red-400 hover:text-red-300 p-1\"\n                    title=\"Revoke code\"\n                  >\n                    <FaTrash />\n                  </button>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Accept Invite Code Section */}\n      <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n        <div className=\"flex items-center justify-between mb-3\">\n          <h3 className=\"font-semibold text-purple-300\">Accept Invite Code</h3>\n          <button\n            onClick={() => setShowAcceptInvite(!showAcceptInvite)}\n            className=\"text-purple-400 hover:text-purple-300 text-sm\"\n          >\n            {showAcceptInvite ? \"Cancel\" : \"Enter Code\"}\n          </button>\n        </div>\n        {showAcceptInvite && (\n          <div className=\"space-y-3\">\n            <p className=\"text-sm text-gray-400\">\n              Enter an invite code from a submissive to become their keyholder.\n            </p>\n            <input\n              type=\"text\"\n              value={inviteCodeInput}\n              onChange={(e) => setInviteCodeInput(e.target.value.toUpperCase())}\n              placeholder=\"Enter 6-character code\"\n              maxLength={6}\n              className=\"w-full p-2 bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400 font-mono text-center tracking-wider\"\n            />\n            <input\n              type=\"text\"\n              value={keyholderNameInput}\n              onChange={(e) => setKeyholderNameInput(e.target.value)}\n              placeholder=\"Your name (optional)\"\n              className=\"w-full p-2 bg-gray-700 border border-gray-600 rounded text-white placeholder-gray-400\"\n            />\n            <button\n              onClick={handleAcceptInvite}\n              disabled={inviteCodeInput.length !== 6}\n              className=\"w-full bg-purple-600 hover:bg-purple-700 disabled:bg-purple-800 text-white py-2 px-4 rounded transition-colors\"\n            >\n              Accept Invite Code\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Submissive Relationships */}\n      {relationships.asKeyholder.length > 0 && (\n        <div className=\"bg-gray-800 rounded-lg p-4 border border-purple-500/30\">\n          <h3 className=\"font-semibold text-purple-300 mb-3\">\n            Your Submissives\n          </h3>\n          <div className=\"space-y-2\">\n            {relationships.asKeyholder.map((relationship: any) => (\n              <div\n                key={relationship.id}\n                className=\"p-3 bg-gray-700 rounded border\"\n              >\n                <div className=\"flex items-center justify-between mb-2\">\n                  <div className=\"text-sm\">\n                    <div className=\"text-green-400\">Active Submissive</div>\n                    <div className=\"text-xs text-gray-400\">\n                      Connected:{\" \"}\n                      {formatDistanceToNow(\n                        relationship.acceptedAt || relationship.createdAt,\n                      )}{\" \"}\n                      ago\n                    </div>\n                  </div>\n                  <button className=\"text-red-400 hover:text-red-300 text-sm px-2 py-1 border border-red-500 rounded hover:bg-red-900/30\">\n                    End\n                  </button>\n                </div>\n                <div className=\"text-xs text-gray-400\">\n                  Permissions:{\" \"}\n                  {\n                    Object.values(relationship.permissions).filter(Boolean)\n                      .length\n                  }{\" \"}\n                  of {Object.keys(relationship.permissions).length} granted\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Help Section */}\n      <div className=\"bg-blue-900/30 border border-blue-500/50 rounded-lg p-4\">\n        <div className=\"flex items-start\">\n          <FaExclamationTriangle className=\"text-blue-400 mt-1 mr-2 flex-shrink-0\" />\n          <div className=\"text-sm text-blue-300\">\n            <h4 className=\"font-medium mb-1\">About Account Linking</h4>\n            <ul className=\"space-y-1 text-xs text-blue-200\">\n              <li>\n                 Submissives can create invite codes for keyholders to accept\n              </li>\n              <li>\n                 Only one active keyholder per submissive currently supported\n              </li>\n              <li> Invite codes expire after 24 hours</li>\n              <li> Either party can end the relationship at any time</li>\n              <li> Submissives control what permissions keyholders have</li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AccountLinkingDemo;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHelp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingLoading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AccountLinkingPreview.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (288). Maximum allowed is 75.","line":18,"column":48,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":324,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used.","line":19,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'relationships' is assigned a value but never used.","line":26,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isKeyholder' is assigned a value but never used.","line":27,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isWearer' is assigned a value but never used.","line":28,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":63,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport {\n  FaUserShield,\n  FaLink,\n  FaUsers,\n  FaQrcode,\n  FaClipboard,\n  FaPlus,\n  FaSpinner,\n  FaExclamationTriangle,\n  FaTimes,\n  FaCheck,\n} from \"../../utils/iconImport\";\nimport { useAccountLinking } from \"../../hooks/account-linking/useAccountLinking\";\nimport { useAuthState } from \"../../contexts\";\n\n// Account Linking Component - Now functional!\nexport const AccountLinkingPreview: React.FC = () => {\n  const { user } = useAuthState();\n  const {\n    currentLinkCode,\n    linkCodeError,\n    isGeneratingCode,\n    isUsingCode,\n    codeUsageError,\n    relationships,\n    isKeyholder,\n    isWearer,\n    hasActiveRelationships,\n    keyholderRelationships,\n    wearerRelationships,\n    generateLinkCode,\n    redeemLinkCode,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearErrors,\n    toggleQRCode,\n    showQRCode,\n  } = useAccountLinking();\n\n  const [showLinkForm, setShowLinkForm] = useState(false);\n  const [linkCodeInput, setLinkCodeInput] = useState(\"\");\n  const [copySuccess, setCopySuccess] = useState(false);\n\n  const handleGenerateCode = () => {\n    generateLinkCode({ shareMethod: \"manual\" });\n  };\n\n  const handleUseLinkCode = () => {\n    if (linkCodeInput.trim()) {\n      redeemLinkCode({ code: linkCodeInput.trim() });\n      setLinkCodeInput(\"\");\n      setShowLinkForm(false);\n    }\n  };\n\n  const handleCopyCode = async () => {\n    if (currentLinkCode?.code) {\n      try {\n        await navigator.clipboard.writeText(currentLinkCode.code);\n        setCopySuccess(true);\n        setTimeout(() => setCopySuccess(false), 2000);\n      } catch (error) {\n        // Silently fail - copying is a nice-to-have feature\n      }\n    }\n  };\n\n  const handleDisconnect = (relationshipId: string) => {\n    // TODO: Replace with proper confirmation modal\n    disconnectKeyholder(relationshipId, \"User requested disconnection\");\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaUserShield className=\"text-nightly-lavender-floral\" />\n        <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n          Account Linking\n        </h2>\n        <span className=\"bg-green-500/20 text-green-400 px-2 py-1 text-xs rounded\">\n          ACTIVE\n        </span>\n      </div>\n\n      {/* Current Relationships */}\n      {hasActiveRelationships && (\n        <div className=\"mb-6\">\n          <h3 className=\"text-lg font-medium text-nightly-honeydew mb-3\">\n            Active Relationships\n          </h3>\n          <div className=\"space-y-3\">\n            {keyholderRelationships.map((relationship) => (\n              <div\n                key={relationship.id}\n                className=\"bg-white/5 rounded-lg p-4 flex items-center justify-between\"\n              >\n                <div>\n                  <div className=\"font-medium text-nightly-honeydew\">\n                    Keyholder for: {relationship.wearerId}\n                  </div>\n                  <div className=\"text-sm text-nightly-celadon\">\n                    Established:{\" \"}\n                    {relationship.establishedAt.toDate().toLocaleDateString()}\n                  </div>\n                </div>\n                <button\n                  onClick={() => handleDisconnect(relationship.id)}\n                  className=\"text-red-400 hover:text-red-300 px-3 py-1 rounded text-sm\"\n                >\n                  Disconnect\n                </button>\n              </div>\n            ))}\n            {wearerRelationships.map((relationship) => (\n              <div\n                key={relationship.id}\n                className=\"bg-white/5 rounded-lg p-4 flex items-center justify-between\"\n              >\n                <div>\n                  <div className=\"font-medium text-nightly-honeydew\">\n                    Managed by: {relationship.keyholderId}\n                  </div>\n                  <div className=\"text-sm text-nightly-celadon\">\n                    Established:{\" \"}\n                    {relationship.establishedAt.toDate().toLocaleDateString()}\n                  </div>\n                </div>\n                <button\n                  onClick={() => handleDisconnect(relationship.id)}\n                  className=\"text-red-400 hover:text-red-300 px-3 py-1 rounded text-sm\"\n                >\n                  Disconnect\n                </button>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Link Code Generation (For Wearers) */}\n      <div className=\"space-y-4\">\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          <div className=\"bg-white/5 rounded-lg p-4\">\n            <h3 className=\"font-medium text-nightly-honeydew mb-2 flex items-center gap-2\">\n              <FaLink className=\"text-nightly-aquamarine\" />\n              For Submissives\n            </h3>\n            <ul className=\"text-sm text-nightly-celadon space-y-1 mb-4\">\n              <li> Generate secure link codes</li>\n              <li> Share privately with keyholder</li>\n              <li> Maintain ultimate control</li>\n              <li> Disconnect anytime</li>\n            </ul>\n\n            {!currentLinkCode ? (\n              <button\n                onClick={handleGenerateCode}\n                disabled={isGeneratingCode}\n                className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2 disabled:opacity-50\"\n              >\n                {isGeneratingCode ? (\n                  <>\n                    <FaSpinner className=\"animate-spin\" />\n                    Generating...\n                  </>\n                ) : (\n                  <>\n                    <FaPlus />\n                    Generate Link Code\n                  </>\n                )}\n              </button>\n            ) : (\n              <div className=\"space-y-3\">\n                <div className=\"bg-black/20 rounded-lg p-4\">\n                  <div className=\"flex items-center justify-between mb-3\">\n                    <span className=\"text-nightly-celadon text-sm\">\n                      Your Link Code:\n                    </span>\n                    <span className=\"text-xs text-nightly-celadon\">\n                      {currentLinkCode.expiresIn}\n                    </span>\n                  </div>\n\n                  <div className=\"flex items-center gap-3 mb-3\">\n                    <code className=\"bg-nightly-aquamarine/20 text-nightly-aquamarine px-3 py-2 rounded font-mono text-lg flex-1\">\n                      {currentLinkCode.code}\n                    </code>\n                    <button\n                      onClick={handleCopyCode}\n                      className=\"text-nightly-aquamarine hover:text-nightly-spring-green p-2\"\n                      title=\"Copy to clipboard\"\n                    >\n                      {copySuccess ? <FaCheck /> : <FaClipboard />}\n                    </button>\n                  </div>\n\n                  <div className=\"flex gap-2\">\n                    <button\n                      onClick={toggleQRCode}\n                      className=\"bg-white/10 hover:bg-white/20 text-nightly-celadon px-3 py-1 rounded text-sm flex items-center gap-2\"\n                    >\n                      <FaQrcode />\n                      QR Code\n                    </button>\n                    <button\n                      onClick={clearLinkCode}\n                      className=\"bg-red-500/20 hover:bg-red-500/30 text-red-400 px-3 py-1 rounded text-sm flex items-center gap-2\"\n                    >\n                      <FaTimes />\n                      Clear\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"text-sm text-nightly-celadon\">\n                  <p className=\"mb-2\">\n                    <strong>Secure Sharing:</strong> Share this code privately\n                    with your keyholder via text, voice, QR code, or secure\n                    message.\n                  </p>\n                  <p>\n                    <strong>One-Time Use:</strong> Code expires in 24 hours or\n                    after first use. You can disconnect the keyholder anytime.\n                  </p>\n                </div>\n              </div>\n            )}\n\n            {linkCodeError && (\n              <div className=\"bg-red-500/20 text-red-400 p-3 rounded mt-3 flex items-center gap-2\">\n                <FaExclamationTriangle />\n                {linkCodeError}\n              </div>\n            )}\n          </div>\n\n          <div className=\"bg-white/5 rounded-lg p-4\">\n            <h3 className=\"font-medium text-nightly-honeydew mb-2 flex items-center gap-2\">\n              <FaUsers className=\"text-nightly-lavender-floral\" />\n              For Keyholders\n            </h3>\n            <ul className=\"text-sm text-nightly-celadon space-y-1 mb-4\">\n              <li> Full admin dashboard access</li>\n              <li> Manage multiple submissives</li>\n              <li> Real-time control & monitoring</li>\n              <li> Audit trail of all actions</li>\n            </ul>\n\n            {!showLinkForm ? (\n              <button\n                onClick={() => setShowLinkForm(true)}\n                className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n              >\n                <FaLink />\n                Enter Link Code\n              </button>\n            ) : (\n              <div className=\"space-y-3\">\n                <div className=\"flex gap-2\">\n                  <input\n                    type=\"text\"\n                    value={linkCodeInput}\n                    onChange={(e) =>\n                      setLinkCodeInput(e.target.value.toUpperCase())\n                    }\n                    placeholder=\"Enter link code\"\n                    className=\"flex-1 bg-black/20 text-nightly-honeydew px-3 py-2 rounded placeholder-nightly-celadon\"\n                    maxLength={20}\n                  />\n                  <button\n                    onClick={handleUseLinkCode}\n                    disabled={isUsingCode || !linkCodeInput.trim()}\n                    className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded font-medium transition-colors disabled:opacity-50\"\n                  >\n                    {isUsingCode ? (\n                      <FaSpinner className=\"animate-spin\" />\n                    ) : (\n                      \"Link\"\n                    )}\n                  </button>\n                </div>\n                <button\n                  onClick={() => {\n                    setShowLinkForm(false);\n                    setLinkCodeInput(\"\");\n                    clearErrors();\n                  }}\n                  className=\"text-nightly-celadon hover:text-nightly-honeydew text-sm\"\n                >\n                  Cancel\n                </button>\n\n                {codeUsageError && (\n                  <div className=\"bg-red-500/20 text-red-400 p-3 rounded flex items-center gap-2\">\n                    <FaExclamationTriangle />\n                    {codeUsageError}\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* QR Code Display */}\n        {showQRCode && currentLinkCode && (\n          <div className=\"bg-white/5 rounded-lg p-4\">\n            <h4 className=\"font-medium text-nightly-honeydew mb-3\">QR Code</h4>\n            <div className=\"flex items-center justify-center\">\n              <div className=\"bg-white p-4 rounded-lg\">\n                <div className=\"text-center text-gray-600\">\n                  QR Code would appear here\n                  <br />\n                  (Implementation requires QR library)\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/ActiveInviteCodesDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/ActiveKeyholderDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/AdminDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FaChartLine' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":14},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (153). Maximum allowed is 75.","line":18,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":185,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used.","line":19,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentAdminSession' is assigned a value but never used.","line":26,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4805,4808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4805,4808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isSessionActive' is defined but never used. Allowed unused args must match /^_/u.","line":320,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport {\n  FaUserShield,\n  FaEye,\n  FaCog,\n  FaUsers,\n  FaTasks,\n  FaChartLine,\n  FaLock,\n  FaHistory,\n  FaShieldAlt,\n  FaSpinner,\n} from \"react-icons/fa\";\nimport { useAccountLinking } from \"../../hooks/account-linking/useAccountLinking\";\nimport { useAuthState } from \"../../contexts\";\nimport { AdminRelationship } from \"../../types/account-linking\";\n\nexport const AdminDashboard: React.FC = () => {\n  const { user } = useAuthState();\n  const {\n    relationships,\n    keyholderRelationships,\n    selectedWearerId,\n    setSelectedWearer,\n    startAdminSession,\n    currentAdminSession,\n    isAdminSessionActive,\n    isLoadingRelationships,\n  } = useAccountLinking();\n\n  const [selectedTab, setSelectedTab] = useState<\n    \"overview\" | \"sessions\" | \"tasks\" | \"settings\"\n  >(\"overview\");\n\n  // Only show admin dashboard if user is a keyholder\n  const isKeyholder = keyholderRelationships.length > 0;\n\n  if (!isKeyholder) {\n    return null;\n  }\n\n  const selectedRelationship = selectedWearerId\n    ? relationships.find((r) => r.wearerId === selectedWearerId)\n    : keyholderRelationships[0];\n\n  const handleStartAdminSession = () => {\n    if (selectedRelationship) {\n      startAdminSession(selectedRelationship.id);\n    }\n  };\n\n  if (isLoadingRelationships) {\n    return (\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n        <div className=\"flex items-center justify-center py-8\">\n          <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine\" />\n          <span className=\"ml-3 text-nightly-celadon\">\n            Loading admin dashboard...\n          </span>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-6\">\n        <FaUserShield className=\"text-nightly-lavender-floral\" />\n        <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n          Keyholder Admin Dashboard\n        </h2>\n        <span className=\"bg-nightly-lavender-floral/20 text-nightly-lavender-floral px-2 py-1 text-xs rounded\">\n          KEYHOLDER\n        </span>\n      </div>\n\n      {/* Wearer Selection */}\n      {keyholderRelationships.length > 1 && (\n        <div className=\"mb-6\">\n          <label className=\"block text-sm font-medium text-nightly-honeydew mb-2\">\n            Select Wearer to Manage:\n          </label>\n          <select\n            value={selectedWearerId || \"\"}\n            onChange={(e) => setSelectedWearer(e.target.value || null)}\n            className=\"bg-black/20 text-nightly-honeydew px-3 py-2 rounded w-full max-w-md\"\n          >\n            {keyholderRelationships.map((relationship) => (\n              <option key={relationship.id} value={relationship.wearerId}>\n                Wearer: {relationship.wearerId}\n              </option>\n            ))}\n          </select>\n        </div>\n      )}\n\n      {selectedRelationship && (\n        <>\n          {/* Admin Session Status */}\n          <div className=\"bg-white/5 rounded-lg p-4 mb-6\">\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <h3 className=\"font-medium text-nightly-honeydew mb-1\">\n                  Admin Session\n                </h3>\n                <p className=\"text-sm text-nightly-celadon\">\n                  {isAdminSessionActive\n                    ? `Active session for ${selectedRelationship.wearerId}`\n                    : \"No active admin session\"}\n                </p>\n              </div>\n              <div>\n                {!isAdminSessionActive ? (\n                  <button\n                    onClick={handleStartAdminSession}\n                    className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n                  >\n                    <FaShieldAlt />\n                    Start Admin Session\n                  </button>\n                ) : (\n                  <div className=\"flex items-center gap-2 text-green-400\">\n                    <FaShieldAlt />\n                    <span className=\"text-sm\">Session Active</span>\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n\n          {/* Navigation Tabs */}\n          <div className=\"flex space-x-1 bg-black/20 rounded-lg p-1 mb-6\">\n            {[\n              { id: \"overview\", label: \"Overview\", icon: FaEye },\n              { id: \"sessions\", label: \"Sessions\", icon: FaLock },\n              { id: \"tasks\", label: \"Tasks\", icon: FaTasks },\n              { id: \"settings\", label: \"Settings\", icon: FaCog },\n            ].map((tab) => (\n              <button\n                key={tab.id}\n                onClick={() => setSelectedTab(tab.id as any)}\n                className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${\n                  selectedTab === tab.id\n                    ? \"bg-nightly-lavender-floral text-white\"\n                    : \"text-nightly-celadon hover:text-nightly-honeydew hover:bg-white/5\"\n                }`}\n              >\n                <tab.icon />\n                {tab.label}\n              </button>\n            ))}\n          </div>\n\n          {/* Tab Content */}\n          <div className=\"space-y-6\">\n            {selectedTab === \"overview\" && (\n              <AdminOverview relationship={selectedRelationship} />\n            )}\n\n            {selectedTab === \"sessions\" && (\n              <AdminSessions\n                relationship={selectedRelationship}\n                isSessionActive={isAdminSessionActive}\n              />\n            )}\n\n            {selectedTab === \"tasks\" && (\n              <AdminTasks\n                relationship={selectedRelationship}\n                isSessionActive={isAdminSessionActive}\n              />\n            )}\n\n            {selectedTab === \"settings\" && (\n              <AdminSettings\n                relationship={selectedRelationship}\n                isSessionActive={isAdminSessionActive}\n              />\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n};\n\n// Sub-components for each tab\nconst AdminOverview: React.FC<{ relationship: AdminRelationship }> = ({\n  relationship,\n}) => (\n  <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <div className=\"flex items-center gap-3 mb-3\">\n        <FaUsers className=\"text-nightly-aquamarine\" />\n        <h4 className=\"font-medium text-nightly-honeydew\">Relationship</h4>\n      </div>\n      <div className=\"text-sm text-nightly-celadon space-y-1\">\n        <p>\n          Status: <span className=\"text-green-400\">{relationship.status}</span>\n        </p>\n        <p>\n          Established:{\" \"}\n          {relationship.establishedAt.toDate().toLocaleDateString()}\n        </p>\n        <p>Method: {relationship.linkMethod}</p>\n      </div>\n    </div>\n\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <div className=\"flex items-center gap-3 mb-3\">\n        <FaShieldAlt className=\"text-nightly-lavender-floral\" />\n        <h4 className=\"font-medium text-nightly-honeydew\">Permissions</h4>\n      </div>\n      <div className=\"text-sm text-nightly-celadon space-y-1\">\n        <p>Sessions: {relationship.permissions.controlSessions ? \"\" : \"\"}</p>\n        <p>Tasks: {relationship.permissions.manageTasks ? \"\" : \"\"}</p>\n        <p>Settings: {relationship.permissions.editSettings ? \"\" : \"\"}</p>\n      </div>\n    </div>\n\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <div className=\"flex items-center gap-3 mb-3\">\n        <FaHistory className=\"text-nightly-spring-green\" />\n        <h4 className=\"font-medium text-nightly-honeydew\">Activity</h4>\n      </div>\n      <div className=\"text-sm text-nightly-celadon\">\n        <p>\n          Last Access:{\" \"}\n          {relationship.lastAdminAccess\n            ? relationship.lastAdminAccess.toDate().toLocaleDateString()\n            : \"Never\"}\n        </p>\n        <p>Session Timeout: {relationship.security.sessionTimeout}m</p>\n      </div>\n    </div>\n  </div>\n);\n\nconst AdminSessions: React.FC<{\n  relationship: AdminRelationship;\n  isSessionActive: boolean;\n}> = ({ relationship, isSessionActive }) => (\n  <div className=\"space-y-4\">\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <h4 className=\"font-medium text-nightly-honeydew mb-3\">\n        Session Control\n      </h4>\n      {isSessionActive ? (\n        <div className=\"space-y-4\">\n          <p className=\"text-nightly-celadon\">\n            You have active admin access to manage {relationship.wearerId}'s\n            chastity sessions.\n          </p>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n            <button className=\"bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 px-4 py-2 rounded font-medium transition-colors\">\n              View Current Session\n            </button>\n            <button className=\"bg-green-500/20 hover:bg-green-500/30 text-green-400 px-4 py-2 rounded font-medium transition-colors\">\n              Start New Session\n            </button>\n            <button className=\"bg-yellow-500/20 hover:bg-yellow-500/30 text-yellow-400 px-4 py-2 rounded font-medium transition-colors\">\n              Pause Session\n            </button>\n            <button className=\"bg-red-500/20 hover:bg-red-500/30 text-red-400 px-4 py-2 rounded font-medium transition-colors\">\n              End Session\n            </button>\n          </div>\n        </div>\n      ) : (\n        <p className=\"text-nightly-celadon\">\n          Start an admin session to control {relationship.wearerId}'s chastity\n          sessions.\n        </p>\n      )}\n    </div>\n  </div>\n);\n\nconst AdminTasks: React.FC<{\n  relationship: AdminRelationship;\n  isSessionActive: boolean;\n}> = ({ relationship, isSessionActive }) => (\n  <div className=\"space-y-4\">\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <h4 className=\"font-medium text-nightly-honeydew mb-3\">\n        Task Management\n      </h4>\n      {isSessionActive ? (\n        <div className=\"space-y-4\">\n          <p className=\"text-nightly-celadon\">\n            Manage tasks for {relationship.wearerId}.\n          </p>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n            <button className=\"bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 px-4 py-2 rounded font-medium transition-colors\">\n              View All Tasks\n            </button>\n            <button className=\"bg-green-500/20 hover:bg-green-500/30 text-green-400 px-4 py-2 rounded font-medium transition-colors\">\n              Create New Task\n            </button>\n            <button className=\"bg-yellow-500/20 hover:bg-yellow-500/30 text-yellow-400 px-4 py-2 rounded font-medium transition-colors\">\n              Review Submissions\n            </button>\n            <button className=\"bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 px-4 py-2 rounded font-medium transition-colors\">\n              Set Rewards/Punishments\n            </button>\n          </div>\n        </div>\n      ) : (\n        <p className=\"text-nightly-celadon\">\n          Start an admin session to manage tasks.\n        </p>\n      )}\n    </div>\n  </div>\n);\n\nconst AdminSettings: React.FC<{\n  relationship: AdminRelationship;\n  isSessionActive: boolean;\n}> = ({ relationship, isSessionActive }) => (\n  <div className=\"space-y-4\">\n    <div className=\"bg-white/5 rounded-lg p-4\">\n      <h4 className=\"font-medium text-nightly-honeydew mb-3\">Admin Settings</h4>\n      <div className=\"space-y-3\">\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Session Timeout</span>\n          <span className=\"text-nightly-honeydew\">\n            {relationship.security.sessionTimeout} minutes\n          </span>\n        </div>\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Audit Logging</span>\n          <span className=\"text-nightly-honeydew\">\n            {relationship.security.auditLog ? \"Enabled\" : \"Disabled\"}\n          </span>\n        </div>\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Wearer Notifications</span>\n          <span className=\"text-nightly-honeydew\">\n            {relationship.privacy.wearerCanSeeAdminActions\n              ? \"Enabled\"\n              : \"Disabled\"}\n          </span>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/InviteCodeCreationSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/KeyholderPasswordUnlock.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (102). Maximum allowed is 75.","line":6,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":116,"endColumn":2},{"ruleId":"zustand-safe-patterns/zustand-selective-subscriptions","severity":1,"message":"Use selective subscriptions instead of subscribing to entire store. Replace useUIStore() with useUIStore(state => state.specificValue) to prevent unnecessary re-renders. See docs/development/architecture/data-flow.md for performance patterns.","line":17,"column":7,"nodeType":"CallExpression","messageId":"useSelectiveSubscription","endLine":17,"endColumn":26},{"ruleId":"zustand-safe-patterns/zustand-no-conditional-subscriptions","severity":1,"message":"Avoid conditional store subscriptions. Move conditions inside the component instead of conditionally calling useStore hooks. This prevents React hooks rule violations and memory leaks.","line":17,"column":7,"nodeType":"CallExpression","messageId":"noConditionalSubscriptions","endLine":17,"endColumn":26},{"ruleId":"zustand-safe-patterns/zustand-no-conditional-subscriptions","severity":1,"message":"Avoid conditional store subscriptions. Move conditions inside the component instead of conditionally calling useStore hooks. This prevents React hooks rule violations and memory leaks.","line":17,"column":7,"nodeType":"CallExpression","messageId":"noConditionalSubscriptions","endLine":17,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { useKeyholderStore } from \"../../stores/keyholderStore\";\nimport { FaLock, FaUnlock, FaKey, FaSpinner } from \"../../utils/iconImport\";\n\n// Password Unlock Component\nexport const KeyholderPasswordUnlock: React.FC = () => {\n  const {\n    isKeyholderModeUnlocked,\n    isPasswordDialogOpen,\n    passwordAttempt,\n    keyholderMessage,\n    isCheckingPassword,\n    openPasswordDialog,\n    setPasswordAttempt,\n    checkPassword,\n    clearMessage,\n  } = useKeyholderStore();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!passwordAttempt.trim()) return;\n\n    // For demo - in real app this would come from settings\n    const storedHash = \"demo_password_hash\"; // This would be from user settings\n    await checkPassword(passwordAttempt, storedHash);\n  };\n\n  if (isKeyholderModeUnlocked) {\n    return (\n      <div className=\"bg-green-500/10 border border-green-500/20 rounded-lg p-4 mb-6\">\n        <div className=\"flex items-center gap-3\">\n          <FaUnlock className=\"text-green-400\" />\n          <span className=\"text-green-400 font-medium\">\n            Keyholder Controls Unlocked\n          </span>\n        </div>\n        <p className=\"text-nightly-celadon text-sm mt-2\">\n          You have temporary admin access to this account's chastity controls.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaLock className=\"text-nightly-aquamarine\" />\n        <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n          Temporary Keyholder Access\n        </h2>\n      </div>\n\n      <p className=\"text-nightly-celadon mb-4\">\n        This is the current temporary password-based keyholder system. In the\n        future, this will be replaced with secure account linking.\n      </p>\n\n      {!isPasswordDialogOpen ? (\n        <button\n          onClick={openPasswordDialog}\n          className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n        >\n          <FaKey />\n          Unlock Keyholder Controls\n        </button>\n      ) : (\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n              Keyholder Password\n            </label>\n            <input\n              type=\"password\"\n              value={passwordAttempt}\n              onChange={(e) => setPasswordAttempt(e.target.value)}\n              placeholder=\"Enter keyholder password\"\n              className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n              disabled={isCheckingPassword}\n            />\n          </div>\n\n          {keyholderMessage && (\n            <div className=\"bg-yellow-500/10 border border-yellow-500/20 rounded p-3\">\n              <p className=\"text-yellow-300 text-sm\">{keyholderMessage}</p>\n              <button\n                type=\"button\"\n                onClick={clearMessage}\n                className=\"text-yellow-400 hover:text-yellow-300 text-sm mt-1\"\n              >\n                Dismiss\n              </button>\n            </div>\n          )}\n\n          <button\n            type=\"submit\"\n            disabled={isCheckingPassword || !passwordAttempt.trim()}\n            className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 disabled:opacity-50 text-black px-6 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n          >\n            {isCheckingPassword ? (\n              <>\n                <FaSpinner className=\"animate-spin\" />\n                Checking...\n              </>\n            ) : (\n              <>\n                <FaUnlock />\n                Unlock\n              </>\n            )}\n          </button>\n        </form>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/LinkingMessageDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/RelationshipSummary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/SessionControls.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (76). Maximum allowed is 75.","line":10,"column":64,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":92,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport type { DBSession } from \"../../types/database\";\nimport { FaClock, FaPlay, FaPause, FaStop } from \"../../utils/iconImport\";\n\n// Current Session Control (for unlocked keyholder mode)\ninterface SessionControlsProps {\n  session: DBSession | null;\n}\n\nexport const SessionControls: React.FC<SessionControlsProps> = ({\n  session,\n}) => {\n  if (!session) {\n    return (\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <div className=\"flex items-center gap-3 mb-4\">\n          <FaClock className=\"text-nightly-aquamarine\" />\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n            Session Control\n          </h3>\n        </div>\n        <p className=\"text-nightly-celadon\">No active session to control.</p>\n      </div>\n    );\n  }\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    return `${hours}h ${minutes}m`;\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaClock className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Session Control\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Status:</span>\n          <div className=\"flex items-center gap-2\">\n            {session.isPaused ? (\n              <>\n                <FaPause className=\"text-yellow-400\" />\n                <span className=\"text-yellow-400\">Paused</span>\n              </>\n            ) : (\n              <>\n                <FaPlay className=\"text-green-400\" />\n                <span className=\"text-green-400\">Active</span>\n              </>\n            )}\n          </div>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Started:</span>\n          <span className=\"text-nightly-honeydew\">\n            {session.startTime.toLocaleDateString()}{\" \"}\n            {session.startTime.toLocaleTimeString()}\n          </span>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-nightly-celadon\">Pause Time:</span>\n          <span className=\"text-nightly-honeydew\">\n            {formatDuration(session.accumulatedPauseTime)}\n          </span>\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-3 mt-6\">\n          <button\n            disabled={session.isPaused}\n            className=\"bg-yellow-500 hover:bg-yellow-600 disabled:opacity-50 disabled:cursor-not-allowed text-white px-4 py-2 rounded font-medium transition-colors flex items-center justify-center gap-2\"\n          >\n            <FaPause />\n            Pause Session\n          </button>\n\n          <button className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded font-medium transition-colors flex items-center justify-center gap-2\">\n            <FaStop />\n            End Session\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/SubmissiveRelationshipsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/TaskManagement.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBTask' is defined but never used.","line":2,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":21},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (182). Maximum allowed is 75.","line":17,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":214,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":50,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":71,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport type { DBTask, TaskStatus } from \"../../types/database\";\nimport { useTasksQuery, useTaskMutations } from \"../../hooks/api\";\nimport { useNotificationActions } from \"../../stores\";\nimport {\n  FaTasks,\n  FaPlus,\n  FaCheckCircle,\n  FaTimesCircle,\n} from \"../../utils/iconImport\";\n\n// Task Management for Keyholder\ninterface TaskManagementProps {\n  userId: string; // Changed to accept userId instead of tasks array\n}\n\nexport const TaskManagement: React.FC<TaskManagementProps> = ({ userId }) => {\n  const [newTaskText, setNewTaskText] = useState(\"\");\n  const [showAddTask, setShowAddTask] = useState(false);\n\n  // Use TanStack Query hooks instead of direct service calls\n  const { data: tasks = [], isLoading, error } = useTasksQuery(userId);\n  const { updateTaskStatus, createTask } = useTaskMutations();\n  const { showSuccess, showError } = useNotificationActions();\n\n  const pendingTasks = tasks.filter((t) =>\n    [\"pending\", \"submitted\"].includes(t.status),\n  );\n\n  const handleTaskAction = async (\n    taskId: string,\n    action: \"approve\" | \"reject\",\n    feedback?: string,\n  ) => {\n    try {\n      const newStatus: TaskStatus =\n        action === \"approve\" ? \"approved\" : \"rejected\";\n\n      await updateTaskStatus.mutateAsync({\n        taskId,\n        userId,\n        status: newStatus,\n        feedback,\n      });\n\n      showSuccess(\n        `Task ${action === \"approve\" ? \"approved\" : \"rejected\"} successfully`,\n        \"Task Updated\",\n      );\n    } catch (error) {\n      showError(\n        `Failed to ${action} task. Please try again.`,\n        \"Task Update Failed\",\n      );\n    }\n  };\n\n  const handleAddTask = async () => {\n    if (!newTaskText.trim()) return;\n\n    try {\n      await createTask.mutateAsync({\n        userId,\n        title: newTaskText.trim(),\n        description: \"\",\n      });\n\n      setNewTaskText(\"\");\n      setShowAddTask(false);\n      showSuccess(\"Task created successfully\", \"Task Added\");\n    } catch (error) {\n      showError(\n        \"Failed to create task. Please try again.\",\n        \"Task Creation Failed\",\n      );\n    }\n  };\n\n  if (error) {\n    return (\n      <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">\n        Failed to load tasks. Please refresh the page.\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center justify-between mb-4\">\n        <div className=\"flex items-center gap-3\">\n          <FaTasks className=\"text-nightly-lavender-floral\" />\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n            Task Management\n          </h3>\n        </div>\n        <button\n          onClick={() => setShowAddTask(!showAddTask)}\n          className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-3 py-1 rounded text-sm flex items-center gap-2\"\n        >\n          <FaPlus />\n          Add Task\n        </button>\n      </div>\n\n      {showAddTask && (\n        <div className=\"mb-6 bg-white/5 rounded-lg p-4\">\n          <h4 className=\"font-medium text-nightly-honeydew mb-3\">\n            Create New Task\n          </h4>\n          <div className=\"space-y-3\">\n            <textarea\n              value={newTaskText}\n              onChange={(e) => setNewTaskText(e.target.value)}\n              placeholder=\"Task description...\"\n              className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n              rows={3}\n            />\n            <div className=\"flex gap-2\">\n              <button\n                onClick={handleAddTask}\n                disabled={!newTaskText.trim() || createTask.isPending}\n                className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 disabled:opacity-50 text-black px-4 py-2 rounded font-medium transition-colors\"\n              >\n                {createTask.isPending ? \"Creating...\" : \"Create Task\"}\n              </button>\n              <button\n                onClick={() => setShowAddTask(false)}\n                className=\"bg-white/10 hover:bg-white/20 text-nightly-celadon px-4 py-2 rounded font-medium transition-colors\"\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Loading state */}\n      {isLoading && (\n        <div className=\"text-center text-nightly-celadon py-4\">\n          Loading tasks...\n        </div>\n      )}\n\n      {/* Tasks list */}\n      <div className=\"space-y-3\">\n        {!isLoading && pendingTasks.length === 0 ? (\n          <p className=\"text-nightly-celadon\">No pending tasks</p>\n        ) : (\n          pendingTasks.map((task) => (\n            <div key={task.id} className=\"bg-white/5 rounded-lg p-4\">\n              <div className=\"mb-3\">\n                <h4 className=\"font-medium text-nightly-honeydew mb-1\">\n                  {task.title}\n                </h4>\n                <div className=\"flex items-center gap-2 text-sm text-nightly-celadon\">\n                  <span>Status: {task.status}</span>\n                  {task.priority && (\n                    <>\n                      <span></span>\n                      <span>Priority: {task.priority}</span>\n                    </>\n                  )}\n                  {task.deadline && (\n                    <>\n                      <span></span>\n                      <span>Due: {task.deadline.toLocaleDateString()}</span>\n                    </>\n                  )}\n                </div>\n                {task.description && (\n                  <p className=\"text-sm text-nightly-celadon mt-1\">\n                    {task.description}\n                  </p>\n                )}\n              </div>\n\n              {task.submissiveNote && (\n                <div className=\"bg-white/5 rounded p-2 mb-3\">\n                  <div className=\"text-xs text-nightly-celadon mb-1\">\n                    Submissive Note:\n                  </div>\n                  <div className=\"text-sm text-nightly-honeydew\">\n                    {task.submissiveNote}\n                  </div>\n                </div>\n              )}\n\n              {task.status === \"submitted\" && (\n                <div className=\"flex gap-2\">\n                  <button\n                    onClick={() => handleTaskAction(task.id, \"approve\")}\n                    disabled={updateTaskStatus.isPending}\n                    className=\"bg-green-500 hover:bg-green-600 disabled:opacity-50 text-white px-3 py-1 rounded text-sm flex items-center gap-1\"\n                  >\n                    <FaCheckCircle />\n                    {updateTaskStatus.isPending ? \"Processing...\" : \"Approve\"}\n                  </button>\n                  <button\n                    onClick={() => handleTaskAction(task.id, \"reject\")}\n                    disabled={updateTaskStatus.isPending}\n                    className=\"bg-red-500 hover:bg-red-600 disabled:opacity-50 text-white px-3 py-1 rounded text-sm flex items-center gap-1\"\n                  >\n                    <FaTimesCircle />\n                    {updateTaskStatus.isPending ? \"Processing...\" : \"Reject\"}\n                  </button>\n                </div>\n              )}\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/keyholder/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/layout/AppLayout.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (179). Maximum allowed is 75.","line":15,"column":45,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":213,"endColumn":2},{"ruleId":"zustand-safe-patterns/zustand-selective-subscriptions","severity":1,"message":"Use selective subscriptions instead of subscribing to entire store. Replace useUIStore() with useUIStore(state => state.specificValue) to prevent unnecessary re-renders. See docs/development/architecture/data-flow.md for performance patterns.","line":25,"column":5,"nodeType":"CallExpression","messageId":"useSelectiveSubscription","endLine":25,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'navItems' and 'setPageTitle'. Either include them or remove the dependency array.","line":48,"column":6,"nodeType":"ArrayExpression","endLine":48,"endColumn":25,"suggestions":[{"desc":"Update the dependencies array to be: [location.pathname, navItems, setPageTitle]","fix":{"range":[1692,1711],"text":"[location.pathname, navItems, setPageTitle]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'closeMobileMenu'. Either include it or remove the dependency array.","line":53,"column":6,"nodeType":"ArrayExpression","endLine":53,"endColumn":25,"suggestions":[{"desc":"Update the dependencies array to be: [closeMobileMenu, location.pathname]","fix":{"range":[1805,1824],"text":"[closeMobileMenu, location.pathname]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from \"react\";\nimport { Link, useLocation } from \"react-router-dom\";\nimport { SyncStatusIndicator } from \"@/components/common\";\nimport { useNavigationStore } from \"@/stores\";\nimport { ToastContainer } from \"react-toastify\";\nimport { useAuthState } from \"../../contexts\";\nimport { useAchievements } from \"../../hooks/useAchievements\";\nimport { AchievementNotification } from \"../achievements\";\nimport \"react-toastify/dist/ReactToastify.css\";\n\ninterface AppLayoutProps {\n  children: React.ReactNode;\n}\n\nconst AppLayout: React.FC<AppLayoutProps> = ({ children }) => {\n  const location = useLocation();\n  const { user } = useAuthState();\n\n  // Achievement notifications\n  const { unreadNotifications, allAchievements, markNotificationRead } =\n    useAchievements(user?.uid);\n\n  // Use navigation store for mobile menu state\n  const { isMobileMenuOpen, toggleMobileMenu, closeMobileMenu, setPageTitle } =\n    useNavigationStore();\n\n  const navItems = [\n    { path: \"/\", label: \"Dashboard\" },\n    { path: \"/chastity-tracking\", label: \"Tracker\" },\n    { path: \"/tasks\", label: \"Tasks\" },\n    { path: \"/achievements\", label: \"Achievements\" },\n    { path: \"/log-event\", label: \"Log Event\" },\n    { path: \"/rewards-punishments\", label: \"Rewards\" },\n    { path: \"/rules\", label: \"Rules\" },\n    { path: \"/full-report\", label: \"Report\" },\n    { path: \"/settings\", label: \"Settings\" },\n  ];\n\n  // Update page title based on current route\n  useEffect(() => {\n    const currentItem = navItems.find(\n      (item) => item.path === location.pathname,\n    );\n    const title = currentItem\n      ? `${currentItem.label} - ChastityOS`\n      : \"ChastityOS\";\n    setPageTitle(title);\n  }, [location.pathname]);\n\n  // Close mobile menu when route changes\n  useEffect(() => {\n    closeMobileMenu();\n  }, [location.pathname]);\n\n  return (\n    <div className=\"bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 min-h-screen text-white\">\n      {/* Top Navigation with Glass Morphism */}\n      <header className=\"glass-header sticky top-0 z-50\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex justify-between items-center py-4\">\n            {/* Logo and Sync Status */}\n            <div className=\"flex items-center space-x-4\">\n              <Link\n                to=\"/\"\n                className=\"text-2xl font-bold text-white glass-float\"\n              >\n                ChastityOS\n              </Link>\n              <SyncStatusIndicator />\n            </div>\n\n            {/* Desktop Navigation with Glass Pills */}\n            <nav className=\"hidden md:flex space-x-3\">\n              {navItems.slice(1, -1).map((item) => (\n                <Link\n                  key={item.path}\n                  to={item.path}\n                  className={`glass-nav text-sm font-medium transition-all duration-300 ${\n                    location.pathname === item.path\n                      ? \"glass-card-primary text-blue-200 shadow-liquid\"\n                      : \"text-gray-300 hover:text-white glass-hover\"\n                  }`}\n                >\n                  {item.label}\n                </Link>\n              ))}\n\n              {/* Settings */}\n              <Link\n                to=\"/settings\"\n                className={`glass-nav text-sm font-medium transition-all duration-300 ${\n                  location.pathname === \"/settings\"\n                    ? \"glass-card-primary text-blue-200 shadow-liquid\"\n                    : \"text-gray-300 hover:text-white glass-hover\"\n                }`}\n              >\n                Settings\n              </Link>\n\n              {/* Keyholder Access - Special Glass Button */}\n              <Link\n                to=\"/keyholder\"\n                className=\"glass-button bg-gradient-to-r from-purple-600/80 to-pink-600/80 text-white font-medium transition-all duration-300 hover:from-purple-500/90 hover:to-pink-500/90 shadow-lg hover:shadow-purple-500/25\"\n              >\n                KH Access\n              </Link>\n            </nav>\n\n            {/* Mobile Menu Button */}\n            <button\n              className=\"md:hidden text-white glass-button p-2\"\n              onClick={toggleMobileMenu}\n              aria-label=\"Toggle mobile menu\"\n            >\n              <svg\n                className=\"h-6 w-6\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n                stroke=\"currentColor\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d={\n                    isMobileMenuOpen\n                      ? \"M6 18L18 6M6 6l12 12\"\n                      : \"M4 6h16M4 12h16M4 18h16\"\n                  }\n                />\n              </svg>\n            </button>\n          </div>\n\n          {/* Mobile Navigation Menu */}\n          {isMobileMenuOpen && (\n            <div className=\"md:hidden\">\n              <div className=\"px-2 pt-2 pb-3 space-y-1 bg-black/20 backdrop-blur-sm rounded-lg mt-2\">\n                {navItems.map((item) => (\n                  <Link\n                    key={item.path}\n                    to={item.path}\n                    className={`block px-3 py-2 rounded-md text-base font-medium transition-colors ${\n                      location.pathname === item.path\n                        ? \"bg-nightly-aquamarine/20 text-nightly-aquamarine\"\n                        : \"text-nightly-celadon hover:text-nightly-spring-green hover:bg-white/10\"\n                    }`}\n                    onClick={closeMobileMenu}\n                  >\n                    {item.label}\n                  </Link>\n                ))}\n\n                {/* Mobile Keyholder Access */}\n                <Link\n                  to=\"/keyholder\"\n                  className=\"block bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-3 py-2 rounded-md text-base font-medium transition-colors\"\n                  onClick={closeMobileMenu}\n                >\n                  KH Access\n                </Link>\n              </div>\n            </div>\n          )}\n        </div>\n      </header>\n\n      {/* Main Content Area with Enhanced Glass Container */}\n      <main className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        <div className=\"glass-morphism p-8 min-h-[calc(100vh-12rem)] relative overflow-hidden\">\n          {/* Subtle background pattern */}\n          <div className=\"absolute inset-0 opacity-5\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-blue-400 via-purple-400 to-pink-400 opacity-20 blur-3xl\"></div>\n          </div>\n          <div className=\"relative z-10\">{children}</div>\n        </div>\n      </main>\n\n      {/* Footer with Glass Effect */}\n      <footer className=\"glass-header mt-8\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4\">\n          <div className=\"text-center text-gray-400 text-sm\">\n            <p>ChastityOS v4.0.0 | Privacy | Terms | Support</p>\n          </div>\n        </div>\n      </footer>\n\n      {/* Achievement Notifications */}\n      {user && (\n        <AchievementNotification\n          notifications={unreadNotifications}\n          achievements={allAchievements}\n          onMarkRead={markNotificationRead}\n        />\n      )}\n\n      {/* Toast Container */}\n      <ToastContainer\n        position=\"top-right\"\n        autoClose={8000}\n        hideProgressBar={false}\n        newestOnTop={false}\n        closeOnClick={false}\n        rtl={false}\n        pauseOnFocusLoss\n        draggable\n        pauseOnHover\n        theme=\"dark\"\n        toastClassName=\"achievement-toast\"\n      />\n    </div>\n  );\n};\n\nexport default AppLayout;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/EventList.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (78). Maximum allowed is 75.","line":48,"column":52,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":131,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport type { DBEvent, EventType } from \"../../types/database\";\nimport {\n  FaCalendar,\n  FaHeart,\n  FaFire,\n  FaGamepad,\n  FaTint,\n} from \"../../utils/iconImport\";\n\n// Event type definitions with modern icons\nconst EVENT_TYPES = [\n  {\n    value: \"orgasm\" as EventType,\n    label: \"Orgasm\",\n    icon: FaHeart,\n    color: \"text-red-400\",\n    description: \"Self or partner induced orgasm\",\n  },\n  {\n    value: \"sexual_activity\" as EventType,\n    label: \"Sexual Activity\",\n    icon: FaFire,\n    color: \"text-orange-400\",\n    description: \"Sexual play or activity\",\n  },\n  {\n    value: \"milestone\" as EventType,\n    label: \"Milestone\",\n    icon: FaGamepad,\n    color: \"text-nightly-aquamarine\",\n    description: \"Achievement or milestone reached\",\n  },\n  {\n    value: \"note\" as EventType,\n    label: \"Note\",\n    icon: FaTint,\n    color: \"text-nightly-lavender-floral\",\n    description: \"General note or observation\",\n  },\n];\n\n// Event List Component\ninterface EventListProps {\n  events: DBEvent[];\n}\n\nexport const EventList: React.FC<EventListProps> = ({ events }) => {\n  const getEventTypeInfo = (type: EventType) => {\n    return EVENT_TYPES.find((et) => et.value === type) || EVENT_TYPES[3]; // Default to note\n  };\n\n  const formatDate = (date: Date) => {\n    return date.toLocaleDateString() + \" \" + date.toLocaleTimeString();\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      {events.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <FaCalendar className=\"text-4xl text-nightly-celadon/50 mb-4 mx-auto\" />\n          <div className=\"text-nightly-celadon\">No events logged yet</div>\n          <div className=\"text-sm text-nightly-celadon/70\">\n            Log your first event above\n          </div>\n        </div>\n      ) : (\n        events.map((event) => {\n          const eventTypeInfo = getEventTypeInfo(event.type);\n          const Icon = eventTypeInfo.icon;\n\n          return (\n            <div\n              key={event.id}\n              className=\"bg-white/10 backdrop-blur-sm rounded-lg p-4\"\n            >\n              {/* Header */}\n              <div className=\"flex items-start justify-between mb-3\">\n                <div className=\"flex items-center gap-3\">\n                  <Icon className={eventTypeInfo.color} />\n                  <div>\n                    <h3 className=\"font-medium text-nighty-honeydew\">\n                      {eventTypeInfo.label}\n                    </h3>\n                    <div className=\"text-xs text-nightly-celadon\">\n                      {formatDate(event.timestamp)}\n                    </div>\n                  </div>\n                </div>\n                {event.isPrivate && (\n                  <span className=\"bg-nightly-lavender-floral/20 text-nightly-lavender-floral px-2 py-1 text-xs rounded\">\n                    Private\n                  </span>\n                )}\n              </div>\n\n              {/* Content */}\n              {event.details.notes && (\n                <p className=\"text-nighty-honeydew mb-3\">\n                  {event.details.notes}\n                </p>\n              )}\n\n              {/* Details */}\n              <div className=\"flex gap-4 text-xs text-nightly-celadon\">\n                {event.details.mood && <span>Mood: {event.details.mood}</span>}\n                {event.details.intensity && (\n                  <span>Intensity: {event.details.intensity}/10</span>\n                )}\n              </div>\n\n              {/* Tags */}\n              {event.details.tags && event.details.tags.length > 0 && (\n                <div className=\"flex gap-2 mt-3\">\n                  {event.details.tags.map((tag, index) => (\n                    <span\n                      key={index}\n                      className=\"bg-nightly-aquamarine/20 text-nightly-aquamarine px-2 py-1 text-xs rounded\"\n                    >\n                      {tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n            </div>\n          );\n        })\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/LogEventForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBEvent' is defined but never used.","line":5,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (230). Maximum allowed is 75.","line":52,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":298,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":105,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { useAuthState } from \"../../contexts\";\nimport { useEventMutations } from \"../../hooks/api\";\nimport { useNotificationActions } from \"../../stores\";\nimport type { DBEvent, EventType } from \"../../types/database\";\nimport {\n  FaPlus,\n  FaHeart,\n  FaFire,\n  FaGamepad,\n  FaTint,\n  FaSpinner,\n} from \"../../utils/iconImport\";\n\n// Event type definitions with modern icons\nconst EVENT_TYPES = [\n  {\n    value: \"orgasm\" as EventType,\n    label: \"Orgasm\",\n    icon: FaHeart,\n    color: \"text-red-400\",\n    description: \"Self or partner induced orgasm\",\n  },\n  {\n    value: \"sexual_activity\" as EventType,\n    label: \"Sexual Activity\",\n    icon: FaFire,\n    color: \"text-orange-400\",\n    description: \"Sexual play or activity\",\n  },\n  {\n    value: \"milestone\" as EventType,\n    label: \"Milestone\",\n    icon: FaGamepad,\n    color: \"text-nightly-aquamarine\",\n    description: \"Achievement or milestone reached\",\n  },\n  {\n    value: \"note\" as EventType,\n    label: \"Note\",\n    icon: FaTint,\n    color: \"text-nightly-lavender-floral\",\n    description: \"General note or observation\",\n  },\n];\n\n// Event Form Component\ninterface LogEventFormProps {\n  onEventLogged?: () => void; // Simplified callback since TanStack Query handles data updates\n}\n\nexport const LogEventForm: React.FC<LogEventFormProps> = ({\n  onEventLogged,\n}) => {\n  const { user } = useAuthState();\n  const { createEvent } = useEventMutations();\n  const { showSuccess, showError } = useNotificationActions();\n  const [formData, setFormData] = useState({\n    type: \"note\" as EventType,\n    notes: \"\",\n    timestamp: new Date().toISOString().slice(0, 16), // Format for datetime-local input\n    mood: \"\",\n    intensity: 5,\n    tags: \"\",\n    isPrivate: false,\n  });\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!user) return;\n\n    try {\n      await createEvent.mutateAsync({\n        userId: user.uid,\n        type: formData.type,\n        timestamp: new Date(formData.timestamp),\n        notes: formData.notes,\n        isPrivate: formData.isPrivate,\n        metadata: {\n          mood: formData.mood,\n          intensity: formData.intensity,\n          tags: formData.tags\n            .split(\",\")\n            .map((tag) => tag.trim())\n            .filter((tag) => tag),\n        },\n      });\n\n      // Show success notification\n      showSuccess(\"Event logged successfully\", \"Event Added\");\n\n      // Call optional callback\n      onEventLogged?.();\n\n      // Reset form on success\n      setFormData({\n        type: \"note\" as EventType,\n        notes: \"\",\n        timestamp: new Date().toISOString().slice(0, 16),\n        mood: \"\",\n        intensity: 5,\n        tags: \"\",\n        isPrivate: false,\n      });\n    } catch (error) {\n      showError(\"Failed to log event. Please try again.\", \"Event Log Failed\");\n    }\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-6\">\n        <FaPlus className=\"text-nightly-aquamarine\" />\n        <h2 className=\"text-xl font-semibold text-nighty-honeydew\">\n          Log New Event\n        </h2>\n      </div>\n\n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        {/* Event Type Selection */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-3\">\n            Event Type\n          </label>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3\">\n            {EVENT_TYPES.map((eventType) => {\n              const Icon = eventType.icon;\n              return (\n                <button\n                  key={eventType.value}\n                  type=\"button\"\n                  onClick={() =>\n                    setFormData((prev) => ({ ...prev, type: eventType.value }))\n                  }\n                  className={`p-3 rounded-lg border-2 transition-all ${\n                    formData.type === eventType.value\n                      ? \"border-nightly-aquamarine bg-nightly-aquamarine/10\"\n                      : \"border-white/10 bg-white/5 hover:bg-white/10\"\n                  }`}\n                >\n                  <Icon\n                    className={`text-lg mb-2 mx-auto ${\n                      formData.type === eventType.value\n                        ? \"text-nightly-aquamarine\"\n                        : eventType.color\n                    }`}\n                  />\n                  <div\n                    className={`text-sm font-medium ${\n                      formData.type === eventType.value\n                        ? \"text-nighty-honeydew\"\n                        : \"text-nightly-celadon\"\n                    }`}\n                  >\n                    {eventType.label}\n                  </div>\n                </button>\n              );\n            })}\n          </div>\n        </div>\n\n        {/* Timestamp */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Date & Time\n          </label>\n          <input\n            type=\"datetime-local\"\n            value={formData.timestamp}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, timestamp: e.target.value }))\n            }\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nighty-honeydew\"\n          />\n        </div>\n\n        {/* Notes */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Notes\n          </label>\n          <textarea\n            value={formData.notes}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, notes: e.target.value }))\n            }\n            placeholder=\"Describe the event...\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nighty-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={4}\n          />\n        </div>\n\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          {/* Mood */}\n          <div>\n            <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n              Mood\n            </label>\n            <input\n              type=\"text\"\n              value={formData.mood}\n              onChange={(e) =>\n                setFormData((prev) => ({ ...prev, mood: e.target.value }))\n              }\n              placeholder=\"Happy, frustrated, excited...\"\n              className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nighty-honeydew placeholder-nightly-celadon/50\"\n            />\n          </div>\n\n          {/* Intensity */}\n          <div>\n            <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n              Intensity (1-10)\n            </label>\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"10\"\n              value={formData.intensity}\n              onChange={(e) =>\n                setFormData((prev) => ({\n                  ...prev,\n                  intensity: parseInt(e.target.value),\n                }))\n              }\n              className=\"w-full mb-2\"\n            />\n            <div className=\"text-center text-nighty-honeydew\">\n              {formData.intensity}\n            </div>\n          </div>\n        </div>\n\n        {/* Tags */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Tags (comma separated)\n          </label>\n          <input\n            type=\"text\"\n            value={formData.tags}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, tags: e.target.value }))\n            }\n            placeholder=\"romantic, intense, relaxed...\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nighty-honeydew placeholder-nightly-celadon/50\"\n          />\n        </div>\n\n        {/* Privacy */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Private Event\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Keep this event private\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={formData.isPrivate}\n              onChange={(e) =>\n                setFormData((prev) => ({\n                  ...prev,\n                  isPrivate: e.target.checked,\n                }))\n              }\n              className=\"sr-only peer\"\n            />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        {/* Submit Button */}\n        <button\n          type=\"submit\"\n          disabled={createEvent.isPending}\n          className=\"w-full bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 disabled:opacity-50 text-black px-6 py-3 rounded font-medium transition-colors flex items-center justify-center gap-2\"\n        >\n          {createEvent.isPending ? (\n            <>\n              <FaSpinner className=\"animate-spin\" />\n              Logging Event...\n            </>\n          ) : (\n            <>\n              <FaPlus />\n              Log Event\n            </>\n          )}\n        </button>\n      </form>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/log_event/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/modals/PrivacyPolicyModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (274). Maximum allowed is 75.","line":15,"column":63,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":299,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport {\n  FaTimes,\n  FaShieldAlt,\n  FaLock,\n  FaDatabase,\n  FaUsers,\n} from \"../../utils/iconImport\";\n\ninterface PrivacyPolicyModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nconst PrivacyPolicyModal: React.FC<PrivacyPolicyModalProps> = ({\n  isOpen,\n  onClose,\n}) => {\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"glass-modal fixed inset-0 z-50 flex items-center justify-center p-4\">\n      <div className=\"glass-modal-content max-w-4xl w-full max-h-[90vh] overflow-hidden animate-fade-in-up\">\n        {/* Enhanced Header with Glass Effect */}\n        <div className=\"glass-card-primary border-b border-white/20 p-6\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <div className=\"p-2 rounded-lg bg-blue-500/20 border border-blue-400/30\">\n                <FaShieldAlt className=\"text-blue-300 text-xl\" />\n              </div>\n              <h2 className=\"text-2xl font-bold bg-gradient-to-r from-white to-blue-200 bg-clip-text text-transparent\">\n                Privacy Policy\n              </h2>\n            </div>\n            <button\n              onClick={onClose}\n              className=\"glass-button p-3 hover:bg-red-500/20 text-gray-300 hover:text-white transition-all duration-300\"\n            >\n              <FaTimes />\n            </button>\n          </div>\n        </div>\n\n        {/* Enhanced Content with Glass Styling */}\n        <div className=\"p-6 overflow-y-auto max-h-[70vh] space-y-6\">\n          {/* Last Updated */}\n          <div className=\"glass-card bg-blue-500/10 border-blue-400/20 p-3 text-center\">\n            <span className=\"text-sm text-blue-200\">\n              Last updated: {new Date().toLocaleDateString()}\n            </span>\n          </div>\n\n          {/* Introduction */}\n          <section className=\"glass-card glass-hover\">\n            <div className=\"flex items-center gap-3 mb-4\">\n              <div className=\"p-2 rounded-lg bg-purple-500/20 border border-purple-400/30\">\n                <FaShieldAlt className=\"text-purple-300\" />\n              </div>\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Introduction\n              </h3>\n            </div>\n            <p className=\"leading-relaxed\">\n              ChastityOS is committed to protecting your privacy and ensuring\n              the security of your personal information. This privacy policy\n              explains how we collect, use, and protect your data when you use\n              our application.\n            </p>\n            <p className=\"leading-relaxed mt-3\">\n              We understand the sensitive nature of the data you entrust to us\n              and have implemented strict security measures to protect your\n              privacy at all times.\n            </p>\n          </section>\n\n          {/* Data Collection */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaDatabase className=\"text-nightly-spring-green\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Data We Collect\n              </h3>\n            </div>\n            <div className=\"space-y-3\">\n              <div>\n                <h4 className=\"font-medium text-nightly-honeydew mb-2\">\n                  Account Information\n                </h4>\n                <ul className=\"list-disc list-inside space-y-1 ml-4\">\n                  <li>Email address for account authentication</li>\n                  <li>Display name and profile information you provide</li>\n                  <li>Account preferences and settings</li>\n                </ul>\n              </div>\n              <div>\n                <h4 className=\"font-medium text-nightly-honeydew mb-2\">\n                  Usage Data\n                </h4>\n                <ul className=\"list-disc list-inside space-y-1 ml-4\">\n                  <li>Chastity session data (duration, start/end times)</li>\n                  <li>Task completion records</li>\n                  <li>Event logs you create</li>\n                  <li>Goal tracking information</li>\n                </ul>\n              </div>\n              <div>\n                <h4 className=\"font-medium text-nightly-honeydew mb-2\">\n                  Technical Data\n                </h4>\n                <ul className=\"list-disc list-inside space-y-1 ml-4\">\n                  <li>Device information and browser type</li>\n                  <li>IP address for security purposes</li>\n                  <li>Usage analytics to improve our service</li>\n                </ul>\n              </div>\n            </div>\n          </section>\n\n          {/* Data Usage */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaLock className=\"text-nightly-aquamarine\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                How We Use Your Data\n              </h3>\n            </div>\n            <ul className=\"list-disc list-inside space-y-2 ml-4\">\n              <li>To provide and maintain the ChastityOS service</li>\n              <li>To personalize your experience and track your progress</li>\n              <li>\n                To communicate with you about your account and service updates\n              </li>\n              <li>To improve our application and develop new features</li>\n              <li>To ensure the security and integrity of our service</li>\n              <li>To comply with legal obligations when required</li>\n            </ul>\n          </section>\n\n          {/* Data Security */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaShieldAlt className=\"text-nightly-lavender-floral\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Data Security\n              </h3>\n            </div>\n            <div className=\"space-y-3\">\n              <p className=\"leading-relaxed\">\n                We implement industry-standard security measures to protect your\n                data:\n              </p>\n              <ul className=\"list-disc list-inside space-y-1 ml-4\">\n                <li>\n                  <strong>Encryption:</strong> All data is encrypted in transit\n                  and at rest\n                </li>\n                <li>\n                  <strong>Authentication:</strong> Secure login with optional\n                  two-factor authentication\n                </li>\n                <li>\n                  <strong>Access Control:</strong> Strict access controls limit\n                  who can view your data\n                </li>\n                <li>\n                  <strong>Regular Audits:</strong> We regularly review and\n                  update our security practices\n                </li>\n                <li>\n                  <strong>Local Storage:</strong> Some data is stored locally on\n                  your device for offline access\n                </li>\n              </ul>\n            </div>\n          </section>\n\n          {/* Data Sharing */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaUsers className=\"text-nightly-spring-green\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Data Sharing\n              </h3>\n            </div>\n            <div className=\"space-y-3\">\n              <p className=\"leading-relaxed\">\n                <strong>\n                  We do not sell, trade, or rent your personal information to\n                  third parties.\n                </strong>\n              </p>\n              <p className=\"leading-relaxed\">\n                We may share limited data only in these circumstances:\n              </p>\n              <ul className=\"list-disc list-inside space-y-1 ml-4\">\n                <li>\n                  With your explicit consent (e.g., public profiles you choose\n                  to share)\n                </li>\n                <li>\n                  With keyholder accounts you explicitly link to your account\n                </li>\n                <li>When required by law or to protect our legal rights</li>\n                <li>\n                  With service providers who help us operate our application\n                  (under strict confidentiality agreements)\n                </li>\n              </ul>\n            </div>\n          </section>\n\n          {/* Your Rights */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaShieldAlt className=\"text-nightly-aquamarine\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Your Rights\n              </h3>\n            </div>\n            <p className=\"leading-relaxed mb-3\">\n              You have the following rights regarding your personal data:\n            </p>\n            <ul className=\"list-disc list-inside space-y-1 ml-4\">\n              <li>\n                <strong>Access:</strong> Request a copy of your personal data\n              </li>\n              <li>\n                <strong>Correction:</strong> Update or correct inaccurate\n                information\n              </li>\n              <li>\n                <strong>Deletion:</strong> Request deletion of your account and\n                data\n              </li>\n              <li>\n                <strong>Export:</strong> Download your data in a portable format\n              </li>\n              <li>\n                <strong>Opt-out:</strong> Withdraw consent for data processing\n              </li>\n              <li>\n                <strong>Privacy Settings:</strong> Control what information is\n                shared\n              </li>\n            </ul>\n          </section>\n\n          {/* Contact */}\n          <section>\n            <div className=\"flex items-center gap-2 mb-3\">\n              <FaDatabase className=\"text-nightly-lavender-floral\" />\n              <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                Contact Us\n              </h3>\n            </div>\n            <p className=\"leading-relaxed\">\n              If you have questions about this privacy policy or how we handle\n              your data, please contact our privacy team:\n            </p>\n            <div className=\"mt-3 bg-white/5 rounded-lg p-4\">\n              <p>\n                <strong>Email:</strong> privacy@chastityos.com\n              </p>\n              <p>\n                <strong>Response Time:</strong> Within 48 hours\n              </p>\n              <p>\n                <strong>Data Protection Officer:</strong> Available upon request\n              </p>\n            </div>\n          </section>\n\n          {/* Changes to Policy */}\n          <section className=\"border-t border-white/10 pt-6\">\n            <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-3\">\n              Changes to This Policy\n            </h3>\n            <p className=\"leading-relaxed\">\n              We may update this privacy policy from time to time. We will\n              notify you of any changes by posting the new privacy policy on\n              this page and updating the \"Last updated\" date. We encourage you\n              to review this privacy policy periodically for any changes.\n            </p>\n          </section>\n        </div>\n\n        {/* Footer */}\n        <div className=\"p-6 border-t border-white/10 bg-white/5\">\n          <button\n            onClick={onClose}\n            className=\"w-full bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-3 rounded-lg font-medium transition-colors\"\n          >\n            I Understand\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PrivacyPolicyModal;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileAchievements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileErrorStates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileRecentAchievements.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/ProfileStatistics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/PublicProfileHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/profile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/relationships/RelationshipManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Relationship' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipRequest' is defined but never used.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":22},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (383). Maximum allowed is 75.","line":28,"column":65,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":449,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":68,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":77,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":19},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (97). Maximum allowed is 75.","line":176,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":277,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (80). Maximum allowed is 75.","line":191,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":274,"endColumn":10},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (91). Maximum allowed is 75.","line":280,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":375,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Manager Component\n * Main interface for managing keyholder relationships\n */\nimport React, { useState } from \"react\";\nimport { useRelationships } from \"@/hooks/useRelationships\";\nimport {\n  Relationship,\n  RelationshipRequest,\n  RelationshipStatus,\n} from \"@/types/relationships\";\nimport {\n  FaUserPlus,\n  FaUsers,\n  FaCog,\n  FaTrash,\n  FaCheck,\n  FaTimes,\n  FaEye,\n  FaSpinner,\n  FaExclamationTriangle,\n} from \"react-icons/fa\";\n\ninterface RelationshipManagerProps {\n  className?: string;\n}\n\nconst RelationshipManager: React.FC<RelationshipManagerProps> = ({\n  className = \"\",\n}) => {\n  const {\n    relationships,\n    pendingRequests,\n    activeRelationship,\n    isLoading,\n    error,\n    needsMigration,\n    sendRelationshipRequest,\n    acceptRelationshipRequest,\n    rejectRelationshipRequest,\n    endRelationship,\n    setActiveRelationship,\n    migrateSingleUserData,\n    clearError,\n  } = useRelationships();\n\n  const [showRequestForm, setShowRequestForm] = useState(false);\n  const [requestForm, setRequestForm] = useState({\n    email: \"\",\n    role: \"submissive\" as \"submissive\" | \"keyholder\",\n    message: \"\",\n  });\n\n  // Handle sending relationship request\n  const handleSendRequest = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    try {\n      // In a real implementation, you'd need to look up user by email\n      // For now, we'll use email as userId (this would need to be implemented)\n      await sendRelationshipRequest(\n        requestForm.email,\n        requestForm.role,\n        requestForm.message,\n      );\n      setShowRequestForm(false);\n      setRequestForm({ email: \"\", role: \"submissive\", message: \"\" });\n    } catch (error) {\n      // Handle error silently or with proper error handling\n    }\n  };\n\n  // Handle migration\n  const handleMigration = async () => {\n    try {\n      await migrateSingleUserData();\n    } catch (error) {\n      // Handle migration error silently or with proper error handling\n    }\n  };\n\n  // Render migration banner\n  const renderMigrationBanner = () => {\n    if (!needsMigration) return null;\n\n    return (\n      <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6\">\n        <div className=\"flex items-start\">\n          <FaExclamationTriangle className=\"text-yellow-600 mt-1 mr-3\" />\n          <div className=\"flex-1\">\n            <h3 className=\"text-yellow-800 font-semibold mb-2\">\n              Data Migration Available\n            </h3>\n            <p className=\"text-yellow-700 text-sm mb-3\">\n              We've detected existing chastity data that can be migrated to the\n              new relationship-based system. This will create a self-managed\n              profile that you can later share with a keyholder.\n            </p>\n            <button\n              onClick={handleMigration}\n              disabled={isLoading}\n              className=\"bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700 disabled:opacity-50 text-sm\"\n            >\n              {isLoading ? (\n                <>\n                  <FaSpinner className=\"animate-spin mr-2\" />\n                  Migrating...\n                </>\n              ) : (\n                \"Migrate My Data\"\n              )}\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  // Render pending requests\n  const renderPendingRequests = () => {\n    if (pendingRequests.length === 0) return null;\n\n    return (\n      <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6\">\n        <h3 className=\"text-blue-800 font-semibold mb-3 flex items-center\">\n          <FaUsers className=\"mr-2\" />\n          Pending Requests ({pendingRequests.length})\n        </h3>\n        <div className=\"space-y-3\">\n          {pendingRequests.map((request) => (\n            <div key={request.id} className=\"bg-white p-3 rounded border\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <p className=\"font-medium text-gray-900\">\n                    Relationship Request\n                  </p>\n                  <p className=\"text-sm text-gray-600\">\n                    From: {request.fromUserId} (as {request.fromRole})\n                  </p>\n                  <p className=\"text-sm text-gray-600\">\n                    You would be: {request.toRole}\n                  </p>\n                  {request.message && (\n                    <p className=\"text-sm text-gray-700 mt-1 italic\">\n                      \"{request.message}\"\n                    </p>\n                  )}\n                </div>\n                <div className=\"flex gap-2\">\n                  <button\n                    onClick={() => acceptRelationshipRequest(request.id)}\n                    disabled={isLoading}\n                    className=\"bg-green-600 text-white p-2 rounded hover:bg-green-700 disabled:opacity-50\"\n                    title=\"Accept\"\n                  >\n                    <FaCheck />\n                  </button>\n                  <button\n                    onClick={() => rejectRelationshipRequest(request.id)}\n                    disabled={isLoading}\n                    className=\"bg-red-600 text-white p-2 rounded hover:bg-red-700 disabled:opacity-50\"\n                    title=\"Reject\"\n                  >\n                    <FaTimes />\n                  </button>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  // Render existing relationships\n  const renderRelationships = () => {\n    if (relationships.length === 0) {\n      return (\n        <div className=\"text-center py-8 text-gray-500\">\n          <FaUsers className=\"mx-auto text-4xl mb-4 opacity-50\" />\n          <p>No relationships yet</p>\n          <p className=\"text-sm\">\n            Send a request to connect with a keyholder or submissive\n          </p>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-4\">\n        {relationships.map((relationship) => (\n          <div\n            key={relationship.id}\n            className={`border rounded-lg p-4 ${\n              activeRelationship?.id === relationship.id\n                ? \"border-blue-500 bg-blue-50\"\n                : \"border-gray-200\"\n            }`}\n          >\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex-1\">\n                <div className=\"flex items-center gap-3\">\n                  <h3 className=\"font-semibold text-gray-900\">\n                    Relationship with{\" \"}\n                    {relationship.submissiveId === relationship.keyholderId\n                      ? \"Yourself (Self-managed)\"\n                      : relationship.keyholderId}\n                  </h3>\n                  <span\n                    className={`px-2 py-1 rounded text-xs font-medium ${\n                      relationship.status === RelationshipStatus.ACTIVE\n                        ? \"bg-green-100 text-green-800\"\n                        : relationship.status === RelationshipStatus.PAUSED\n                          ? \"bg-yellow-100 text-yellow-800\"\n                          : \"bg-gray-100 text-gray-800\"\n                    }`}\n                  >\n                    {relationship.status}\n                  </span>\n                </div>\n                <p className=\"text-sm text-gray-600 mt-1\">\n                  Your role:{\" \"}\n                  {relationship.submissiveId === relationship.keyholderId\n                    ? \"Both\"\n                    : relationship.submissiveId === \"current-user-id\"\n                      ? \"Submissive\"\n                      : \"Keyholder\"}\n                </p>\n                {relationship.notes && (\n                  <p className=\"text-sm text-gray-700 mt-1 italic\">\n                    \"{relationship.notes}\"\n                  </p>\n                )}\n                <p className=\"text-xs text-gray-500 mt-2\">\n                  Established:{\" \"}\n                  {relationship.establishedAt.toDate().toLocaleDateString()}\n                </p>\n              </div>\n\n              <div className=\"flex gap-2\">\n                <button\n                  onClick={() => setActiveRelationship(relationship)}\n                  className={`p-2 rounded ${\n                    activeRelationship?.id === relationship.id\n                      ? \"bg-blue-600 text-white\"\n                      : \"bg-gray-100 text-gray-600 hover:bg-gray-200\"\n                  }`}\n                  title=\"Set as active\"\n                >\n                  <FaEye />\n                </button>\n\n                <button\n                  className=\"p-2 rounded bg-gray-100 text-gray-600 hover:bg-gray-200\"\n                  title=\"Settings\"\n                >\n                  <FaCog />\n                </button>\n\n                <button\n                  onClick={() => {\n                    // TODO: Replace with proper confirmation modal\n                    endRelationship(relationship.id);\n                  }}\n                  disabled={isLoading}\n                  className=\"p-2 rounded bg-red-100 text-red-600 hover:bg-red-200 disabled:opacity-50\"\n                  title=\"End relationship\"\n                >\n                  <FaTrash />\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  // Render request form\n  const renderRequestForm = () => {\n    if (!showRequestForm) return null;\n\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50\">\n        <div className=\"bg-white rounded-lg p-6 w-full max-w-md\">\n          <h3 className=\"text-lg font-semibold mb-4\">\n            Send Relationship Request\n          </h3>\n\n          <form onSubmit={handleSendRequest} className=\"space-y-4\">\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n                User Email\n              </label>\n              <input\n                type=\"email\"\n                value={requestForm.email}\n                onChange={(e) =>\n                  setRequestForm((prev) => ({ ...prev, email: e.target.value }))\n                }\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                placeholder=\"their@email.com\"\n                required\n              />\n            </div>\n\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n                Your Role\n              </label>\n              <select\n                value={requestForm.role}\n                onChange={(e) =>\n                  setRequestForm((prev) => ({\n                    ...prev,\n                    role: e.target.value as \"submissive\" | \"keyholder\",\n                  }))\n                }\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              >\n                <option value=\"submissive\">\n                  Submissive (they'll be your keyholder)\n                </option>\n                <option value=\"keyholder\">\n                  Keyholder (they'll be your submissive)\n                </option>\n              </select>\n            </div>\n\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n                Message (Optional)\n              </label>\n              <textarea\n                value={requestForm.message}\n                onChange={(e) =>\n                  setRequestForm((prev) => ({\n                    ...prev,\n                    message: e.target.value,\n                  }))\n                }\n                className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                rows={3}\n                placeholder=\"Optional message to include with your request...\"\n              />\n            </div>\n\n            <div className=\"flex gap-3 pt-4\">\n              <button\n                type=\"submit\"\n                disabled={isLoading}\n                className=\"flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50\"\n              >\n                {isLoading ? (\n                  <>\n                    <FaSpinner className=\"animate-spin mr-2\" />\n                    Sending...\n                  </>\n                ) : (\n                  \"Send Request\"\n                )}\n              </button>\n              <button\n                type=\"button\"\n                onClick={() => setShowRequestForm(false)}\n                className=\"px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50\"\n              >\n                Cancel\n              </button>\n            </div>\n          </form>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className={`max-w-4xl mx-auto p-6 ${className}`}>\n      {/* Error display */}\n      {error && (\n        <div className=\"bg-red-50 border border-red-200 rounded-lg p-4 mb-6\">\n          <div className=\"flex items-center justify-between\">\n            <p className=\"text-red-800\">{error}</p>\n            <button\n              onClick={clearError}\n              className=\"text-red-600 hover:text-red-800\"\n            >\n              <FaTimes />\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Migration banner */}\n      {renderMigrationBanner()}\n\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-6\">\n        <h1 className=\"text-2xl font-bold text-gray-900\">\n          Relationship Manager\n        </h1>\n\n        <button\n          onClick={() => setShowRequestForm(true)}\n          className=\"bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 flex items-center gap-2\"\n        >\n          <FaUserPlus />\n          Send Request\n        </button>\n      </div>\n\n      {/* Active relationship indicator */}\n      {activeRelationship && (\n        <div className=\"bg-green-50 border border-green-200 rounded-lg p-4 mb-6\">\n          <p className=\"text-green-800\">\n            <strong>Active:</strong> Relationship with{\" \"}\n            {activeRelationship.submissiveId === activeRelationship.keyholderId\n              ? \"Yourself\"\n              : activeRelationship.keyholderId}\n          </p>\n        </div>\n      )}\n\n      {/* Pending requests */}\n      {renderPendingRequests()}\n\n      {/* Relationships list */}\n      <div className=\"bg-white rounded-lg border border-gray-200 p-6\">\n        <h2 className=\"text-lg font-semibold text-gray-900 mb-4\">\n          Your Relationships ({relationships.length})\n        </h2>\n        {renderRelationships()}\n      </div>\n\n      {/* Request form modal */}\n      {renderRequestForm()}\n\n      {/* Loading overlay */}\n      {isLoading && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-25 flex items-center justify-center z-40\">\n          <div className=\"bg-white rounded-lg p-4 flex items-center gap-3\">\n            <FaSpinner className=\"animate-spin text-blue-600\" />\n            <span>Processing...</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default RelationshipManager;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/LogItem.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (85). Maximum allowed is 75.","line":33,"column":48,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":125,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport {\n  FaAward,\n  FaGavel,\n  FaClock,\n  FaStickyNote,\n  FaTrophy,\n  FaExclamationTriangle,\n} from \"../../utils/iconImport\";\n\n// Mock reward/punishment log item interface\nexport interface RewardPunishmentLog {\n  id: string;\n  type: \"reward\" | \"punishment\";\n  title: string;\n  description: string;\n  timeChangeSeconds: number; // Positive for added time, negative for removed time\n  source:\n    | \"task_completion\"\n    | \"keyholder_action\"\n    | \"rule_violation\"\n    | \"milestone\";\n  sourceId?: string; // Reference to task, rule, etc.\n  createdAt: Date;\n  notes?: string;\n}\n\n// Log Item Component\ninterface LogItemProps {\n  item: RewardPunishmentLog;\n}\n\nexport const LogItem: React.FC<LogItemProps> = ({ item }) => {\n  const isReward = item.type === \"reward\";\n  const timeChange = Math.abs(item.timeChangeSeconds);\n\n  const formatDuration = (seconds: number) => {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    } else {\n      return `${minutes}m`;\n    }\n  };\n\n  const getSourceIcon = () => {\n    switch (item.source) {\n      case \"task_completion\":\n        return <FaTrophy className=\"text-nightly-aquamarine\" />;\n      case \"keyholder_action\":\n        return <FaGavel className=\"text-nightly-lavender-floral\" />;\n      case \"rule_violation\":\n        return <FaExclamationTriangle className=\"text-red-400\" />;\n      case \"milestone\":\n        return <FaAward className=\"text-nightly-spring-green\" />;\n      default:\n        return <FaClock />;\n    }\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-4\">\n      {/* Header */}\n      <div className=\"flex items-start justify-between mb-3\">\n        <div className=\"flex items-center gap-3\">\n          {isReward ? (\n            <FaAward className=\"text-green-400 text-xl\" />\n          ) : (\n            <FaGavel className=\"text-red-400 text-xl\" />\n          )}\n          <div>\n            <h3 className=\"font-medium text-nightly-honeydew\">{item.title}</h3>\n            <p className=\"text-sm text-nightly-celadon\">{item.description}</p>\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {getSourceIcon()}\n          <span\n            className={`px-2 py-1 text-xs rounded ${\n              isReward\n                ? \"bg-green-500/20 text-green-300\"\n                : \"bg-red-500/20 text-red-300\"\n            }`}\n          >\n            {isReward ? \"REWARD\" : \"PUNISHMENT\"}\n          </span>\n        </div>\n      </div>\n\n      {/* Time Impact */}\n      {item.timeChangeSeconds !== 0 && (\n        <div\n          className={`flex items-center gap-2 mb-3 ${\n            isReward ? \"text-green-400\" : \"text-red-400\"\n          }`}\n        >\n          <FaClock />\n          <span className=\"font-mono\">\n            {formatDuration(timeChange)}{\" \"}\n            {isReward ? \"removed from\" : \"added to\"} chastity time\n          </span>\n        </div>\n      )}\n\n      {/* Notes */}\n      {item.notes && (\n        <div className=\"bg-white/5 rounded p-2 mb-3\">\n          <div className=\"flex items-center gap-2 text-nightly-celadon\">\n            <FaStickyNote />\n            <span className=\"text-sm\">{item.notes}</span>\n          </div>\n        </div>\n      )}\n\n      {/* Timestamp */}\n      <div className=\"text-xs text-nightly-celadon text-right\">\n        {item.createdAt.toLocaleDateString()}{\" \"}\n        {item.createdAt.toLocaleTimeString()}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/ManualEntryForm.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (176). Maximum allowed is 75.","line":10,"column":64,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":197,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { RewardPunishmentLog } from \"./LogItem\";\nimport { FaPlus } from \"../../utils/iconImport\";\n\n// Manual Entry Form Component\ninterface ManualEntryFormProps {\n  onSubmit: (entry: Omit<RewardPunishmentLog, \"id\" | \"createdAt\">) => void;\n}\n\nexport const ManualEntryForm: React.FC<ManualEntryFormProps> = ({\n  onSubmit,\n}) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [formData, setFormData] = useState({\n    type: \"reward\" as \"reward\" | \"punishment\",\n    title: \"\",\n    description: \"\",\n    timeChangeSeconds: 3600, // Default 1 hour\n    notes: \"\",\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    onSubmit({\n      ...formData,\n      timeChangeSeconds:\n        formData.type === \"reward\"\n          ? -Math.abs(formData.timeChangeSeconds)\n          : Math.abs(formData.timeChangeSeconds),\n      source: \"keyholder_action\",\n    });\n\n    // Reset form\n    setFormData({\n      type: \"reward\",\n      title: \"\",\n      description: \"\",\n      timeChangeSeconds: 3600,\n      notes: \"\",\n    });\n    setIsOpen(false);\n  };\n\n  if (!isOpen) {\n    return (\n      <button\n        onClick={() => setIsOpen(true)}\n        className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n      >\n        <FaPlus />\n        Add Manual Entry\n      </button>\n    );\n  }\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <h3 className=\"text-lg font-semibold text-nightly-honeydew mb-4\">\n        Manual Reward/Punishment\n      </h3>\n\n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        {/* Type Selection */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Type\n          </label>\n          <div className=\"flex gap-4\">\n            <label className=\"flex items-center\">\n              <input\n                type=\"radio\"\n                value=\"reward\"\n                checked={formData.type === \"reward\"}\n                onChange={(e) =>\n                  setFormData((prev) => ({\n                    ...prev,\n                    type: e.target.value as \"reward\" | \"punishment\",\n                  }))\n                }\n                className=\"mr-2\"\n              />\n              <span className=\"text-green-400\">Reward</span>\n            </label>\n            <label className=\"flex items-center\">\n              <input\n                type=\"radio\"\n                value=\"punishment\"\n                checked={formData.type === \"punishment\"}\n                onChange={(e) =>\n                  setFormData((prev) => ({\n                    ...prev,\n                    type: e.target.value as \"reward\" | \"punishment\",\n                  }))\n                }\n                className=\"mr-2\"\n              />\n              <span className=\"text-red-400\">Punishment</span>\n            </label>\n          </div>\n        </div>\n\n        {/* Title */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Title\n          </label>\n          <input\n            type=\"text\"\n            value={formData.title}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, title: e.target.value }))\n            }\n            placeholder=\"Brief title for this entry\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            required\n          />\n        </div>\n\n        {/* Description */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Description\n          </label>\n          <textarea\n            value={formData.description}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, description: e.target.value }))\n            }\n            placeholder=\"Detailed description of the reason\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={3}\n            required\n          />\n        </div>\n\n        {/* Time Change */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Time Impact (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"0\"\n            max=\"168\"\n            step=\"0.5\"\n            value={formData.timeChangeSeconds / 3600}\n            onChange={(e) =>\n              setFormData((prev) => ({\n                ...prev,\n                timeChangeSeconds: parseFloat(e.target.value) * 3600,\n              }))\n            }\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\"\n          />\n          <div className=\"text-xs text-nightly-celadon mt-1\">\n            This will {formData.type === \"reward\" ? \"reduce\" : \"add\"} chastity\n            time\n          </div>\n        </div>\n\n        {/* Notes */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Notes (optional)\n          </label>\n          <textarea\n            value={formData.notes}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, notes: e.target.value }))\n            }\n            placeholder=\"Additional notes or comments\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={2}\n          />\n        </div>\n\n        {/* Actions */}\n        <div className=\"flex gap-3\">\n          <button\n            type=\"submit\"\n            className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\"\n          >\n            Add Entry\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => setIsOpen(false)}\n            className=\"bg-white/10 hover:bg-white/20 text-nightly-celadon px-6 py-2 rounded font-medium transition-colors\"\n          >\n            Cancel\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/RewardPunishmentStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rewards_punishments/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RuleCard.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (92). Maximum allowed is 75.","line":23,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":119,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { FaEdit, FaLock, FaUnlock } from \"../../utils/iconImport\";\n\n// Mock rules interface\nexport interface ChastityRule {\n  id: string;\n  title: string;\n  content: string;\n  isActive: boolean;\n  createdBy: \"submissive\" | \"keyholder\";\n  createdAt: Date;\n  lastModified: Date;\n}\n\n// Rule Card Component\ninterface RuleCardProps {\n  rule: ChastityRule;\n  isEditable: boolean;\n  onEdit?: (ruleId: string) => void;\n  onToggle?: (ruleId: string) => void;\n}\n\nexport const RuleCard: React.FC<RuleCardProps> = ({\n  rule,\n  isEditable,\n  onEdit,\n  onToggle,\n}) => {\n  const formatMarkdownToReact = (content: string) => {\n    // Simple markdown-to-HTML conversion (in real app, use a proper library)\n    return content.split(\"\\n\").map((line, index) => {\n      if (line.startsWith(\"**\") && line.endsWith(\"**\")) {\n        return (\n          <strong key={index} className=\"text-nightly-honeydew\">\n            {line.slice(2, -2)}\n          </strong>\n        );\n      }\n      if (line.startsWith(\"- \")) {\n        return (\n          <li key={index} className=\"ml-4 text-nightly-celadon\">\n            {line.slice(2)}\n          </li>\n        );\n      }\n      if (line.trim() === \"\") {\n        return <br key={index} />;\n      }\n      return (\n        <p key={index} className=\"text-nightly-celadon mb-2\">\n          {line}\n        </p>\n      );\n    });\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      {/* Header */}\n      <div className=\"flex items-start justify-between mb-4\">\n        <div className=\"flex-1\">\n          <div className=\"flex items-center gap-3 mb-2\">\n            {rule.isActive ? (\n              <FaUnlock className=\"text-green-400\" />\n            ) : (\n              <FaLock className=\"text-gray-400\" />\n            )}\n            <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n              {rule.title}\n            </h3>\n            <span\n              className={`px-2 py-1 text-xs rounded ${\n                rule.isActive\n                  ? \"bg-green-500/20 text-green-300\"\n                  : \"bg-gray-500/20 text-gray-300\"\n              }`}\n            >\n              {rule.isActive ? \"ACTIVE\" : \"INACTIVE\"}\n            </span>\n          </div>\n\n          <div className=\"flex items-center gap-4 text-xs text-nightly-celadon\">\n            <span>Created by: {rule.createdBy}</span>\n            <span></span>\n            <span>Modified: {rule.lastModified.toLocaleDateString()}</span>\n          </div>\n        </div>\n\n        {isEditable && (\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={() => onToggle?.(rule.id)}\n              className={`p-2 rounded transition-colors ${\n                rule.isActive\n                  ? \"bg-gray-500/20 hover:bg-gray-500/30 text-gray-300\"\n                  : \"bg-green-500/20 hover:bg-green-500/30 text-green-300\"\n              }`}\n              title={rule.isActive ? \"Deactivate rule\" : \"Activate rule\"}\n            >\n              {rule.isActive ? <FaLock /> : <FaUnlock />}\n            </button>\n            <button\n              onClick={() => onEdit?.(rule.id)}\n              className=\"p-2 bg-nightly-aquamarine/20 hover:bg-nightly-aquamarine/30 text-nightly-aquamarine rounded transition-colors\"\n              title=\"Edit rule\"\n            >\n              <FaEdit />\n            </button>\n          </div>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"prose prose-sm max-w-none\">\n        {formatMarkdownToReact(rule.content)}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/RuleEditor.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (128). Maximum allowed is 75.","line":14,"column":54,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":151,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { ChastityRule } from \"./RuleCard\";\nimport { FaEdit, FaSave, FaTimes } from \"../../utils/iconImport\";\n\n// Rule Editor Component\ninterface RuleEditorProps {\n  rule: ChastityRule | null;\n  onSave: (\n    rule: Omit<ChastityRule, \"id\" | \"createdAt\" | \"lastModified\">,\n  ) => void;\n  onCancel: () => void;\n}\n\nexport const RuleEditor: React.FC<RuleEditorProps> = ({\n  rule,\n  onSave,\n  onCancel,\n}) => {\n  const [formData, setFormData] = useState({\n    title: rule?.title || \"\",\n    content: rule?.content || \"\",\n    isActive: rule?.isActive ?? true,\n    createdBy: rule?.createdBy || (\"submissive\" as \"submissive\" | \"keyholder\"),\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSave(formData);\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-6\">\n        <FaEdit className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          {rule ? \"Edit Rule\" : \"Create New Rule\"}\n        </h3>\n      </div>\n\n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        {/* Title */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Rule Title\n          </label>\n          <input\n            type=\"text\"\n            value={formData.title}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, title: e.target.value }))\n            }\n            placeholder=\"Enter a clear, descriptive title\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            required\n          />\n        </div>\n\n        {/* Content */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Rule Content\n            <span className=\"text-xs text-nightly-celadon/70 ml-2\">\n              (Supports basic markdown: **bold**, bullet points with -)\n            </span>\n          </label>\n          <textarea\n            value={formData.content}\n            onChange={(e) =>\n              setFormData((prev) => ({ ...prev, content: e.target.value }))\n            }\n            placeholder={`Describe the rule in detail, including:\n\n**Requirements:**\n- What needs to be done\n- When it needs to be done\n- How to provide evidence\n\n**Consequences:**\n- For following the rule (rewards)\n- For breaking the rule (punishments)\n\n**Additional notes:**\n- Any special circumstances\n- Exceptions or modifications`}\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none font-mono text-sm\"\n            rows={12}\n            required\n          />\n        </div>\n\n        {/* Settings */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          <div>\n            <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n              Created By\n            </label>\n            <select\n              value={formData.createdBy}\n              onChange={(e) =>\n                setFormData((prev) => ({\n                  ...prev,\n                  createdBy: e.target.value as \"submissive\" | \"keyholder\",\n                }))\n              }\n              className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\"\n            >\n              <option value=\"submissive\">Submissive</option>\n              <option value=\"keyholder\">Keyholder</option>\n            </select>\n          </div>\n\n          <div className=\"flex items-center\">\n            <label className=\"flex items-center\">\n              <input\n                type=\"checkbox\"\n                checked={formData.isActive}\n                onChange={(e) =>\n                  setFormData((prev) => ({\n                    ...prev,\n                    isActive: e.target.checked,\n                  }))\n                }\n                className=\"mr-2\"\n              />\n              <span className=\"text-nightly-celadon\">Rule is active</span>\n            </label>\n          </div>\n        </div>\n\n        {/* Actions */}\n        <div className=\"flex gap-3 pt-4\">\n          <button\n            type=\"submit\"\n            className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n          >\n            <FaSave />\n            {rule ? \"Update Rule\" : \"Create Rule\"}\n          </button>\n          <button\n            type=\"button\"\n            onClick={onCancel}\n            className=\"bg-white/10 hover:bg-white/20 text-nightly-celadon px-6 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n          >\n            <FaTimes />\n            Cancel\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/rules/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/AccountSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/DisplaySettingsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/PersonalGoalSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/PublicProfileSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/settings/SessionEditSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/system/OfflineStatus.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FaDatabase' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FaCloud' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":10},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (81). Maximum allowed is 75.","line":17,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":107,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isLoading' is assigned a value but never used.","line":19,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Offline Status Component\n * Shows the status of the offline queue and sync operations\n * Demonstrates the complete Firebase  Dexie  TanStack Query architecture\n */\nimport React, { useState } from \"react\";\nimport { useOfflineQueueStats } from \"../../hooks/api\";\nimport { useNotificationActions } from \"../../stores\";\nimport {\n  FaWifi,\n  FaWifiSlash,\n  FaSync,\n  FaDatabase,\n  FaCloud,\n} from \"react-icons/fa\";\n\nexport const OfflineStatus: React.FC = () => {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const { data: queueStats, isLoading } = useOfflineQueueStats();\n  const { showInfo } = useNotificationActions();\n\n  // Listen for online/offline events\n  React.useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      showInfo(\n        \"Back online! Syncing pending changes...\",\n        \"Connection Restored\",\n      );\n    };\n\n    const handleOffline = () => {\n      setIsOnline(false);\n      showInfo(\n        \"You're offline. Changes will sync when connection is restored.\",\n        \"Offline Mode\",\n      );\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n    };\n  }, [showInfo]);\n\n  const statusColor = isOnline\n    ? (queueStats?.pending || 0) > 0\n      ? \"bg-yellow-500\"\n      : \"bg-green-500\"\n    : \"bg-red-500\";\n\n  const statusIcon = isOnline ? (\n    queueStats?.pending ? (\n      <FaSync className=\"animate-spin\" />\n    ) : (\n      <FaWifi />\n    )\n  ) : (\n    <FaWifiSlash />\n  );\n\n  return (\n    <div className=\"fixed bottom-4 right-4 bg-white/10 backdrop-blur-sm border border-white/20 rounded-lg shadow-lg p-4 max-w-sm\">\n      {/* Status Header */}\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"flex items-center gap-2\">\n          <div className={`w-3 h-3 rounded-full ${statusColor}`} />\n          <span className=\"text-sm font-medium text-white\">\n            {isOnline ? \"Online\" : \"Offline\"}\n          </span>\n          {statusIcon}\n        </div>\n      </div>\n\n      {/* Architecture Flow Indicator */}\n      <div className=\"mt-3 pt-3 border-t border-white/10\">\n        <div className=\"text-xs font-medium text-white mb-2\">\n           Migration Complete\n        </div>\n        <div className=\"flex items-center justify-between text-xs\">\n          <span className=\"text-blue-400\">Firebase</span>\n          <span className=\"text-gray-400\"></span>\n          <span className=\"text-green-400\">Dexie</span>\n          <span className=\"text-gray-400\"></span>\n          <span className=\"text-purple-400\">TanStack</span>\n          <span className=\"text-gray-400\"></span>\n          <span className=\"text-yellow-400\">UI</span>\n        </div>\n        <div className=\"text-center mt-1\">\n          <span className=\"text-xs text-gray-400\"></span>\n        </div>\n        <div className=\"text-center\">\n          <span className=\"text-xs text-orange-400\">Zustand</span>\n        </div>\n      </div>\n\n      {/* Implementation Status */}\n      <div className=\"mt-3 p-2 bg-green-500/20 rounded text-xs text-green-200\">\n        <strong> Architecture Ready:</strong> Firebase to TanStack Query\n        migration is complete and functional.\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/CountdownTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/TaskItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tasks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/ActionButtons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/CooldownTimer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/DenialCooldown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/EmergencyUnlockButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/EmergencyUnlockModal.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (265). Maximum allowed is 75.","line":25,"column":74,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":313,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isProcessing' is assigned a value but never used. Allowed unused args must match /^_/u.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":15},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (92). Maximum allowed is 75.","line":125,"column":23,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":220,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from \"react\";\nimport {\n  FaTimes,\n  FaExclamationTriangle,\n  FaArrowLeft,\n  FaArrowRight,\n} from \"react-icons/fa\";\nimport type { EmergencyUnlockReason } from \"@/types/events\";\nimport { EMERGENCY_UNLOCK_REASONS } from \"@/types/events\";\nimport { logger } from \"../../utils/logging\";\n\ninterface EmergencyUnlockModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onEmergencyUnlock: (\n    reason: EmergencyUnlockReason,\n    additionalNotes?: string,\n  ) => Promise<void>;\n  sessionId: string;\n  isProcessing?: boolean;\n}\n\ntype ModalStage = \"warning\" | \"reason\" | \"confirm\";\n\nexport const EmergencyUnlockModal: React.FC<EmergencyUnlockModalProps> = ({\n  isOpen,\n  onClose,\n  onEmergencyUnlock,\n  sessionId,\n  isProcessing = false,\n}) => {\n  const [stage, setStage] = useState<ModalStage>(\"warning\");\n  const [reason, setReason] = useState<EmergencyUnlockReason | \"\">(\"\");\n  const [customReason, setCustomReason] = useState(\"\");\n  const [confirmText, setConfirmText] = useState(\"\");\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const confirmInputRef = useRef<HTMLInputElement>(null);\n  const requiredText = \"EMERGENCY UNLOCK\";\n\n  // Reset state when modal opens/closes\n  useEffect(() => {\n    if (isOpen) {\n      setStage(\"warning\");\n      setReason(\"\");\n      setCustomReason(\"\");\n      setConfirmText(\"\");\n      setIsSubmitting(false);\n    }\n  }, [isOpen]);\n\n  // Focus confirm input when reaching confirm stage\n  useEffect(() => {\n    if (stage === \"confirm\" && confirmInputRef.current) {\n      confirmInputRef.current.focus();\n    }\n  }, [stage]);\n\n  if (!isOpen) return null;\n\n  const handleEmergencyUnlock = async () => {\n    if (!reason || confirmText !== requiredText) return;\n\n    setIsSubmitting(true);\n    try {\n      const finalReason = reason as EmergencyUnlockReason;\n      const additionalNotes = reason === \"Other\" ? customReason : undefined;\n      await onEmergencyUnlock(finalReason, additionalNotes);\n      onClose();\n    } catch (error) {\n      logger.error(\"Emergency unlock failed in modal\", error, { sessionId });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const canProceedFromReason =\n    reason && (reason !== \"Other\" || customReason.trim());\n  const canConfirm = confirmText === requiredText && canProceedFromReason;\n\n  const WarningStage = () => (\n    <div className=\"text-center\">\n      <FaExclamationTriangle className=\"text-6xl text-red-400 mx-auto mb-6\" />\n      <h3 className=\"text-xl font-bold mb-4 text-red-300\">\n         Emergency Unlock\n      </h3>\n\n      <div className=\"bg-red-900/30 border border-red-600 rounded-lg p-4 mb-6 text-left\">\n        <h4 className=\"font-semibold text-red-300 mb-2\">\n           Warning: Emergency Use Only\n        </h4>\n        <ul className=\"text-sm text-red-200 space-y-1\">\n          <li> This will immediately end your current session</li>\n          <li> All session goals and restrictions will be bypassed</li>\n          <li> This action will be logged for safety and accountability</li>\n          <li> Frequent use may trigger cooldown periods</li>\n          <li> Use only in genuine emergency situations</li>\n        </ul>\n      </div>\n\n      <p className=\"text-sm text-gray-300 mb-6\">\n        This feature is designed for medical emergencies, safety concerns,\n        equipment malfunctions, or other urgent situations that genuinely\n        require immediate unlock.\n      </p>\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={() => setStage(\"reason\")}\n          className=\"w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition flex items-center justify-center\"\n        >\n          I Understand - Continue\n          <FaArrowRight className=\"ml-2\" />\n        </button>\n        <button\n          onClick={onClose}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Cancel\n        </button>\n      </div>\n    </div>\n  );\n\n  const ReasonStage = () => (\n    <div>\n      <div className=\"flex items-center mb-6\">\n        <button\n          onClick={() => setStage(\"warning\")}\n          className=\"mr-3 p-1 text-gray-400 hover:text-white transition\"\n          aria-label=\"Go back\"\n        >\n          <FaArrowLeft />\n        </button>\n        <h3 className=\"text-xl font-bold text-red-300\">\n          Select Emergency Reason\n        </h3>\n      </div>\n\n      <p className=\"text-sm text-gray-300 mb-4\">\n        Please select the reason for your emergency unlock. This information\n        helps ensure the feature is used appropriately and safely.\n      </p>\n\n      <div className=\"space-y-3 mb-6\">\n        {EMERGENCY_UNLOCK_REASONS.map((emergencyReason) => (\n          <label\n            key={emergencyReason}\n            className={`flex items-start p-3 rounded-lg border cursor-pointer transition ${\n              reason === emergencyReason\n                ? \"border-red-500 bg-red-900/30\"\n                : \"border-gray-600 bg-gray-800/50 hover:bg-gray-700/50\"\n            }`}\n          >\n            <input\n              type=\"radio\"\n              name=\"emergency-reason\"\n              value={emergencyReason}\n              checked={reason === emergencyReason}\n              onChange={(e) =>\n                setReason(e.target.value as EmergencyUnlockReason)\n              }\n              className=\"mt-1 mr-3 text-red-600\"\n            />\n            <div>\n              <div className=\"font-medium text-white\">{emergencyReason}</div>\n              <div className=\"text-xs text-gray-400 mt-1\">\n                {emergencyReason === \"Medical Emergency\" &&\n                  \"Health-related emergencies requiring immediate unlock\"}\n                {emergencyReason === \"Safety Concern\" &&\n                  \"Physical safety or security situations\"}\n                {emergencyReason === \"Equipment Malfunction\" &&\n                  \"Device failure or malfunction\"}\n                {emergencyReason === \"Urgent Situation\" &&\n                  \"Other urgent circumstances requiring unlock\"}\n                {emergencyReason === \"Other\" &&\n                  \"Custom reason with additional details\"}\n              </div>\n            </div>\n          </label>\n        ))}\n      </div>\n\n      {reason === \"Other\" && (\n        <div className=\"mb-6\">\n          <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n            Please specify the emergency reason:\n          </label>\n          <textarea\n            value={customReason}\n            onChange={(e) => setCustomReason(e.target.value)}\n            placeholder=\"Describe your emergency situation...\"\n            rows={3}\n            className=\"w-full p-3 rounded-lg border border-gray-600 bg-gray-800 text-white focus:border-red-500 focus:ring-1 focus:ring-red-500 resize-none\"\n            maxLength={500}\n          />\n          <div className=\"text-xs text-gray-400 mt-1\">\n            {customReason.length}/500 characters\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={() => setStage(\"confirm\")}\n          disabled={!canProceedFromReason}\n          className=\"w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition flex items-center justify-center\"\n        >\n          Continue to Confirmation\n          <FaArrowRight className=\"ml-2\" />\n        </button>\n        <button\n          onClick={() => setStage(\"warning\")}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Back\n        </button>\n      </div>\n    </div>\n  );\n\n  const ConfirmationStage = () => (\n    <div>\n      <div className=\"flex items-center mb-6\">\n        <button\n          onClick={() => setStage(\"reason\")}\n          className=\"mr-3 p-1 text-gray-400 hover:text-white transition\"\n          aria-label=\"Go back\"\n        >\n          <FaArrowLeft />\n        </button>\n        <h3 className=\"text-xl font-bold text-red-300\">Final Confirmation</h3>\n      </div>\n\n      <div className=\"bg-yellow-900/30 border border-yellow-600 rounded-lg p-4 mb-6\">\n        <h4 className=\"font-semibold text-yellow-300 mb-2\"> Final Warning</h4>\n        <p className=\"text-sm text-yellow-200 mb-3\">\n          You are about to perform an emergency unlock. This action:\n        </p>\n        <ul className=\"text-sm text-yellow-200 space-y-1 mb-3\">\n          <li> Will immediately end session #{sessionId.slice(-8)}</li>\n          <li> Cannot be undone</li>\n          <li> Will be permanently logged</li>\n          <li>\n             Reason: <strong>{reason}</strong>\n          </li>\n        </ul>\n      </div>\n\n      <div className=\"mb-6\">\n        <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n          Type \"{requiredText}\" to confirm:\n        </label>\n        <input\n          ref={confirmInputRef}\n          type=\"text\"\n          value={confirmText}\n          onChange={(e) => setConfirmText(e.target.value.toUpperCase())}\n          placeholder={requiredText}\n          className={`w-full p-3 rounded-lg border bg-gray-800 text-white text-center font-mono text-lg tracking-widest focus:ring-2 transition ${\n            confirmText === requiredText\n              ? \"border-green-500 focus:ring-green-500\"\n              : \"border-gray-600 focus:ring-red-500\"\n          }`}\n          maxLength={requiredText.length}\n        />\n        <div className=\"text-xs text-gray-400 mt-1 text-center\">\n          {confirmText.length}/{requiredText.length} characters\n        </div>\n      </div>\n\n      <div className=\"flex flex-col space-y-3\">\n        <button\n          onClick={handleEmergencyUnlock}\n          disabled={!canConfirm || isSubmitting}\n          className=\"w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          {isSubmitting\n            ? \"Processing Emergency Unlock...\"\n            : \" EMERGENCY UNLOCK \"}\n        </button>\n        <button\n          onClick={() => setStage(\"reason\")}\n          disabled={isSubmitting}\n          className=\"w-full bg-gray-600 hover:bg-gray-500 disabled:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg transition\"\n        >\n          Back to Reason Selection\n        </button>\n      </div>\n    </div>\n  );\n\n  return (\n    <div className=\"fixed inset-0 bg-black/75 backdrop-blur-sm z-50 flex items-center justify-center p-4\">\n      <div className=\"bg-gradient-to-br from-gray-900 to-gray-800 max-w-md w-full rounded-xl border-2 border-red-500 shadow-2xl\">\n        <div className=\"relative p-6\">\n          <button\n            onClick={onClose}\n            disabled={isSubmitting}\n            className=\"absolute top-4 right-4 text-gray-400 hover:text-white transition-colors disabled:cursor-not-allowed\"\n            aria-label=\"Close modal\"\n          >\n            <FaTimes size={20} />\n          </button>\n\n          {stage === \"warning\" && <WarningStage />}\n          {stage === \"reason\" && <ReasonStage />}\n          {stage === \"confirm\" && <ConfirmationStage />}\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/GoalDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/KeyholderRequirement.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/PauseCooldownMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/PauseResumeButtons.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (79). Maximum allowed is 75.","line":122,"column":47,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":205,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\n// TODO: Replace with proper hook pattern to avoid architectural violations\n// import { PauseService, EnhancedPauseReason } from \"../../services/PauseService\";\nimport { serviceLogger } from \"../../utils/logging\";\n\n// Temporary types until proper hook pattern is implemented\ntype EnhancedPauseReason = \"Bathroom Break\" | \"Emergency\" | \"Medical\" | \"Other\";\n\ntype PauseState = {\n  canPause: boolean;\n  lastPauseTime?: Date;\n  nextPauseAvailable?: Date;\n  cooldownRemaining?: number;\n};\n\nconst logger = serviceLogger(\"PauseResumeButtons\");\n\n// Helper function to format cooldown time (inline until proper hook pattern)\nconst formatTimeRemaining = (cooldownSeconds: number): string => {\n  const hours = Math.floor(cooldownSeconds / 3600);\n  const minutes = Math.floor((cooldownSeconds % 3600) / 60);\n  const seconds = cooldownSeconds % 60;\n\n  if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;\n  if (minutes > 0) return `${minutes}m ${seconds}s`;\n  return `${seconds}s`;\n};\n\n// Helper function to get button states and conditions\nconst getButtonStates = (isPaused: boolean, pauseState?: PauseState) => {\n  return {\n    showPause: !isPaused,\n    showResume: isPaused,\n    canPause: pauseState?.canPause ?? false,\n    showCooldown: !pauseState?.canPause && !!pauseState?.cooldownRemaining,\n  };\n};\n\n// Helper function to get button styling\nconst getPauseButtonStyling = (canPause: boolean) => {\n  return canPause\n    ? \"bg-gradient-to-r from-yellow-600/80 to-orange-600/80 hover:from-yellow-500/90 hover:to-orange-500/90 text-white hover:shadow-yellow-500/20\"\n    : \"bg-gradient-to-r from-gray-400/80 to-gray-500/80 text-gray-300 cursor-not-allowed\";\n};\n\n// Helper function to get button text\nconst getPauseButtonText = (canPause: boolean) => {\n  return canPause ? \"Pause Session\" : \"Cooldown Active\";\n};\n\n// PauseButton sub-component\ninterface PauseButtonProps {\n  canPause: boolean;\n  isLoading: boolean;\n  onPauseClick: () => void;\n}\n\nconst PauseButton: React.FC<PauseButtonProps> = ({\n  canPause,\n  isLoading,\n  onPauseClick,\n}) => (\n  <div className=\"flex justify-center mb-8\">\n    <button\n      type=\"button\"\n      onClick={onPauseClick}\n      disabled={!canPause || isLoading}\n      className={`glass-button font-bold py-3 px-6 shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 ${getPauseButtonStyling(canPause)}`}\n    >\n       {getPauseButtonText(canPause)}\n    </button>\n  </div>\n);\n\n// ResumeButton sub-component\ninterface ResumeButtonProps {\n  isLoading: boolean;\n  onResumeClick: () => void;\n}\n\nconst ResumeButton: React.FC<ResumeButtonProps> = ({\n  isLoading,\n  onResumeClick,\n}) => (\n  <div className=\"flex justify-center mb-8\">\n    <button\n      type=\"button\"\n      onClick={onResumeClick}\n      disabled={isLoading}\n      className=\"glass-button bg-gradient-to-r from-green-600/80 to-emerald-600/80 hover:from-green-500/90 hover:to-emerald-500/90 text-white font-bold py-3 px-6 shadow-lg hover:shadow-green-500/20 transition-all duration-300 transform hover:scale-105 disabled:opacity-50\"\n    >\n       {isLoading ? \"Resuming...\" : \"Resume Session\"}\n    </button>\n  </div>\n);\n\n// CooldownDisplay sub-component\ninterface CooldownDisplayProps {\n  cooldownRemaining: number;\n}\n\nconst CooldownDisplay: React.FC<CooldownDisplayProps> = ({\n  cooldownRemaining,\n}) => (\n  <div className=\"text-sm text-yellow-600 mb-4 text-center\">\n    Next pause available in: {formatTimeRemaining(cooldownRemaining)}\n  </div>\n);\n\n// PauseModal sub-component\ninterface PauseModalProps {\n  show: boolean;\n  selectedReason: EnhancedPauseReason;\n  customReason: string;\n  isLoading: boolean;\n  onReasonChange: (reason: EnhancedPauseReason) => void;\n  onCustomReasonChange: (reason: string) => void;\n  onConfirm: () => void;\n  onCancel: () => void;\n}\n\nconst PauseModal: React.FC<PauseModalProps> = ({\n  show,\n  selectedReason,\n  customReason,\n  isLoading,\n  onReasonChange,\n  onCustomReasonChange,\n  onConfirm,\n  onCancel,\n}) => {\n  if (!show) return null;\n\n  const reasons: EnhancedPauseReason[] = [\n    \"Bathroom Break\",\n    \"Emergency\",\n    \"Medical\",\n    \"Other\",\n  ];\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4\">\n      <div className=\"glass-morphism p-6 md:p-8 text-center w-full max-w-md text-gray-50 border border-yellow-700/30\">\n        <h3 className=\"text-lg md:text-xl font-bold mb-4 text-yellow-300\">\n          Reason for Pausing Session\n        </h3>\n\n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n            Select reason:\n          </label>\n          <select\n            value={selectedReason}\n            onChange={(e) =>\n              onReasonChange(e.target.value as EnhancedPauseReason)\n            }\n            className=\"w-full p-2 rounded-lg border border-yellow-600/50 bg-gray-900/50 backdrop-blur-sm text-gray-50 focus:outline-none focus:ring-2 focus:ring-yellow-500\"\n          >\n            {reasons.map((reason) => (\n              <option key={reason} value={reason}>\n                {reason}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        {selectedReason === \"Other\" && (\n          <div className=\"mb-4\">\n            <label className=\"block text-sm font-medium text-gray-300 mb-2\">\n              Custom reason:\n            </label>\n            <input\n              type=\"text\"\n              value={customReason}\n              onChange={(e) => onCustomReasonChange(e.target.value)}\n              placeholder=\"Enter custom reason\"\n              className=\"w-full p-2 rounded-lg border border-yellow-600/50 bg-gray-900/50 backdrop-blur-sm text-gray-50 focus:outline-none focus:ring-2 focus:ring-yellow-500\"\n            />\n          </div>\n        )}\n\n        <div className=\"flex flex-col sm:flex-row justify-around space-y-3 sm:space-y-0 sm:space-x-4\">\n          <button\n            type=\"button\"\n            onClick={onConfirm}\n            disabled={\n              isLoading || (selectedReason === \"Other\" && !customReason.trim())\n            }\n            className=\"w-full sm:w-auto glass-button bg-gradient-to-r from-yellow-600/80 to-yellow-700/80 hover:from-yellow-500/90 hover:to-yellow-600/90 text-white font-bold py-2 px-4 transition-all duration-300 disabled:opacity-50\"\n          >\n            {isLoading ? \"Pausing...\" : \"Confirm Pause\"}\n          </button>\n          <button\n            type=\"button\"\n            onClick={onCancel}\n            disabled={isLoading}\n            className=\"w-full sm:w-auto glass-button bg-gradient-to-r from-gray-600/80 to-gray-700/80 hover:from-gray-500/90 hover:to-gray-600/90 text-white font-bold py-2 px-4 transition-all duration-300 disabled:opacity-50\"\n          >\n            Cancel\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface PauseResumeButtonsProps {\n  sessionId: string;\n  userId: string;\n  isPaused: boolean;\n  pauseState?: PauseState;\n  onPause?: () => void;\n  onResume?: () => void;\n}\n\n// Helper functions for async operations\nconst executeWithLoadingState = async (\n  setIsLoading: (loading: boolean) => void,\n  operation: () => Promise<void>,\n) => {\n  setIsLoading(true);\n  try {\n    await operation();\n  } catch (error) {\n    logger.error(\"Operation failed\", error);\n  } finally {\n    setIsLoading(false);\n  }\n};\n\nconst resetModalState = (\n  setShowPauseModal: (show: boolean) => void,\n  setSelectedReason: (reason: EnhancedPauseReason) => void,\n  setCustomReason: (reason: string) => void,\n) => {\n  setShowPauseModal(false);\n  setSelectedReason(\"Bathroom Break\");\n  setCustomReason(\"\");\n};\n\n// Custom hook to manage pause/resume logic\nconst usePauseResumeLogic = (\n  sessionId: string,\n  onPause?: () => void,\n  onResume?: () => void,\n) => {\n  const [showPauseModal, setShowPauseModal] = useState(false);\n  const [selectedReason, setSelectedReason] =\n    useState<EnhancedPauseReason>(\"Bathroom Break\");\n  const [customReason, setCustomReason] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleConfirmPause = async () => {\n    if (!sessionId) return;\n    await executeWithLoadingState(setIsLoading, async () => {\n      // TODO: Replace with proper service hook call\n      await new Promise((resolve) => setTimeout(resolve, 500)); // Mock delay\n      resetModalState(setShowPauseModal, setSelectedReason, setCustomReason);\n      onPause?.();\n      logger.info(\"Session paused successfully (mocked)\", { sessionId });\n    });\n  };\n\n  const handleResumeClick = async () => {\n    if (!sessionId) return;\n    await executeWithLoadingState(setIsLoading, async () => {\n      // TODO: Replace with proper service hook call\n      await new Promise((resolve) => setTimeout(resolve, 500)); // Mock delay\n      onResume?.();\n      logger.info(\"Session resumed successfully (mocked)\", { sessionId });\n    });\n  };\n\n  const handleModalCancel = () => {\n    resetModalState(setShowPauseModal, setSelectedReason, setCustomReason);\n  };\n\n  return {\n    showPauseModal,\n    setShowPauseModal,\n    selectedReason,\n    setSelectedReason,\n    customReason,\n    setCustomReason,\n    isLoading,\n    handleConfirmPause,\n    handleResumeClick,\n    handleModalCancel,\n  };\n};\n\nexport const PauseResumeButtons: React.FC<PauseResumeButtonsProps> = ({\n  sessionId,\n  _userId, // Mark as unused with underscore prefix\n  isPaused,\n  pauseState,\n  onPause,\n  onResume,\n}) => {\n  const {\n    showPauseModal,\n    setShowPauseModal,\n    selectedReason,\n    setSelectedReason,\n    customReason,\n    setCustomReason,\n    isLoading,\n    handleConfirmPause,\n    handleResumeClick,\n    handleModalCancel,\n  } = usePauseResumeLogic(sessionId, onPause, onResume);\n\n  const buttonStates = getButtonStates(isPaused, pauseState);\n\n  const handlePauseClick = () => {\n    if (!pauseState?.canPause) return;\n    setShowPauseModal(true);\n  };\n\n  return (\n    <>\n      {buttonStates.showResume && (\n        <ResumeButton isLoading={isLoading} onResumeClick={handleResumeClick} />\n      )}\n\n      {buttonStates.showPause && (\n        <PauseButton\n          canPause={buttonStates.canPause}\n          isLoading={isLoading}\n          onPauseClick={handlePauseClick}\n        />\n      )}\n\n      {buttonStates.showCooldown && pauseState?.cooldownRemaining && (\n        <CooldownDisplay cooldownRemaining={pauseState.cooldownRemaining} />\n      )}\n\n      <PauseModal\n        show={showPauseModal}\n        selectedReason={selectedReason}\n        customReason={customReason}\n        isLoading={isLoading}\n        onReasonChange={setSelectedReason}\n        onCustomReasonChange={setCustomReason}\n        onConfirm={handleConfirmPause}\n        onCancel={handleModalCancel}\n      />\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/ReasonModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/RestoreSessionPrompt.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/TrackerHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/tracker/TrackerStats.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (100). Maximum allowed is 75.","line":16,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":118,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\n\ninterface TrackerStatsProps {\n  topBoxLabel: string;\n  topBoxTime: string;\n  mainChastityDisplayTime: number;\n  isPaused: boolean;\n  livePauseDuration: number;\n  accumulatedPauseTimeThisSession: number;\n  isCageOn: boolean;\n  timeCageOff: number;\n  totalChastityTime: number;\n  totalTimeCageOff: number;\n}\n\nexport const TrackerStats: React.FC<TrackerStatsProps> = ({\n  topBoxLabel,\n  topBoxTime,\n  mainChastityDisplayTime,\n  isPaused,\n  livePauseDuration,\n  accumulatedPauseTimeThisSession,\n  isCageOn,\n  timeCageOff,\n  totalChastityTime,\n  totalTimeCageOff,\n}) => {\n  return (\n    <div className=\"space-y-6 mb-8\">\n      {/* Top stat card with enhanced glass effect */}\n      <div className=\"glass-card-primary text-center glass-float\">\n        <p className=\"text-blue-200 text-sm md:text-lg font-medium mb-2\">\n          {topBoxLabel}\n        </p>\n        <p className=\"text-3xl md:text-5xl font-bold bg-gradient-to-r from-blue-200 to-white bg-clip-text text-transparent\">\n          {topBoxTime}\n        </p>\n      </div>\n\n      {/* Stats grid with enhanced glass cards */}\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-6\">\n        <div\n          className={`glass-card transition-all duration-500 ${\n            isCageOn\n              ? isPaused\n                ? \"glass-card-accent border-yellow-400/30 shadow-yellow-400/20\"\n                : \"border-green-400/30 shadow-green-400/20\"\n              : \"glass-card-primary\"\n          }`}\n        >\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Current Session In Chastity {isPaused ? \"(Paused)\" : \"\"}:\n          </p>\n          <p\n            className={`text-2xl md:text-4xl font-bold mb-2 ${\n              isCageOn\n                ? isPaused\n                  ? \"text-yellow-300\"\n                  : \"text-green-300\"\n                : \"text-white\"\n            }`}\n          >\n            {mainChastityDisplayTime}\n          </p>\n          {isPaused && (\n            <p className=\"text-xs text-yellow-200 bg-yellow-400/10 px-2 py-1 rounded-md\">\n              Currently paused for: {livePauseDuration}\n            </p>\n          )}\n          {isCageOn && accumulatedPauseTimeThisSession > 0 && (\n            <p className=\"text-xs text-yellow-200 bg-yellow-400/10 px-2 py-1 rounded-md mt-2\">\n              Total time paused this session: {accumulatedPauseTimeThisSession}\n            </p>\n          )}\n        </div>\n\n        <div\n          className={`glass-card transition-all duration-500 ${\n            !isCageOn && timeCageOff > 0\n              ? \"border-red-400/30 shadow-red-400/20\"\n              : \"glass-card-primary\"\n          }`}\n        >\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Current Session Cage Off:\n          </p>\n          <p\n            className={`text-2xl md:text-4xl font-bold ${\n              !isCageOn && timeCageOff > 0 ? \"text-red-300\" : \"text-white\"\n            }`}\n          >\n            {timeCageOff}\n          </p>\n        </div>\n      </div>\n\n      {/* Total stats with subtle glass cards */}\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-6\">\n        <div className=\"glass-card glass-hover\">\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Total Time In Chastity:\n          </p>\n          <p className=\"text-2xl md:text-4xl font-bold text-white\">\n            {totalChastityTime}\n          </p>\n        </div>\n        <div className=\"glass-card glass-hover\">\n          <p className=\"text-sm md:text-lg font-medium mb-3 text-gray-200\">\n            Total Time Cage Off:\n          </p>\n          <p className=\"text-2xl md:text-4xl font-bold text-white\">\n            {totalTimeCageOff}\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/components/ui/NotificationContainer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":5,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":26},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (82). Maximum allowed is 75.","line":9,"column":54,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":90,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (129). Maximum allowed is 75.","line":92,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":228,"endColumn":2},{"ruleId":"zustand-safe-patterns/zustand-selective-subscriptions","severity":1,"message":"Use selective subscriptions instead of subscribing to entire store. Replace useUIStore() with useUIStore(state => state.specificValue) to prevent unnecessary re-renders. See docs/development/architecture/data-flow.md for performance patterns.","line":94,"column":5,"nodeType":"CallExpression","messageId":"useSelectiveSubscription","endLine":94,"endColumn":27},{"ruleId":"zustand-safe-patterns/zustand-no-conditional-subscriptions","severity":1,"message":"Avoid conditional store subscriptions. Move conditions inside the component instead of conditionally calling useStore hooks. This prevents React hooks rule violations and memory leaks.","line":94,"column":5,"nodeType":"CallExpression","messageId":"noConditionalSubscriptions","endLine":94,"endColumn":27},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (76). Maximum allowed is 75.","line":146,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":224,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * NotificationContainer Component\n * Displays toast notifications using NotificationStore\n */\nimport React, { useEffect } from \"react\";\nimport { useNotificationStore } from \"@/stores\";\n\n// Simple icons for notification types\nconst NotificationIcon: React.FC<{ type: string }> = ({ type }) => {\n  switch (type) {\n    case \"success\":\n      return (\n        <svg\n          className=\"w-5 h-5 text-green-400\"\n          fill=\"currentColor\"\n          viewBox=\"0 0 20 20\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      );\n    case \"error\":\n      return (\n        <svg\n          className=\"w-5 h-5 text-red-400\"\n          fill=\"currentColor\"\n          viewBox=\"0 0 20 20\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      );\n    case \"warning\":\n      return (\n        <svg\n          className=\"w-5 h-5 text-yellow-400\"\n          fill=\"currentColor\"\n          viewBox=\"0 0 20 20\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      );\n    case \"loading\":\n      return (\n        <svg\n          className=\"animate-spin w-5 h-5 text-blue-400\"\n          fill=\"none\"\n          viewBox=\"0 0 24 24\"\n        >\n          <circle\n            className=\"opacity-25\"\n            cx=\"12\"\n            cy=\"12\"\n            r=\"10\"\n            stroke=\"currentColor\"\n            strokeWidth=\"4\"\n          ></circle>\n          <path\n            className=\"opacity-75\"\n            fill=\"currentColor\"\n            d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n          ></path>\n        </svg>\n      );\n    default:\n      return (\n        <svg\n          className=\"w-5 h-5 text-blue-400\"\n          fill=\"currentColor\"\n          viewBox=\"0 0 20 20\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      );\n  }\n};\n\nconst NotificationContainer: React.FC = () => {\n  const { notifications, removeNotification, pauseOnHover } =\n    useNotificationStore();\n\n  // Group notifications by position\n  const notificationsByPosition = notifications.reduce(\n    (acc, notification) => {\n      const position = notification.position || \"top-right\";\n      if (!acc[position]) {\n        acc[position] = [];\n      }\n      acc[position].push(notification);\n      return acc;\n    },\n    {} as Record<string, typeof notifications>,\n  );\n\n  const getPositionClasses = (position: string) => {\n    switch (position) {\n      case \"top-left\":\n        return \"top-4 left-4\";\n      case \"top-center\":\n        return \"top-4 left-1/2 transform -translate-x-1/2\";\n      case \"top-right\":\n        return \"top-4 right-4\";\n      case \"bottom-left\":\n        return \"bottom-4 left-4\";\n      case \"bottom-center\":\n        return \"bottom-4 left-1/2 transform -translate-x-1/2\";\n      case \"bottom-right\":\n        return \"bottom-4 right-4\";\n      default:\n        return \"top-4 right-4\";\n    }\n  };\n\n  const getTypeClasses = (type: string) => {\n    switch (type) {\n      case \"success\":\n        return \"bg-green-50 border-green-200 text-green-800\";\n      case \"error\":\n        return \"bg-red-50 border-red-200 text-red-800\";\n      case \"warning\":\n        return \"bg-yellow-50 border-yellow-200 text-yellow-800\";\n      case \"loading\":\n        return \"bg-blue-50 border-blue-200 text-blue-800\";\n      default:\n        return \"bg-blue-50 border-blue-200 text-blue-800\";\n    }\n  };\n\n  return (\n    <>\n      {Object.entries(notificationsByPosition).map(\n        ([position, positionNotifications]) => (\n          <div\n            key={position}\n            className={`fixed z-50 ${getPositionClasses(position)} space-y-2 max-w-sm w-full`}\n          >\n            {positionNotifications.map((notification) => (\n              <div\n                key={notification.id}\n                className={`\n                flex items-start p-4 border rounded-lg shadow-lg backdrop-blur-sm\n                ${getTypeClasses(notification.type)}\n                ${pauseOnHover ? \"hover:shadow-xl transition-shadow\" : \"\"}\n              `}\n                role=\"alert\"\n              >\n                <div className=\"flex-shrink-0\">\n                  <NotificationIcon type={notification.type} />\n                </div>\n\n                <div className=\"ml-3 flex-1\">\n                  {notification.title && (\n                    <h4 className=\"text-sm font-medium mb-1\">\n                      {notification.title}\n                    </h4>\n                  )}\n                  <p className=\"text-sm\">{notification.message}</p>\n\n                  {notification.actions && notification.actions.length > 0 && (\n                    <div className=\"mt-3 flex space-x-2\">\n                      {notification.actions.map((action, index) => (\n                        <button\n                          key={index}\n                          onClick={() => {\n                            action.handler();\n                            if (notification.dismissible !== false) {\n                              removeNotification(notification.id);\n                            }\n                          }}\n                          className={`\n                          text-xs px-2 py-1 rounded border transition-colors\n                          ${\n                            action.style === \"danger\"\n                              ? \"border-red-300 text-red-700 hover:bg-red-100\"\n                              : action.style === \"secondary\"\n                                ? \"border-gray-300 text-gray-700 hover:bg-gray-100\"\n                                : \"border-current text-current hover:bg-current hover:bg-opacity-10\"\n                          }\n                        `}\n                        >\n                          {action.label}\n                        </button>\n                      ))}\n                    </div>\n                  )}\n                </div>\n\n                {notification.dismissible !== false && (\n                  <button\n                    onClick={() => removeNotification(notification.id)}\n                    className=\"ml-2 flex-shrink-0 text-gray-400 hover:text-gray-600 transition-colors\"\n                    aria-label=\"Dismiss notification\"\n                  >\n                    <svg\n                      className=\"w-4 h-4\"\n                      fill=\"currentColor\"\n                      viewBox=\"0 0 20 20\"\n                    >\n                      <path\n                        fillRule=\"evenodd\"\n                        d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\"\n                        clipRule=\"evenodd\"\n                      />\n                    </svg>\n                  </button>\n                )}\n              </div>\n            ))}\n          </div>\n        ),\n      )}\n    </>\n  );\n};\n\nexport default NotificationContainer;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/consistency-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/goal-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/milestone-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/special-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/streak-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/constants/achievements/task-achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/AppContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (137). Maximum allowed is 75.","line":49,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":228,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2253,2256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2253,2256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3370,3373],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3370,3373],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3715,3718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3715,3718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4014,4017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4014,4017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Application Context\n * Manages global app-level state (non-auth, non-UI)\n * Context layer - App state like connection status, sync status, etc.\n */\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n} from \"react\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { preloadCriticalServices } from \"@/services/firebase\";\nimport { achievementIntegration } from \"@/services/AchievementIntegration\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db } from \"@/services/database\";\nimport type { SyncStatus } from \"@/types/database\";\n\nconst logger = serviceLogger(\"AppContext\");\n\nexport interface AppState {\n  isInitialized: boolean;\n  isOnline: boolean;\n  syncStatus: SyncStatus | null;\n  lastSyncTime: Date | null;\n  hasUnreadNotifications: boolean;\n  connectionType: string | null;\n}\n\nexport interface AppActions {\n  initializeApp: () => Promise<void>;\n  triggerSync: (userId: string) => Promise<void>;\n  markNotificationsRead: () => void;\n  updateConnectionStatus: (isOnline: boolean) => void;\n}\n\nexport interface AppContextType {\n  state: AppState;\n  actions: AppActions;\n}\n\nconst AppContext = createContext<AppContextType | null>(null);\n\ninterface AppProviderProps {\n  children: ReactNode;\n}\n\nexport const AppProvider: React.FC<AppProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    isInitialized: false,\n    isOnline: navigator.onLine,\n    syncStatus: null,\n    lastSyncTime: null,\n    hasUnreadNotifications: false,\n    connectionType: null,\n  });\n\n  // Initialize app on mount\n  useEffect(() => {\n    const initializeApp = async () => {\n      try {\n        logger.info(\"Initializing application\");\n\n        // Initialize Dexie database first\n        await db.initialize();\n        logger.info(\"Dexie database initialized\");\n\n        // Preload critical Firebase services\n        await preloadCriticalServices();\n\n        // Initialize achievement system\n        await achievementIntegration.initialize();\n\n        // Initialize sync service\n        // FirebaseSync initializes automatically\n\n        // Set initial sync status\n        const syncStatus = \"synced\" as SyncStatus;\n\n        // Detect connection type\n        const connection = (navigator as any).connection;\n        const connectionType = connection?.effectiveType || \"unknown\";\n\n        setState((prev) => ({\n          ...prev,\n          isInitialized: true,\n          syncStatus,\n          connectionType,\n        }));\n\n        logger.info(\"Application initialized successfully\", { connectionType });\n      } catch (error) {\n        logger.error(\"Failed to initialize application\", {\n          error: error as Error,\n        });\n        setState((prev) => ({\n          ...prev,\n          isInitialized: false,\n        }));\n      }\n    };\n\n    initializeApp();\n\n    // Listen for online/offline events\n    const handleOnline = () => {\n      setState((prev) => ({ ...prev, isOnline: true }));\n      logger.debug(\"App went online\");\n    };\n\n    const handleOffline = () => {\n      setState((prev) => ({ ...prev, isOnline: false }));\n      logger.debug(\"App went offline\");\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    // Listen for connection changes\n    const handleConnectionChange = () => {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        setState((prev) => ({\n          ...prev,\n          connectionType: connection.effectiveType || \"unknown\",\n        }));\n        logger.debug(\"Connection type changed\", {\n          type: connection.effectiveType,\n        });\n      }\n    };\n\n    if (\"connection\" in navigator) {\n      (navigator as any).connection.addEventListener(\n        \"change\",\n        handleConnectionChange,\n      );\n    }\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n\n      if (\"connection\" in navigator) {\n        (navigator as any).connection.removeEventListener(\n          \"change\",\n          handleConnectionChange,\n        );\n      }\n    };\n  }, []);\n\n  const actions: AppActions = {\n    initializeApp: async () => {\n      if (state.isInitialized) {\n        logger.debug(\"App already initialized, skipping\");\n        return;\n      }\n\n      setState((prev) => ({ ...prev, isInitialized: false }));\n\n      try {\n        // Initialize Dexie database first\n        await db.initialize();\n        logger.info(\"Dexie database re-initialized\");\n\n        await preloadCriticalServices();\n        // FirebaseSync initializes automatically\n\n        const syncStatus = \"synced\" as SyncStatus;\n\n        setState((prev) => ({\n          ...prev,\n          isInitialized: true,\n          syncStatus,\n        }));\n\n        logger.info(\"App re-initialized successfully\");\n      } catch (error) {\n        logger.error(\"Failed to re-initialize app\", { error: error as Error });\n      }\n    },\n\n    triggerSync: async (userId: string) => {\n      logger.debug(\"Triggering manual sync\", { userId });\n\n      await firebaseSync.sync();\n      const result = { success: true };\n\n      if (result.success && result.data) {\n        setState((prev) => ({\n          ...prev,\n          syncStatus: result.data!,\n          lastSyncTime: result.data!.lastSyncTime,\n        }));\n        logger.info(\"Manual sync completed\", { userId });\n      } else {\n        logger.warn(\"Manual sync failed\", { userId, error: result.error });\n      }\n    },\n\n    markNotificationsRead: () => {\n      setState((prev) => ({\n        ...prev,\n        hasUnreadNotifications: false,\n      }));\n      logger.debug(\"Notifications marked as read\");\n    },\n\n    updateConnectionStatus: (isOnline: boolean) => {\n      setState((prev) => ({\n        ...prev,\n        isOnline,\n      }));\n      logger.debug(\"Connection status updated\", { isOnline });\n    },\n  };\n\n  const contextValue: AppContextType = {\n    state,\n    actions,\n  };\n\n  return (\n    <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>\n  );\n};\n\nexport const useApp = (): AppContextType => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error(\"useApp must be used within an AppProvider\");\n  }\n  return context;\n};\n\n// Convenience hooks for common use cases\nexport const useAppState = () => {\n  const { state } = useApp();\n  return state;\n};\n\nexport const useAppActions = () => {\n  const { actions } = useApp();\n  return actions;\n};\n\nexport const useConnectionStatus = () => {\n  const { state } = useApp();\n  return {\n    isOnline: state.isOnline,\n    connectionType: state.connectionType,\n  };\n};\n\nexport const useSyncStatus = () => {\n  const { state, actions } = useApp();\n  return {\n    syncStatus: state.syncStatus,\n    lastSyncTime: state.lastSyncTime,\n    triggerSync: actions.triggerSync,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/AuthContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (210). Maximum allowed is 75.","line":48,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":298,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Authentication Context\n * Manages auth state using the AuthService\n * Context layer - React state management for authentication\n */\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n} from \"react\";\nimport { AuthService } from \"@/services/auth/auth-service\";\nimport { getFirebaseAuth } from \"@/services/firebase\";\nimport { User, LoginForm, RegisterForm, ApiResponse } from \"@/types\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"AuthContext\");\n\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface AuthActions {\n  signIn: (credentials: LoginForm) => Promise<ApiResponse<User>>;\n  register: (userData: RegisterForm) => Promise<ApiResponse<User>>;\n  signOut: () => Promise<ApiResponse<void>>;\n  resetPassword: (email: string) => Promise<ApiResponse<void>>;\n  updatePassword: (newPassword: string) => Promise<ApiResponse<void>>;\n  updateProfile: (updates: Partial<User>) => Promise<ApiResponse<User>>;\n  clearError: () => void;\n}\n\nexport interface AuthContextType {\n  state: AuthState;\n  actions: AuthActions;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AuthState>({\n    user: null,\n    isAuthenticated: false,\n    isLoading: true,\n    error: null,\n  });\n\n  // Initialize auth state on mount\n  useEffect(() => {\n    const initializeAuth = async () => {\n      try {\n        logger.debug(\"Initializing auth state\");\n\n        const auth = await getFirebaseAuth();\n\n        // Check if user is already authenticated\n        const currentUser = await AuthService.getCurrentUser();\n\n        if (currentUser) {\n          setState({\n            user: currentUser,\n            isAuthenticated: true,\n            isLoading: false,\n            error: null,\n          });\n          logger.info(\"User already authenticated\", { uid: currentUser.uid });\n        } else {\n          setState((prev) => ({\n            ...prev,\n            isLoading: false,\n          }));\n          logger.debug(\"No authenticated user found\");\n        }\n\n        // Listen for auth state changes\n        const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {\n          if (firebaseUser) {\n            logger.debug(\"Firebase auth state changed: user signed in\", {\n              uid: firebaseUser.uid,\n            });\n\n            // Get full user profile from our service\n            const user = await AuthService.getCurrentUser();\n            if (user) {\n              setState({\n                user,\n                isAuthenticated: true,\n                isLoading: false,\n                error: null,\n              });\n            }\n          } else {\n            logger.debug(\"Firebase auth state changed: user signed out\");\n            setState({\n              user: null,\n              isAuthenticated: false,\n              isLoading: false,\n              error: null,\n            });\n          }\n        });\n\n        return unsubscribe;\n      } catch (error) {\n        logger.error(\"Failed to initialize auth\", { error: error as Error });\n        setState({\n          user: null,\n          isAuthenticated: false,\n          isLoading: false,\n          error: \"Failed to initialize authentication\",\n        });\n      }\n    };\n\n    const unsubscribePromise = initializeAuth();\n\n    return () => {\n      unsubscribePromise.then((unsubscribe) => {\n        if (unsubscribe) {\n          unsubscribe();\n        }\n      });\n    };\n  }, []);\n\n  const actions: AuthActions = {\n    signIn: async (credentials: LoginForm) => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.signIn(credentials);\n\n      if (result.success && result.data) {\n        setState({\n          user: result.data,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User signed in via context\", { uid: result.data.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Sign in failed\",\n        }));\n        logger.warn(\"Sign in failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    register: async (userData: RegisterForm) => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.register(userData);\n\n      if (result.success && result.data) {\n        setState({\n          user: result.data,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User registered via context\", { uid: result.data.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Registration failed\",\n        }));\n        logger.warn(\"Registration failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    signOut: async () => {\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      const result = await AuthService.signOut();\n\n      if (result.success) {\n        setState({\n          user: null,\n          isAuthenticated: false,\n          isLoading: false,\n          error: null,\n        });\n        logger.info(\"User signed out via context\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: result.error || \"Sign out failed\",\n        }));\n        logger.warn(\"Sign out failed via context\", { error: result.error });\n      }\n\n      return result;\n    },\n\n    resetPassword: async (email: string) => {\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.resetPassword(email);\n\n      if (!result.success) {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Password reset failed\",\n        }));\n        logger.warn(\"Password reset failed via context\", {\n          error: result.error,\n          email,\n        });\n      } else {\n        logger.info(\"Password reset sent via context\", { email });\n      }\n\n      return result;\n    },\n\n    updatePassword: async (newPassword: string) => {\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.updatePassword(newPassword);\n\n      if (!result.success) {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Password update failed\",\n        }));\n        logger.warn(\"Password update failed via context\", {\n          error: result.error,\n        });\n      } else {\n        logger.info(\"Password updated via context\");\n      }\n\n      return result;\n    },\n\n    updateProfile: async (updates: Partial<User>) => {\n      if (!state.user) {\n        const error = \"No authenticated user found\";\n        setState((prev) => ({ ...prev, error }));\n        return { success: false, error };\n      }\n\n      setState((prev) => ({ ...prev, error: null }));\n\n      const result = await AuthService.updateUserProfile(\n        state.user.uid,\n        updates,\n      );\n\n      if (result.success && result.data) {\n        setState((prev) => ({\n          ...prev,\n          user: result.data!,\n        }));\n        logger.info(\"Profile updated via context\", { uid: state.user.uid });\n      } else {\n        setState((prev) => ({\n          ...prev,\n          error: result.error || \"Profile update failed\",\n        }));\n        logger.warn(\"Profile update failed via context\", {\n          error: result.error,\n          uid: state.user.uid,\n        });\n      }\n\n      return result;\n    },\n\n    clearError: () => {\n      setState((prev) => ({ ...prev, error: null }));\n    },\n  };\n\n  const contextValue: AuthContextType = {\n    state,\n    actions,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>\n  );\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n};\n\n// Convenience hooks for common use cases\nexport const useAuthState = () => {\n  const { state } = useAuth();\n  return state;\n};\n\nexport const useAuthActions = () => {\n  const { actions } = useAuth();\n  return actions;\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/SyncContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (86). Maximum allowed is 75.","line":37,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":145,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lastSyncResult' is assigned a value but never used.","line":41,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'sync'. Either include it or remove the dependency array.","line":79,"column":6,"nodeType":"ArrayExpression","endLine":79,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [sync, userId]","fix":{"range":[2233,2241],"text":"[sync, userId]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sync Context\n * Provides sync state and conflict resolution across the app\n */\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\nimport { useSync } from \"@/hooks/useSync\";\nimport { useAuth } from \"@/hooks/useAuth\";\nimport { ConflictResolutionModal } from \"@/components/common/ConflictResolutionModal\";\nimport type { ConflictInfo } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"SyncContext\");\n\ninterface SyncContextType {\n  isSyncing: boolean;\n  lastSyncTime: Date | null;\n  syncStatus: \"synced\" | \"pending\" | \"conflict\" | \"error\";\n  pendingConflicts: ConflictInfo[];\n  triggerSync: () => Promise<void>;\n  hasConflicts: boolean;\n}\n\nconst SyncContext = createContext<SyncContextType | undefined>(undefined);\n\nexport const useSyncContext = (): SyncContextType => {\n  const context = useContext(SyncContext);\n  if (!context) {\n    throw new Error(\"useSyncContext must be used within SyncProvider\");\n  }\n  return context;\n};\n\ninterface SyncProviderProps {\n  children: React.ReactNode;\n}\n\nexport const SyncProvider: React.FC<SyncProviderProps> = ({ children }) => {\n  const { userId } = useAuth();\n  const {\n    isSyncing,\n    lastSyncResult,\n    pendingConflicts,\n    sync,\n    resolveConflicts,\n    error,\n  } = useSync();\n\n  const [showConflictModal, setShowConflictModal] = useState(false);\n  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\n\n  // Determine sync status\n  const getSyncStatus = (): SyncContextType[\"syncStatus\"] => {\n    if (error) return \"error\";\n    if (pendingConflicts.length > 0) return \"conflict\";\n    if (isSyncing) return \"pending\";\n    return \"synced\";\n  };\n\n  // Auto-sync on user change and periodically\n  useEffect(() => {\n    if (!userId) return;\n\n    const performSync = async () => {\n      try {\n        await sync(userId, { conflictResolution: \"auto\" });\n        setLastSyncTime(new Date());\n      } catch (error) {\n        logger.error(\"Auto-sync failed\", { error: error as Error });\n      }\n    };\n\n    // Initial sync\n    performSync();\n\n    // Periodic sync every 5 minutes\n    const interval = setInterval(performSync, 5 * 60 * 1000);\n\n    return () => clearInterval(interval);\n  }, [userId]);\n\n  // Show conflict modal when conflicts are detected\n  useEffect(() => {\n    if (pendingConflicts.length > 0 && !showConflictModal) {\n      setShowConflictModal(true);\n    }\n  }, [pendingConflicts.length, showConflictModal]);\n\n  const triggerSync = async (): Promise<void> => {\n    if (!userId) {\n      throw new Error(\"No user authenticated\");\n    }\n\n    try {\n      await sync(userId, { force: true });\n      setLastSyncTime(new Date());\n    } catch (error) {\n      logger.error(\"Manual sync failed\", { error: error as Error });\n      throw error;\n    }\n  };\n\n  const handleResolveConflicts = async (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => {\n    try {\n      await resolveConflicts(resolutions);\n      setShowConflictModal(false);\n\n      // Trigger a sync after resolving conflicts\n      if (userId) {\n        await sync(userId);\n        setLastSyncTime(new Date());\n      }\n    } catch (error) {\n      logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n    }\n  };\n\n  const handleCancelConflictResolution = () => {\n    setShowConflictModal(false);\n    // Conflicts remain pending - user can resolve them later\n  };\n\n  const contextValue: SyncContextType = {\n    isSyncing,\n    lastSyncTime,\n    syncStatus: getSyncStatus(),\n    pendingConflicts,\n    triggerSync,\n    hasConflicts: pendingConflicts.length > 0,\n  };\n\n  return (\n    <SyncContext.Provider value={contextValue}>\n      {children}\n\n      <ConflictResolutionModal\n        conflicts={pendingConflicts}\n        onResolve={handleResolveConflicts}\n        onCancel={handleCancelConflictResolution}\n        isOpen={showConflictModal}\n      />\n    </SyncContext.Provider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/contexts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/account-linking/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/account-linking/useAccountLinking.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (256). Maximum allowed is 75.","line":30,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":333,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (27). Maximum allowed is 25.","line":30,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":333,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Linking Hook\n * React hook for managing keyholder-wearer account linking\n */\nimport { useState, useCallback, useEffect } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { AccountLinkingService } from \"../../services/auth/account-linking\";\nimport { useAuthState } from \"../../contexts\";\nimport {\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  AccountLinkingState,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\n\nconst logger = serviceLogger(\"useAccountLinking\");\n\n// Query keys\nconst QUERY_KEYS = {\n  relationships: (userId: string) => [\"adminRelationships\", userId],\n  validation: (code: string) => [\"linkCodeValidation\", code],\n  adminSession: (relationshipId: string) => [\"adminSession\", relationshipId],\n} as const;\n\nexport const useAccountLinking = () => {\n  const { user } = useAuthState();\n  const queryClient = useQueryClient();\n\n  // Local state\n  const [state, setState] = useState<AccountLinkingState>({\n    isGeneratingCode: false,\n    currentLinkCode: null,\n    linkCodeError: null,\n    isUsingCode: false,\n    codeUsageError: null,\n    adminRelationships: [],\n    selectedWearerId: null,\n    currentAdminSession: null,\n    isAdminSessionActive: false,\n    showQRCode: false,\n    showDisconnectionDialog: false,\n    showPermissionEditor: false,\n  });\n\n  // ==================== QUERIES ====================\n\n  // Get admin relationships for current user\n  const {\n    data: relationships = [],\n    isLoading: isLoadingRelationships,\n    error: relationshipsError,\n  } = useQuery({\n    queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n    queryFn: () => AccountLinkingService.getAdminRelationships(user!.uid),\n    enabled: !!user,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n\n  // Update local state when relationships change\n  useEffect(() => {\n    setState((prev) => ({ ...prev, adminRelationships: relationships }));\n  }, [relationships]);\n\n  // ==================== MUTATIONS ====================\n\n  // Generate link code\n  const generateLinkCodeMutation = useMutation({\n    mutationFn: (request: GenerateLinkCodeRequest) =>\n      AccountLinkingService.generateLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isGeneratingCode: true,\n        linkCodeError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<LinkCodeResponse>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentLinkCode: response.data!,\n          isGeneratingCode: false,\n        }));\n        logger.info(\"Link code generated successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: response.error || \"Failed to generate link code\",\n          isGeneratingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        linkCodeError: error.message,\n        isGeneratingCode: false,\n      }));\n      logger.error(\"Failed to generate link code\", { error });\n    },\n  });\n\n  // Use link code\n  const useLinkCodeMutation = useMutation({\n    mutationFn: (request: UseLinkCodeRequest) =>\n      AccountLinkingService.redeemLinkCode(request),\n    onMutate: () => {\n      setState((prev) => ({\n        ...prev,\n        isUsingCode: true,\n        codeUsageError: null,\n      }));\n    },\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          isUsingCode: false,\n        }));\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Link code used successfully\");\n      } else {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: response.error || \"Failed to use link code\",\n          isUsingCode: false,\n        }));\n      }\n    },\n    onError: (error: Error) => {\n      setState((prev) => ({\n        ...prev,\n        codeUsageError: error.message,\n        isUsingCode: false,\n      }));\n      logger.error(\"Failed to use link code\", { error });\n    },\n  });\n\n  // Update relationship\n  const updateRelationshipMutation = useMutation({\n    mutationFn: (request: UpdateRelationshipRequest) =>\n      AccountLinkingService.updateRelationship(request),\n    onSuccess: (response: ApiResponse<AdminRelationship>) => {\n      if (response.success) {\n        // Refresh relationships\n        queryClient.invalidateQueries({\n          queryKey: QUERY_KEYS.relationships(user?.uid || \"\"),\n        });\n        logger.info(\"Relationship updated successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to update relationship\", { error });\n    },\n  });\n\n  // Start admin session\n  const startAdminSessionMutation = useMutation({\n    mutationFn: (relationshipId: string) =>\n      AccountLinkingService.startAdminSession(relationshipId),\n    onSuccess: (response: ApiResponse<AdminSession>) => {\n      if (response.success && response.data) {\n        setState((prev) => ({\n          ...prev,\n          currentAdminSession: response.data!,\n          isAdminSessionActive: true,\n        }));\n        logger.info(\"Admin session started successfully\");\n      }\n    },\n    onError: (error: Error) => {\n      logger.error(\"Failed to start admin session\", { error });\n    },\n  });\n\n  // ==================== CALLBACK FUNCTIONS ====================\n\n  const generateLinkCode = useCallback(\n    (request: GenerateLinkCodeRequest = {}) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          linkCodeError: \"Authentication required\",\n        }));\n        return;\n      }\n      generateLinkCodeMutation.mutate(request);\n    },\n    [user, generateLinkCodeMutation],\n  );\n\n  const redeemLinkCode = useCallback(\n    (request: UseLinkCodeRequest) => {\n      if (!user) {\n        setState((prev) => ({\n          ...prev,\n          codeUsageError: \"Authentication required\",\n        }));\n        return;\n      }\n      useLinkCodeMutation.mutate(request);\n    },\n    [user, useLinkCodeMutation],\n  );\n\n  const updateRelationship = useCallback(\n    (request: UpdateRelationshipRequest) => {\n      updateRelationshipMutation.mutate(request);\n    },\n    [updateRelationshipMutation],\n  );\n\n  const startAdminSession = useCallback(\n    (relationshipId: string) => {\n      startAdminSessionMutation.mutate(relationshipId);\n    },\n    [startAdminSessionMutation],\n  );\n\n  const disconnectKeyholder = useCallback(\n    (relationshipId: string, reason?: string) => {\n      updateRelationship({\n        relationshipId,\n        status: \"terminated\",\n        terminationReason: reason,\n      });\n    },\n    [updateRelationship],\n  );\n\n  const clearLinkCode = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      currentLinkCode: null,\n      linkCodeError: null,\n    }));\n  }, []);\n\n  const clearErrors = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      linkCodeError: null,\n      codeUsageError: null,\n    }));\n  }, []);\n\n  const setSelectedWearer = useCallback((wearerId: string | null) => {\n    setState((prev) => ({ ...prev, selectedWearerId: wearerId }));\n  }, []);\n\n  const toggleQRCode = useCallback(() => {\n    setState((prev) => ({ ...prev, showQRCode: !prev.showQRCode }));\n  }, []);\n\n  const toggleDisconnectionDialog = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      showDisconnectionDialog: !prev.showDisconnectionDialog,\n    }));\n  }, []);\n\n  const togglePermissionEditor = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      showPermissionEditor: !prev.showPermissionEditor,\n    }));\n  }, []);\n\n  // ==================== DERIVED STATE ====================\n\n  const isKeyholder = relationships.some((r) => r.keyholderId === user?.uid);\n  const isWearer = relationships.some((r) => r.wearerId === user?.uid);\n  const hasActiveRelationships = relationships.some(\n    (r) => r.status === \"active\",\n  );\n\n  const selectedRelationship = state.selectedWearerId\n    ? relationships.find((r) => r.wearerId === state.selectedWearerId)\n    : null;\n\n  const keyholderRelationships = relationships.filter(\n    (r) => r.keyholderId === user?.uid,\n  );\n  const wearerRelationships = relationships.filter(\n    (r) => r.wearerId === user?.uid,\n  );\n\n  // ==================== RETURN OBJECT ====================\n\n  return {\n    // State\n    ...state,\n    relationships,\n    isLoadingRelationships,\n    relationshipsError,\n\n    // Derived state\n    isKeyholder,\n    isWearer,\n    hasActiveRelationships,\n    selectedRelationship,\n    keyholderRelationships,\n    wearerRelationships,\n\n    // Actions\n    generateLinkCode,\n    redeemLinkCode,\n    updateRelationship,\n    startAdminSession,\n    disconnectKeyholder,\n    clearLinkCode,\n    clearErrors,\n    setSelectedWearer,\n    toggleQRCode,\n    toggleDisconnectionDialog,\n    togglePermissionEditor,\n\n    // Loading states\n    isGeneratingCode: generateLinkCodeMutation.isPending,\n    isUsingCode: useLinkCodeMutation.isPending,\n    isUpdatingRelationship: updateRelationshipMutation.isPending,\n    isStartingSession: startAdminSessionMutation.isPending,\n  };\n};\n\n// ==================== ADDITIONAL HOOKS ====================\n\n/**\n * Hook for validating link codes\n */\nexport const useLinkCodeValidation = (code: string) => {\n  return useQuery({\n    queryKey: QUERY_KEYS.validation(code),\n    queryFn: () => AccountLinkingService.validateLinkCode(code),\n    enabled: code.length > 0,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n};\n\n/**\n * Hook for admin access validation\n */\nexport const useAdminAccess = (wearerId: string) => {\n  const { user } = useAuthState();\n  const { relationships } = useAccountLinking();\n\n  const adminRelationship = relationships.find(\n    (r) =>\n      r.keyholderId === user?.uid &&\n      r.wearerId === wearerId &&\n      r.status === \"active\",\n  );\n\n  const hasAccess = !!adminRelationship;\n  const permissions = adminRelationship?.permissions || null;\n  const security = adminRelationship?.security || null;\n\n  const canPerformAction = useCallback(\n    (action: keyof typeof permissions) => {\n      return hasAccess && permissions?.[action] === true;\n    },\n    [hasAccess, permissions],\n  );\n\n  return {\n    hasAccess,\n    adminRelationship,\n    permissions,\n    security,\n    canPerformAction,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/queryClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEmergency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEvents.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1376,1379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1376,1379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1477,1480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1477,1480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  useMutation,\n  useQuery,\n  useQueryClient,\n  useInfiniteQuery,\n} from \"@tanstack/react-query\";\nimport { eventDBService } from \"../../services/database/EventDBService\";\nimport { Event } from \"../../types/events\";\nimport { logger } from \"../../utils/logging\";\n\n/**\n * Event Management Hooks - TanStack Query Integration\n *\n * Integrates with:\n * - eventDBService  Dexie  Firebase sync\n * - LogEventPage.tsx, LogEventForm.tsx (critical fixes needed)\n *\n * Fixes:\n * - LogEventForm.tsx:92-93 (commented eventDBService.create)\n * - LogEventPage.tsx:20 (eventDBService.findByUserId)\n *\n * Strategy: Dexie-first write, Firebase background sync\n */\n\n// Query Keys\nexport const eventKeys = {\n  all: [\"events\"] as const,\n  lists: () => [...eventKeys.all, \"list\"] as const,\n  list: (userId: string, filters?: EventFilters) =>\n    [...eventKeys.lists(), userId, filters] as const,\n  infinite: (userId: string, filters?: EventFilters) =>\n    [...eventKeys.all, \"infinite\", userId, filters] as const,\n  detail: (eventId: string) => [...eventKeys.all, \"detail\", eventId] as const,\n  recent: (userId: string, limit?: number) =>\n    [...eventKeys.all, \"recent\", userId, limit] as const,\n} as const;\n\n// Types\ninterface EventFilters {\n  type?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n}\n\ninterface CreateEventData {\n  type: string;\n  details: Record<string, any>;\n  timestamp?: Date;\n}\n\ninterface UpdateEventData {\n  type?: string;\n  details?: Record<string, any>;\n  timestamp?: Date;\n}\n\n/**\n * Get event history for a user with filters\n * Fixes: LogEventPage.tsx:20 (eventDBService.findByUserId)\n */\nexport function useEventHistory(userId: string, filters?: EventFilters) {\n  return useQuery({\n    queryKey: eventKeys.list(userId, filters),\n    queryFn: async (): Promise<Event[]> => {\n      logger.info(\"Fetching event history\", { userId, filters });\n\n      try {\n        const events = await eventDBService.findByUserId(userId);\n\n        // Apply filters\n        let filteredEvents = events;\n\n        if (filters?.type) {\n          filteredEvents = filteredEvents.filter(\n            (event) => event.type === filters.type,\n          );\n        }\n\n        if (filters?.startDate) {\n          filteredEvents = filteredEvents.filter(\n            (event) => new Date(event.timestamp) >= filters.startDate!,\n          );\n        }\n\n        if (filters?.endDate) {\n          filteredEvents = filteredEvents.filter(\n            (event) => new Date(event.timestamp) <= filters.endDate!,\n          );\n        }\n\n        // Sort by timestamp (newest first)\n        filteredEvents.sort(\n          (a, b) =>\n            new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\n        );\n\n        if (filters?.limit) {\n          filteredEvents = filteredEvents.slice(0, filters.limit);\n        }\n\n        logger.info(\"Event history retrieved\", {\n          userId,\n          totalEvents: events.length,\n          filteredEvents: filteredEvents.length,\n        });\n\n        return filteredEvents;\n      } catch (error) {\n        logger.error(\"Failed to fetch event history\", error, { userId });\n        throw error;\n      }\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes - warm data\n    gcTime: 30 * 60 * 1000, // 30 minutes garbage collection\n    enabled: !!userId,\n  });\n}\n\n/**\n * Infinite query for event history with pagination\n * Useful for long event lists with infinite scroll\n */\nexport function useInfiniteEventHistory(\n  userId: string,\n  filters?: EventFilters,\n  pageSize = 20,\n) {\n  return useInfiniteQuery({\n    queryKey: eventKeys.infinite(userId, filters),\n    queryFn: async ({\n      pageParam = 0,\n    }): Promise<{ events: Event[]; nextPage?: number }> => {\n      logger.info(\"Fetching infinite event page\", {\n        userId,\n        pageParam,\n        pageSize,\n      });\n\n      const events = await eventDBService.findByUserId(userId);\n\n      // Apply filters and sorting (same as useEventHistory)\n      let filteredEvents = events;\n\n      if (filters?.type) {\n        filteredEvents = filteredEvents.filter(\n          (event) => event.type === filters.type,\n        );\n      }\n\n      if (filters?.startDate) {\n        filteredEvents = filteredEvents.filter(\n          (event) => new Date(event.timestamp) >= filters.startDate!,\n        );\n      }\n\n      if (filters?.endDate) {\n        filteredEvents = filteredEvents.filter(\n          (event) => new Date(event.timestamp) <= filters.endDate!,\n        );\n      }\n\n      filteredEvents.sort(\n        (a, b) =>\n          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\n      );\n\n      // Pagination\n      const start = pageParam * pageSize;\n      const end = start + pageSize;\n      const pageEvents = filteredEvents.slice(start, end);\n\n      const hasMore = end < filteredEvents.length;\n\n      return {\n        events: pageEvents,\n        nextPage: hasMore ? pageParam + 1 : undefined,\n      };\n    },\n    initialPageParam: 0,\n    getNextPageParam: (lastPage) => lastPage.nextPage,\n    staleTime: 5 * 60 * 1000,\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get recent events for quick overview\n * Useful for dashboard summaries\n */\nexport function useRecentEvents(userId: string, limit = 10) {\n  return useQuery({\n    queryKey: eventKeys.recent(userId, limit),\n    queryFn: async (): Promise<Event[]> => {\n      logger.info(\"Fetching recent events\", { userId, limit });\n\n      const events = await eventDBService.findByUserId(userId);\n\n      // Sort by timestamp and take most recent\n      const recentEvents = events\n        .sort(\n          (a, b) =>\n            new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),\n        )\n        .slice(0, limit);\n\n      return recentEvents;\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes - recent data changes frequently\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get single event by ID\n */\nexport function useEvent(eventId: string) {\n  return useQuery({\n    queryKey: eventKeys.detail(eventId),\n    queryFn: async (): Promise<Event | null> => {\n      logger.info(\"Fetching event detail\", { eventId });\n      return await eventDBService.findById(eventId);\n    },\n    staleTime: 10 * 60 * 1000, // 10 minutes - historical data is stable\n    enabled: !!eventId,\n  });\n}\n\n/**\n * Create new event\n * Fixes: LogEventForm.tsx:92-93 (commented eventDBService.create)\n * Strategy: Dexie-first write, Firebase background sync\n */\nexport function useCreateEvent() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      eventData,\n    }: {\n      userId: string;\n      eventData: CreateEventData;\n    }): Promise<Event> => {\n      logger.info(\"Creating new event\", { userId, eventType: eventData.type });\n\n      // Generate event ID\n      const eventId = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      const newEvent: Event = {\n        id: eventId,\n        userId,\n        type: eventData.type,\n        timestamp: eventData.timestamp || new Date(),\n        details: eventData.details,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      // Dexie-first write for immediate UI response\n      await eventDBService.create(newEvent);\n\n      logger.info(\"Event created successfully\", {\n        eventId,\n        userId,\n        type: eventData.type,\n      });\n\n      return newEvent;\n    },\n    onSuccess: (newEvent, { userId }) => {\n      logger.info(\"Event creation successful\", {\n        eventId: newEvent.id,\n        userId,\n      });\n\n      // Invalidate relevant queries to trigger refetch\n      queryClient.invalidateQueries({ queryKey: eventKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: eventKeys.recent(userId) });\n      queryClient.invalidateQueries({ queryKey: eventKeys.infinite(userId) });\n\n      // Optimistically add to cache if we have existing data\n      queryClient.setQueriesData(\n        { queryKey: eventKeys.list(userId) },\n        (oldData: Event[] | undefined) => {\n          if (!oldData) return undefined;\n          return [newEvent, ...oldData];\n        },\n      );\n    },\n    onError: (error, { userId, eventData }) => {\n      logger.error(\"Event creation failed\", error, {\n        userId,\n        eventType: eventData.type,\n      });\n    },\n  });\n}\n\n/**\n * Update existing event\n */\nexport function useUpdateEvent() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      eventId,\n      userId,\n      updates,\n    }: {\n      eventId: string;\n      userId: string;\n      updates: UpdateEventData;\n    }): Promise<Event> => {\n      logger.info(\"Updating event\", { eventId, userId });\n\n      const existingEvent = await eventDBService.findById(eventId);\n      if (!existingEvent) {\n        throw new Error(`Event not found: ${eventId}`);\n      }\n\n      const updatedEvent: Event = {\n        ...existingEvent,\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      await eventDBService.update(eventId, updatedEvent);\n\n      logger.info(\"Event updated successfully\", { eventId, userId });\n\n      return updatedEvent;\n    },\n    onSuccess: (updatedEvent, { userId, eventId }) => {\n      logger.info(\"Event update successful\", { eventId, userId });\n\n      // Update detail cache\n      queryClient.setQueryData(eventKeys.detail(eventId), updatedEvent);\n\n      // Invalidate list queries to reflect changes\n      queryClient.invalidateQueries({ queryKey: eventKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: eventKeys.recent(userId) });\n    },\n    onError: (error, { eventId, userId }) => {\n      logger.error(\"Event update failed\", error, { eventId, userId });\n    },\n  });\n}\n\n/**\n * Delete event\n */\nexport function useDeleteEvent() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      eventId,\n      userId,\n    }: {\n      eventId: string;\n      userId: string;\n    }): Promise<void> => {\n      logger.info(\"Deleting event\", { eventId, userId });\n\n      await eventDBService.delete(eventId);\n\n      logger.info(\"Event deleted successfully\", { eventId, userId });\n    },\n    onSuccess: (_, { eventId, userId }) => {\n      logger.info(\"Event deletion successful\", { eventId, userId });\n\n      // Remove from detail cache\n      queryClient.removeQueries({ queryKey: eventKeys.detail(eventId) });\n\n      // Invalidate list queries\n      queryClient.invalidateQueries({ queryKey: eventKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: eventKeys.recent(userId) });\n      queryClient.invalidateQueries({ queryKey: eventKeys.infinite(userId) });\n\n      // Optimistically remove from cached lists\n      queryClient.setQueriesData(\n        { queryKey: eventKeys.list(userId) },\n        (oldData: Event[] | undefined) => {\n          if (!oldData) return undefined;\n          return oldData.filter((event) => event.id !== eventId);\n        },\n      );\n    },\n    onError: (error, { eventId, userId }) => {\n      logger.error(\"Event deletion failed\", error, { eventId, userId });\n    },\n  });\n}\n\n/**\n * Get event statistics for analytics\n */\nexport function useEventStats(\n  userId: string,\n  timeRange?: { start: Date; end: Date },\n) {\n  return useQuery({\n    queryKey: [...eventKeys.all, \"stats\", userId, timeRange],\n    queryFn: async () => {\n      logger.info(\"Calculating event statistics\", { userId, timeRange });\n\n      const events = await eventDBService.findByUserId(userId);\n\n      let filteredEvents = events;\n      if (timeRange) {\n        filteredEvents = events.filter((event) => {\n          const eventDate = new Date(event.timestamp);\n          return eventDate >= timeRange.start && eventDate <= timeRange.end;\n        });\n      }\n\n      // Calculate statistics\n      const stats = {\n        totalEvents: filteredEvents.length,\n        eventsByType: {} as Record<string, number>,\n        eventsPerDay: {} as Record<string, number>,\n        mostRecentEvent:\n          filteredEvents.length > 0\n            ? filteredEvents.reduce((latest, event) =>\n                new Date(event.timestamp) > new Date(latest.timestamp)\n                  ? event\n                  : latest,\n              )\n            : null,\n      };\n\n      // Count events by type\n      filteredEvents.forEach((event) => {\n        stats.eventsByType[event.type] =\n          (stats.eventsByType[event.type] || 0) + 1;\n\n        const dateKey = new Date(event.timestamp).toDateString();\n        stats.eventsPerDay[dateKey] = (stats.eventsPerDay[dateKey] || 0) + 1;\n      });\n\n      return stats;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    enabled: !!userId,\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useEventsQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useEventMutations' has too many lines (165). Maximum allowed is 75.","line":89,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":286,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2811,2814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2811,2814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6756,6759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6756,6759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Events TanStack Query Hooks\n * Manages event log data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { eventDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBEvent, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useEventsQuery\");\n\n/**\n * Query for getting all events for a user\n */\nexport function useEventsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"events\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const events = await eventDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(userId).catch((error) => {\n          logger.warn(\"Background events sync failed\", { error });\n        });\n      }\n\n      return events;\n    },\n    ...cacheConfig.events, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting recent events (last 30 days)\n */\nexport function useRecentEventsQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"recent\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents\n        .filter((event) => event.timestamp >= thirtyDaysAgo)\n        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Query for getting events by type\n */\nexport function useEventsByTypeQuery(\n  userId: string | undefined,\n  eventType: EventType,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"events\", \"type\", userId, eventType],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allEvents = await eventDBService.findByUserId(userId);\n      return allEvents.filter((event) => event.type === eventType);\n    },\n    ...cacheConfig.events,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for event operations\n */\nexport function useEventMutations() {\n  const queryClient = useQueryClient();\n\n  const createEvent = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      type: EventType;\n      timestamp: Date;\n      notes?: string;\n      duration?: number;\n      isPrivate?: boolean;\n      sessionId?: string;\n      metadata?: Record<string, any>;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const event = await eventDBService.createEvent(params);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event creation sync failed\", { error });\n        });\n      }\n\n      return event;\n    },\n    onSuccess: (data, variables) => {\n      // Add event to the cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return [data];\n          return [data, ...oldEvents].sort(\n            (a, b) => b.timestamp.getTime() - a.timestamp.getTime(),\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create event\", { error });\n    },\n  });\n\n  const updateEvent = useMutation({\n    mutationFn: async (params: {\n      eventId: string;\n      userId: string;\n      updates: Partial<DBEvent>;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedEvent = await eventDBService.updateEvent(\n        params.eventId,\n        params.updates,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event update sync failed\", { error });\n        });\n      }\n\n      return updatedEvent;\n    },\n    onSuccess: (data, variables) => {\n      // Update event in cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.map((event) =>\n            event.id === variables.eventId ? { ...event, ...data } : event,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update event\", { error });\n    },\n  });\n\n  const deleteEvent = useMutation({\n    mutationFn: async (params: { eventId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await eventDBService.deleteEvent(params.eventId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Event deletion sync failed\", { error });\n        });\n      }\n\n      return params.eventId;\n    },\n    onSuccess: (eventId, variables) => {\n      // Remove event from cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return oldEvents;\n          return oldEvents.filter((event) => event.id !== eventId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete event\", { error });\n    },\n  });\n\n  const bulkCreateEvents = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      events: Array<{\n        type: EventType;\n        timestamp: Date;\n        notes?: string;\n        duration?: number;\n        isPrivate?: boolean;\n        sessionId?: string;\n        metadata?: Record<string, any>;\n      }>;\n    }) => {\n      // 1. Create all events in local Dexie\n      const createdEvents = await Promise.all(\n        params.events.map((eventData) =>\n          eventDBService.createEvent({\n            ...eventData,\n            userId: params.userId,\n          }),\n        ),\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserEvents(params.userId).catch((error) => {\n          logger.warn(\"Bulk event creation sync failed\", { error });\n        });\n      }\n\n      return createdEvents;\n    },\n    onSuccess: (data, variables) => {\n      // Add all events to cache\n      queryClient.setQueryData(\n        [\"events\", \"user\", variables.userId],\n        (oldEvents: DBEvent[] | undefined) => {\n          if (!oldEvents) return data;\n          return [...data, ...oldEvents].sort(\n            (a, b) => b.timestamp.getTime() - a.timestamp.getTime(),\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"recent\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"events\", \"type\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to bulk create events\", { error });\n    },\n  });\n\n  return {\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    bulkCreateEvents,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useOfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSessionQuery.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBSession' is defined but never used.","line":9,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":24},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSessionMutations' has too many lines (104). Maximum allowed is 75.","line":70,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":202,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session TanStack Query Hooks\n * Manages chastity session data with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { sessionDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBSession } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSessionQuery\");\n\n/**\n * Query for getting current active session\n */\nexport function useCurrentSession(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"session\", \"current\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      const session = await sessionDBService.getCurrentSession(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    ...cacheConfig.currentSession, // Apply specific cache settings\n    enabled: !!userId, // The query will not run until the userId is available\n  });\n}\n\n/**\n * Query for getting session history\n */\nexport function useSessionHistory(userId: string | undefined, enabled = true) {\n  return useQuery({\n    queryKey: [\"sessions\", \"history\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const sessions = await sessionDBService.findByUserId(userId);\n\n      // Trigger background sync if online\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(userId).catch((error) => {\n          logger.warn(\"Background session history sync failed:\", { error });\n        });\n      }\n\n      return sessions.sort(\n        (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n      );\n    },\n    ...cacheConfig.sessionHistory,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for session operations\n */\nexport function useSessionMutations() {\n  const queryClient = useQueryClient();\n\n  const startSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      startTime?: Date;\n      requiredDuration?: number;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const session = await sessionDBService.startSession({\n        userId: params.userId,\n        startTime: params.startTime || new Date(),\n        requiredDuration: params.requiredDuration,\n      });\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session start sync failed:\", { error });\n        });\n      }\n\n      return session;\n    },\n    onSuccess: (data, variables) => {\n      // Update the current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n\n      // Invalidate session history to include new session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to start session:\", { error });\n    },\n  });\n\n  const endSession = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      endTime?: Date;\n      reason?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.endSession(\n        params.userId,\n        params.endTime || new Date(),\n        params.reason,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session end sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Clear current session since it's ended\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], null);\n\n      // Invalidate session history to reflect ended session\n      queryClient.invalidateQueries({\n        queryKey: [\"sessions\", \"history\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to end session:\", { error });\n    },\n  });\n\n  const pauseSession = useMutation({\n    mutationFn: async (params: { userId: string; reason?: string }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.pauseSession(\n        params.userId,\n        params.reason,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session pause sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to pause session:\", { error });\n    },\n  });\n\n  const resumeSession = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Update local Dexie immediately\n      const updatedSession = await sessionDBService.resumeSession(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSessions(params.userId).catch((error) => {\n          logger.warn(\"Session resume sync failed:\", { error });\n        });\n      }\n\n      return updatedSession;\n    },\n    onSuccess: (data, variables) => {\n      // Update current session cache\n      queryClient.setQueryData([\"session\", \"current\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to resume session:\", { error });\n    },\n  });\n\n  return {\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSettings.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'secret' is defined but never used. Allowed unused args must match /^_/u.","line":251,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":251,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentPassword' is defined but never used. Allowed unused args must match /^_/u.","line":301,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":301,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newPassword' is defined but never used. Allowed unused args must match /^_/u.","line":302,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":302,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'importData' is defined but never used. Allowed unused args must match /^_/u.","line":412,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":412,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { settingsDBService } from \"../../services/database/SettingsDBService\";\nimport { UserSettings } from \"../../types/database\";\nimport { logger } from \"../../utils/logging\";\n\n// Types for data import operations\ninterface ImportUserData {\n  settings?: Partial<UserSettings>;\n  sessions?: unknown[];\n  events?: unknown[];\n  tasks?: unknown[];\n  goals?: unknown[];\n  metadata?: {\n    version: string;\n    exportedAt: string;\n    format: \"json\" | \"csv\" | \"xlsx\";\n  };\n}\n\n// Query Keys\nexport const settingsKeys = {\n  all: [\"settings\"] as const,\n  user: (userId: string) => [...settingsKeys.all, \"user\", userId] as const,\n  section: (userId: string, section: string) =>\n    [...settingsKeys.user(userId), \"section\", section] as const,\n} as const;\n\n// Settings section types\ntype SettingsSection =\n  | \"account\"\n  | \"display\"\n  | \"profile\"\n  | \"goals\"\n  | \"privacy\"\n  | \"data\"\n  | \"security\";\n\ninterface UpdateSettingsData {\n  // Account settings\n  displayName?: string;\n  email?: string;\n  timezone?: string;\n  language?: string;\n\n  // Display settings\n  theme?: \"light\" | \"dark\" | \"system\";\n  fontSize?: \"small\" | \"medium\" | \"large\";\n  animations?: boolean;\n  notifications?: boolean;\n\n  // Profile settings\n  publicProfile?: boolean;\n  profileVisibility?: \"private\" | \"keyholder\" | \"public\";\n  showStats?: boolean;\n  showAchievements?: boolean;\n\n  // Goal settings\n  defaultGoalDuration?: number;\n  allowKeyholderOverride?: boolean;\n  goalReminders?: boolean;\n  progressSharing?: \"private\" | \"keyholder\" | \"public\";\n\n  // Privacy settings\n  dataCollection?: boolean;\n  analytics?: boolean;\n  crashReporting?: boolean;\n  locationTracking?: boolean;\n\n  // Security settings\n  twoFactorEnabled?: boolean;\n  sessionTimeout?: number;\n  requirePasswordForSensitive?: boolean;\n  emergencyContacts?: string[];\n\n  // Data settings\n  autoBackup?: boolean;\n  backupFrequency?: \"daily\" | \"weekly\" | \"monthly\";\n  dataRetention?: number; // days\n  exportFormat?: \"json\" | \"csv\" | \"pdf\";\n\n  // Advanced settings\n  advancedLogging?: boolean;\n  betaFeatures?: boolean;\n  developmentMode?: boolean;\n\n  // Keyholder settings\n  keyholderLinked?: boolean;\n  keyholderUid?: string;\n  keyholderPermissions?: {\n    viewTasks?: boolean;\n    assignTasks?: boolean;\n    viewSessions?: boolean;\n    controlSessions?: boolean;\n    viewEvents?: boolean;\n    viewSettings?: boolean;\n    modifySettings?: boolean;\n  };\n}\n\ninterface ExportDataOptions {\n  format: \"json\" | \"csv\" | \"pdf\";\n  sections: string[];\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  includeMetadata?: boolean;\n}\n\n/**\n * Get user settings\n * Fixes: SettingsPage.tsx:696 (settingsDBService.findByUserId)\n * Impact: Entire 780-line settings page becomes functional\n */\nexport function useUserSettings(userId: string) {\n  return useQuery({\n    queryKey: settingsKeys.user(userId),\n    queryFn: async (): Promise<UserSettings | null> => {\n      logger.info(\"Fetching user settings\", { userId });\n\n      try {\n        const settings = await settingsDBService.findByUserId(userId);\n\n        if (!settings) {\n          logger.info(\"No settings found for user, will create defaults\", {\n            userId,\n          });\n          return null;\n        }\n\n        logger.info(\"User settings retrieved successfully\", {\n          userId,\n          hasSettings: !!settings,\n          sectionsCount: Object.keys(settings).length,\n        });\n\n        return settings;\n      } catch (error) {\n        logger.error(\"Failed to fetch user settings\", error, { userId });\n        throw error;\n      }\n    },\n    staleTime: 30 * 60 * 1000, // 30 minutes - cold data that changes infrequently\n    gcTime: 60 * 60 * 1000, // 1 hour garbage collection\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get settings for a specific section (for performance)\n * Useful when only one settings section is being edited\n */\nexport function useSettingsSection(userId: string, section: SettingsSection) {\n  return useQuery({\n    queryKey: settingsKeys.section(userId, section),\n    queryFn: async () => {\n      logger.info(\"Fetching settings section\", { userId, section });\n\n      const settings = await settingsDBService.findByUserId(userId);\n      if (!settings) return null;\n\n      // Extract just the requested section\n      const sectionData = extractSettingsSection(settings, section);\n\n      return sectionData;\n    },\n    staleTime: 30 * 60 * 1000,\n    enabled: !!userId && !!section,\n  });\n}\n\n/**\n * Update user settings (all sections)\n * Fixes: SettingsPage.tsx - Save all settings forms functionality\n */\nexport function useUpdateSettings() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      updates,\n    }: {\n      userId: string;\n      updates: UpdateSettingsData;\n    }): Promise<UserSettings> => {\n      logger.info(\"Updating user settings\", {\n        userId,\n        updateKeys: Object.keys(updates),\n      });\n\n      try {\n        // Get existing settings or create defaults\n        let existingSettings = await settingsDBService.findByUserId(userId);\n\n        if (!existingSettings) {\n          // Create default settings if none exist\n          existingSettings = createDefaultSettings(userId);\n          logger.info(\"Created default settings for user\", { userId });\n        }\n\n        // Merge updates with existing settings\n        const updatedSettings: UserSettings = {\n          ...existingSettings,\n          ...updates,\n          updatedAt: new Date(),\n        };\n\n        // Save to Dexie (immediate local update)\n        await settingsDBService.update(userId, updatedSettings);\n\n        logger.info(\"Settings updated successfully\", {\n          userId,\n          updatedFields: Object.keys(updates).length,\n        });\n\n        return updatedSettings;\n      } catch (error) {\n        logger.error(\"Failed to update settings\", error, { userId });\n        throw error;\n      }\n    },\n    onSuccess: (updatedSettings, { userId }) => {\n      logger.info(\"Settings update successful\", { userId });\n\n      // Update cache with new settings\n      queryClient.setQueryData(settingsKeys.user(userId), updatedSettings);\n\n      // Invalidate section caches to refresh them\n      queryClient.invalidateQueries({\n        queryKey: [...settingsKeys.user(userId), \"section\"],\n      });\n    },\n    onError: (error, { userId }) => {\n      logger.error(\"Settings update failed\", error, { userId });\n    },\n  });\n}\n\n/**\n * Account operations (2FA, password, etc.)\n * Fixes: SettingsPage.tsx account section functionality\n */\nexport function useAccountMutations() {\n  const queryClient = useQueryClient();\n\n  return {\n    enable2FA: useMutation({\n      mutationFn: async ({\n        userId,\n        secret,\n      }: {\n        userId: string;\n        secret: string;\n      }) => {\n        logger.info(\"Enabling 2FA\", { userId });\n\n        // This would integrate with auth service for 2FA setup\n        // For now, just update settings\n        const settings = await settingsDBService.findByUserId(userId);\n        if (settings) {\n          await settingsDBService.update(userId, {\n            ...settings,\n            twoFactorEnabled: true,\n            updatedAt: new Date(),\n          });\n        }\n\n        return { success: true };\n      },\n      onSuccess: (_, { userId }) => {\n        queryClient.invalidateQueries({ queryKey: settingsKeys.user(userId) });\n        logger.info(\"2FA enabled successfully\");\n      },\n    }),\n\n    disable2FA: useMutation({\n      mutationFn: async ({ userId }: { userId: string }) => {\n        logger.info(\"Disabling 2FA\", { userId });\n\n        const settings = await settingsDBService.findByUserId(userId);\n        if (settings) {\n          await settingsDBService.update(userId, {\n            ...settings,\n            twoFactorEnabled: false,\n            updatedAt: new Date(),\n          });\n        }\n\n        return { success: true };\n      },\n      onSuccess: (_, { userId }) => {\n        queryClient.invalidateQueries({ queryKey: settingsKeys.user(userId) });\n        logger.info(\"2FA disabled successfully\");\n      },\n    }),\n\n    updatePassword: useMutation({\n      mutationFn: async ({\n        userId,\n        currentPassword,\n        newPassword,\n      }: {\n        userId: string;\n        currentPassword: string;\n        newPassword: string;\n      }) => {\n        logger.info(\"Updating password\", { userId });\n\n        // This would integrate with auth service for password updates\n        // Implementation would involve Firebase auth password update\n\n        return { success: true };\n      },\n      onSuccess: () => {\n        logger.info(\"Password updated successfully\");\n      },\n    }),\n  };\n}\n\n/**\n * Privacy and data management mutations\n * Fixes: SettingsPage.tsx privacy and data sections\n */\nexport function usePrivacyMutations() {\n  return {\n    updatePrivacySettings: useMutation({\n      mutationFn: async ({\n        userId,\n        privacySettings,\n      }: {\n        userId: string;\n        privacySettings: {\n          dataCollection?: boolean;\n          analytics?: boolean;\n          crashReporting?: boolean;\n          locationTracking?: boolean;\n        };\n      }) => {\n        logger.info(\"Updating privacy settings\", {\n          userId,\n          settings: privacySettings,\n        });\n\n        const settings = await settingsDBService.findByUserId(userId);\n        if (settings) {\n          await settingsDBService.update(userId, {\n            ...settings,\n            ...privacySettings,\n            updatedAt: new Date(),\n          });\n        }\n\n        return { success: true };\n      },\n    }),\n  };\n}\n\n/**\n * Data export functionality\n * Fixes: SettingsPage.tsx data export section\n */\nexport function useDataExport() {\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      options,\n    }: {\n      userId: string;\n      options: ExportDataOptions;\n    }) => {\n      logger.info(\"Exporting user data\", { userId, format: options.format });\n\n      try {\n        // This would integrate with data export service\n        // For now, return a mock export URL\n\n        const exportData = {\n          userId,\n          exportedAt: new Date(),\n          format: options.format,\n          sections: options.sections,\n          downloadUrl: `https://api.chastityos.com/export/${userId}/${Date.now()}.${options.format}`,\n        };\n\n        logger.info(\"Data export completed\", {\n          userId,\n          format: options.format,\n        });\n\n        return exportData;\n      } catch (error) {\n        logger.error(\"Data export failed\", error, { userId });\n        throw error;\n      }\n    },\n  });\n}\n\n/**\n * Data import functionality\n * Fixes: SettingsPage.tsx data import section\n */\nexport function useDataImport() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      importData,\n    }: {\n      userId: string;\n      importData: ImportUserData;\n    }) => {\n      logger.info(\"Importing user data\", { userId });\n\n      try {\n        // This would integrate with data import service\n        // Process the import data and update relevant services\n\n        logger.info(\"Data import completed\", { userId });\n\n        return { success: true, importedRecords: 0 };\n      } catch (error) {\n        logger.error(\"Data import failed\", error, { userId });\n        throw error;\n      }\n    },\n    onSuccess: (_, { userId }) => {\n      // Invalidate all user data caches after import\n      queryClient.invalidateQueries({ queryKey: settingsKeys.user(userId) });\n      queryClient.invalidateQueries({ queryKey: [\"events\", \"list\", userId] });\n      queryClient.invalidateQueries({ queryKey: [\"tasks\", \"list\", userId] });\n\n      logger.info(\"Cache invalidated after data import\");\n    },\n  });\n}\n\n/**\n * Reset all user data\n * Fixes: SettingsPage.tsx data reset functionality\n */\nexport function useResetAllData() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({ userId }: { userId: string }) => {\n      logger.info(\"Resetting all user data\", { userId });\n\n      try {\n        // This would integrate with all services to reset data\n        // Reset settings to defaults\n        const defaultSettings = createDefaultSettings(userId);\n        await settingsDBService.update(userId, defaultSettings);\n\n        logger.info(\"All user data reset completed\", { userId });\n\n        return { success: true };\n      } catch (error) {\n        logger.error(\"Data reset failed\", error, { userId });\n        throw error;\n      }\n    },\n    onSuccess: (_, { userId }) => {\n      // Clear all user data from cache\n      queryClient.removeQueries({ queryKey: [\"events\"] });\n      queryClient.removeQueries({ queryKey: [\"tasks\"] });\n      queryClient.removeQueries({ queryKey: [\"sessions\"] });\n      queryClient.invalidateQueries({ queryKey: settingsKeys.user(userId) });\n\n      logger.info(\"All user data cache cleared after reset\");\n    },\n  });\n}\n\n// Helper functions\n\nfunction createDefaultSettings(userId: string): UserSettings {\n  return {\n    id: userId,\n    userId,\n    // Account defaults\n    displayName: \"\",\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: \"en\",\n\n    // Display defaults\n    theme: \"system\",\n    fontSize: \"medium\",\n    animations: true,\n    notifications: true,\n\n    // Profile defaults\n    publicProfile: false,\n    profileVisibility: \"private\",\n    showStats: true,\n    showAchievements: true,\n\n    // Goal defaults\n    defaultGoalDuration: 7 * 24 * 60 * 60 * 1000, // 7 days in milliseconds\n    allowKeyholderOverride: false,\n    goalReminders: true,\n    progressSharing: \"private\",\n\n    // Privacy defaults\n    dataCollection: true,\n    analytics: false,\n    crashReporting: true,\n    locationTracking: false,\n\n    // Security defaults\n    twoFactorEnabled: false,\n    sessionTimeout: 60 * 60 * 1000, // 1 hour\n    requirePasswordForSensitive: true,\n    emergencyContacts: [],\n\n    // Data defaults\n    autoBackup: true,\n    backupFrequency: \"weekly\",\n    dataRetention: 365, // 1 year\n    exportFormat: \"json\",\n\n    // Advanced defaults\n    advancedLogging: false,\n    betaFeatures: false,\n    developmentMode: false,\n\n    // Keyholder defaults\n    keyholderLinked: false,\n    keyholderPermissions: {\n      viewTasks: false,\n      assignTasks: false,\n      viewSessions: false,\n      controlSessions: false,\n      viewEvents: false,\n      viewSettings: false,\n      modifySettings: false,\n    },\n\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n}\n\nfunction extractSettingsSection(\n  settings: UserSettings,\n  section: SettingsSection,\n) {\n  switch (section) {\n    case \"account\":\n      return {\n        displayName: settings.displayName,\n        email: settings.email,\n        timezone: settings.timezone,\n        language: settings.language,\n      };\n    case \"display\":\n      return {\n        theme: settings.theme,\n        fontSize: settings.fontSize,\n        animations: settings.animations,\n        notifications: settings.notifications,\n      };\n    case \"profile\":\n      return {\n        publicProfile: settings.publicProfile,\n        profileVisibility: settings.profileVisibility,\n        showStats: settings.showStats,\n        showAchievements: settings.showAchievements,\n      };\n    case \"goals\":\n      return {\n        defaultGoalDuration: settings.defaultGoalDuration,\n        allowKeyholderOverride: settings.allowKeyholderOverride,\n        goalReminders: settings.goalReminders,\n        progressSharing: settings.progressSharing,\n      };\n    case \"privacy\":\n      return {\n        dataCollection: settings.dataCollection,\n        analytics: settings.analytics,\n        crashReporting: settings.crashReporting,\n        locationTracking: settings.locationTracking,\n      };\n    case \"data\":\n      return {\n        autoBackup: settings.autoBackup,\n        backupFrequency: settings.backupFrequency,\n        dataRetention: settings.dataRetention,\n        exportFormat: settings.exportFormat,\n      };\n    case \"security\":\n      return {\n        twoFactorEnabled: settings.twoFactorEnabled,\n        sessionTimeout: settings.sessionTimeout,\n        requirePasswordForSensitive: settings.requirePasswordForSensitive,\n        emergencyContacts: settings.emergencyContacts,\n      };\n    default:\n      return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useSettingsQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useSettingsMutations' has too many lines (91). Maximum allowed is 75.","line":48,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":163,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Settings TanStack Query Hooks\n * Manages user settings with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { settingsDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBSettings } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSettingsQuery\");\n\n/**\n * Query for getting user settings\n */\nexport function useSettingsQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"settings\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return null;\n\n      // Always read from local Dexie first for instant response\n      let settings = await settingsDBService.getUserSettings(userId);\n\n      // If no settings exist, create default settings\n      if (!settings) {\n        settings = await settingsDBService.createDefaultSettings(userId);\n      }\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(userId).catch((error) => {\n          logger.warn(\"Background settings sync failed:\", { error });\n        });\n      }\n\n      return settings;\n    },\n    ...cacheConfig.userSettings, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Mutations for settings operations\n */\nexport function useSettingsMutations() {\n  const queryClient = useQueryClient();\n\n  const updateSettings = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      settings: Partial<DBSettings>;\n    }) => {\n      // 1. Update local Dexie immediately for optimistic update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        params.settings,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache immediately\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update settings:\", { error });\n\n      // Invalidate cache to refetch from server in case of error\n      queryClient.invalidateQueries({\n        queryKey: [\"settings\", \"user\"],\n      });\n    },\n  });\n\n  const resetSettings = useMutation({\n    mutationFn: async (params: { userId: string }) => {\n      // 1. Reset to defaults in local Dexie\n      const defaultSettings = await settingsDBService.createDefaultSettings(\n        params.userId,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Settings reset sync failed:\", { error });\n        });\n      }\n\n      return defaultSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update the settings cache with default values\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n    onError: (error) => {\n      logger.error(\"Failed to reset settings:\", { error });\n    },\n  });\n\n  const updateTheme = useMutation({\n    mutationFn: async (params: { userId: string; theme: \"light\" | \"dark\" }) => {\n      // Quick theme update\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { theme: params.theme },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Theme update sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      // Update settings cache\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  const updateEventDisplayMode = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      eventDisplayMode: \"kinky\" | \"vanilla\";\n    }) => {\n      const updatedSettings = await settingsDBService.updateSettings(\n        params.userId,\n        { eventDisplayMode: params.eventDisplayMode },\n      );\n\n      // Background sync\n      if (navigator.onLine) {\n        firebaseSync.syncUserSettings(params.userId).catch((error) => {\n          logger.warn(\"Event display mode sync failed:\", { error });\n        });\n      }\n\n      return updatedSettings;\n    },\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData([\"settings\", \"user\", variables.userId], data);\n    },\n  });\n\n  return {\n    updateSettings,\n    resetSettings,\n    updateTheme,\n    updateEventDisplayMode,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useTaskQuery.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useTaskMutations' has too many lines (138). Maximum allowed is 75.","line":65,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":233,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task TanStack Query Hooks\n * Manages server state for tasks with Dexie as backend\n */\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"@/services/database\";\nimport { cacheConfig } from \"@/services/cache-config\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { DBTask, TaskStatus } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useTaskQuery\");\n\n/**\n * Query for getting all tasks for a user\n */\nexport function useTasksQuery(userId: string | undefined) {\n  return useQuery({\n    queryKey: [\"tasks\", \"user\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      // Always read from local Dexie first for instant response\n      const tasks = await taskDBService.findByUserId(userId);\n\n      // Trigger background sync if online to ensure data freshness\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(userId).catch((error) => {\n          logger.warn(\"Background task sync failed\", { error });\n        });\n      }\n\n      return tasks;\n    },\n    ...cacheConfig.tasks, // Apply specific cache settings\n    enabled: !!userId, // Only run when userId is available\n  });\n}\n\n/**\n * Query for getting pending tasks that need keyholder attention\n */\nexport function usePendingTasksQuery(\n  userId: string | undefined,\n  enabled = true,\n) {\n  return useQuery({\n    queryKey: [\"tasks\", \"pending\", userId],\n    queryFn: async () => {\n      if (!userId) return [];\n\n      const allTasks = await taskDBService.findByUserId(userId);\n      return allTasks.filter((task) =>\n        [\"pending\", \"submitted\"].includes(task.status),\n      );\n    },\n    ...cacheConfig.tasks,\n    enabled: !!userId && enabled,\n  });\n}\n\n/**\n * Mutations for task operations\n */\nexport function useTaskMutations() {\n  const queryClient = useQueryClient();\n\n  const createTask = useMutation({\n    mutationFn: async (params: {\n      userId: string;\n      title: string;\n      description?: string;\n      deadline?: Date;\n    }) => {\n      // 1. Write to local Dexie immediately for optimistic update\n      const task = await taskDBService.createTask({\n        ...params,\n        status: \"pending\" as TaskStatus,\n      });\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task creation sync failed\", { error });\n        });\n      }\n\n      return task;\n    },\n    onSuccess: (data, variables) => {\n      // Invalidate and refetch tasks queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"user\", variables.userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to create task\", { error });\n    },\n  });\n\n  const updateTaskStatus = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      feedback?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        params.status,\n        params.feedback,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task status update sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update specific task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId ? { ...task, ...data } : task,\n          );\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to update task status\", { error });\n    },\n  });\n\n  const deleteTask = useMutation({\n    mutationFn: async (params: { taskId: string; userId: string }) => {\n      // 1. Delete from local Dexie immediately\n      await taskDBService.deleteTask(params.taskId);\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task deletion sync failed\", { error });\n        });\n      }\n\n      return params.taskId;\n    },\n    onSuccess: (taskId, variables) => {\n      // Remove task from cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.filter((task) => task.id !== taskId);\n        },\n      );\n\n      // Invalidate related queries\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to delete task\", { error });\n    },\n  });\n\n  const submitTaskForReview = useMutation({\n    mutationFn: async (params: {\n      taskId: string;\n      userId: string;\n      note?: string;\n    }) => {\n      // 1. Update local Dexie immediately\n      const updatedTask = await taskDBService.updateTaskStatus(\n        params.taskId,\n        \"submitted\",\n        params.note,\n      );\n\n      // 2. Trigger Firebase sync in background\n      if (navigator.onLine) {\n        firebaseSync.syncUserTasks(params.userId).catch((error) => {\n          logger.warn(\"Task submission sync failed\", { error });\n        });\n      }\n\n      return updatedTask;\n    },\n    onSuccess: (data, variables) => {\n      // Update task in cache\n      queryClient.setQueryData(\n        [\"tasks\", \"user\", variables.userId],\n        (oldTasks: DBTask[] | undefined) => {\n          if (!oldTasks) return oldTasks;\n          return oldTasks.map((task) =>\n            task.id === variables.taskId ? { ...task, ...data } : task,\n          );\n        },\n      );\n\n      // Invalidate pending tasks since this affects that query\n      queryClient.invalidateQueries({\n        queryKey: [\"tasks\", \"pending\", variables.userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\"Failed to submit task for review\", { error });\n    },\n  });\n\n  return {\n    createTask,\n    updateTaskStatus,\n    deleteTask,\n    submitTaskForReview,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/api/useTasks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1629,1632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1629,1632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1814,1817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1814,1817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useUpdateTaskStatus' has too many lines (85). Maximum allowed is 75.","line":290,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":394,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { taskDBService } from \"../../services/database/TaskDBService\";\nimport { Task, TaskStatus } from \"../../types/database\";\nimport { logger } from \"../../utils/logging\";\n\n/**\n * Task Management Hooks - TanStack Query Integration\n *\n * Integrates with:\n * - taskDBService  Dexie  Firebase sync\n * - TasksPage.tsx, TaskManagement.tsx (critical fixes needed)\n *\n * Fixes:\n * - TasksPage.tsx:20 (taskDBService.findByUserId)\n * - TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n *\n * Strategy: Optimistic update + background sync\n */\n\n// Query Keys\nexport const taskKeys = {\n  all: [\"tasks\"] as const,\n  lists: () => [...taskKeys.all, \"list\"] as const,\n  list: (userId: string, filters?: TaskFilters) =>\n    [...taskKeys.lists(), userId, filters] as const,\n  detail: (taskId: string) => [...taskKeys.all, \"detail\", taskId] as const,\n  byStatus: (userId: string, status: TaskStatus) =>\n    [...taskKeys.all, \"status\", userId, status] as const,\n  assigned: (userId: string) => [...taskKeys.all, \"assigned\", userId] as const,\n  assignedBy: (keyholderUid: string) =>\n    [...taskKeys.all, \"assignedBy\", keyholderUid] as const,\n} as const;\n\n// Types\ninterface TaskFilters {\n  status?: TaskStatus;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  assignedBy?: string;\n  dueDate?: {\n    start?: Date;\n    end?: Date;\n  };\n}\n\ninterface CreateTaskData {\n  title: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  assignedBy?: string; // keyholder UID\n  metadata?: Record<string, any>;\n}\n\ninterface UpdateTaskData {\n  title?: string;\n  description?: string;\n  priority?: \"low\" | \"medium\" | \"high\";\n  category?: string;\n  dueDate?: Date;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Get tasks for a user with optional filtering\n * Fixes: TasksPage.tsx:20 (taskDBService.findByUserId)\n */\nexport function useTasks(userId: string, filters?: TaskFilters) {\n  return useQuery({\n    queryKey: taskKeys.list(userId, filters),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks\", { userId, filters });\n\n      try {\n        const tasks = await taskDBService.findByUserId(userId);\n\n        // Apply filters\n        let filteredTasks = tasks;\n\n        if (filters?.status) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.status === filters.status,\n          );\n        }\n\n        if (filters?.priority) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.priority === filters.priority,\n          );\n        }\n\n        if (filters?.category) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.category === filters.category,\n          );\n        }\n\n        if (filters?.assignedBy) {\n          filteredTasks = filteredTasks.filter(\n            (task) => task.assignedBy === filters.assignedBy,\n          );\n        }\n\n        if (filters?.dueDate) {\n          filteredTasks = filteredTasks.filter((task) => {\n            if (!task.dueDate) return false;\n            const taskDue = new Date(task.dueDate);\n\n            if (filters.dueDate?.start && taskDue < filters.dueDate.start)\n              return false;\n            if (filters.dueDate?.end && taskDue > filters.dueDate.end)\n              return false;\n\n            return true;\n          });\n        }\n\n        // Sort by priority and due date\n        filteredTasks.sort((a, b) => {\n          // Priority sorting (high > medium > low)\n          const priorityOrder = { high: 3, medium: 2, low: 1 };\n          const aPriority = priorityOrder[a.priority || \"medium\"];\n          const bPriority = priorityOrder[b.priority || \"medium\"];\n\n          if (aPriority !== bPriority) {\n            return bPriority - aPriority;\n          }\n\n          // Due date sorting (sooner first)\n          if (a.dueDate && b.dueDate) {\n            return (\n              new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()\n            );\n          }\n\n          if (a.dueDate && !b.dueDate) return -1;\n          if (!a.dueDate && b.dueDate) return 1;\n\n          // Created date sorting (newest first)\n          return (\n            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n          );\n        });\n\n        logger.info(\"Tasks retrieved successfully\", {\n          userId,\n          totalTasks: tasks.length,\n          filteredTasks: filteredTasks.length,\n        });\n\n        return filteredTasks;\n      } catch (error) {\n        logger.error(\"Failed to fetch tasks\", error, { userId, filters });\n        throw error;\n      }\n    },\n    staleTime: 2 * 60 * 1000, // 2 minutes - active data\n    gcTime: 30 * 60 * 1000, // 30 minutes garbage collection\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get tasks by status (useful for kanban boards)\n */\nexport function useTasksByStatus(userId: string, status: TaskStatus) {\n  return useQuery({\n    queryKey: taskKeys.byStatus(userId, status),\n    queryFn: async (): Promise<Task[]> => {\n      const tasks = await taskDBService.findByUserId(userId);\n      return tasks.filter((task) => task.status === status);\n    },\n    staleTime: 2 * 60 * 1000,\n    enabled: !!userId,\n  });\n}\n\n/**\n * Get single task by ID\n */\nexport function useTask(taskId: string) {\n  return useQuery({\n    queryKey: taskKeys.detail(taskId),\n    queryFn: async (): Promise<Task | null> => {\n      logger.info(\"Fetching task detail\", { taskId });\n      return await taskDBService.findById(taskId);\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes - task details are stable\n    enabled: !!taskId,\n  });\n}\n\n/**\n * Get tasks assigned by a specific keyholder\n */\nexport function useTasksAssignedBy(keyholderUid: string) {\n  return useQuery({\n    queryKey: taskKeys.assignedBy(keyholderUid),\n    queryFn: async (): Promise<Task[]> => {\n      logger.info(\"Fetching tasks assigned by keyholder\", { keyholderUid });\n\n      // Note: This would require a different query method in the future\n      // For now, we'll need to scan all tasks (inefficient but works)\n      const allTasks = await taskDBService.getAll();\n      return allTasks.filter((task) => task.assignedBy === keyholderUid);\n    },\n    staleTime: 5 * 60 * 1000,\n    enabled: !!keyholderUid,\n  });\n}\n\n/**\n * Create new task\n */\nexport function useCreateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      userId,\n      taskData,\n    }: {\n      userId: string;\n      taskData: CreateTaskData;\n    }): Promise<Task> => {\n      logger.info(\"Creating new task\", { userId, title: taskData.title });\n\n      // Generate task ID\n      const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      const newTask: Task = {\n        id: taskId,\n        userId,\n        title: taskData.title,\n        description: taskData.description || \"\",\n        status: \"pending\",\n        priority: taskData.priority || \"medium\",\n        category: taskData.category,\n        dueDate: taskData.dueDate,\n        assignedBy: taskData.assignedBy,\n        metadata: taskData.metadata,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      // Dexie-first write for immediate UI response\n      await taskDBService.create(newTask);\n\n      logger.info(\"Task created successfully\", {\n        taskId,\n        userId,\n        title: taskData.title,\n      });\n\n      return newTask;\n    },\n    onSuccess: (newTask, { userId }) => {\n      logger.info(\"Task creation successful\", { taskId: newTask.id, userId });\n\n      // Invalidate task lists to trigger refetch\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n\n      // Optimistically add to cache if we have existing data\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return [newTask, ...oldData];\n        },\n      );\n    },\n    onError: (error, { userId, taskData }) => {\n      logger.error(\"Task creation failed\", error, {\n        userId,\n        title: taskData.title,\n      });\n    },\n  });\n}\n\n/**\n * Update task status (most common operation)\n * Fixes: TasksPage.tsx:34 (taskDBService.updateTaskStatus)\n * Strategy: Optimistic update + background sync\n */\nexport function useUpdateTaskStatus() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      status,\n      completedAt,\n    }: {\n      taskId: string;\n      userId: string;\n      status: TaskStatus;\n      completedAt?: Date;\n    }): Promise<Task> => {\n      logger.info(\"Updating task status\", { taskId, userId, status });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        status,\n        completedAt:\n          status === \"completed\" ? completedAt || new Date() : undefined,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.updateTaskStatus(taskId, status);\n\n      logger.info(\"Task status updated successfully\", {\n        taskId,\n        userId,\n        status,\n      });\n\n      return updatedTask;\n    },\n    onMutate: async ({ taskId, userId, status }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: taskKeys.detail(taskId) });\n      await queryClient.cancelQueries({ queryKey: taskKeys.list(userId) });\n\n      // Snapshot previous values\n      const previousTask = queryClient.getQueryData(taskKeys.detail(taskId));\n      const previousTasks = queryClient.getQueryData(taskKeys.list(userId));\n\n      // Optimistically update task detail\n      queryClient.setQueryData(\n        taskKeys.detail(taskId),\n        (old: Task | undefined) => {\n          if (!old) return old;\n          return { ...old, status, updatedAt: new Date() };\n        },\n      );\n\n      // Optimistically update task lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return oldData;\n          return oldData.map((task) =>\n            task.id === taskId\n              ? { ...task, status, updatedAt: new Date() }\n              : task,\n          );\n        },\n      );\n\n      return { previousTask, previousTasks };\n    },\n    onSuccess: (updatedTask, { userId, taskId }) => {\n      logger.info(\"Task status update successful\", {\n        taskId,\n        userId,\n        status: updatedTask.status,\n      });\n\n      // Invalidate relevant queries\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n\n      // If task was completed, invalidate pending tasks\n      if (updatedTask.status === \"completed\") {\n        queryClient.invalidateQueries({\n          queryKey: taskKeys.byStatus(userId, \"pending\"),\n        });\n      }\n    },\n    onError: (error, { taskId, userId }, context) => {\n      logger.error(\"Task status update failed\", error, { taskId, userId });\n\n      // Rollback optimistic updates\n      if (context?.previousTask) {\n        queryClient.setQueryData(taskKeys.detail(taskId), context.previousTask);\n      }\n      if (context?.previousTasks) {\n        queryClient.setQueryData(taskKeys.list(userId), context.previousTasks);\n      }\n    },\n  });\n}\n\n/**\n * Update full task details\n */\nexport function useUpdateTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n      updates,\n    }: {\n      taskId: string;\n      userId: string;\n      updates: UpdateTaskData;\n    }): Promise<Task> => {\n      logger.info(\"Updating task\", { taskId, userId });\n\n      const existingTask = await taskDBService.findById(taskId);\n      if (!existingTask) {\n        throw new Error(`Task not found: ${taskId}`);\n      }\n\n      const updatedTask: Task = {\n        ...existingTask,\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      await taskDBService.update(taskId, updatedTask);\n\n      logger.info(\"Task updated successfully\", { taskId, userId });\n\n      return updatedTask;\n    },\n    onSuccess: (updatedTask, { userId, taskId }) => {\n      logger.info(\"Task update successful\", { taskId, userId });\n\n      // Update detail cache\n      queryClient.setQueryData(taskKeys.detail(taskId), updatedTask);\n\n      // Invalidate list queries to reflect changes\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, updatedTask.status),\n      });\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task update failed\", error, { taskId, userId });\n    },\n  });\n}\n\n/**\n * Delete task\n */\nexport function useDeleteTask() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async ({\n      taskId,\n      userId,\n    }: {\n      taskId: string;\n      userId: string;\n    }): Promise<void> => {\n      logger.info(\"Deleting task\", { taskId, userId });\n\n      await taskDBService.delete(taskId);\n\n      logger.info(\"Task deleted successfully\", { taskId, userId });\n    },\n    onSuccess: (_, { taskId, userId }) => {\n      logger.info(\"Task deletion successful\", { taskId, userId });\n\n      // Remove from detail cache\n      queryClient.removeQueries({ queryKey: taskKeys.detail(taskId) });\n\n      // Invalidate list queries\n      queryClient.invalidateQueries({ queryKey: taskKeys.lists() });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"pending\"),\n      });\n      queryClient.invalidateQueries({\n        queryKey: taskKeys.byStatus(userId, \"completed\"),\n      });\n\n      // Optimistically remove from cached lists\n      queryClient.setQueriesData(\n        { queryKey: taskKeys.list(userId) },\n        (oldData: Task[] | undefined) => {\n          if (!oldData) return undefined;\n          return oldData.filter((task) => task.id !== taskId);\n        },\n      );\n    },\n    onError: (error, { taskId, userId }) => {\n      logger.error(\"Task deletion failed\", error, { taskId, userId });\n    },\n  });\n}\n\n/**\n * Get task statistics for dashboard\n */\nexport function useTaskStats(userId: string) {\n  return useQuery({\n    queryKey: [...taskKeys.all, \"stats\", userId],\n    queryFn: async () => {\n      logger.info(\"Calculating task statistics\", { userId });\n\n      const tasks = await taskDBService.findByUserId(userId);\n\n      const stats = {\n        total: tasks.length,\n        pending: tasks.filter((t) => t.status === \"pending\").length,\n        inProgress: tasks.filter((t) => t.status === \"in_progress\").length,\n        completed: tasks.filter((t) => t.status === \"completed\").length,\n        overdue: tasks.filter((t) => {\n          if (!t.dueDate || t.status === \"completed\") return false;\n          return new Date(t.dueDate) < new Date();\n        }).length,\n        byPriority: {\n          high: tasks.filter((t) => t.priority === \"high\").length,\n          medium: tasks.filter((t) => t.priority === \"medium\").length,\n          low: tasks.filter((t) => t.priority === \"low\").length,\n        },\n        completionRate:\n          tasks.length > 0\n            ? Math.round(\n                (tasks.filter((t) => t.status === \"completed\").length /\n                  tasks.length) *\n                  100,\n              )\n            : 0,\n      };\n\n      return stats;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    enabled: !!userId,\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileAchievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfilePrivacy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileSharing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/useProfileStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/profile/usePublicProfile.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2405,2408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2405,2408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * usePublicProfile Hook\n * Handles profile data fetching and management for public profiles\n */\n\nimport { useState, useEffect } from \"react\";\nimport { logger } from \"../../utils/logging\";\n\n// Profile interface - keeping from original\nexport interface PublicProfile {\n  username: string;\n  displayName: string;\n  bio: string;\n  joinDate: Date;\n  isPublic: boolean;\n  shareStatistics: boolean;\n  stats: {\n    totalSessions: number;\n    longestSession: number; // in seconds\n    totalChastityTime: number; // in seconds\n    streakDays: number;\n  };\n  badges: Array<{\n    id: string;\n    name: string;\n    description: string;\n    earnedDate: Date;\n    icon: string;\n  }>;\n  recentAchievements: Array<{\n    id: string;\n    title: string;\n    date: Date;\n    type: \"milestone\" | \"streak\" | \"goal\";\n  }>;\n}\n\n// Mock profile data - in real app would come from API\nconst mockProfile: PublicProfile = {\n  username: \"dedication_seeker\",\n  displayName: \"Alex Thompson\",\n  bio: \"On a journey of self-discipline and personal growth. Exploring the intersection of mindfulness and commitment. Always looking to improve and support others on similar paths.\",\n  joinDate: new Date(Date.now() - 120 * 24 * 60 * 60 * 1000), // 120 days ago\n  isPublic: true,\n  shareStatistics: true,\n  stats: {\n    totalSessions: 47,\n    longestSession: 15 * 24 * 60 * 60, // 15 days in seconds\n    totalChastityTime: 180 * 24 * 60 * 60, // 180 days total\n    streakDays: 12,\n  },\n  badges: [\n    {\n      id: \"1\",\n      name: \"First Week\",\n      description: \"Completed your first 7-day session\",\n      earnedDate: new Date(Date.now() - 100 * 24 * 60 * 60 * 1000),\n      icon: \"\",\n    },\n    {\n      id: \"2\",\n      name: \"Dedication\",\n      description: \"Reached 30 total sessions\",\n      earnedDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\n      icon: \"\",\n    },\n    {\n      id: \"3\",\n      name: \"Consistency\",\n      description: \"Maintained a 10-day streak\",\n      earnedDate: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),\n      icon: \"\",\n    },\n  ],\n  recentAchievements: [\n    {\n      id: \"1\",\n      title: \"Completed 2-week session\",\n      date: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),\n      type: \"milestone\",\n    },\n    {\n      id: \"2\",\n      title: \"12-day streak achieved\",\n      date: new Date(),\n      type: \"streak\",\n    },\n  ],\n};\n\nexport const usePublicProfile = (username?: string, currentUser?: any) => {\n  const [profile, setProfile] = useState<PublicProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [isOwnProfile, setIsOwnProfile] = useState(false);\n\n  useEffect(() => {\n    const fetchProfile = async () => {\n      if (!username) {\n        setLoading(false);\n        return;\n      }\n\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Simulate API call to fetch profile\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n\n        setProfile(mockProfile);\n\n        // Check if this is the user's own profile\n        if (\n          currentUser &&\n          username === currentUser.displayName?.toLowerCase().replace(\" \", \"_\")\n        ) {\n          setIsOwnProfile(true);\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error ? err.message : \"Unknown error\";\n        setError(errorMessage);\n        logger.error(\"Error fetching profile:\", err, \"usePublicProfile\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchProfile();\n  }, [username, currentUser]);\n\n  return {\n    profile,\n    loading,\n    error,\n    isOwnProfile,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/types.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipPermissions' is defined but never used.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared types and interfaces for relationship hooks\n * Extracted from useRelationships.ts for reuse across focused hooks\n */\nimport {\n  Relationship,\n  RelationshipRequest,\n  RelationshipChastityData,\n  RelationshipTask,\n  RelationshipEvent,\n  RelationshipSession,\n  RelationshipPermissions,\n} from \"@/types/relationships\";\n\nexport interface RelationshipState {\n  relationships: Relationship[];\n  pendingRequests: RelationshipRequest[];\n  activeRelationship: Relationship | null;\n  chastityData: RelationshipChastityData | null;\n  tasks: RelationshipTask[];\n  events: RelationshipEvent[];\n  sessions: RelationshipSession[];\n  isLoading: boolean;\n  error: string | null;\n  needsMigration: boolean;\n}\n\nexport interface BaseHookState {\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface BaseHookActions {\n  clearError: () => void;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipInvites.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadPendingRequests'. Either include it or remove the dependency array.","line":90,"column":6,"nodeType":"ArrayExpression","endLine":90,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [loadPendingRequests, userId]","fix":{"range":[2487,2495],"text":"[loadPendingRequests, userId]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Invitation Management\n * Handles sending and managing relationship invitations\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipService } from \"@/services/database/RelationshipService\";\nimport { RelationshipRequest } from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipInvitesState extends BaseHookState {\n  pendingRequests: RelationshipRequest[];\n}\n\ninterface RelationshipInvitesActions extends BaseHookActions {\n  sendRelationshipRequest: (\n    targetUserId: string,\n    role: \"submissive\" | \"keyholder\",\n    message?: string,\n  ) => Promise<void>;\n  refreshPendingRequests: () => Promise<void>;\n}\n\nexport function useRelationshipInvites(): RelationshipInvitesState &\n  RelationshipInvitesActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipInvitesState>({\n    pendingRequests: [],\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadPendingRequests = useCallback(async () => {\n    if (!userId) return;\n\n    return withErrorHandling(\n      async () => {\n        const pendingRequests =\n          await relationshipService.getPendingRequests(userId);\n        setState((prev) => ({ ...prev, pendingRequests }));\n      },\n      \"load pending requests\",\n      setState,\n    );\n  }, [userId]);\n\n  const sendRelationshipRequest = useCallback(\n    async (\n      targetUserId: string,\n      role: \"submissive\" | \"keyholder\",\n      message?: string,\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipService.sendRelationshipRequest(\n            userId,\n            targetUserId,\n            role,\n            message,\n          );\n          await loadPendingRequests();\n        },\n        \"send relationship request\",\n        setState,\n      );\n    },\n    [userId, loadPendingRequests],\n  );\n\n  const refreshPendingRequests = useCallback(async () => {\n    await loadPendingRequests();\n  }, [loadPendingRequests]);\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Initial load\n  useEffect(() => {\n    if (userId) {\n      loadPendingRequests();\n    }\n  }, [userId]); // Removed loadPendingRequests from dependencies to avoid Zustand warning\n\n  return {\n    ...state,\n    sendRelationshipRequest,\n    refreshPendingRequests,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipList.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadRelationships'. Either include it or remove the dependency array.","line":78,"column":6,"nodeType":"ArrayExpression","endLine":78,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [loadRelationships, userId]","fix":{"range":[2319,2327],"text":"[loadRelationships, userId]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship List Management\n * Handles loading, filtering, and selecting relationships\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipService } from \"@/services/database/RelationshipService\";\nimport { Relationship } from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipListState extends BaseHookState {\n  relationships: Relationship[];\n  activeRelationship: Relationship | null;\n}\n\ninterface RelationshipListActions extends BaseHookActions {\n  setActiveRelationship: (relationship: Relationship | null) => void;\n  refreshRelationships: () => Promise<void>;\n}\n\nexport function useRelationshipList(): RelationshipListState &\n  RelationshipListActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipListState>({\n    relationships: [],\n    activeRelationship: null,\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadRelationships = useCallback(async () => {\n    if (!userId) return;\n\n    return withErrorHandling(\n      async () => {\n        const relationships =\n          await relationshipService.getUserRelationships(userId);\n        setState((prev) => ({ ...prev, relationships }));\n\n        // Set active relationship if there's only one and none is set\n        if (relationships.length === 1 && !state.activeRelationship) {\n          setState((prev) => ({\n            ...prev,\n            activeRelationship: relationships[0],\n          }));\n        }\n      },\n      \"load relationships\",\n      setState,\n    );\n  }, [userId, state.activeRelationship]);\n\n  const setActiveRelationship = useCallback(\n    (relationship: Relationship | null) => {\n      setState((prev) => ({ ...prev, activeRelationship: relationship }));\n    },\n    [],\n  );\n\n  const refreshRelationships = useCallback(async () => {\n    await loadRelationships();\n  }, [loadRelationships]);\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Initial load\n  useEffect(() => {\n    if (userId) {\n      loadRelationships();\n    }\n  }, [userId]); // Removed loadRelationships from dependencies to avoid Zustand warning\n\n  // Set up real-time listeners\n  useEffect(() => {\n    if (!userId) return;\n\n    const unsubscribe = relationshipService.subscribeToUserRelationships(\n      userId,\n      (relationships) => {\n        setState((prev) => ({ ...prev, relationships }));\n      },\n    );\n\n    return unsubscribe;\n  }, [userId]);\n\n  return {\n    ...state,\n    setActiveRelationship,\n    refreshRelationships,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipPermissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipStatus.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipStatus' has too many lines (138). Maximum allowed is 75.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":199,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Status Management\n * Handles session management and status updates\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport {\n  RelationshipChastityData,\n  RelationshipSession,\n} from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipStatusState extends BaseHookState {\n  chastityData: RelationshipChastityData | null;\n  sessions: RelationshipSession[];\n}\n\ninterface RelationshipStatusActions extends BaseHookActions {\n  startSession: (\n    relationshipId: string,\n    options?: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    },\n  ) => Promise<void>;\n  endSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  pauseSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  resumeSession: (relationshipId: string, sessionId: string) => Promise<void>;\n  loadRelationshipData: (relationshipId: string) => Promise<void>;\n}\n\nexport function useRelationshipStatus(): RelationshipStatusState &\n  RelationshipStatusActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipStatusState>({\n    chastityData: null,\n    sessions: [],\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadChastityData = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const chastityData =\n          await relationshipChastityService.getChastityData(relationshipId);\n        setState((prev) => ({ ...prev, chastityData }));\n      },\n      \"load chastity data\",\n      setState,\n    );\n  }, []);\n\n  const loadSessions = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const sessions =\n          await relationshipChastityService.getSessionHistory(relationshipId);\n        setState((prev) => ({ ...prev, sessions }));\n      },\n      \"load sessions\",\n      setState,\n    );\n  }, []);\n\n  const loadRelationshipData = useCallback(\n    async (relationshipId: string) => {\n      await Promise.all([\n        loadChastityData(relationshipId),\n        loadSessions(relationshipId),\n      ]);\n    },\n    [loadChastityData, loadSessions],\n  );\n\n  const startSession = useCallback(\n    async (\n      relationshipId: string,\n      options?: {\n        goalDuration?: number;\n        isHardcoreMode?: boolean;\n        notes?: string;\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.startSession(\n            relationshipId,\n            userId,\n            options || {},\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"start session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const endSession = useCallback(\n    async (relationshipId: string, sessionId: string, reason?: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.endSession(\n            relationshipId,\n            sessionId,\n            userId,\n            reason,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"end session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const pauseSession = useCallback(\n    async (relationshipId: string, sessionId: string, reason?: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.pauseSession(\n            relationshipId,\n            sessionId,\n            userId,\n            reason,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"pause session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const resumeSession = useCallback(\n    async (relationshipId: string, sessionId: string) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.resumeSession(\n            relationshipId,\n            sessionId,\n            userId,\n          );\n          await loadRelationshipData(relationshipId);\n        },\n        \"resume session\",\n        setState,\n      );\n    },\n    [userId, loadRelationshipData],\n  );\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Set up real-time listeners for active relationship data\n  useEffect(() => {\n    // This would be called externally when activeRelationship changes\n    // The parent hook will need to manage this subscription\n  }, []);\n\n  return {\n    ...state,\n    startSession,\n    endSession,\n    pauseSession,\n    resumeSession,\n    loadRelationshipData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipTasks.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipTasks' has too many lines (132). Maximum allowed is 75.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":192,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Task and Event Management\n * Handles creating, updating tasks and logging events\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport { RelationshipTask, RelationshipEvent } from \"@/types/relationships\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipTasksState extends BaseHookState {\n  tasks: RelationshipTask[];\n  events: RelationshipEvent[];\n}\n\ninterface RelationshipTasksActions extends BaseHookActions {\n  createTask: (\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n  ) => Promise<void>;\n  updateTaskStatus: (\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTask[\"status\"],\n    note?: string,\n  ) => Promise<void>;\n  logEvent: (\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n  ) => Promise<void>;\n  loadRelationshipData: (relationshipId: string) => Promise<void>;\n}\n\nexport function useRelationshipTasks(): RelationshipTasksState &\n  RelationshipTasksActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipTasksState>({\n    tasks: [],\n    events: [],\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const loadTasks = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const tasks =\n          await relationshipChastityService.getTasks(relationshipId);\n        setState((prev) => ({ ...prev, tasks }));\n      },\n      \"load tasks\",\n      setState,\n    );\n  }, []);\n\n  const loadEvents = useCallback(async (relationshipId: string) => {\n    return withErrorHandling(\n      async () => {\n        const events =\n          await relationshipChastityService.getEvents(relationshipId);\n        setState((prev) => ({ ...prev, events }));\n      },\n      \"load events\",\n      setState,\n    );\n  }, []);\n\n  const loadRelationshipData = useCallback(\n    async (relationshipId: string) => {\n      await Promise.all([\n        loadTasks(relationshipId),\n        loadEvents(relationshipId),\n      ]);\n    },\n    [loadTasks, loadEvents],\n  );\n\n  const createTask = useCallback(\n    async (\n      relationshipId: string,\n      taskData: {\n        text: string;\n        dueDate?: Date;\n        consequence?: RelationshipTask[\"consequence\"];\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.createTask(\n            relationshipId,\n            taskData,\n            userId,\n          );\n          await loadTasks(relationshipId);\n        },\n        \"create task\",\n        setState,\n      );\n    },\n    [userId, loadTasks],\n  );\n\n  const updateTaskStatus = useCallback(\n    async (\n      relationshipId: string,\n      taskId: string,\n      status: RelationshipTask[\"status\"],\n      note?: string,\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.updateTaskStatus(\n            relationshipId,\n            taskId,\n            status,\n            userId,\n            note,\n          );\n          await loadTasks(relationshipId);\n        },\n        \"update task status\",\n        setState,\n      );\n    },\n    [userId, loadTasks],\n  );\n\n  const logEvent = useCallback(\n    async (\n      relationshipId: string,\n      eventData: {\n        type: RelationshipEvent[\"type\"];\n        details: RelationshipEvent[\"details\"];\n        isPrivate?: boolean;\n        tags?: string[];\n      },\n    ) => {\n      if (!userId) throw new Error(\"User not authenticated\");\n\n      return withErrorHandling(\n        async () => {\n          await relationshipChastityService.logEvent(\n            relationshipId,\n            eventData,\n            userId,\n          );\n          await loadEvents(relationshipId);\n        },\n        \"log event\",\n        setState,\n      );\n    },\n    [userId, loadEvents],\n  );\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  // Set up real-time listeners for tasks\n  useEffect(() => {\n    // This would be called externally when activeRelationship changes\n    // The parent hook will need to manage this subscription\n  }, []);\n\n  return {\n    ...state,\n    createTask,\n    updateTaskStatus,\n    logEvent,\n    loadRelationshipData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/useRelationshipValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[876,879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[876,879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationshipValidation' has too many lines (79). Maximum allowed is 75.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":128,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":48,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2976,2979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2976,2979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Form Validation\n * Handles validation logic for relationship forms and rules\n */\nimport { useState, useCallback } from \"react\";\nimport { useAuthState } from \"@/contexts/AuthContext\";\nimport { dataMigrationService } from \"@/services/migration/DataMigrationService\";\nimport { BaseHookState, BaseHookActions } from \"./types\";\nimport { withErrorHandling, createBaseActions } from \"./utils\";\n\ninterface RelationshipValidationState extends BaseHookState {\n  needsMigration: boolean;\n}\n\ninterface RelationshipValidationActions extends BaseHookActions {\n  migrateSingleUserData: () => Promise<void>;\n  checkMigrationStatus: () => Promise<void>;\n  validateRequestForm: (formData: {\n    email: string;\n    role: \"submissive\" | \"keyholder\";\n    message?: string;\n  }) => { isValid: boolean; errors: string[] };\n  validatePermissionsForm: (permissions: any) => {\n    isValid: boolean;\n    errors: string[];\n  };\n}\n\nexport function useRelationshipValidation(): RelationshipValidationState &\n  RelationshipValidationActions {\n  const { user } = useAuthState();\n  const userId = user?.uid;\n\n  const [state, setState] = useState<RelationshipValidationState>({\n    needsMigration: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const { clearError: clearErrorFn } = createBaseActions();\n\n  const checkMigrationStatus = useCallback(async () => {\n    if (!userId) return;\n\n    try {\n      const needsMigration = await dataMigrationService.needsMigration(userId);\n      setState((prev) => ({ ...prev, needsMigration }));\n    } catch (error) {\n      // Silent fail for migration check - using logger instead of console\n      // logger.warn(\"Failed to check migration status\", error);\n    }\n  }, [userId]);\n\n  const migrateSingleUserData = useCallback(async () => {\n    if (!userId) throw new Error(\"User not authenticated\");\n\n    return withErrorHandling(\n      async () => {\n        const result = await dataMigrationService.migrateSingleUserData(userId);\n        if (!result.success) {\n          throw new Error(result.errors.join(\", \"));\n        }\n        setState((prev) => ({ ...prev, needsMigration: false }));\n      },\n      \"migrate single user data\",\n      setState,\n    );\n  }, [userId]);\n\n  const validateRequestForm = useCallback(\n    (formData: {\n      email: string;\n      role: \"submissive\" | \"keyholder\";\n      message?: string;\n    }) => {\n      const errors: string[] = [];\n\n      if (!formData.email.trim()) {\n        errors.push(\"Email is required\");\n      } else if (!/\\S+@\\S+\\.\\S+/.test(formData.email)) {\n        errors.push(\"Email format is invalid\");\n      }\n\n      if (!formData.role) {\n        errors.push(\"Role is required\");\n      }\n\n      if (formData.message && formData.message.length > 500) {\n        errors.push(\"Message cannot exceed 500 characters\");\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n      };\n    },\n    [],\n  );\n\n  const validatePermissionsForm = useCallback((permissions: any) => {\n    const errors: string[] = [];\n\n    // Add specific validation rules for permissions\n    if (typeof permissions !== \"object\" || permissions === null) {\n      errors.push(\"Permissions must be an object\");\n    }\n\n    // Add more specific validation as needed based on RelationshipPermissions type\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }, []);\n\n  const clearError = useCallback(() => {\n    clearErrorFn(setState);\n  }, [clearErrorFn]);\n\n  return {\n    ...state,\n    migrateSingleUserData,\n    checkMigrationStatus,\n    validateRequestForm,\n    validatePermissionsForm,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/relationships/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[488,491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[488,491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[535,538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[535,538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[744,747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[744,747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[752,755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[752,755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[803,806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[803,806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1068,1071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1068,1071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1159,1162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1159,1162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Shared utilities for relationship hooks\n * Common error handling and state management functions\n */\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"relationships\");\n\nexport const createBaseActions = () => {\n  const handleError = (error: unknown, operation: string): string => {\n    const message = (error as Error).message;\n    logger.error(`Failed to ${operation}`, { error });\n    return message;\n  };\n\n  const clearError = (setState: (fn: (prev: any) => any) => void) => {\n    setState((prev: any) => ({ ...prev, error: null }));\n  };\n\n  return { handleError, clearError };\n};\n\nexport const withErrorHandling = async <T>(\n  operation: () => Promise<T>,\n  operationName: string,\n  setState: (fn: (prev: any) => any) => void,\n): Promise<T> => {\n  setState((prev: any) => ({ ...prev, isLoading: true, error: null }));\n\n  try {\n    const result = await operation();\n    return result;\n  } catch (error) {\n    const message = (error as Error).message;\n    logger.error(`Failed to ${operationName}`, { error });\n    setState((prev: any) => ({ ...prev, error: message }));\n    throw error;\n  } finally {\n    setState((prev: any) => ({ ...prev, isLoading: false }));\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useAchievements.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBAchievementNotification' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":28},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (218). Maximum allowed is 75.","line":26,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":339,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useAchievements Hook\n * React hook for managing achievements and progress\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService, achievementEngine } from \"../services\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  DBAchievementNotification,\n  AchievementCategory,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface AchievementStats {\n  totalEarned: number;\n  totalPoints: number;\n  completionPercentage: number;\n  categoryCounts: Record<AchievementCategory, number>;\n  recentAchievements: DBUserAchievement[];\n}\n\nexport const useAchievements = (userId?: string) => {\n  const queryClient = useQueryClient();\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get all available achievements\n   */\n  const { data: allAchievements = [], isLoading: isLoadingAchievements } =\n    useQuery({\n      queryKey: [\"achievements\"],\n      queryFn: () => achievementDBService.getAllAchievements(),\n      enabled: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n\n  /**\n   * Get user's earned achievements\n   */\n  const { data: userAchievements = [], isLoading: isLoadingUserAchievements } =\n    useQuery({\n      queryKey: [\"achievements\", \"user\", userId],\n      queryFn: () => achievementDBService.getUserAchievements(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  const { data: visibleAchievements = [] } = useQuery({\n    queryKey: [\"achievements\", \"visible\", userId],\n    queryFn: () => achievementDBService.getUserVisibleAchievements(userId!),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's achievement progress\n   */\n  const { data: achievementProgress = [], isLoading: isLoadingProgress } =\n    useQuery({\n      queryKey: [\"achievements\", \"progress\", userId],\n      queryFn: () => achievementDBService.getUserAchievementProgress(userId!),\n      enabled: Boolean(userId),\n      staleTime: 30 * 1000, // 30 seconds\n    });\n\n  /**\n   * Get unread notifications\n   */\n  const { data: unreadNotifications = [], isLoading: isLoadingNotifications } =\n    useQuery({\n      queryKey: [\"achievements\", \"notifications\", userId],\n      queryFn: () => achievementDBService.getUserUnreadNotifications(userId!),\n      enabled: Boolean(userId),\n      refetchInterval: 30 * 1000, // Check every 30 seconds\n    });\n\n  /**\n   * Get achievement statistics\n   */\n  const { data: achievementStats, isLoading: isLoadingStats } = useQuery({\n    queryKey: [\"achievements\", \"stats\", userId],\n    queryFn: async (): Promise<AchievementStats> => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const [stats, achievements] = await Promise.all([\n        achievementDBService.getUserAchievementStats(userId),\n        achievementDBService.getUserAchievements(userId),\n      ]);\n\n      // Get recent achievements (last 5)\n      const recentAchievements = achievements\n        .sort((a, b) => b.earnedAt.getTime() - a.earnedAt.getTime())\n        .slice(0, 5);\n\n      return {\n        ...stats,\n        recentAchievements,\n      };\n    },\n    enabled: Boolean(userId),\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Toggle achievement visibility\n   */\n  const toggleVisibilityMutation = useMutation({\n    mutationFn: ({ achievementId }: { achievementId: string }) =>\n      achievementDBService.toggleAchievementVisibility(userId!, achievementId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"visible\", userId],\n      });\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"user\", userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Mark notification as read\n   */\n  const markNotificationReadMutation = useMutation({\n    mutationFn: (notificationId: string) =>\n      achievementDBService.markNotificationRead(notificationId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({\n        queryKey: [\"achievements\", \"notifications\", userId],\n      });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  /**\n   * Perform full achievement check\n   */\n  const performFullCheckMutation = useMutation({\n    mutationFn: () => achievementEngine.performFullCheck(userId!),\n    onSuccess: () => {\n      // Invalidate all achievement-related queries\n      queryClient.invalidateQueries({ queryKey: [\"achievements\"] });\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"useAchievements\",\n      );\n    },\n  });\n\n  // ==================== HELPER FUNCTIONS ====================\n\n  /**\n   * Get achievement by ID\n   */\n  const getAchievementById = useCallback(\n    (achievementId: string): DBAchievement | undefined => {\n      return allAchievements.find((a) => a.id === achievementId);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Check if user has specific achievement\n   */\n  const hasAchievement = useCallback(\n    (achievementId: string): boolean => {\n      return userAchievements.some((ua) => ua.achievementId === achievementId);\n    },\n    [userAchievements],\n  );\n\n  /**\n   * Get progress for specific achievement\n   */\n  const getProgressForAchievement = useCallback(\n    (achievementId: string): DBAchievementProgress | undefined => {\n      return achievementProgress.find(\n        (ap) => ap.achievementId === achievementId,\n      );\n    },\n    [achievementProgress],\n  );\n\n  /**\n   * Get achievements by category\n   */\n  const getAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBAchievement[] => {\n      return allAchievements.filter((a) => a.category === category);\n    },\n    [allAchievements],\n  );\n\n  /**\n   * Get user's achievements by category\n   */\n  const getUserAchievementsByCategory = useCallback(\n    (category: AchievementCategory): DBUserAchievement[] => {\n      const categoryAchievementIds = allAchievements\n        .filter((a) => a.category === category)\n        .map((a) => a.id);\n\n      return userAchievements.filter((ua) =>\n        categoryAchievementIds.includes(ua.achievementId),\n      );\n    },\n    [allAchievements, userAchievements],\n  );\n\n  /**\n   * Get achievements with progress information\n   */\n  const getAchievementsWithProgress = useCallback(() => {\n    return allAchievements.map((achievement) => {\n      const userAchievement = userAchievements.find(\n        (ua) => ua.achievementId === achievement.id,\n      );\n      const progress = achievementProgress.find(\n        (ap) => ap.achievementId === achievement.id,\n      );\n\n      return {\n        achievement,\n        userAchievement,\n        progress: progress\n          ? {\n              currentValue: progress.currentValue,\n              targetValue: progress.targetValue,\n              percentage: Math.min(\n                (progress.currentValue / progress.targetValue) * 100,\n                100,\n              ),\n              isCompleted: progress.isCompleted,\n            }\n          : null,\n        isEarned: Boolean(userAchievement),\n        isVisible: userAchievement?.isVisible ?? true,\n      };\n    });\n  }, [allAchievements, userAchievements, achievementProgress]);\n\n  // ==================== ACTIONS ====================\n\n  const toggleAchievementVisibility = useCallback(\n    (achievementId: string) => {\n      if (!userId) return;\n      toggleVisibilityMutation.mutate({ achievementId });\n    },\n    [userId, toggleVisibilityMutation],\n  );\n\n  const markNotificationRead = useCallback(\n    (notificationId: string) => {\n      markNotificationReadMutation.mutate(notificationId);\n    },\n    [markNotificationReadMutation],\n  );\n\n  const performFullCheck = useCallback(() => {\n    if (!userId) return;\n    performFullCheckMutation.mutate();\n  }, [userId, performFullCheckMutation]);\n\n  // ==================== EFFECTS ====================\n\n  /**\n   * Initialize achievement engine on mount\n   */\n  useEffect(() => {\n    achievementEngine.initialize().catch((error) => {\n      logger.error(\n        \"Failed to initialize achievement engine\",\n        error,\n        \"useAchievements\",\n      );\n    });\n  }, []);\n\n  // ==================== RETURN ====================\n\n  return {\n    // Data\n    allAchievements,\n    userAchievements,\n    visibleAchievements,\n    achievementProgress,\n    unreadNotifications,\n    achievementStats,\n\n    // Loading states\n    isLoading: isLoadingAchievements || isLoadingUserAchievements,\n    isLoadingProgress,\n    isLoadingNotifications,\n    isLoadingStats,\n\n    // Helper functions\n    getAchievementById,\n    hasAchievement,\n    getProgressForAchievement,\n    getAchievementsByCategory,\n    getUserAchievementsByCategory,\n    getAchievementsWithProgress,\n\n    // Actions\n    toggleAchievementVisibility,\n    markNotificationRead,\n    performFullCheck,\n\n    // Mutation states\n    isTogglingVisibility: toggleVisibilityMutation.isPending,\n    isMarkingRead: markNotificationReadMutation.isPending,\n    isPerformingCheck: performFullCheckMutation.isPending,\n  };\n};\n\n/**\n * Hook for achievement notifications (can be used globally)\n */\nexport const useAchievementNotifications = (userId?: string) => {\n  const { unreadNotifications, markNotificationRead, isLoadingNotifications } =\n    useAchievements(userId);\n\n  return {\n    notifications: unreadNotifications,\n    isLoading: isLoadingNotifications,\n    markAsRead: markNotificationRead,\n    hasUnread: unreadNotifications.length > 0,\n    unreadCount: unreadNotifications.length,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useDexieSync.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (109). Maximum allowed is 75.","line":20,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":172,"endColumn":2},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 75) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 103) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 127) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 150) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 157) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'services' object makes the dependencies of useCallback Hook (at line 169) change on every render. To fix this, wrap the initialization of 'services' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":33,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1549,1552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1549,1552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2274,2277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2274,2277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dexie Sync Hook\n * Provides easy access to Dexie services with automatic sync management\n */\nimport { useCallback } from \"react\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { useApp } from \"@/contexts/AppContext\";\nimport {\n  sessionDBService,\n  eventDBService,\n  taskDBService,\n  goalDBService,\n  settingsDBService,\n} from \"@/services/database\";\nimport { firebaseSync } from \"@/services/sync\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useDexieSync\");\n\nexport const useDexieSync = () => {\n  const { state: appState, actions: appActions } = useApp();\n  const { user } = useAuth();\n\n  /**\n   * Get all Dexie services\n   */\n  const services = {\n    sessions: sessionDBService,\n    events: eventDBService,\n    tasks: taskDBService,\n    goals: goalDBService,\n    settings: settingsDBService,\n  };\n\n  /**\n   * Trigger manual sync\n   */\n  const triggerSync = useCallback(async () => {\n    if (!user?.uid) {\n      logger.warn(\"Cannot sync: no authenticated user\");\n      return;\n    }\n\n    try {\n      await appActions.triggerSync(user.uid);\n    } catch (error) {\n      logger.error(\"Sync failed\", { error: error as Error });\n      throw error;\n    }\n  }, [user?.uid, appActions]);\n\n  /**\n   * Create a record with automatic sync queuing\n   */\n  const createWithSync = useCallback(\n    async <T>(service: keyof typeof services, data: T): Promise<string> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      const id = await services[service].create(data as any);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n\n      return id;\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Update a record with automatic sync queuing\n   */\n  const updateWithSync = useCallback(\n    async <T>(\n      service: keyof typeof services,\n      id: string,\n      updates: T,\n    ): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].update(id, updates as any);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  /**\n   * Delete a record with automatic sync queuing\n   */\n  const deleteWithSync = useCallback(\n    async (service: keyof typeof services, id: string): Promise<void> => {\n      if (!user?.uid) {\n        throw new Error(\"No authenticated user\");\n      }\n\n      await services[service].delete(id);\n\n      // Trigger background sync if online\n      if (appState.isOnline) {\n        try {\n          await firebaseSync.sync();\n        } catch (error) {\n          logger.warn(\"Background sync failed\", { error: error as Error });\n          // Don't throw - local data is saved\n        }\n      }\n    },\n    [user?.uid, appState.isOnline, services],\n  );\n\n  return {\n    // Services\n    services,\n\n    // Sync control\n    triggerSync,\n    syncStatus: appState.syncStatus,\n    lastSyncTime: appState.lastSyncTime,\n    isOnline: appState.isOnline,\n\n    // CRUD operations with sync\n    createWithSync,\n    updateWithSync,\n    deleteWithSync,\n\n    // Direct service access for read operations\n    findById: useCallback(\n      async (service: keyof typeof services, id: string) => {\n        return services[service].findById(id);\n      },\n      [services],\n    ),\n\n    findByUserId: useCallback(\n      async (service: keyof typeof services, userId: string) => {\n        return services[service].findByUserId(userId);\n      },\n      [services],\n    ),\n\n    paginate: useCallback(\n      async (\n        service: keyof typeof services,\n        userId: string,\n        offset: number = 0,\n        limit: number = 50,\n      ) => {\n        return services[service].paginate(userId, offset, limit);\n      },\n      [services],\n    ),\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useKeyholderRelationships.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useKeyholderRelationships' has too many lines (272). Maximum allowed is 75.","line":99,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":423,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'relationship' is assigned a value but never used.","line":231,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":231,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is assigned a value but never used.","line":280,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is assigned a value but never used.","line":338,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":338,"endColumn":27},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadInviteCodes', 'loadRelationshipSummary', and 'loadRelationships'. Either include them or remove the dependency array.","line":403,"column":6,"nodeType":"ArrayExpression","endLine":403,"endColumn":17,"suggestions":[{"desc":"Update the dependencies array to be: [loadInviteCodes, loadRelationshipSummary, loadRelationships, user?.uid]","fix":{"range":[11819,11830],"text":"[loadInviteCodes, loadRelationshipSummary, loadRelationships, user?.uid]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook for managing keyholder relationships\n * Provides UI state and actions for account linking\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { KeyholderRelationshipService } from \"../services/KeyholderRelationshipService\";\nimport { KeyholderRelationship, KeyholderPermissions } from \"../types/core\";\nimport { InviteCode } from \"../services/database/KeyholderRelationshipDBService\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"useKeyholderRelationships\");\n\nexport interface KeyholderRelationshipState {\n  // Relationships\n  relationships: {\n    asSubmissive: KeyholderRelationship[];\n    asKeyholder: KeyholderRelationship[];\n  };\n  activeKeyholder: KeyholderRelationship | null;\n\n  // Invite codes\n  activeInviteCodes: InviteCode[];\n\n  // Loading states\n  isLoading: boolean;\n  isCreatingInvite: boolean;\n  isAcceptingInvite: boolean;\n  isUpdatingPermissions: boolean;\n\n  // Form states\n  inviteCodeInput: string;\n  keyholderNameInput: string;\n\n  // Messages\n  message: string;\n  messageType: \"success\" | \"error\" | \"info\";\n\n  // Summary\n  relationshipSummary: {\n    hasActiveKeyholder: boolean;\n    hasSubmissives: boolean;\n    activeKeyholderCount: number;\n    submissiveCount: number;\n  } | null;\n}\n\nexport interface KeyholderRelationshipActions {\n  // Data loading\n  loadRelationships: () => Promise<void>;\n  loadInviteCodes: () => Promise<void>;\n  loadRelationshipSummary: () => Promise<void>;\n\n  // Invite code management\n  createInviteCode: (expirationHours?: number) => Promise<InviteCode | null>;\n  acceptInviteCode: (code: string, keyholderName?: string) => Promise<boolean>;\n  revokeInviteCode: (codeId: string) => Promise<void>;\n\n  // Relationship management\n  updatePermissions: (\n    relationshipId: string,\n    permissions: KeyholderPermissions,\n  ) => Promise<void>;\n  endRelationship: (relationshipId: string) => Promise<void>;\n\n  // Form actions\n  setInviteCodeInput: (code: string) => void;\n  setKeyholderNameInput: (name: string) => void;\n  clearMessage: () => void;\n  clearForm: () => void;\n\n  // Utilities\n  validateInviteCode: (code: string) => boolean;\n  canCreateInviteCode: () => Promise<boolean>;\n  hasPermission: (\n    submissiveUserId: string,\n    permission: keyof KeyholderPermissions,\n  ) => Promise<boolean>;\n}\n\nconst initialState: KeyholderRelationshipState = {\n  relationships: {\n    asSubmissive: [],\n    asKeyholder: [],\n  },\n  activeKeyholder: null,\n  activeInviteCodes: [],\n  isLoading: false,\n  isCreatingInvite: false,\n  isAcceptingInvite: false,\n  isUpdatingPermissions: false,\n  inviteCodeInput: \"\",\n  keyholderNameInput: \"\",\n  message: \"\",\n  messageType: \"info\",\n  relationshipSummary: null,\n};\n\nexport function useKeyholderRelationships(): KeyholderRelationshipState &\n  KeyholderRelationshipActions {\n  const [state, setState] = useState<KeyholderRelationshipState>(initialState);\n  const { user } = useAuthState();\n\n  // Load relationships\n  const loadRelationships = useCallback(async () => {\n    if (!user?.uid) return;\n\n    setState((prev) => ({ ...prev, isLoading: true }));\n\n    try {\n      const relationships =\n        await KeyholderRelationshipService.getUserRelationships(user.uid);\n      const activeKeyholder =\n        await KeyholderRelationshipService.getActiveKeyholder(user.uid);\n\n      setState((prev) => ({\n        ...prev,\n        relationships,\n        activeKeyholder,\n        isLoading: false,\n      }));\n\n      logger.debug(\"Relationships loaded\", {\n        submissiveCount: relationships.asSubmissive.length,\n        keyholderCount: relationships.asKeyholder.length,\n      });\n    } catch (error) {\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        message: \"Failed to load relationships\",\n        messageType: \"error\",\n      }));\n      logger.error(\"Failed to load relationships\", { error: error as Error });\n    }\n  }, [user?.uid]);\n\n  // Load invite codes\n  const loadInviteCodes = useCallback(async () => {\n    if (!user?.uid) return;\n\n    try {\n      const activeInviteCodes =\n        await KeyholderRelationshipService.getActiveInviteCodes(user.uid);\n      setState((prev) => ({ ...prev, activeInviteCodes }));\n    } catch (error) {\n      logger.error(\"Failed to load invite codes\", { error: error as Error });\n    }\n  }, [user?.uid]);\n\n  // Load relationship summary\n  const loadRelationshipSummary = useCallback(async () => {\n    if (!user?.uid) return;\n\n    try {\n      const relationshipSummary =\n        await KeyholderRelationshipService.getRelationshipSummary(user.uid);\n      setState((prev) => ({ ...prev, relationshipSummary }));\n    } catch (error) {\n      logger.error(\"Failed to load relationship summary\", {\n        error: error as Error,\n      });\n    }\n  }, [user?.uid]);\n\n  // Create invite code\n  const createInviteCode = useCallback(\n    async (expirationHours = 24): Promise<InviteCode | null> => {\n      if (!user?.uid || !user.displayName) return null;\n\n      setState((prev) => ({ ...prev, isCreatingInvite: true, message: \"\" }));\n\n      try {\n        const canCreate =\n          await KeyholderRelationshipService.canCreateInviteCode(user.uid);\n        if (!canCreate) {\n          setState((prev) => ({\n            ...prev,\n            isCreatingInvite: false,\n            message: \"You already have an active keyholder relationship\",\n            messageType: \"error\",\n          }));\n          return null;\n        }\n\n        const inviteCode = await KeyholderRelationshipService.createInviteCode(\n          user.uid,\n          user.displayName,\n          expirationHours,\n        );\n\n        setState((prev) => ({\n          ...prev,\n          isCreatingInvite: false,\n          message: `Invite code created: ${inviteCode.code}`,\n          messageType: \"success\",\n        }));\n\n        logger.info(\"Invite code created successfully\", {\n          code: inviteCode.code,\n        });\n\n        // Reload invite codes\n        await loadInviteCodes();\n\n        return inviteCode;\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to create invite code\";\n        setState((prev) => ({\n          ...prev,\n          isCreatingInvite: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to create invite code\", { error: error as Error });\n        return null;\n      }\n    },\n    [user?.uid, user?.displayName, loadInviteCodes],\n  );\n\n  // Accept invite code\n  const acceptInviteCode = useCallback(\n    async (code: string, keyholderName?: string): Promise<boolean> => {\n      if (!user?.uid) return false;\n\n      setState((prev) => ({ ...prev, isAcceptingInvite: true, message: \"\" }));\n\n      try {\n        const relationship =\n          await KeyholderRelationshipService.acceptInviteCode(\n            code,\n            user.uid,\n            keyholderName || user.displayName,\n          );\n\n        setState((prev) => ({\n          ...prev,\n          isAcceptingInvite: false,\n          message: \"Successfully linked with submissive!\",\n          messageType: \"success\",\n          inviteCodeInput: \"\",\n          keyholderNameInput: \"\",\n        }));\n\n        logger.info(\"Invite code accepted successfully\");\n\n        // Reload relationships\n        await loadRelationships();\n        await loadRelationshipSummary();\n\n        return true;\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to accept invite code\";\n        setState((prev) => ({\n          ...prev,\n          isAcceptingInvite: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to accept invite code\", { error: error as Error });\n        return false;\n      }\n    },\n    [user?.uid, user?.displayName, loadRelationships, loadRelationshipSummary],\n  );\n\n  // Revoke invite code\n  const revokeInviteCode = useCallback(\n    async (codeId: string) => {\n      if (!user?.uid) return;\n\n      try {\n        await KeyholderRelationshipService.revokeInviteCode(codeId, user.uid);\n        logger.info(\"Invite code revoked successfully\", { codeId });\n        await loadInviteCodes();\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to revoke invite code\";\n        logger.error(\"Failed to revoke invite code\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadInviteCodes],\n  );\n\n  // Update permissions\n  const updatePermissions = useCallback(\n    async (relationshipId: string, permissions: KeyholderPermissions) => {\n      if (!user?.uid) return;\n\n      setState((prev) => ({ ...prev, isUpdatingPermissions: true }));\n\n      try {\n        await KeyholderRelationshipService.updatePermissions(\n          relationshipId,\n          permissions,\n          user.uid,\n        );\n        setState((prev) => ({\n          ...prev,\n          isUpdatingPermissions: false,\n          message: \"Permissions updated successfully\",\n          messageType: \"success\",\n        }));\n        logger.info(\"Permissions updated successfully\");\n        await loadRelationships();\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to update permissions\";\n        setState((prev) => ({\n          ...prev,\n          isUpdatingPermissions: false,\n          message: errorMessage,\n          messageType: \"error\",\n        }));\n        logger.error(\"Failed to update permissions\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadRelationships],\n  );\n\n  // End relationship\n  const endRelationship = useCallback(\n    async (relationshipId: string) => {\n      if (!user?.uid) return;\n\n      try {\n        await KeyholderRelationshipService.endRelationship(\n          relationshipId,\n          user.uid,\n        );\n        logger.info(\"Relationship ended successfully\");\n        await loadRelationships();\n        await loadRelationshipSummary();\n      } catch (error) {\n        const errorMessage =\n          (error as Error).message || \"Failed to end relationship\";\n        logger.error(\"Failed to end relationship\", { error: error as Error });\n      }\n    },\n    [user?.uid, loadRelationships, loadRelationshipSummary],\n  );\n\n  // Form actions\n  const setInviteCodeInput = useCallback((code: string) => {\n    setState((prev) => ({ ...prev, inviteCodeInput: code.toUpperCase() }));\n  }, []);\n\n  const setKeyholderNameInput = useCallback((name: string) => {\n    setState((prev) => ({ ...prev, keyholderNameInput: name }));\n  }, []);\n\n  const clearMessage = useCallback(() => {\n    setState((prev) => ({ ...prev, message: \"\", messageType: \"info\" }));\n  }, []);\n\n  const clearForm = useCallback(() => {\n    setState((prev) => ({\n      ...prev,\n      inviteCodeInput: \"\",\n      keyholderNameInput: \"\",\n      message: \"\",\n      messageType: \"info\",\n    }));\n  }, []);\n\n  // Utilities\n  const validateInviteCode = useCallback((code: string): boolean => {\n    return KeyholderRelationshipService.validateInviteCodeFormat(code);\n  }, []);\n\n  const canCreateInviteCode = useCallback(async (): Promise<boolean> => {\n    if (!user?.uid) return false;\n    return await KeyholderRelationshipService.canCreateInviteCode(user.uid);\n  }, [user?.uid]);\n\n  const hasPermission = useCallback(\n    async (\n      submissiveUserId: string,\n      permission: keyof KeyholderPermissions,\n    ): Promise<boolean> => {\n      if (!user?.uid) return false;\n      return await KeyholderRelationshipService.hasPermission(\n        user.uid,\n        submissiveUserId,\n        permission,\n      );\n    },\n    [user?.uid],\n  );\n\n  // Load data on mount and user change\n  useEffect(() => {\n    if (user?.uid) {\n      loadRelationships();\n      loadInviteCodes();\n      loadRelationshipSummary();\n    } else {\n      setState(initialState);\n    }\n  }, [user?.uid]);\n\n  return {\n    ...state,\n    loadRelationships,\n    loadInviteCodes,\n    loadRelationshipSummary,\n    createInviteCode,\n    acceptInviteCode,\n    revokeInviteCode,\n    updatePermissions,\n    endRelationship,\n    setInviteCodeInput,\n    setKeyholderNameInput,\n    clearMessage,\n    clearForm,\n    validateInviteCode,\n    canCreateInviteCode,\n    hasPermission,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useLeaderboards.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":6,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":29},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (161). Maximum allowed is 75.","line":40,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":254,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userPrivacySettings' is assigned a value but never used.","line":87,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useLeaderboards Hook\n * React hook for managing leaderboard data and user participation\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { achievementDBService } from \"../services\";\nimport {\n  LeaderboardCategory,\n  LeaderboardPeriod,\n  DBLeaderboardEntry,\n} from \"../types\";\nimport { logger } from \"../utils/logging\";\n\nexport interface LeaderboardEntry {\n  id: string;\n  displayName: string;\n  value: number;\n  rank: number;\n  isCurrentUser: boolean;\n}\n\nexport interface UserRankInfo {\n  rank: number;\n  value: number;\n  totalParticipants: number;\n}\n\nexport interface LeaderboardPrivacySettings {\n  participateInGlobal: boolean;\n  participateInMonthly: boolean;\n  shareSessionTime: boolean;\n  shareStreakData: boolean;\n  shareAchievements: boolean;\n  displayName: \"real\" | \"username\" | \"anonymous\";\n  showOnPublicProfile: boolean;\n}\n\nexport const useLeaderboards = (\n  userId?: string,\n  category: LeaderboardCategory = LeaderboardCategory.TOTAL_POINTS,\n  period: LeaderboardPeriod = LeaderboardPeriod.ALL_TIME,\n) => {\n  const queryClient = useQueryClient();\n  const [privacySettings, setPrivacySettings] =\n    useState<LeaderboardPrivacySettings>({\n      participateInGlobal: false,\n      participateInMonthly: false,\n      shareSessionTime: false,\n      shareStreakData: false,\n      shareAchievements: true,\n      displayName: \"anonymous\",\n      showOnPublicProfile: false,\n    });\n\n  // ==================== QUERIES ====================\n\n  /**\n   * Get leaderboard data for a specific category and period\n   */\n  const {\n    data: rawLeaderboardData = [],\n    isLoading: isLoadingLeaderboard,\n    error: leaderboardError,\n  } = useQuery({\n    queryKey: [\"leaderboards\", category, period],\n    queryFn: () => achievementDBService.getLeaderboard(category, period),\n    enabled: true,\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's rank in the leaderboard\n   */\n  const { data: userRank, isLoading: isLoadingUserRank } = useQuery({\n    queryKey: [\"leaderboards\", \"rank\", userId, category, period],\n    queryFn: () =>\n      achievementDBService.getUserLeaderboardRank(userId!, category, period),\n    enabled: Boolean(userId),\n    staleTime: 60 * 1000, // 1 minute\n  });\n\n  /**\n   * Get user's leaderboard privacy settings\n   */\n  const { data: userPrivacySettings } = useQuery({\n    queryKey: [\"leaderboards\", \"privacy\", userId],\n    queryFn: () => achievementDBService.getLeaderboardPrivacy(userId!),\n    enabled: Boolean(userId),\n    onSuccess: (data) => {\n      if (data) {\n        setPrivacySettings(data);\n      }\n    },\n  });\n\n  // ==================== MUTATIONS ====================\n\n  /**\n   * Opt into leaderboards\n   */\n  const optInMutation = useMutation({\n    mutationFn: async () => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const defaultSettings: LeaderboardPrivacySettings = {\n        participateInGlobal: true,\n        participateInMonthly: true,\n        shareSessionTime: true,\n        shareStreakData: true,\n        shareAchievements: true,\n        displayName: \"anonymous\",\n        showOnPublicProfile: false,\n      };\n\n      await achievementDBService.updateLeaderboardPrivacy(\n        userId,\n        defaultSettings,\n      );\n      return defaultSettings;\n    },\n    onSuccess: (data) => {\n      setPrivacySettings(data);\n      queryClient.invalidateQueries({ queryKey: [\"leaderboards\"] });\n      logger.info(\"User opted into leaderboards\", \"useLeaderboards\");\n    },\n    onError: (error) => {\n      logger.error(\"Failed to opt into leaderboards\", error, \"useLeaderboards\");\n    },\n  });\n\n  /**\n   * Opt out of leaderboards\n   */\n  const optOutMutation = useMutation({\n    mutationFn: async () => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const optOutSettings: LeaderboardPrivacySettings = {\n        participateInGlobal: false,\n        participateInMonthly: false,\n        shareSessionTime: false,\n        shareStreakData: false,\n        shareAchievements: false,\n        displayName: \"anonymous\",\n        showOnPublicProfile: false,\n      };\n\n      await achievementDBService.updateLeaderboardPrivacy(\n        userId,\n        optOutSettings,\n      );\n      return optOutSettings;\n    },\n    onSuccess: (data) => {\n      setPrivacySettings(data);\n      queryClient.invalidateQueries({ queryKey: [\"leaderboards\"] });\n      logger.info(\"User opted out of leaderboards\", \"useLeaderboards\");\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to opt out of leaderboards\",\n        error,\n        \"useLeaderboards\",\n      );\n    },\n  });\n\n  /**\n   * Update leaderboard privacy settings\n   */\n  const updatePrivacyMutation = useMutation({\n    mutationFn: async (settings: Partial<LeaderboardPrivacySettings>) => {\n      if (!userId) throw new Error(\"User ID required\");\n\n      const newSettings = { ...privacySettings, ...settings };\n      await achievementDBService.updateLeaderboardPrivacy(userId, newSettings);\n      return newSettings;\n    },\n    onSuccess: (data) => {\n      setPrivacySettings(data);\n      queryClient.invalidateQueries({ queryKey: [\"leaderboards\"] });\n      logger.info(\"Updated leaderboard privacy settings\", \"useLeaderboards\");\n    },\n    onError: (error) => {\n      logger.error(\n        \"Failed to update privacy settings\",\n        error,\n        \"useLeaderboards\",\n      );\n    },\n  });\n\n  // ==================== PROCESSED DATA ====================\n\n  /**\n   * Process raw leaderboard data into displayable format\n   */\n  const leaderboardData: LeaderboardEntry[] = rawLeaderboardData.map(\n    (entry, index) => ({\n      id: entry.id,\n      displayName: getDisplayName(entry),\n      value: entry.value,\n      rank: index + 1,\n      isCurrentUser: entry.userId === userId,\n    }),\n  );\n\n  /**\n   * Generate display name based on privacy settings\n   */\n  function getDisplayName(entry: DBLeaderboardEntry): string {\n    if (entry.userId === userId) {\n      return \"You\";\n    }\n\n    switch (entry.displayNameType) {\n      case \"real\":\n        return entry.displayName || \"Unknown User\";\n      case \"username\":\n        return entry.displayName || `User_${entry.userId.slice(-6)}`;\n      case \"anonymous\":\n      default:\n        return `ChastityUser_${entry.userId.slice(-4)}`;\n    }\n  }\n\n  // ==================== PUBLIC API ====================\n\n  return {\n    // Data\n    leaderboardData,\n    userRank,\n    privacySettings,\n\n    // Loading states\n    isLoading: isLoadingLeaderboard || isLoadingUserRank,\n    error: leaderboardError,\n\n    // Actions\n    optInToLeaderboards: optInMutation.mutateAsync,\n    optOutFromLeaderboards: optOutMutation.mutateAsync,\n    updateLeaderboardPrivacy: updatePrivacyMutation.mutateAsync,\n\n    // Status\n    isOptedIn:\n      privacySettings.participateInGlobal ||\n      privacySettings.participateInMonthly,\n    isOptingIn: optInMutation.isPending,\n    isOptingOut: optOutMutation.isPending,\n    isUpdatingPrivacy: updatePrivacyMutation.isPending,\n  };\n};\n\n// Named export only - hook files should only export hooks starting with 'use'\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useOfflineDemo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/usePauseState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PauseService' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionId' is defined but never used. Allowed unused args must match /^_/u.","line":27,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refreshPauseStateRef' is assigned a value but never used.","line":33,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":29},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'refreshPauseState'. Either include it or remove the dependency array.","line":58,"column":6,"nodeType":"ArrayExpression","endLine":58,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [refreshPauseState]","fix":{"range":[1660,1662],"text":"[refreshPauseState]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'refreshPauseState'. Either include it or remove the dependency array.","line":66,"column":6,"nodeType":"ArrayExpression","endLine":66,"endColumn":35,"suggestions":[{"desc":"Update the dependencies array to be: [pauseState, refreshInterval, refreshPauseState]","fix":{"range":[1977,2006],"text":"[pauseState, refreshInterval, refreshPauseState]"}}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":66,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":66,"endColumn":17},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'refreshPauseState'. Either include it or remove the dependency array.","line":93,"column":6,"nodeType":"ArrayExpression","endLine":93,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [pauseState, refreshPauseState]","fix":{"range":[2766,2778],"text":"[pauseState, refreshPauseState]"}}]},{"ruleId":"zustand-safe-patterns/zustand-no-store-actions-in-deps","severity":2,"message":"Dangerous pattern: Store action in useEffect dependency array! This causes React error #185 infinite render loops. Zustand store actions are stable and should not be in dependency arrays. Remove store actions from the dependency array to fix this issue.","line":93,"column":7,"nodeType":"Identifier","messageId":"noStoreActionsInDeps","endLine":93,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from \"react\";\nimport {\n  PauseCooldownService,\n  PauseState,\n} from \"../services/PauseCooldownService\";\nimport { PauseService } from \"../services/PauseService\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"usePauseState\");\n\ninterface UsePauseStateProps {\n  userId: string;\n  sessionId?: string;\n  refreshInterval?: number; // milliseconds\n}\n\ninterface UsePauseStateReturn {\n  pauseState: PauseState | null;\n  isLoading: boolean;\n  error: string | null;\n  refreshPauseState: () => Promise<void>;\n  canPause: boolean;\n}\n\nexport const usePauseState = ({\n  userId,\n  sessionId,\n  refreshInterval = 30000, // 30 seconds\n}: UsePauseStateProps): UsePauseStateReturn => {\n  const [pauseState, setPauseState] = useState<PauseState | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const refreshPauseStateRef = useRef<() => Promise<void>>();\n\n  const refreshPauseState = useCallback(async () => {\n    if (!userId) return;\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const state = await PauseCooldownService.canUserPause(userId);\n      setPauseState(state);\n      logger.debug(\"Pause state refreshed\", { userId, state });\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to check pause state\";\n      setError(errorMessage);\n      logger.error(\"Failed to refresh pause state\", { error: err, userId });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId]);\n\n  // Initial load\n  useEffect(() => {\n    refreshPauseState();\n  }, []); // refreshPauseState is stable (useCallback), omitted to prevent infinite loops\n\n  // Auto-refresh for cooldown countdown\n  useEffect(() => {\n    if (!pauseState || pauseState.canPause) return;\n\n    const interval = setInterval(refreshPauseState, refreshInterval);\n    return () => clearInterval(interval);\n  }, [pauseState, refreshInterval]); // refreshPauseState is stable (useCallback), omitted to prevent infinite loops\n\n  // Real-time cooldown countdown\n  useEffect(() => {\n    if (!pauseState || pauseState.canPause || !pauseState.cooldownRemaining)\n      return;\n\n    const interval = setInterval(() => {\n      setPauseState((prev) => {\n        if (!prev || prev.canPause || !prev.cooldownRemaining) return prev;\n\n        const newCooldown = Math.max(0, prev.cooldownRemaining - 1);\n\n        if (newCooldown === 0) {\n          // Cooldown expired, refresh from server\n          refreshPauseState();\n          return prev;\n        }\n\n        return {\n          ...prev,\n          cooldownRemaining: newCooldown,\n        };\n      });\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [pauseState]); // refreshPauseState is stable (useCallback), omitted to prevent infinite loops\n\n  return {\n    pauseState,\n    isLoading,\n    error,\n    refreshPauseState,\n    canPause: pauseState?.canPause ?? false,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useRelationships.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipStatus' is defined but never used.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipChastityData' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipSession' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2744,2747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2744,2747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'useRelationships' has too many lines (169). Maximum allowed is 75.","line":107,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":307,"endColumn":2},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'relationshipStatus' and 'relationshipTasks'. Either include them or remove the dependency array.","line":124,"column":6,"nodeType":"ArrayExpression","endLine":124,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [relationshipList.activeRelationship, relationshipStatus, relationshipTasks]","fix":{"range":[3634,3671],"text":"[relationshipList.activeRelationship, relationshipStatus, relationshipTasks]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chastityData' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tasks' is defined but never used. Allowed unused args must match /^_/u.","line":143,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":143,"endColumn":13},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'relationshipStatus' and 'relationshipTasks'. Either include them or remove the dependency array.","line":153,"column":6,"nodeType":"ArrayExpression","endLine":153,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [relationshipList.activeRelationship, relationshipStatus, relationshipTasks]","fix":{"range":[4498,4535],"text":"[relationshipList.activeRelationship, relationshipStatus, relationshipTasks]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hasError' is assigned a value but never used.","line":179,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7753,7756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7753,7756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Relationship Management (Composed)\n * Provides state management and actions for the dual-account keyholder system\n * Refactored to use focused hooks for better maintainability\n */\nimport { useEffect, useCallback, useMemo } from \"react\";\nimport { relationshipChastityService } from \"@/services/database/RelationshipChastityService\";\nimport {\n  RelationshipStatus,\n  RelationshipChastityData,\n  RelationshipTask,\n  RelationshipEvent,\n  RelationshipSession,\n  RelationshipPermissions,\n} from \"@/types/relationships\";\nimport {\n  useRelationshipList,\n  useRelationshipInvites,\n  useRelationshipActions,\n  useRelationshipStatus,\n  useRelationshipPermissions,\n  useRelationshipTasks,\n  useRelationshipValidation,\n} from \"./relationships\";\n\n// Re-export types from the shared types file\nexport type {\n  RelationshipState,\n  BaseHookState,\n  BaseHookActions,\n} from \"./relationships/types\";\n\n// Maintain backward compatibility with the original interface\nexport interface RelationshipActions {\n  // Relationship management\n  sendRelationshipRequest: (\n    targetUserId: string,\n    role: \"submissive\" | \"keyholder\",\n    message?: string,\n  ) => Promise<void>;\n  acceptRelationshipRequest: (requestId: string) => Promise<void>;\n  rejectRelationshipRequest: (requestId: string) => Promise<void>;\n  endRelationship: (relationshipId: string) => Promise<void>;\n  updatePermissions: (\n    relationshipId: string,\n    permissions: RelationshipPermissions,\n  ) => Promise<void>;\n\n  // Session management\n  startSession: (\n    relationshipId: string,\n    options?: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    },\n  ) => Promise<void>;\n  endSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  pauseSession: (\n    relationshipId: string,\n    sessionId: string,\n    reason?: string,\n  ) => Promise<void>;\n  resumeSession: (relationshipId: string, sessionId: string) => Promise<void>;\n\n  // Task management\n  createTask: (\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n  ) => Promise<void>;\n  updateTaskStatus: (\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTask[\"status\"],\n    note?: string,\n  ) => Promise<void>;\n\n  // Event logging\n  logEvent: (\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n  ) => Promise<void>;\n\n  // Migration\n  migrateSingleUserData: () => Promise<void>;\n  checkMigrationStatus: () => Promise<void>;\n\n  // Utility\n  setActiveRelationship: (relationship: any) => void;\n  refreshData: () => Promise<void>;\n  clearError: () => void;\n}\n\nexport function useRelationships() {\n  // Use focused hooks for specific functionalities\n  const relationshipList = useRelationshipList();\n  const relationshipInvites = useRelationshipInvites();\n  const relationshipActions = useRelationshipActions();\n  const relationshipStatus = useRelationshipStatus();\n  const relationshipPermissions = useRelationshipPermissions();\n  const relationshipTasks = useRelationshipTasks();\n  const relationshipValidation = useRelationshipValidation();\n\n  // Load data for active relationship when it changes\n  useEffect(() => {\n    if (relationshipList.activeRelationship) {\n      const relationshipId = relationshipList.activeRelationship.id;\n      relationshipStatus.loadRelationshipData(relationshipId);\n      relationshipTasks.loadRelationshipData(relationshipId);\n    }\n  }, [relationshipList.activeRelationship]);\n\n  // Set up real-time listeners for active relationship data\n  useEffect(() => {\n    if (!relationshipList.activeRelationship) return;\n\n    const relationshipId = relationshipList.activeRelationship.id;\n\n    const unsubscribeChastityData =\n      relationshipChastityService.subscribeToChastityData(\n        relationshipId,\n        (chastityData) => {\n          // Update the status hook with new data\n          relationshipStatus.loadRelationshipData(relationshipId);\n        },\n      );\n\n    const unsubscribeTasks = relationshipChastityService.subscribeToTasks(\n      relationshipId,\n      (tasks) => {\n        // Update the tasks hook with new data\n        relationshipTasks.loadRelationshipData(relationshipId);\n      },\n    );\n\n    return () => {\n      unsubscribeChastityData();\n      unsubscribeTasks();\n    };\n  }, [relationshipList.activeRelationship]);\n\n  // Enhanced refresh function that coordinates all hooks\n  const refreshData = useCallback(async () => {\n    await Promise.all([\n      relationshipList.refreshRelationships(),\n      relationshipInvites.refreshPendingRequests(),\n      relationshipValidation.checkMigrationStatus(),\n    ]);\n\n    if (relationshipList.activeRelationship) {\n      const relationshipId = relationshipList.activeRelationship.id;\n      await Promise.all([\n        relationshipStatus.loadRelationshipData(relationshipId),\n        relationshipTasks.loadRelationshipData(relationshipId),\n      ]);\n    }\n  }, [\n    relationshipList,\n    relationshipInvites,\n    relationshipValidation,\n    relationshipStatus,\n    relationshipTasks,\n  ]);\n\n  // Unified error handling - combine errors from all hooks\n  const hasError = useMemo(() => {\n    return !!(\n      relationshipList.error ||\n      relationshipInvites.error ||\n      relationshipActions.error ||\n      relationshipStatus.error ||\n      relationshipPermissions.error ||\n      relationshipTasks.error ||\n      relationshipValidation.error\n    );\n  }, [\n    relationshipList.error,\n    relationshipInvites.error,\n    relationshipActions.error,\n    relationshipStatus.error,\n    relationshipPermissions.error,\n    relationshipTasks.error,\n    relationshipValidation.error,\n  ]);\n\n  const combinedError = useMemo(() => {\n    const errors = [\n      relationshipList.error,\n      relationshipInvites.error,\n      relationshipActions.error,\n      relationshipStatus.error,\n      relationshipPermissions.error,\n      relationshipTasks.error,\n      relationshipValidation.error,\n    ].filter(Boolean);\n\n    return errors.length > 0 ? errors[0] : null;\n  }, [\n    relationshipList.error,\n    relationshipInvites.error,\n    relationshipActions.error,\n    relationshipStatus.error,\n    relationshipPermissions.error,\n    relationshipTasks.error,\n    relationshipValidation.error,\n  ]);\n\n  // Unified loading state - true if any hook is loading\n  const isLoading = useMemo(() => {\n    return !!(\n      relationshipList.isLoading ||\n      relationshipInvites.isLoading ||\n      relationshipActions.isLoading ||\n      relationshipStatus.isLoading ||\n      relationshipPermissions.isLoading ||\n      relationshipTasks.isLoading ||\n      relationshipValidation.isLoading\n    );\n  }, [\n    relationshipList.isLoading,\n    relationshipInvites.isLoading,\n    relationshipActions.isLoading,\n    relationshipStatus.isLoading,\n    relationshipPermissions.isLoading,\n    relationshipTasks.isLoading,\n    relationshipValidation.isLoading,\n  ]);\n\n  // Unified clear error function\n  const clearError = useCallback(() => {\n    relationshipList.clearError();\n    relationshipInvites.clearError();\n    relationshipActions.clearError();\n    relationshipStatus.clearError();\n    relationshipPermissions.clearError();\n    relationshipTasks.clearError();\n    relationshipValidation.clearError();\n  }, [\n    relationshipList,\n    relationshipInvites,\n    relationshipActions,\n    relationshipStatus,\n    relationshipPermissions,\n    relationshipTasks,\n    relationshipValidation,\n  ]);\n\n  // Enhanced setActiveRelationship that clears data when switching\n  const setActiveRelationship = useCallback(\n    (relationship: any) => {\n      relationshipList.setActiveRelationship(relationship);\n\n      // Clear old data when switching relationships\n      if (!relationship) {\n        // Data will be automatically cleared since hooks are reactive\n      }\n    },\n    [relationshipList],\n  );\n\n  // Return combined state and actions for backward compatibility\n  return {\n    // Combined state - maintaining backward compatibility\n    relationships: relationshipList.relationships,\n    pendingRequests: relationshipInvites.pendingRequests,\n    activeRelationship: relationshipList.activeRelationship,\n    chastityData: relationshipStatus.chastityData,\n    tasks: relationshipTasks.tasks,\n    events: relationshipTasks.events,\n    sessions: relationshipStatus.sessions,\n    isLoading,\n    error: combinedError,\n    needsMigration: relationshipValidation.needsMigration,\n\n    // Combined actions - maintaining backward compatibility\n    sendRelationshipRequest: relationshipInvites.sendRelationshipRequest,\n    acceptRelationshipRequest: relationshipActions.acceptRelationshipRequest,\n    rejectRelationshipRequest: relationshipActions.rejectRelationshipRequest,\n    endRelationship: relationshipActions.endRelationship,\n    updatePermissions: relationshipPermissions.updatePermissions,\n    startSession: relationshipStatus.startSession,\n    endSession: relationshipStatus.endSession,\n    pauseSession: relationshipStatus.pauseSession,\n    resumeSession: relationshipStatus.resumeSession,\n    createTask: relationshipTasks.createTask,\n    updateTaskStatus: relationshipTasks.updateTaskStatus,\n    logEvent: relationshipTasks.logEvent,\n    migrateSingleUserData: relationshipValidation.migrateSingleUserData,\n    checkMigrationStatus: relationshipValidation.checkMigrationStatus,\n    setActiveRelationship,\n    refreshData,\n    clearError,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/hooks/useSync.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (99). Maximum allowed is 75.","line":27,"column":24,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":154,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3502,3505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3502,3505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSync Hook\n * Manages synchronization state and conflict resolution\n */\nimport { useState, useEffect, useCallback } from \"react\";\nimport { firebaseSync } from \"@/services/sync\";\nimport type { SyncResult, ConflictInfo, SyncOptions } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"useSync\");\n\ninterface UseSyncState {\n  isSyncing: boolean;\n  lastSyncResult: SyncResult | null;\n  pendingConflicts: ConflictInfo[];\n  error: Error | null;\n}\n\ninterface UseSyncActions {\n  sync: (userId: string, options?: SyncOptions) => Promise<SyncResult>;\n  resolveConflicts: (\n    resolutions: Record<string, \"local\" | \"remote\">,\n  ) => Promise<void>;\n  clearError: () => void;\n}\n\nexport const useSync = (): UseSyncState & UseSyncActions => {\n  const [state, setState] = useState<UseSyncState>({\n    isSyncing: false,\n    lastSyncResult: null,\n    pendingConflicts: [],\n    error: null,\n  });\n\n  // Check for pending conflicts on mount\n  useEffect(() => {\n    const checkPendingConflicts = () => {\n      const conflicts = firebaseSync.getPendingConflicts();\n      setState((prev) => ({ ...prev, pendingConflicts: conflicts }));\n    };\n\n    checkPendingConflicts();\n\n    // Check periodically for conflicts\n    const interval = setInterval(checkPendingConflicts, 30000); // Every 30 seconds\n\n    return () => clearInterval(interval);\n  }, []);\n\n  const sync = useCallback(\n    async (userId: string, options?: SyncOptions): Promise<SyncResult> => {\n      setState((prev) => ({ ...prev, isSyncing: true, error: null }));\n\n      try {\n        logger.info(\"Starting sync\", { userId, options });\n        const result = await firebaseSync.syncUserData(userId, options);\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          lastSyncResult: result,\n          pendingConflicts:\n            result.conflicts.length > 0\n              ? result.conflicts\n              : prev.pendingConflicts,\n        }));\n\n        logger.info(\"Sync completed\", {\n          success: result.success,\n          conflicts: result.conflicts.length,\n        });\n\n        return result;\n      } catch (error) {\n        const err = error as Error;\n        logger.error(\"Sync failed\", { error: err });\n\n        setState((prev) => ({\n          ...prev,\n          isSyncing: false,\n          error: err,\n        }));\n\n        throw error;\n      }\n    },\n    [],\n  );\n\n  const resolveConflicts = useCallback(\n    async (resolutions: Record<string, \"local\" | \"remote\">): Promise<void> => {\n      try {\n        logger.info(\"Resolving conflicts\", {\n          resolutionCount: Object.keys(resolutions).length,\n        });\n\n        // Apply resolutions (implementation would depend on specific conflict resolution logic)\n        const resolvedIds: string[] = [];\n\n        for (const [conflictKey, resolution] of Object.entries(resolutions)) {\n          // conflictKey format: \"collection-documentId-index\" or similar\n          const conflict = state.pendingConflicts.find(\n            (c) =>\n              `${c.collection}-${c.documentId}` ===\n              conflictKey.split(\"-\").slice(0, 2).join(\"-\"),\n          );\n\n          if (conflict) {\n            // Apply the chosen resolution\n            const dataToApply =\n              resolution === \"local\" ? conflict.localData : conflict.remoteData;\n\n            // Update both local and remote with chosen data\n            await firebaseSync.applyRemoteChanges(conflict.collection, [\n              dataToApply as any,\n            ]);\n\n            resolvedIds.push(`${conflict.collection}-${conflict.documentId}`);\n          }\n        }\n\n        // Clear resolved conflicts\n        firebaseSync.clearResolvedConflicts(resolvedIds);\n\n        setState((prev) => ({\n          ...prev,\n          pendingConflicts: prev.pendingConflicts.filter(\n            (c) => !resolvedIds.includes(`${c.collection}-${c.documentId}`),\n          ),\n        }));\n\n        logger.info(\"Conflicts resolved\", {\n          resolvedCount: resolvedIds.length,\n        });\n      } catch (error) {\n        logger.error(\"Failed to resolve conflicts\", { error: error as Error });\n        setState((prev) => ({ ...prev, error: error as Error }));\n        throw error;\n      }\n    },\n    [state.pendingConflicts],\n  );\n\n  const clearError = useCallback(() => {\n    setState((prev) => ({ ...prev, error: null }));\n  }, []);\n\n  return {\n    ...state,\n    sync,\n    resolveConflicts,\n    clearError,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/AchievementPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (114). Maximum allowed is 75.","line":25,"column":42,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":148,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'allAchievements' is assigned a value but never used.","line":30,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Page\n * Dedicated page for viewing and managing achievements\n */\n\nimport React, { useState } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { useAchievements } from \"../hooks/useAchievements\";\nimport {\n  AchievementGallery,\n  AchievementDashboard,\n} from \"../components/achievements\";\nimport LeaderboardView from \"../components/achievements/LeaderboardView\";\nimport AchievementPrivacySettings from \"../components/achievements/AchievementPrivacySettings\";\nimport {\n  FaTrophy,\n  FaList,\n  FaChartBar,\n  FaUsers,\n  FaCog,\n} from \"../utils/iconImport\";\n\ntype ViewMode = \"dashboard\" | \"gallery\" | \"leaderboards\" | \"privacy\";\n\nexport const AchievementPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [viewMode, setViewMode] = useState<ViewMode>(\"dashboard\");\n\n  const {\n    allAchievements,\n    getAchievementsWithProgress,\n    toggleAchievementVisibility,\n    isLoading,\n  } = useAchievements(user?.uid);\n\n  if (!user) {\n    return (\n      <div className=\"text-nightly-spring-green\">\n        <div className=\"flex items-center justify-center py-20\">\n          <div className=\"text-center\">\n            <FaTrophy className=\"text-4xl text-nightly-celadon/50 mb-4 mx-auto\" />\n            <div className=\"text-nightly-celadon\">\n              Please sign in to view achievements\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (isLoading) {\n    return (\n      <div className=\"text-nightly-spring-green\">\n        <div className=\"flex items-center justify-center py-20\">\n          <div className=\"text-center\">\n            <div className=\"animate-spin w-8 h-8 border-2 border-nightly-aquamarine border-t-transparent rounded-full mb-4 mx-auto\"></div>\n            <div className=\"text-nightly-celadon\">Loading achievements...</div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const achievementsWithProgress = getAchievementsWithProgress();\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      <div className=\"p-4 max-w-6xl mx-auto\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between mb-6\">\n          <div className=\"flex items-center space-x-3\">\n            <FaTrophy className=\"text-3xl text-nightly-lavender-floral\" />\n            <h1 className=\"text-3xl font-bold text-nightly-honeydew\">\n              Achievements\n            </h1>\n          </div>\n\n          {/* View Mode Toggle */}\n          <div className=\"flex items-center bg-white/10 rounded-lg p-1\">\n            <button\n              onClick={() => setViewMode(\"dashboard\")}\n              className={`flex items-center space-x-2 px-3 py-2 rounded-md text-sm transition-colors ${\n                viewMode === \"dashboard\"\n                  ? \"bg-nightly-aquamarine text-black font-semibold\"\n                  : \"text-nightly-celadon hover:text-nightly-honeydew\"\n              }`}\n            >\n              <FaChartBar />\n              <span>Dashboard</span>\n            </button>\n            <button\n              onClick={() => setViewMode(\"gallery\")}\n              className={`flex items-center space-x-2 px-3 py-2 rounded-md text-sm transition-colors ${\n                viewMode === \"gallery\"\n                  ? \"bg-nightly-aquamarine text-black font-semibold\"\n                  : \"text-nightly-celadon hover:text-nightly-honeydew\"\n              }`}\n            >\n              <FaList />\n              <span>Gallery</span>\n            </button>\n            <button\n              onClick={() => setViewMode(\"leaderboards\")}\n              className={`flex items-center space-x-2 px-3 py-2 rounded-md text-sm transition-colors ${\n                viewMode === \"leaderboards\"\n                  ? \"bg-nightly-aquamarine text-black font-semibold\"\n                  : \"text-nightly-celadon hover:text-nightly-honeydew\"\n              }`}\n            >\n              <FaUsers />\n              <span>Leaderboards</span>\n            </button>\n            <button\n              onClick={() => setViewMode(\"privacy\")}\n              className={`flex items-center space-x-2 px-3 py-2 rounded-md text-sm transition-colors ${\n                viewMode === \"privacy\"\n                  ? \"bg-nightly-aquamarine text-black font-semibold\"\n                  : \"text-nightly-celadon hover:text-nightly-honeydew\"\n              }`}\n            >\n              <FaCog />\n              <span>Privacy</span>\n            </button>\n          </div>\n        </div>\n\n        {/* Content */}\n        {viewMode === \"dashboard\" && <AchievementDashboard />}\n\n        {viewMode === \"gallery\" && (\n          <AchievementGallery\n            achievementsWithProgress={achievementsWithProgress}\n            onToggleVisibility={toggleAchievementVisibility}\n            isOwnGallery={true}\n          />\n        )}\n\n        {viewMode === \"leaderboards\" && <LeaderboardView />}\n\n        {viewMode === \"privacy\" && (\n          <AchievementPrivacySettings\n            onClose={() => setViewMode(\"dashboard\")}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default AchievementPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/ChastityTracking.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EmergencyUnlockModal' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":30},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (148). Maximum allowed is 75.","line":16,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":194,"endColumn":2},{"ruleId":"max-statements","severity":1,"message":"Arrow function has too many statements (36). Maximum allowed is 25.","line":16,"column":31,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":194,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1093,1096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1093,1096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { EmergencyUnlockModal } from \"../components/tracker/EmergencyUnlockModal\";\nimport { RestoreSessionPrompt } from \"../components/tracker/RestoreSessionPrompt\";\nimport { TrackerStats } from \"../components/tracker/TrackerStats\";\nimport { ActionButtons } from \"../components/tracker/ActionButtons\";\nimport { PauseResumeButtons } from \"../components/tracker/PauseResumeButtons\";\n// TODO: CooldownTimer temporarily disabled due to service import restrictions\n// import { CooldownTimer } from \"../components/tracker/CooldownTimer\";\nimport { ReasonModals } from \"../components/tracker/ReasonModals\";\nimport { TrackerHeader } from \"../components/tracker/TrackerHeader\";\nimport { logger } from \"../utils/logging\";\n// TODO: Replace with proper hook pattern\n// import { usePauseState } from \"../hooks/usePauseState\";\n// import { SessionService } from \"../services/api/session-service\";\n\nconst TrackerPage: React.FC = () => {\n  // Mock data - in a real app this would come from context/hooks\n  const [currentSession, setCurrentSession] = useState<any>(null);\n  const [userId] = useState(\"user123\"); // This would come from auth context\n\n  // TODO: Replace with proper hook pattern\n  // const {\n  //   pauseState,\n  //   isLoading: pauseStateLoading,\n  //   error: pauseStateError,\n  //   refreshPauseState,\n  // } = usePauseState({ userId, sessionId: currentSession?.id });\n\n  // Mock pause state data for now\n  const pauseState = { canPause: true, cooldownRemaining: undefined };\n  const pauseStateLoading = false;\n  const pauseStateError = null;\n  const refreshPauseState = () => {};\n\n  // Mock session data - replace with real session management\n  const isCageOn = true;\n  const isPaused = false;\n  const remainingGoalTime = 3600;\n  const keyholderName = \"Keyholder\";\n  const savedSubmissivesName = \"Submissive\";\n  const requiredKeyholderDurationSeconds = 7200;\n  const mainChastityDisplayTime = 3600;\n  const topBoxLabel = \"Total Locked Time\";\n  const topBoxTime = \"1d 2h 3m\";\n  const livePauseDuration = 0;\n  const accumulatedPauseTimeThisSession = 0;\n  const timeCageOff = 0;\n  const totalChastityTime = 86400;\n  const totalTimeCageOff = 0;\n  const showRestoreSessionPrompt = false;\n  const pauseCooldownMessage = null;\n  const denialCooldownActive = false;\n  const hasPendingReleaseRequest = false;\n  const isGoalActive = true;\n  const isHardcoreGoal = false;\n  const showReasonModal = false;\n  const showPauseReasonModal = false;\n  const showEmergencyUnlockModal = false;\n\n  // Mock session data for emergency unlock\n  const sessionId = \"mock-session-123\";\n\n  const handleEmergencyUnlock = () => {\n    // This would typically refresh the session state or redirect\n    logger.info(\"Emergency unlock completed - refreshing session state\", {\n      sessionId,\n      userId,\n    });\n  };\n\n  // Initialize mock session\n  useEffect(() => {\n    setCurrentSession({\n      id: \"session123\",\n      userId: \"user123\",\n      startTime: new Date(Date.now() - 86400000), // 1 day ago\n      isPaused: false,\n      accumulatedPauseTime: 0,\n    });\n  }, []);\n\n  const handlePause = () => {\n    logger.info(\"Session paused\", { sessionId: currentSession?.id, userId });\n    refreshPauseState();\n  };\n\n  const handleResume = () => {\n    logger.info(\"Session resumed\", { sessionId: currentSession?.id, userId });\n    refreshPauseState();\n  };\n\n  // Override pause state for demo - show that pause is available\n  const mockPauseState = {\n    canPause: true,\n    lastPauseTime: undefined,\n    nextPauseAvailable: undefined,\n    cooldownRemaining: undefined,\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {showRestoreSessionPrompt && (\n        <RestoreSessionPrompt onConfirm={() => {}} onDiscard={() => {}} />\n      )}\n\n      <TrackerHeader\n        remainingGoalTime={remainingGoalTime}\n        keyholderName={keyholderName}\n        savedSubmissivesName={savedSubmissivesName}\n        requiredKeyholderDurationSeconds={requiredKeyholderDurationSeconds}\n        isCageOn={isCageOn}\n        denialCooldownActive={denialCooldownActive}\n        pauseCooldownMessage={pauseCooldownMessage}\n      />\n\n      <TrackerStats\n        mainChastityDisplayTime={mainChastityDisplayTime}\n        topBoxLabel={topBoxLabel}\n        topBoxTime={topBoxTime}\n        livePauseDuration={livePauseDuration}\n        accumulatedPauseTimeThisSession={accumulatedPauseTimeThisSession}\n        timeCageOff={timeCageOff}\n        isCageOn={isCageOn}\n        totalChastityTime={totalChastityTime}\n        totalTimeCageOff={totalTimeCageOff}\n      />\n\n      {/* Enhanced Pause Controls with 4-hour cooldown */}\n      {isCageOn && currentSession && (\n        <>\n          {pauseState &&\n            !pauseState.canPause &&\n            pauseState.cooldownRemaining && (\n              <div className=\"mx-4 text-center\">\n                {/* TODO: Replace with proper CooldownTimer component */}\n                <div className=\"text-yellow-600\">\n                  Cooldown: {pauseState.cooldownRemaining}s remaining\n                </div>\n              </div>\n            )}\n\n          <PauseResumeButtons\n            sessionId={currentSession.id}\n            userId={userId}\n            isPaused={isPaused}\n            pauseState={mockPauseState} // Use mock state to show functionality\n            onPause={handlePause}\n            onResume={handleResume}\n          />\n        </>\n      )}\n\n      <ActionButtons\n        isCageOn={isCageOn}\n        isPaused={isPaused}\n        denialCooldownActive={denialCooldownActive}\n        hasPendingReleaseRequest={hasPendingReleaseRequest}\n        isGoalActive={isGoalActive}\n        isHardcoreGoal={isHardcoreGoal}\n        requiredKeyholderDurationSeconds={requiredKeyholderDurationSeconds}\n        sessionId={sessionId}\n        userId={userId}\n        onEmergencyUnlock={handleEmergencyUnlock}\n      />\n\n      <ReasonModals\n        showReasonModal={showReasonModal}\n        showPauseReasonModal={showPauseReasonModal}\n        showEmergencyUnlockModal={showEmergencyUnlockModal}\n      />\n\n      {/* Debug info for development */}\n      {process.env.NODE_ENV === \"development\" && (\n        <div className=\"mt-8 p-4 bg-gray-800 rounded-lg text-xs\">\n          <h4 className=\"text-yellow-400 font-bold mb-2\">Debug: Pause State</h4>\n          <pre className=\"text-gray-300\">\n            {JSON.stringify(\n              {\n                canPause: pauseState?.canPause,\n                cooldownRemaining: pauseState?.cooldownRemaining,\n                lastPauseTime: pauseState?.lastPauseTime,\n                nextPauseAvailable: pauseState?.nextPauseAvailable,\n                isLoading: pauseStateLoading,\n                error: pauseStateError,\n              },\n              null,\n              2,\n            )}\n          </pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TrackerPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/Dashboard.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (91). Maximum allowed is 75.","line":10,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":110,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { FeatureCard } from \"../components/dashboard/FeatureCard\";\nimport { AchievementDashboard } from \"../components/achievements\";\n// TODO: DexieDemo temporarily disabled due to architectural restrictions\n// import { DexieDemo } from \"../components/common\";\nimport { sessionDBService } from \"../services/database\";\nimport { useAuthState } from \"../contexts\";\n\nconst Dashboard: React.FC = () => {\n  const { user } = useAuthState();\n  const [sessionDuration, setSessionDuration] = useState(\"0s\");\n\n  useEffect(() => {\n    if (user) {\n      const fetchSession = async () => {\n        const session = await sessionDBService.getCurrentSession(user.uid);\n        if (session) {\n          // This is a simplified duration calculation. A more robust solution would be needed.\n          const duration = Math.floor(\n            (new Date().getTime() - session.startTime.getTime()) / 1000,\n          );\n          setSessionDuration(`${duration}s`);\n        }\n      };\n      fetchSession();\n    }\n  }, [user]);\n\n  return (\n    <>\n      <main>\n        {/* Enhanced title with glass effect */}\n        <div className=\"text-center mb-12\">\n          <h1 className=\"text-5xl font-bold bg-gradient-to-r from-white via-blue-200 to-purple-200 bg-clip-text text-transparent mb-4 glass-float\">\n            Welcome to ChastityOS Dashboard\n          </h1>\n          <div className=\"w-24 h-1 bg-gradient-to-r from-blue-400 to-purple-400 mx-auto rounded-full\"></div>\n        </div>\n\n        {/* Feature cards with enhanced spacing and glass effects */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-8 mb-12\">\n          <Link\n            to=\"/chastity-tracking\"\n            className=\"transform transition-transform hover:scale-[1.02]\"\n          >\n            <FeatureCard\n              title=\"Chastity Tracker\"\n              description={`Current Session: ${sessionDuration}`}\n              accentColor=\"orange\"\n            />\n          </Link>\n          <Link\n            to=\"/log-event\"\n            className=\"transform transition-transform hover:scale-[1.02]\"\n          >\n            <FeatureCard\n              title=\"Log Event\"\n              description=\"Record new events\"\n              accentColor=\"purple\"\n            />\n          </Link>\n          <Link\n            to=\"/tasks\"\n            className=\"transform transition-transform hover:scale-[1.02]\"\n          >\n            <FeatureCard\n              title=\"Tasks\"\n              description=\"View upcoming tasks\"\n              accentColor=\"purple\"\n            />\n          </Link>\n          <Link\n            to=\"/full-report\"\n            className=\"transform transition-transform hover:scale-[1.02]\"\n          >\n            <FeatureCard\n              title=\"Full Report\"\n              description=\"Analyze your journey\"\n              accentColor=\"orange\"\n            />\n          </Link>\n        </div>\n\n        {/* Achievement Dashboard */}\n        {user && (\n          <div className=\"mt-12\">\n            <AchievementDashboard />\n          </div>\n        )}\n\n        {/* TODO: Dexie Offline Demo temporarily disabled due to architectural restrictions */}\n        {/* <div className=\"mb-8\">\n          <div className=\"glass-card\">\n            <DexieDemo />\n          </div>\n        </div> */}\n\n        {/* Enhanced Keyholder access button */}\n        <div className=\"text-center\">\n          <Link to=\"/keyholder\">\n            <button className=\"glass-button bg-gradient-to-r from-purple-600/80 to-pink-600/80 text-white px-8 py-4 text-lg font-bold transition-all duration-300 hover:from-purple-500/90 hover:to-pink-500/90 shadow-xl hover:shadow-purple-500/25 transform hover:scale-105\">\n              View Keyholder Dashboard\n            </button>\n          </Link>\n        </div>\n      </main>\n    </>\n  );\n};\n\nexport default Dashboard;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/FullReportPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (108). Maximum allowed is 75.","line":26,"column":6,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":145,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (104). Maximum allowed is 75.","line":153,"column":6,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":264,"endColumn":2},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (106). Maximum allowed is 75.","line":267,"column":68,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":382,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport {\n  sessionDBService,\n  eventDBService,\n  taskDBService,\n  goalDBService,\n} from \"../services/database\";\nimport type { DBSession, DBEvent, DBTask, DBGoal } from \"../types/database\";\nimport { logger } from \"../utils/logging\";\nimport {\n  FaClock,\n  FaPlay,\n  FaPause,\n  FaStop,\n  FaTrophy,\n  FaCalendar,\n  FaChartBar,\n  FaHistory,\n  FaSpinner,\n} from \"../utils/iconImport\";\n\n// Current Status Section\nconst CurrentStatusSection: React.FC<{\n  currentSession: DBSession | null;\n}> = ({ currentSession }) => {\n  const [currentTime, setCurrentTime] = useState(new Date());\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCurrentTime(new Date());\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const formatDuration = (seconds: number) => {\n    const days = Math.floor(seconds / (24 * 60 * 60));\n    const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));\n    const minutes = Math.floor((seconds % (60 * 60)) / 60);\n    const secs = seconds % 60;\n\n    if (days > 0) {\n      return `${days}d ${hours}h ${minutes}m ${secs}s`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes}m ${secs}s`;\n    } else {\n      return `${minutes}m ${secs}s`;\n    }\n  };\n\n  const getCurrentSessionDuration = () => {\n    if (!currentSession) return 0;\n\n    const startTime = currentSession.startTime.getTime();\n    const now = currentTime.getTime();\n    const totalDuration = Math.floor((now - startTime) / 1000);\n\n    // Subtract accumulated pause time\n    return Math.max(0, totalDuration - currentSession.accumulatedPauseTime);\n  };\n\n  const getSessionStatus = () => {\n    if (!currentSession)\n      return {\n        status: \"No Active Session\",\n        icon: FaStop,\n        color: \"text-gray-400\",\n      };\n    if (currentSession.isPaused)\n      return { status: \"Paused\", icon: FaPause, color: \"text-yellow-400\" };\n    return { status: \"Active\", icon: FaPlay, color: \"text-green-400\" };\n  };\n\n  const sessionStatus = getSessionStatus();\n  const StatusIcon = sessionStatus.icon;\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-6\">\n        <FaClock className=\"text-nightly-aquamarine\" />\n        <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n          Current Status\n        </h2>\n      </div>\n\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n        {/* Session Status */}\n        <div className=\"text-center\">\n          <div className=\"flex items-center justify-center gap-2 mb-2\">\n            <StatusIcon className={sessionStatus.color} />\n            <span className={`text-lg font-medium ${sessionStatus.color}`}>\n              {sessionStatus.status}\n            </span>\n          </div>\n          {currentSession && (\n            <>\n              <div className=\"text-3xl font-mono text-nightly-honeydew mb-2\">\n                {formatDuration(getCurrentSessionDuration())}\n              </div>\n              <div className=\"text-sm text-nightly-celadon\">\n                Started: {currentSession.startTime.toLocaleDateString()}{\" \"}\n                {currentSession.startTime.toLocaleTimeString()}\n              </div>\n              {currentSession.goalDuration && (\n                <div className=\"text-sm text-nightly-celadon\">\n                  Goal: {formatDuration(currentSession.goalDuration)}\n                </div>\n              )}\n            </>\n          )}\n        </div>\n\n        {/* Session Details */}\n        <div className=\"space-y-3\">\n          {currentSession && (\n            <>\n              <div className=\"flex justify-between\">\n                <span className=\"text-nightly-celadon\">Mode:</span>\n                <span className=\"text-nightly-honeydew\">\n                  {currentSession.isHardcoreMode ? \"Hardcore\" : \"Normal\"}\n                </span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span className=\"text-nightly-celadon\">Pause Time:</span>\n                <span className=\"text-nightly-honeydew\">\n                  {formatDuration(currentSession.accumulatedPauseTime)}\n                </span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span className=\"text-nightly-celadon\">\n                  Keyholder Approval:\n                </span>\n                <span className=\"text-nightly-honeydew\">\n                  {currentSession.keyholderApprovalRequired\n                    ? \"Required\"\n                    : \"Not Required\"}\n                </span>\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Statistics Section\nconst StatisticsSection: React.FC<{\n  sessions: DBSession[];\n  events: DBEvent[];\n  tasks: DBTask[];\n  goals: DBGoal[];\n}> = ({ sessions, events, tasks, goals }) => {\n  const stats = useMemo(() => {\n    const completedSessions = sessions.filter((s) => s.endTime);\n    const totalChastityTime = completedSessions.reduce((acc, session) => {\n      if (session.endTime) {\n        const duration = Math.floor(\n          (session.endTime.getTime() - session.startTime.getTime()) / 1000,\n        );\n        return acc + Math.max(0, duration - session.accumulatedPauseTime);\n      }\n      return acc;\n    }, 0);\n\n    const totalPauseTime = sessions.reduce(\n      (acc, session) => acc + session.accumulatedPauseTime,\n      0,\n    );\n    const completedTasks = tasks.filter((t) => t.status === \"completed\").length;\n    const completedGoals = goals.filter((g) => g.isCompleted).length;\n\n    const longestSession = Math.max(\n      ...completedSessions.map((s) => {\n        if (s.endTime) {\n          const duration = Math.floor(\n            (s.endTime.getTime() - s.startTime.getTime()) / 1000,\n          );\n          return Math.max(0, duration - s.accumulatedPauseTime);\n        }\n        return 0;\n      }),\n      0,\n    );\n\n    return {\n      totalSessions: sessions.length,\n      completedSessions: completedSessions.length,\n      totalChastityTime,\n      totalPauseTime,\n      completedTasks,\n      completedGoals,\n      longestSession,\n      totalEvents: events.length,\n    };\n  }, [sessions, events, tasks, goals]);\n\n  const formatDuration = (seconds: number) => {\n    const days = Math.floor(seconds / (24 * 60 * 60));\n    const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));\n    const minutes = Math.floor((seconds % (60 * 60)) / 60);\n\n    if (days > 0) {\n      return `${days}d ${hours}h ${minutes}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    } else {\n      return `${minutes}m`;\n    }\n  };\n\n  const statItems = [\n    { label: \"Total Sessions\", value: stats.totalSessions, icon: FaPlay },\n    {\n      label: \"Completed Sessions\",\n      value: stats.completedSessions,\n      icon: FaStop,\n    },\n    {\n      label: \"Total Chastity Time\",\n      value: formatDuration(stats.totalChastityTime),\n      icon: FaClock,\n    },\n    {\n      label: \"Total Pause Time\",\n      value: formatDuration(stats.totalPauseTime),\n      icon: FaPause,\n    },\n    {\n      label: \"Longest Session\",\n      value: formatDuration(stats.longestSession),\n      icon: FaTrophy,\n    },\n    { label: \"Completed Tasks\", value: stats.completedTasks, icon: FaChartBar },\n    { label: \"Completed Goals\", value: stats.completedGoals, icon: FaTrophy },\n    { label: \"Total Events\", value: stats.totalEvents, icon: FaHistory },\n  ];\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center gap-3 mb-6\">\n        <FaChartBar className=\"text-nightly-lavender-floral\" />\n        <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n          Statistics\n        </h2>\n      </div>\n\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n        {statItems.map((item, index) => {\n          const Icon = item.icon;\n          return (\n            <div key={index} className=\"text-center\">\n              <Icon className=\"text-nightly-aquamarine text-2xl mb-2 mx-auto\" />\n              <div className=\"text-lg font-semibold text-nightly-honeydew mb-1\">\n                {item.value}\n              </div>\n              <div className=\"text-sm text-nightly-celadon\">{item.label}</div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\n// Session History Section\nconst SessionHistorySection: React.FC<{ sessions: DBSession[] }> = ({\n  sessions,\n}) => {\n  const [showAll, setShowAll] = useState(false);\n\n  const sortedSessions = useMemo(() => {\n    return [...sessions].sort(\n      (a, b) => b.startTime.getTime() - a.startTime.getTime(),\n    );\n  }, [sessions]);\n\n  const displaySessions = showAll\n    ? sortedSessions\n    : sortedSessions.slice(0, 10);\n\n  const formatDuration = (seconds: number) => {\n    const days = Math.floor(seconds / (24 * 60 * 60));\n    const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));\n    const minutes = Math.floor((seconds % (60 * 60)) / 60);\n\n    if (days > 0) {\n      return `${days}d ${hours}h ${minutes}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    } else {\n      return `${minutes}m`;\n    }\n  };\n\n  const getSessionDuration = (session: DBSession) => {\n    if (!session.endTime) return 0;\n    const totalDuration = Math.floor(\n      (session.endTime.getTime() - session.startTime.getTime()) / 1000,\n    );\n    return Math.max(0, totalDuration - session.accumulatedPauseTime);\n  };\n\n  return (\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6 mb-6\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <div className=\"flex items-center gap-3\">\n          <FaHistory className=\"text-nightly-spring-green\" />\n          <h2 className=\"text-xl font-semibold text-nightly-honeydew\">\n            Session History\n          </h2>\n        </div>\n        {sessions.length > 10 && (\n          <button\n            onClick={() => setShowAll(!showAll)}\n            className=\"text-nightly-aquamarine hover:text-nightly-spring-green transition-colors\"\n          >\n            {showAll ? \"Show Less\" : `Show All (${sessions.length})`}\n          </button>\n        )}\n      </div>\n\n      {displaySessions.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <FaCalendar className=\"text-4xl text-nightly-celadon/50 mb-4 mx-auto\" />\n          <div className=\"text-nightly-celadon\">No sessions found</div>\n        </div>\n      ) : (\n        <div className=\"space-y-3\">\n          {displaySessions.map((session) => (\n            <div key={session.id} className=\"bg-white/5 rounded-lg p-4\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <div className=\"font-medium text-nightly-honeydew\">\n                    {session.startTime.toLocaleDateString()}{\" \"}\n                    {session.startTime.toLocaleTimeString()}\n                  </div>\n                  <div className=\"text-sm text-nightly-celadon\">\n                    {session.endTime ? (\n                      <>\n                        Ended: {session.endTime.toLocaleDateString()}{\" \"}\n                        {session.endTime.toLocaleTimeString()}\n                        {session.endReason && ` (${session.endReason})`}\n                      </>\n                    ) : (\n                      \"Active Session\"\n                    )}\n                  </div>\n                </div>\n\n                <div className=\"text-right\">\n                  <div className=\"font-mono text-nightly-honeydew\">\n                    {session.endTime\n                      ? formatDuration(getSessionDuration(session))\n                      : \"Ongoing\"}\n                  </div>\n                  {session.accumulatedPauseTime > 0 && (\n                    <div className=\"text-xs text-yellow-400\">\n                      Pause: {formatDuration(session.accumulatedPauseTime)}\n                    </div>\n                  )}\n                </div>\n              </div>\n\n              {session.isHardcoreMode && (\n                <span className=\"inline-block mt-2 bg-red-500/20 text-red-400 px-2 py-1 text-xs rounded\">\n                  Hardcore Mode\n                </span>\n              )}\n\n              {session.notes && (\n                <div className=\"mt-2 text-sm text-nightly-celadon\">\n                  Notes: {session.notes}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n\nconst FullReportPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [sessions, setSessions] = useState<DBSession[]>([]);\n  const [events, setEvents] = useState<DBEvent[]>([]);\n  const [tasks, setTasks] = useState<DBTask[]>([]);\n  const [goals, setGoals] = useState<DBGoal[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      if (!user) return;\n\n      try {\n        setLoading(true);\n\n        const [currentSessionData, sessionData, eventData, taskData, goalData] =\n          await Promise.all([\n            sessionDBService.getCurrentSession(user.uid),\n            sessionDBService.findByUserId(user.uid),\n            eventDBService.findByUserId(user.uid),\n            taskDBService.findByUserId(user.uid),\n            goalDBService.findByUserId(user.uid),\n          ]);\n\n        setCurrentSession(currentSessionData || null);\n        setSessions(sessionData);\n        setEvents(eventData);\n        setTasks(taskData);\n        setGoals(goalData);\n      } catch (error) {\n        logger.error(\"Error fetching report data:\", error, \"FullReportPage\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [user]);\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-6xl mx-auto\">\n        {loading ? (\n          <div className=\"text-center py-8\">\n            <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n            <div className=\"text-nightly-celadon\">Loading report...</div>\n          </div>\n        ) : (\n          <>\n            <CurrentStatusSection currentSession={currentSession} />\n            <StatisticsSection\n              sessions={sessions}\n              events={events}\n              tasks={tasks}\n              goals={goals}\n            />\n            <SessionHistorySection sessions={sessions} />\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default FullReportPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/KeyholderDemo.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (123). Maximum allowed is 75.","line":13,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":140,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Demo page for Keyholder Account Linking\n * Shows the UI components without requiring authentication\n */\nimport React, { useState } from \"react\";\nimport { AccountLinkingDemo } from \"../components/keyholder/AccountLinkingDemo\";\n\ntype Scenario =\n  | \"submissive-with-keyholder\"\n  | \"submissive-no-keyholder\"\n  | \"keyholder-with-submissives\";\n\nconst KeyholderDemo: React.FC = () => {\n  const [scenario, setScenario] = useState<Scenario>(\"submissive-no-keyholder\");\n\n  return (\n    <div className=\"min-h-screen bg-gray-900 text-white\">\n      <div className=\"container mx-auto px-4 py-8\">\n        <div className=\"mb-8\">\n          <h1 className=\"text-3xl font-bold text-purple-300 mb-2\">\n             Keyholder Account Linking - Demo\n          </h1>\n          <p className=\"text-purple-400 mb-4\">\n            Phase 1 Implementation: Secure account linking foundation for\n            keyholder-submissive relationships\n          </p>\n\n          {/* Scenario Selector */}\n          <div className=\"flex gap-2 mb-6\">\n            <button\n              onClick={() => setScenario(\"submissive-no-keyholder\")}\n              className={`px-3 py-2 rounded text-sm ${\n                scenario === \"submissive-no-keyholder\"\n                  ? \"bg-purple-600 text-white\"\n                  : \"bg-gray-700 text-gray-300 hover:bg-gray-600\"\n              }`}\n            >\n              Submissive (No Keyholder)\n            </button>\n            <button\n              onClick={() => setScenario(\"submissive-with-keyholder\")}\n              className={`px-3 py-2 rounded text-sm ${\n                scenario === \"submissive-with-keyholder\"\n                  ? \"bg-purple-600 text-white\"\n                  : \"bg-gray-700 text-gray-300 hover:bg-gray-600\"\n              }`}\n            >\n              Submissive (With Keyholder)\n            </button>\n            <button\n              onClick={() => setScenario(\"keyholder-with-submissives\")}\n              className={`px-3 py-2 rounded text-sm ${\n                scenario === \"keyholder-with-submissives\"\n                  ? \"bg-purple-600 text-white\"\n                  : \"bg-gray-700 text-gray-300 hover:bg-gray-600\"\n              }`}\n            >\n              Keyholder (With Submissives)\n            </button>\n          </div>\n        </div>\n\n        <div className=\"max-w-4xl mx-auto\">\n          <AccountLinkingDemo scenario={scenario} />\n        </div>\n\n        <div className=\"mt-12 bg-blue-900/30 border border-blue-500/50 rounded-lg p-6\">\n          <h2 className=\"text-xl font-bold text-blue-300 mb-4\">\n             Features Implemented\n          </h2>\n          <div className=\"grid md:grid-cols-2 gap-4 text-sm\">\n            <div>\n              <h3 className=\"font-semibold text-blue-200 mb-2\">\n                 Account Linking\n              </h3>\n              <ul className=\"space-y-1 text-blue-100\">\n                <li> 6-character invite code generation</li>\n                <li> 24-hour code expiration</li>\n                <li> Secure code validation</li>\n                <li> Multi-invite support (max 3 active)</li>\n              </ul>\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-blue-200 mb-2\">\n                 Security & Management\n              </h3>\n              <ul className=\"space-y-1 text-blue-100\">\n                <li> Permission-based access control</li>\n                <li> Relationship status management</li>\n                <li> Code revocation capabilities</li>\n                <li> Database versioning (v3)</li>\n              </ul>\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-blue-200 mb-2\">\n                 Database Layer\n              </h3>\n              <ul className=\"space-y-1 text-blue-100\">\n                <li> KeyholderRelationshipDBService</li>\n                <li> InviteCode table with indexes</li>\n                <li> Relationship tracking</li>\n                <li> Transaction-safe operations</li>\n              </ul>\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-blue-200 mb-2\">\n                 React Integration\n              </h3>\n              <ul className=\"space-y-1 text-blue-100\">\n                <li> useKeyholderRelationships hook</li>\n                <li> AccountLinking component</li>\n                <li> Real-time UI updates</li>\n                <li> Form validation & UX</li>\n              </ul>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"mt-8 bg-gray-800 border border-gray-600 rounded-lg p-6\">\n          <h2 className=\"text-xl font-bold text-gray-300 mb-4\">\n             Next Phase: Session Integration\n          </h2>\n          <div className=\"text-sm text-gray-400\">\n            <p className=\"mb-2\">\n              Phase 2 will build on this foundation to add real-time session\n              control capabilities:\n            </p>\n            <ul className=\"space-y-1 text-gray-300\">\n              <li> Remote session start/stop/pause controls</li>\n              <li> Real-time session monitoring for keyholders</li>\n              <li> Goal modification by keyholders</li>\n              <li> Emergency unlock approval system</li>\n              <li> Session event logging and notifications</li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default KeyholderDemo;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/KeyholderPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TaskStatus' is defined but never used.","line":5,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AccountLinking' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":17},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (105). Maximum allowed is 75.","line":17,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":135,"endColumn":2},{"ruleId":"zustand-safe-patterns/zustand-selective-subscriptions","severity":1,"message":"Use selective subscriptions instead of subscribing to entire store. Replace useUIStore() with useUIStore(state => state.specificValue) to prevent unnecessary re-renders. See docs/development/architecture/data-flow.md for performance patterns.","line":20,"column":5,"nodeType":"CallExpression","messageId":"useSelectiveSubscription","endLine":20,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { useKeyholderStore } from \"../stores/keyholderStore\";\nimport { sessionDBService, taskDBService } from \"../services/database\";\nimport type { DBSession, DBTask, TaskStatus } from \"../types/database\";\nimport {\n  KeyholderPasswordUnlock,\n  AccountLinking,\n  AccountLinkingPreview,\n  AdminDashboard,\n  SessionControls,\n  TaskManagement,\n} from \"../components/keyholder\";\nimport { logger } from \"../utils/logging\";\nimport { FaLock, FaCog, FaEye, FaSpinner } from \"../utils/iconImport\";\n\nconst KeyholderPage: React.FC = () => {\n  const { user } = useAuthState();\n  const { isKeyholderModeUnlocked, lockKeyholderControls } =\n    useKeyholderStore();\n  const [currentSession, setCurrentSession] = useState<DBSession | null>(null);\n  const [tasks, setTasks] = useState<DBTask[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      if (!user) return;\n\n      try {\n        setLoading(true);\n        const [session, userTasks] = await Promise.all([\n          sessionDBService.getCurrentSession(user.uid),\n          taskDBService.findByUserId(user.uid),\n        ]);\n\n        setCurrentSession(session || null);\n        setTasks(userTasks);\n      } catch (error) {\n        logger.error(\"Error fetching keyholder data:\", error, \"KeyholderPage\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [user]);\n\n  // Auto-lock when leaving page\n  useEffect(() => {\n    return () => {\n      if (isKeyholderModeUnlocked) {\n        lockKeyholderControls();\n      }\n    };\n  }, [isKeyholderModeUnlocked, lockKeyholderControls]);\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-4xl mx-auto\">\n        {loading ? (\n          <div className=\"text-center py-8\">\n            <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n            <div className=\"text-nightly-celadon\">\n              Loading keyholder controls...\n            </div>\n          </div>\n        ) : (\n          <div className=\"space-y-6\">\n            {/* Account Linking - Always visible */}\n            <AccountLinkingPreview />\n\n            {/* Admin Dashboard - Always visible for keyholders */}\n            <AdminDashboard />\n\n            {/* Current Password System */}\n            <KeyholderPasswordUnlock />\n\n            {/* Keyholder Controls - Only when unlocked */}\n            {isKeyholderModeUnlocked && (\n              <>\n                <SessionControls session={currentSession} />\n                <TaskManagement tasks={tasks} />\n\n                {/* Additional Controls */}\n                <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n                  <div className=\"flex items-center gap-3 mb-4\">\n                    <FaCog className=\"text-nightly-spring-green\" />\n                    <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n                      Keyholder Settings\n                    </h3>\n                  </div>\n\n                  <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                    <button className=\"bg-white/5 hover:bg-white/10 p-4 rounded-lg text-left transition-colors\">\n                      <div className=\"flex items-center gap-3 mb-2\">\n                        <FaEye className=\"text-nightly-aquamarine\" />\n                        <span className=\"font-medium text-nightly-honeydew\">\n                          View Full Report\n                        </span>\n                      </div>\n                      <p className=\"text-sm text-nightly-celadon\">\n                        See complete session history and statistics\n                      </p>\n                    </button>\n\n                    <button className=\"bg-white/5 hover:bg-white/10 p-4 rounded-lg text-left transition-colors\">\n                      <div className=\"flex items-center gap-3 mb-2\">\n                        <FaCog className=\"text-nightly-lavender-floral\" />\n                        <span className=\"font-medium text-nightly-honeydew\">\n                          Manage Rules\n                        </span>\n                      </div>\n                      <p className=\"text-sm text-nightly-celadon\">\n                        Set requirements and restrictions\n                      </p>\n                    </button>\n                  </div>\n\n                  <button\n                    onClick={lockKeyholderControls}\n                    className=\"mt-4 bg-red-500/20 hover:bg-red-500/30 text-red-400 px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n                  >\n                    <FaLock />\n                    Lock Controls\n                  </button>\n                </div>\n              </>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default KeyholderPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/LogEventPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBEvent' is defined but never used.","line":4,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { useEventHistory } from \"../hooks/api/useEvents\";\nimport type { DBEvent } from \"../types/database\";\nimport { LogEventForm, EventList } from \"../components/log_event\";\nimport { FaSpinner } from \"../utils/iconImport\";\n\nconst LogEventPage: React.FC = () => {\n  const { user } = useAuthState();\n\n  // Use TanStack Query hook for event history\n  const {\n    data: events = [],\n    isLoading: loading,\n    error,\n  } = useEventHistory(user?.uid || \"\", { limit: 50 });\n\n  const handleEventLogged = () => {\n    // Event creation now handled by LogEventForm using useCreateEvent hook\n    // No need for manual state updates - TanStack Query will handle cache updates\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-4xl\">\n        <LogEventForm onEventLogged={handleEventLogged} />\n\n        <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n          <h2 className=\"text-xl font-semibold text-nighty-honeydew mb-6\">\n            Recent Events\n          </h2>\n\n          {loading ? (\n            <div className=\"text-center py-8\">\n              <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n              <div className=\"text-nightly-celadon\">Loading events...</div>\n            </div>\n          ) : error ? (\n            <div className=\"text-center py-8\">\n              <div className=\"text-red-400\">\n                Error loading events. Please try again.\n              </div>\n            </div>\n          ) : (\n            <EventList events={events} />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LogEventPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/PublicProfilePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RelationshipsPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (78). Maximum allowed is 75.","line":9,"column":37,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":91,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activeRelationship' is assigned a value but never used.","line":10,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationships Page\n * Main page for managing keyholder relationships\n */\nimport React from \"react\";\nimport RelationshipManager from \"@/components/relationships/RelationshipManager\";\nimport { useRelationships } from \"@/hooks/useRelationships\";\n\nconst RelationshipsPage: React.FC = () => {\n  const { activeRelationship, needsMigration } = useRelationships();\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"container mx-auto py-8\">\n        {/* Page header */}\n        <div className=\"text-center mb-8\">\n          <h1 className=\"text-3xl font-bold text-gray-900 mb-2\">\n            Keyholder Relationships\n          </h1>\n          <p className=\"text-gray-600 max-w-2xl mx-auto\">\n            Manage your connections with keyholders and submissives. Create\n            relationships to share chastity tracking, tasks, and oversight.\n          </p>\n        </div>\n\n        {/* Relationship manager */}\n        <RelationshipManager />\n\n        {/* Help section */}\n        <div className=\"max-w-4xl mx-auto mt-12 p-6\">\n          <div className=\"bg-white rounded-lg border border-gray-200 p-6\">\n            <h2 className=\"text-lg font-semibold text-gray-900 mb-4\">\n              How Relationships Work\n            </h2>\n            <div className=\"grid md:grid-cols-2 gap-6 text-sm text-gray-600\">\n              <div>\n                <h3 className=\"font-medium text-gray-900 mb-2\">\n                  For Submissives:\n                </h3>\n                <ul className=\"space-y-1\">\n                  <li> Send requests to keyholders</li>\n                  <li> Share your chastity sessions and progress</li>\n                  <li> Receive tasks and assignments</li>\n                  <li> Get approval for session changes</li>\n                  <li> Log events and milestones</li>\n                </ul>\n              </div>\n              <div>\n                <h3 className=\"font-medium text-gray-900 mb-2\">\n                  For Keyholders:\n                </h3>\n                <ul className=\"space-y-1\">\n                  <li> Accept requests from submissives</li>\n                  <li> Monitor their chastity progress</li>\n                  <li> Create and approve tasks</li>\n                  <li> Control session permissions</li>\n                  <li> Set goals and requirements</li>\n                </ul>\n              </div>\n            </div>\n\n            <div className=\"mt-6 p-4 bg-blue-50 rounded-lg\">\n              <h3 className=\"font-medium text-blue-900 mb-2\">\n                Privacy & Security\n              </h3>\n              <p className=\"text-blue-800 text-sm\">\n                All relationship data is encrypted and only visible to the\n                participants. You can end relationships at any time, and your\n                data remains under your control.\n              </p>\n            </div>\n\n            {needsMigration && (\n              <div className=\"mt-6 p-4 bg-yellow-50 rounded-lg\">\n                <h3 className=\"font-medium text-yellow-900 mb-2\">\n                  Data Migration\n                </h3>\n                <p className=\"text-yellow-800 text-sm\">\n                  We've detected existing chastity data. Use the migration\n                  feature above to convert your data to the new relationship\n                  system. This creates a self-managed profile that you can later\n                  share with a keyholder.\n                </p>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default RelationshipsPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RewardsPunishmentsPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (86). Maximum allowed is 75.","line":43,"column":42,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":135,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used.","line":44,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setLoading' is assigned a value but never used.","line":51,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport {\n  LogItem,\n  RewardPunishmentStats,\n  ManualEntryForm,\n} from \"../components/rewards_punishments\";\nimport type { RewardPunishmentLog } from \"../components/rewards_punishments\";\nimport { FaFilter, FaSpinner, FaTrophy } from \"../utils/iconImport\";\n// Mock data for demonstration\nconst mockRewardsAndPunishments: RewardPunishmentLog[] = [\n  {\n    id: \"1\",\n    type: \"reward\",\n    title: \"Task Completed Early\",\n    description: \"Completed daily exercise routine ahead of schedule\",\n    timeChangeSeconds: -7200, // 2 hours removed\n    source: \"task_completion\",\n    createdAt: new Date(Date.now() - 86400000), // 1 day ago\n    notes: \"Excellent dedication to fitness goals\",\n  },\n  {\n    id: \"2\",\n    type: \"punishment\",\n    title: \"Late Task Submission\",\n    description: \"Failed to submit daily report on time\",\n    timeChangeSeconds: 14400, // 4 hours added\n    source: \"rule_violation\",\n    createdAt: new Date(Date.now() - 172800000), // 2 days ago\n  },\n  {\n    id: \"3\",\n    type: \"reward\",\n    title: \"Weekly Milestone\",\n    description: \"Successfully completed one week of consistent tracking\",\n    timeChangeSeconds: -10800, // 3 hours removed\n    source: \"milestone\",\n    createdAt: new Date(Date.now() - 604800000), // 1 week ago\n    notes: \"Keep up the great progress!\",\n  },\n];\n\nconst RewardsPunishmentsPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [logs, setLogs] = useState<RewardPunishmentLog[]>(\n    mockRewardsAndPunishments,\n  );\n  const [filter, setFilter] = useState<\"all\" | \"rewards\" | \"punishments\">(\n    \"all\",\n  );\n  const [loading, setLoading] = useState(false);\n\n  const filteredLogs = logs\n    .filter((log) => {\n      if (filter === \"all\") return true;\n      if (filter === \"rewards\") return log.type === \"reward\";\n      if (filter === \"punishments\") return log.type === \"punishment\";\n      return true;\n    })\n    .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n\n  const handleManualEntry = (\n    entry: Omit<RewardPunishmentLog, \"id\" | \"createdAt\">,\n  ) => {\n    const newEntry: RewardPunishmentLog = {\n      ...entry,\n      id: `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      createdAt: new Date(),\n    };\n\n    setLogs((prev) => [newEntry, ...prev]);\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-4xl mx-auto\">\n        <RewardPunishmentStats logs={logs} />\n\n        {/* Controls */}\n        <div className=\"flex items-center justify-between mb-6\">\n          <div className=\"flex items-center gap-4\">\n            <FaFilter className=\"text-nightly-celadon\" />\n            <select\n              value={filter}\n              onChange={(e) =>\n                setFilter(e.target.value as \"all\" | \"rewards\" | \"punishments\")\n              }\n              className=\"bg-white/10 border border-white/10 rounded p-2 text-nightly-honeydew\"\n            >\n              <option value=\"all\">All ({logs.length})</option>\n              <option value=\"rewards\">\n                Rewards ({logs.filter((l) => l.type === \"reward\").length})\n              </option>\n              <option value=\"punishments\">\n                Punishments (\n                {logs.filter((l) => l.type === \"punishment\").length})\n              </option>\n            </select>\n          </div>\n\n          <ManualEntryForm onSubmit={handleManualEntry} />\n        </div>\n\n        {/* Logs */}\n        {loading ? (\n          <div className=\"text-center py-8\">\n            <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n            <div className=\"text-nightly-celadon\">\n              Loading rewards and punishments...\n            </div>\n          </div>\n        ) : filteredLogs.length === 0 ? (\n          <div className=\"text-center py-8\">\n            <FaTrophy className=\"text-4xl text-nightly-celadon/50 mb-4 mx-auto\" />\n            <div className=\"text-nightly-celadon\">\n              No {filter === \"all\" ? \"entries\" : filter} found\n            </div>\n            <div className=\"text-sm text-nightly-celadon/70\">\n              {filter === \"all\"\n                ? \"Complete tasks or have your keyholder add entries\"\n                : `Switch to 'All' to see other entries`}\n            </div>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            {filteredLogs.map((log) => (\n              <LogItem key={log.id} item={log} />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default RewardsPunishmentsPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/RulesPage.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (160). Maximum allowed is 75.","line":73,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":247,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used.","line":74,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { RuleCard, RuleEditor } from \"../components/rules\";\nimport type { ChastityRule } from \"../components/rules\";\nimport { FaBook, FaEdit, FaInfo } from \"../utils/iconImport\";\n\n// Mock rules data\nconst mockRules: ChastityRule[] = [\n  {\n    id: \"1\",\n    title: \"Daily Check-ins\",\n    content: `Must complete daily check-in form by 10 PM each night.\n\n**Required information:**\n- Current mood and energy level\n- Any challenges or temptations faced\n- Tomorrow's goals and commitments\n\n**Consequences for missing:**\n- +12 hours added to chastity time\n- Extra task assigned for the following day`,\n    isActive: true,\n    createdBy: \"keyholder\",\n    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),\n  },\n  {\n    id: \"2\",\n    title: \"Exercise Requirements\",\n    content: `Minimum 30 minutes of physical activity daily.\n\n**Acceptable activities:**\n- Cardio (running, cycling, swimming)\n- Strength training\n- Yoga or stretching\n- Sports activities\n\n**Tracking:**\n- Log activity type and duration\n- Include photo evidence when requested\n- Heart rate data if available\n\n**Rewards for consistency:**\n- 7 days straight: -4 hours\n- 14 days straight: -8 hours\n- 30 days straight: -24 hours`,\n    isActive: true,\n    createdBy: \"keyholder\",\n    createdAt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000),\n  },\n  {\n    id: \"3\",\n    title: \"Communication Protocol\",\n    content: `Clear communication expectations between keyholder and submissive.\n\n**Response times:**\n- Urgent messages: Within 1 hour\n- Regular messages: Within 4 hours\n- Check-ins: Daily by agreed time\n\n**Escalation process:**\n- If no response within timeframe\n- Emergency contact procedures\n- Safe words and their meanings`,\n    isActive: false,\n    createdBy: \"submissive\",\n    createdAt: new Date(Date.now() - 21 * 24 * 60 * 60 * 1000),\n    lastModified: new Date(Date.now() - 21 * 24 * 60 * 60 * 1000),\n  },\n];\n\nconst RulesPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [rules, setRules] = useState<ChastityRule[]>(mockRules);\n  const [editingRule, setEditingRule] = useState<ChastityRule | null>(null);\n  const [showEditor, setShowEditor] = useState(false);\n  const [filter, setFilter] = useState<\"all\" | \"active\" | \"inactive\">(\"all\");\n\n  const filteredRules = rules\n    .filter((rule) => {\n      if (filter === \"all\") return true;\n      if (filter === \"active\") return rule.isActive;\n      if (filter === \"inactive\") return !rule.isActive;\n      return true;\n    })\n    .sort((a, b) => {\n      // Active rules first, then by last modified\n      if (a.isActive && !b.isActive) return -1;\n      if (!a.isActive && b.isActive) return 1;\n      return b.lastModified.getTime() - a.lastModified.getTime();\n    });\n\n  const handleEditRule = (ruleId: string) => {\n    const rule = rules.find((r) => r.id === ruleId);\n    setEditingRule(rule || null);\n    setShowEditor(true);\n  };\n\n  const handleToggleRule = (ruleId: string) => {\n    setRules((prev) =>\n      prev.map((rule) =>\n        rule.id === ruleId\n          ? { ...rule, isActive: !rule.isActive, lastModified: new Date() }\n          : rule,\n      ),\n    );\n  };\n\n  const handleSaveRule = (\n    ruleData: Omit<ChastityRule, \"id\" | \"createdAt\" | \"lastModified\">,\n  ) => {\n    const now = new Date();\n\n    if (editingRule) {\n      // Update existing rule\n      setRules((prev) =>\n        prev.map((rule) =>\n          rule.id === editingRule.id\n            ? {\n                ...rule,\n                ...ruleData,\n                lastModified: now,\n              }\n            : rule,\n        ),\n      );\n    } else {\n      // Create new rule\n      const newRule: ChastityRule = {\n        ...ruleData,\n        id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        createdAt: now,\n        lastModified: now,\n      };\n      setRules((prev) => [newRule, ...prev]);\n    }\n\n    setShowEditor(false);\n    setEditingRule(null);\n  };\n\n  const handleCancelEdit = () => {\n    setShowEditor(false);\n    setEditingRule(null);\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      {/* Content */}\n      <div className=\"p-4 max-w-4xl mx-auto\">\n        {/* Info Banner */}\n        <div className=\"bg-nightly-aquamarine/10 border border-nightly-aquamarine/20 rounded-lg p-4 mb-6\">\n          <div className=\"flex items-start gap-3\">\n            <FaInfo className=\"text-nightly-aquamarine mt-1\" />\n            <div>\n              <h3 className=\"font-medium text-nightly-honeydew mb-1\">\n                About Rules\n              </h3>\n              <p className=\"text-sm text-nightly-celadon\">\n                Rules define the expectations and consequences for your chastity\n                relationship. Both submissives and keyholders can create rules,\n                but only active rules are enforced. Use markdown formatting for\n                better organization.\n              </p>\n            </div>\n          </div>\n        </div>\n\n        {/* Controls */}\n        {!showEditor && (\n          <div className=\"flex items-center justify-between mb-6\">\n            <div className=\"flex items-center gap-4\">\n              <FaBook className=\"text-nightly-celadon\" />\n              <select\n                value={filter}\n                onChange={(e) =>\n                  setFilter(e.target.value as \"all\" | \"active\" | \"inactive\")\n                }\n                className=\"bg-white/10 border border-white/10 rounded p-2 text-nightly-honeydew\"\n              >\n                <option value=\"all\">All Rules ({rules.length})</option>\n                <option value=\"active\">\n                  Active ({rules.filter((r) => r.isActive).length})\n                </option>\n                <option value=\"inactive\">\n                  Inactive ({rules.filter((r) => !r.isActive).length})\n                </option>\n              </select>\n            </div>\n\n            <button\n              onClick={() => {\n                setEditingRule(null);\n                setShowEditor(true);\n              }}\n              className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n            >\n              <FaEdit />\n              Create Rule\n            </button>\n          </div>\n        )}\n\n        {/* Editor */}\n        {showEditor && (\n          <div className=\"mb-6\">\n            <RuleEditor\n              rule={editingRule}\n              onSave={handleSaveRule}\n              onCancel={handleCancelEdit}\n            />\n          </div>\n        )}\n\n        {/* Rules List */}\n        {!showEditor && (\n          <div className=\"space-y-6\">\n            {filteredRules.length === 0 ? (\n              <div className=\"text-center py-8\">\n                <FaBook className=\"text-4xl text-nightly-celadon/50 mb-4 mx-auto\" />\n                <div className=\"text-nightly-celadon\">\n                  No {filter === \"all\" ? \"rules\" : filter + \" rules\"} found\n                </div>\n                <div className=\"text-sm text-nightly-celadon/70\">\n                  {filter === \"all\"\n                    ? \"Create your first rule to get started\"\n                    : `Switch to 'All' to see other rules`}\n                </div>\n              </div>\n            ) : (\n              filteredRules.map((rule) => (\n                <RuleCard\n                  key={rule.id}\n                  rule={rule}\n                  isEditable={true}\n                  onEdit={handleEditRule}\n                  onToggle={handleToggleRule}\n                />\n              ))\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default RulesPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/SettingsMainPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/SettingsPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FaEye' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FaEyeSlash' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":34,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":92,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":160,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":160,"endColumn":11},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (192). Maximum allowed is 75.","line":234,"column":67,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":436,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":235,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":235,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":440,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":440,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":490,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":490,"endColumn":11},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (108). Maximum allowed is 75.","line":565,"column":64,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":681,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":566,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":566,"endColumn":11},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (89). Maximum allowed is 75.","line":683,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":779,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { settingsDBService } from \"../services/database\";\nimport type { DBSettings } from \"../types/database\";\nimport { logger } from \"../utils/logging\";\nimport {\n  FaUser,\n  FaPalette,\n  FaGlobe,\n  FaBullseye,\n  FaCog,\n  FaDatabase,\n  FaDownload,\n  FaUpload,\n  FaTrash,\n  FaEye,\n  FaEyeSlash,\n  FaSpinner,\n  FaLock,\n  FaShieldAlt,\n} from \"../utils/iconImport\";\n\ntype SettingsTab =\n  | \"account\"\n  | \"display\"\n  | \"profile\"\n  | \"privacy\"\n  | \"goals\"\n  | \"sessions\"\n  | \"data\";\n\n// Account Settings Section\nconst AccountSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaUser className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Account Information\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Display Name\n          </label>\n          <input\n            type=\"text\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter display name\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Email\n          </label>\n          <input\n            type=\"email\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"Enter email address\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Two-Factor Authentication\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Add extra security to your account\n            </div>\n          </div>\n          <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white px-4 py-2 rounded transition-colors\">\n            Setup 2FA\n          </button>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Save Changes\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Display Settings Section\nconst DisplaySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaPalette className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Display Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Theme\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"dark\">Dark</option>\n            <option value=\"light\">Light</option>\n            <option value=\"auto\">Auto</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Language\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"en\">English</option>\n            <option value=\"es\">Spanish</option>\n            <option value=\"fr\">French</option>\n            <option value=\"de\">German</option>\n          </select>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Timezone\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"America/New_York\">Eastern Time</option>\n            <option value=\"America/Chicago\">Central Time</option>\n            <option value=\"America/Denver\">Mountain Time</option>\n            <option value=\"America/Los_Angeles\">Pacific Time</option>\n          </select>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Notifications\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Receive app notifications\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Public Profile Section\nconst ProfileSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaGlobe className=\"text-nightly-spring-green\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Public Profile\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Public Profile\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Make your profile visible to others\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Share Statistics\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Allow others to see your progress stats\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-spring-green\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Bio\n          </label>\n          <textarea\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50 resize-none\"\n            rows={3}\n            placeholder=\"Tell others about yourself...\"\n          />\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Profile URL\n          </label>\n          <div className=\"flex\">\n            <span className=\"bg-white/5 border border-white/10 border-r-0 rounded-l px-3 py-3 text-nightly-celadon text-sm\">\n              chastityos.com/profile/\n            </span>\n            <input\n              type=\"text\"\n              className=\"flex-1 bg-white/5 border border-white/10 rounded-r p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n              placeholder=\"your-username\"\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Privacy Settings Section\nconst PrivacySection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaShieldAlt className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Privacy & Security\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        {/* Data Collection */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Data Collection\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Allow collection of usage analytics\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        {/* Data Sharing */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Data Sharing\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Share anonymous usage data to improve the app\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        {/* Account Visibility */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Account Discoverable\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Allow others to find your account by username\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        {/* Activity Status */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Show Activity Status\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Let others see when you're active\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n\n    {/* Security Settings */}\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaLock className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Security Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        {/* Session Timeout */}\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Auto-logout After Inactivity\n          </label>\n          <select className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew\">\n            <option value=\"never\">Never</option>\n            <option value=\"15\">15 minutes</option>\n            <option value=\"30\">30 minutes</option>\n            <option value=\"60\">1 hour</option>\n            <option value=\"240\">4 hours</option>\n            <option value=\"1440\">24 hours</option>\n          </select>\n        </div>\n\n        {/* Login Alerts */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Login Alerts\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Get notified of new logins to your account\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n\n        {/* Device Management */}\n        <div>\n          <div className=\"text-sm font-medium text-nightly-celadon mb-2\">\n            Logged In Devices\n          </div>\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between bg-white/5 rounded p-3\">\n              <div>\n                <div className=\"text-sm text-nightly-honeydew\">\n                  Current Device (Chrome on macOS)\n                </div>\n                <div className=\"text-xs text-nightly-celadon/70\">\n                  Last used: Just now\n                </div>\n              </div>\n              <span className=\"text-green-400 text-xs\">Active</span>\n            </div>\n            <div className=\"flex items-center justify-between bg-white/5 rounded p-3\">\n              <div>\n                <div className=\"text-sm text-nightly-honeydew\">\n                  iPhone (Safari)\n                </div>\n                <div className=\"text-xs text-nightly-celadon/70\">\n                  Last used: 2 hours ago\n                </div>\n              </div>\n              <button className=\"text-red-400 hover:text-red-300 text-xs\">\n                Remove\n              </button>\n            </div>\n          </div>\n          <button className=\"mt-2 text-nightly-aquamarine hover:text-nightly-spring-green text-sm\">\n            Log out all other devices\n          </button>\n        </div>\n      </div>\n    </div>\n\n    {/* Data Controls */}\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaDatabase className=\"text-nightly-spring-green\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Data Controls\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        {/* Data Export */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Export My Data\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Download all your data in JSON format\n            </div>\n          </div>\n          <button className=\"bg-nightly-spring-green/20 hover:bg-nightly-spring-green/30 text-nightly-spring-green px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\">\n            <FaDownload />\n            Export\n          </button>\n        </div>\n\n        {/* Account Deletion */}\n        <div className=\"flex items-center justify-between pt-4 border-t border-white/10\">\n          <div>\n            <div className=\"text-sm font-medium text-red-400\">\n              Delete Account\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Permanently delete your account and all data\n            </div>\n          </div>\n          <button className=\"bg-red-500/20 hover:bg-red-500/30 text-red-400 px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\">\n            <FaTrash />\n            Delete\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Goals Section\nconst GoalsSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaBullseye className=\"text-nightly-aquamarine\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Personal Goals\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Default Session Goal (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Goal Reminders\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Get notified about goal progress\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-aquamarine\"></div>\n          </label>\n        </div>\n\n        <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black px-6 py-2 rounded font-medium transition-colors\">\n          Create New Goal\n        </button>\n      </div>\n    </div>\n  </div>\n);\n\n// Session Settings Section\nconst SessionSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => (\n  <div className=\"space-y-6\">\n    <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n      <div className=\"flex items-center gap-3 mb-4\">\n        <FaCog className=\"text-nightly-lavender-floral\" />\n        <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n          Session Settings\n        </h3>\n      </div>\n\n      <div className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Allow Emergency Unlock\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Enable emergency unlock feature\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" defaultChecked />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div>\n          <label className=\"block text-sm font-medium text-nightly-celadon mb-2\">\n            Emergency Unlock Cooldown (hours)\n          </label>\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"168\"\n            className=\"w-full bg-white/5 border border-white/10 rounded p-3 text-nightly-honeydew placeholder-nightly-celadon/50\"\n            placeholder=\"24\"\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Require Keyholder Approval\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Sessions need keyholder approval to end\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-nightly-lavender-floral\"></div>\n          </label>\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <div className=\"text-sm font-medium text-nightly-celadon\">\n              Hardcore Mode\n            </div>\n            <div className=\"text-xs text-nightly-celadon/70\">\n              Disable pause and emergency unlock\n            </div>\n          </div>\n          <label className=\"relative inline-flex items-center cursor-pointer\">\n            <input type=\"checkbox\" className=\"sr-only peer\" />\n            <div className=\"w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-red-500\"></div>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n);\n\n// Data Management Section\nconst DataSection: React.FC<{ settings: DBSettings | null }> = ({\n  settings,\n}) => {\n  const [showResetModal, setShowResetModal] = useState(false);\n  const [resetStatus, setResetStatus] = useState<\n    \"idle\" | \"pending\" | \"success\" | \"error\"\n  >(\"idle\");\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"bg-white/10 backdrop-blur-sm rounded-lg p-6\">\n        <div className=\"flex items-center gap-3 mb-4\">\n          <FaDatabase className=\"text-nightly-spring-green\" />\n          <h3 className=\"text-lg font-semibold text-nightly-honeydew\">\n            Data Management\n          </h3>\n        </div>\n\n        <div className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <button className=\"bg-nightly-aquamarine hover:bg-nightly-aquamarine/80 text-black p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaDownload />\n              Export Data\n            </button>\n\n            <button className=\"bg-nightly-lavender-floral hover:bg-nightly-lavender-floral/80 text-white p-4 rounded-lg font-medium transition-colors flex items-center gap-3\">\n              <FaUpload />\n              Import Data\n            </button>\n          </div>\n\n          <div className=\"border-t border-white/10 pt-4\">\n            <div className=\"bg-red-500/10 border border-red-500/20 rounded-lg p-4\">\n              <h4 className=\"text-red-400 font-medium mb-2\">Danger Zone</h4>\n              <p className=\"text-nightly-celadon text-sm mb-4\">\n                Reset all data will permanently delete all your sessions, tasks,\n                goals, and settings. This action cannot be undone.\n              </p>\n              <button\n                onClick={() => setShowResetModal(true)}\n                className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded font-medium transition-colors flex items-center gap-2\"\n              >\n                <FaTrash />\n                Reset All Data\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Reset Modal */}\n      {showResetModal && (\n        <div className=\"fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4\">\n          <div className=\"bg-nightly-dark-purple border border-white/10 rounded-lg p-6 max-w-md w-full\">\n            <h3 className=\"text-lg font-semibold text-red-400 mb-4\">\n              Confirm Data Reset\n            </h3>\n\n            {resetStatus === \"idle\" && (\n              <>\n                <p className=\"text-nightly-celadon mb-6\">\n                  Are you sure you want to reset all your data? This action\n                  cannot be undone and will delete:\n                </p>\n                <ul className=\"text-nightly-celadon text-sm mb-6 list-disc list-inside space-y-1\">\n                  <li>All chastity sessions</li>\n                  <li>All logged events</li>\n                  <li>All tasks and goals</li>\n                  <li>All settings and preferences</li>\n                </ul>\n                <div className=\"flex gap-3\">\n                  <button\n                    onClick={() => {\n                      setResetStatus(\"pending\");\n                      // Simulate reset process\n                      setTimeout(() => {\n                        setResetStatus(\"success\");\n                        setTimeout(() => {\n                          window.location.reload();\n                        }, 2000);\n                      }, 2000);\n                    }}\n                    className=\"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded font-medium transition-colors\"\n                  >\n                    Yes, Reset Everything\n                  </button>\n                  <button\n                    onClick={() => setShowResetModal(false)}\n                    className=\"bg-white/10 hover:bg-white/20 text-nightly-celadon px-4 py-2 rounded font-medium transition-colors\"\n                  >\n                    Cancel\n                  </button>\n                </div>\n              </>\n            )}\n\n            {resetStatus === \"pending\" && (\n              <div className=\"text-center\">\n                <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n                <p className=\"text-nightly-celadon\">Resetting all data...</p>\n              </div>\n            )}\n\n            {resetStatus === \"success\" && (\n              <div className=\"text-center\">\n                <div className=\"text-2xl text-green-400 mb-4\"></div>\n                <p className=\"text-nightly-celadon\">\n                  Data reset complete. Refreshing...\n                </p>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nconst SettingsPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [settings, setSettings] = useState<DBSettings | null>(null);\n  const [activeTab, setActiveTab] = useState<SettingsTab>(\"account\");\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchSettings = async () => {\n      if (!user) return;\n\n      try {\n        setLoading(true);\n        // Try to get user settings\n        const userSettings = await settingsDBService.findByUserId(user.uid);\n        setSettings(userSettings[0] || null);\n      } catch (error) {\n        logger.error(\"Error fetching settings:\", error, \"SettingsPage\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchSettings();\n  }, [user]);\n\n  const tabs = [\n    { id: \"account\" as SettingsTab, label: \"Account\", icon: FaUser },\n    { id: \"display\" as SettingsTab, label: \"Display\", icon: FaPalette },\n    { id: \"profile\" as SettingsTab, label: \"Profile\", icon: FaGlobe },\n    { id: \"privacy\" as SettingsTab, label: \"Privacy\", icon: FaShieldAlt },\n    { id: \"goals\" as SettingsTab, label: \"Goals\", icon: FaBullseye },\n    { id: \"sessions\" as SettingsTab, label: \"Sessions\", icon: FaCog },\n    { id: \"data\" as SettingsTab, label: \"Data\", icon: FaDatabase },\n  ];\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case \"account\":\n        return <AccountSection settings={settings} />;\n      case \"display\":\n        return <DisplaySection settings={settings} />;\n      case \"profile\":\n        return <ProfileSection settings={settings} />;\n      case \"privacy\":\n        return <PrivacySection settings={settings} />;\n      case \"goals\":\n        return <GoalsSection settings={settings} />;\n      case \"sessions\":\n        return <SessionSection settings={settings} />;\n      case \"data\":\n        return <DataSection settings={settings} />;\n      default:\n        return <AccountSection settings={settings} />;\n    }\n  };\n\n  return (\n    <div className=\"text-nightly-spring-green\">\n      <div className=\"flex flex-col lg:flex-row\">\n        {/* Tab Navigation */}\n        <nav className=\"lg:w-64 p-4 border-b lg:border-b-0 lg:border-r border-white/10\">\n          <div className=\"space-y-2\">\n            {tabs.map((tab) => {\n              const Icon = tab.icon;\n              return (\n                <button\n                  key={tab.id}\n                  onClick={() => setActiveTab(tab.id)}\n                  className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg font-medium transition-colors ${\n                    activeTab === tab.id\n                      ? \"bg-nightly-aquamarine text-black\"\n                      : \"text-nightly-celadon hover:bg-white/10 hover:text-nightly-honeydew\"\n                  }`}\n                >\n                  <Icon />\n                  {tab.label}\n                </button>\n              );\n            })}\n          </div>\n        </nav>\n\n        {/* Content */}\n        <main className=\"flex-1 p-4 lg:p-6\">\n          {loading ? (\n            <div className=\"text-center py-8\">\n              <FaSpinner className=\"animate-spin text-2xl text-nightly-aquamarine mb-4 mx-auto\" />\n              <div className=\"text-nightly-celadon\">Loading settings...</div>\n            </div>\n          ) : (\n            <div className=\"max-w-4xl\">{renderTabContent()}</div>\n          )}\n        </main>\n      </div>\n    </div>\n  );\n};\n\nexport default SettingsPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/pages/TasksPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBTask' is defined but never used.","line":4,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (136). Maximum allowed is 75.","line":7,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":155,"endColumn":2},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'note' is defined but never used. Allowed unused args must match /^_/u.","line":20,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":30,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from \"react\";\nimport { useAuthState } from \"../contexts\";\nimport { useTasks, useUpdateTaskStatus } from \"../hooks/api/useTasks\";\nimport type { DBTask, TaskStatus } from \"../types/database\";\nimport { TaskItem } from \"../components/tasks\";\n\nconst TasksPage: React.FC = () => {\n  const { user } = useAuthState();\n  const [activeTab, setActiveTab] = useState<\"active\" | \"archived\">(\"active\");\n\n  // Use TanStack Query hooks for tasks\n  const {\n    data: tasks = [],\n    isLoading: loading,\n    error,\n  } = useTasks(user?.uid || \"\");\n\n  const updateTaskStatus = useUpdateTaskStatus();\n\n  const handleSubmitTask = async (taskId: string, note: string) => {\n    if (!user) return;\n\n    try {\n      await updateTaskStatus.mutateAsync({\n        taskId,\n        userId: user.uid,\n        status: \"submitted\" as TaskStatus,\n        // Note: submissiveNote would be handled in task updates\n      });\n    } catch (error) {\n      // Error is already logged in the hook\n      // TODO: Add toast notification for user feedback on error\n    }\n  };\n\n  const activeTasks = tasks.filter((task) =>\n    [\"pending\", \"submitted\"].includes(task.status),\n  );\n\n  const archivedTasks = tasks.filter((task) =>\n    [\"approved\", \"rejected\", \"completed\", \"cancelled\"].includes(task.status),\n  );\n\n  return (\n    <div className=\"p-6\">\n      {/* Enhanced Header with Glass Effect */}\n      <div className=\"text-center mb-8\">\n        <h1 className=\"text-4xl font-bold bg-gradient-to-r from-white via-blue-200 to-purple-200 bg-clip-text text-transparent mb-2\">\n          Task Management\n        </h1>\n        <div className=\"w-16 h-1 bg-gradient-to-r from-blue-400 to-purple-400 mx-auto rounded-full\"></div>\n      </div>\n\n      {/* Tab Navigation with Glass Pills */}\n      <div className=\"flex justify-center space-x-4 mb-8\">\n        <button\n          onClick={() => setActiveTab(\"active\")}\n          className={`glass-nav px-6 py-3 font-medium transition-all duration-300 ${\n            activeTab === \"active\"\n              ? \"glass-card-primary text-blue-200 shadow-liquid transform scale-105\"\n              : \"text-gray-300 hover:text-white glass-hover\"\n          }`}\n        >\n          Active Tasks ({activeTasks.length})\n        </button>\n        <button\n          onClick={() => setActiveTab(\"archived\")}\n          className={`glass-nav px-6 py-3 font-medium transition-all duration-300 ${\n            activeTab === \"archived\"\n              ? \"glass-card-primary text-blue-200 shadow-liquid transform scale-105\"\n              : \"text-gray-300 hover:text-white glass-hover\"\n          }`}\n        >\n          Archived ({archivedTasks.length})\n        </button>\n      </div>\n\n      {/* Content with Glass Container */}\n      <div className=\"max-w-4xl mx-auto\">\n        {loading ? (\n          <div className=\"glass-card text-center py-12\">\n            <div className=\"glass-float\">\n              <div className=\"inline-flex items-center space-x-2\">\n                <div className=\"w-6 h-6 border-2 border-blue-400 border-t-transparent rounded-full animate-spin\"></div>\n                <span className=\"text-blue-200 text-lg\">Loading tasks...</span>\n              </div>\n            </div>\n          </div>\n        ) : error ? (\n          <div className=\"text-center py-8\">\n            <div className=\"text-red-400\">\n              Error loading tasks. Please try again.\n            </div>\n          </div>\n        ) : (\n          <>\n            {activeTab === \"active\" ? (\n              activeTasks.length > 0 ? (\n                <div className=\"space-y-6\">\n                  {activeTasks.map((task) => (\n                    <div\n                      key={task.id}\n                      className=\"glass-card glass-hover transform transition-all duration-300 hover:scale-[1.02]\"\n                    >\n                      <TaskItem task={task} onSubmit={handleSubmitTask} />\n                    </div>\n                  ))}\n                </div>\n              ) : (\n                <div className=\"glass-card text-center py-12\">\n                  <div className=\"glass-float\">\n                    <div className=\"text-6xl mb-4\"></div>\n                    <h3 className=\"text-xl font-semibold text-gray-200 mb-2\">\n                      No Active Tasks\n                    </h3>\n                    <p className=\"text-gray-400\">\n                      You're all caught up! New tasks will appear here when\n                      assigned.\n                    </p>\n                  </div>\n                </div>\n              )\n            ) : archivedTasks.length > 0 ? (\n              <div className=\"space-y-6\">\n                {archivedTasks.map((task) => (\n                  <div\n                    key={task.id}\n                    className=\"glass-card opacity-75 hover:opacity-100 transition-opacity duration-300\"\n                  >\n                    <TaskItem\n                      task={task}\n                      onSubmit={() => {}} // Archived tasks can't be submitted\n                    />\n                  </div>\n                ))}\n              </div>\n            ) : (\n              <div className=\"glass-card text-center py-12\">\n                <div className=\"glass-float\">\n                  <div className=\"text-6xl mb-4\"></div>\n                  <h3 className=\"text-xl font-semibold text-gray-200 mb-2\">\n                    No Archived Tasks\n                  </h3>\n                  <p className=\"text-gray-400\">\n                    Completed and reviewed tasks will appear here.\n                  </p>\n                </div>\n              </div>\n            )}\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TasksPage;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/AchievementEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/AchievementIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionDBService' is defined but never used.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'taskDBService' is defined but never used.","line":8,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'goalDBService' is defined but never used.","line":8,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBSession' is defined but never used.","line":10,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DBGoal' is defined but never used.","line":10,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Integration Service\n * Integrates achievement engine with existing app events\n */\n\nimport { achievementEngine } from \"./AchievementEngine\";\nimport { achievementDBService } from \"./database\";\nimport { sessionDBService, taskDBService, goalDBService } from \"./database\";\nimport { logger } from \"../utils/logging\";\nimport type { DBSession, DBGoal } from \"../types/database\";\n\n// Type for session event data used in achievements\nexport interface SessionEventData {\n  sessionId?: string;\n  duration?: number;\n  startTime?: Date;\n  endTime?: Date;\n  isHardcoreMode?: boolean;\n  goalDuration?: number;\n  actualDuration?: number;\n}\n\n// Type for goal event data used in achievements\nexport interface GoalEventData {\n  goalId?: string;\n  type?: string;\n  targetValue?: number;\n  currentValue?: number;\n  completedAt?: Date;\n}\n\nexport class AchievementIntegrationService {\n  private initialized = false;\n\n  /**\n   * Initialize the integration service\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Initialize the achievement engine first\n      await achievementEngine.initialize();\n\n      // Set up event listeners\n      this.setupEventListeners();\n\n      this.initialized = true;\n      logger.info(\n        \"Achievement integration service initialized\",\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to initialize achievement integration\",\n        error,\n        \"AchievementIntegration\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Set up event listeners for various app events\n   */\n  private setupEventListeners(): void {\n    // These would ideally be event emitters, but for now we'll provide methods\n    // that components can call when events occur\n    logger.info(\"Achievement event listeners ready\", \"AchievementIntegration\");\n  }\n\n  /**\n   * Handle session start event\n   */\n  async onSessionStart(\n    userId: string,\n    sessionData: SessionEventData,\n  ): Promise<void> {\n    try {\n      await achievementEngine.processSessionEvent(\n        userId,\n        \"session_start\",\n        sessionData,\n      );\n      logger.debug(\n        `Processed session start for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process session start\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Handle session end event\n   */\n  async onSessionEnd(\n    userId: string,\n    sessionData?: SessionEventData,\n  ): Promise<void> {\n    try {\n      await achievementEngine.processSessionEvent(\n        userId,\n        \"session_end\",\n        sessionData,\n      );\n      logger.debug(\n        `Processed session end for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process session end\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Handle task completion event\n   */\n  async onTaskCompleted(userId: string): Promise<void> {\n    try {\n      await achievementEngine.processTaskEvent(userId, \"task_completed\");\n      logger.debug(\n        `Processed task completion for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process task completion\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Handle task approval event\n   */\n  async onTaskApproved(userId: string): Promise<void> {\n    try {\n      await achievementEngine.processTaskEvent(userId, \"task_approved\");\n      logger.debug(\n        `Processed task approval for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process task approval\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Handle task rejection event\n   */\n  async onTaskRejected(userId: string): Promise<void> {\n    try {\n      await achievementEngine.processTaskEvent(userId, \"task_rejected\");\n      logger.debug(\n        `Processed task rejection for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process task rejection\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Handle goal completion event\n   */\n  async onGoalCompleted(\n    userId: string,\n    goalData?: GoalEventData,\n  ): Promise<void> {\n    try {\n      await achievementEngine.processGoalEvent(\n        userId,\n        \"goal_completed\",\n        goalData,\n      );\n      logger.debug(\n        `Processed goal completion for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to process goal completion\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Perform a full achievement check for a user (useful for new users or backfill)\n   */\n  async performFullCheck(userId: string): Promise<void> {\n    try {\n      await achievementEngine.performFullCheck(userId);\n      logger.info(\n        `Performed full achievement check for user ${userId}`,\n        \"AchievementIntegration\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to perform full achievement check\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n\n  /**\n   * Award beta tester achievement to users\n   */\n  async awardBetaTesterAchievement(userId: string): Promise<void> {\n    try {\n      // This would be called for beta users\n      const achievements = await achievementDBService.getAllAchievements();\n      const betaAchievement = achievements.find(\n        (a) => a.name === \"Beta Tester\",\n      );\n\n      if (betaAchievement) {\n        await achievementDBService.awardAchievement(userId, betaAchievement.id);\n        logger.info(\n          `Awarded beta tester achievement to user ${userId}`,\n          \"AchievementIntegration\",\n        );\n      }\n    } catch (error) {\n      logger.error(\n        \"Failed to award beta tester achievement\",\n        error,\n        \"AchievementIntegration\",\n      );\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementIntegration = new AchievementIntegrationService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/EffectiveTimeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/KeyholderRelationshipService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CreateInviteCodeData' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AcceptInviteCodeData' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Keyholder Relationship Service\n * Business logic layer for keyholder-submissive relationships\n */\nimport {\n  keyholderRelationshipDBService,\n  CreateInviteCodeData,\n  AcceptInviteCodeData,\n  InviteCode,\n} from \"./database/KeyholderRelationshipDBService\";\nimport { KeyholderRelationship, KeyholderPermissions } from \"../types/core\";\nimport { serviceLogger } from \"../utils/logging\";\n\nconst logger = serviceLogger(\"KeyholderRelationshipService\");\n\nexport class KeyholderRelationshipService {\n  /**\n   * Create an invite code for account linking\n   */\n  static async createInviteCode(\n    submissiveUserId: string,\n    submissiveName?: string,\n    expirationHours = 24,\n  ): Promise<InviteCode> {\n    try {\n      logger.debug(\"Creating invite code for submissive\", {\n        submissiveUserId,\n        expirationHours,\n      });\n\n      // Check for existing active invite codes (max 3 at a time)\n      const activeInvites =\n        await keyholderRelationshipDBService.getActiveInviteCodes(\n          submissiveUserId,\n        );\n\n      if (activeInvites.length >= 3) {\n        throw new Error(\"Maximum of 3 active invite codes allowed at once\");\n      }\n\n      const inviteCode = await keyholderRelationshipDBService.createInviteCode({\n        submissiveUserId,\n        submissiveName,\n        expirationHours,\n      });\n\n      logger.info(\"Invite code created\", {\n        code: inviteCode.code,\n        submissiveUserId,\n      });\n\n      return inviteCode;\n    } catch (error) {\n      logger.error(\"Failed to create invite code\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * Accept an invite code and establish relationship\n   */\n  static async acceptInviteCode(\n    inviteCode: string,\n    keyholderUserId: string,\n    keyholderName?: string,\n  ): Promise<KeyholderRelationship> {\n    try {\n      logger.debug(\"Accepting invite code\", {\n        code: inviteCode,\n        keyholderUserId,\n      });\n\n      const relationship =\n        await keyholderRelationshipDBService.acceptInviteCode({\n          inviteCode,\n          keyholderUserId,\n          keyholderName,\n        });\n\n      logger.info(\"Relationship established\", {\n        relationshipId: relationship.id,\n        submissiveUserId: relationship.submissiveUserId,\n        keyholderUserId: relationship.keyholderUserId,\n      });\n\n      return relationship;\n    } catch (error) {\n      logger.error(\"Failed to accept invite code\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all relationships for a user\n   */\n  static async getUserRelationships(userId: string): Promise<{\n    asSubmissive: KeyholderRelationship[];\n    asKeyholder: KeyholderRelationship[];\n  }> {\n    try {\n      const relationships =\n        await keyholderRelationshipDBService.getRelationshipsForUser(userId);\n\n      logger.debug(\"Retrieved user relationships\", {\n        userId,\n        submissiveCount: relationships.asSubmissive.length,\n        keyholderCount: relationships.asKeyholder.length,\n      });\n\n      return relationships;\n    } catch (error) {\n      logger.error(\"Failed to get user relationships\", {\n        error: error as Error,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get active keyholder for a submissive\n   */\n  static async getActiveKeyholder(\n    submissiveUserId: string,\n  ): Promise<KeyholderRelationship | null> {\n    try {\n      const relationships =\n        await keyholderRelationshipDBService.getRelationshipsForUser(\n          submissiveUserId,\n        );\n\n      // Return the first active relationship as submissive\n      // (Currently supporting single keyholder, multi-keyholder is future enhancement)\n      const activeRelationship = relationships.asSubmissive.find(\n        (rel) => rel.status === \"active\",\n      );\n\n      return activeRelationship || null;\n    } catch (error) {\n      logger.error(\"Failed to get active keyholder\", {\n        error: error as Error,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if user has keyholder permissions for a submissive\n   */\n  static async hasPermission(\n    keyholderUserId: string,\n    submissiveUserId: string,\n    permission: keyof KeyholderPermissions,\n  ): Promise<boolean> {\n    try {\n      const relationships =\n        await keyholderRelationshipDBService.getRelationshipsForUser(\n          keyholderUserId,\n        );\n\n      const relationship = relationships.asKeyholder.find(\n        (rel) =>\n          rel.submissiveUserId === submissiveUserId && rel.status === \"active\",\n      );\n\n      if (!relationship) {\n        return false;\n      }\n\n      return relationship.permissions[permission] === true;\n    } catch (error) {\n      logger.error(\"Failed to check permission\", { error: error as Error });\n      return false;\n    }\n  }\n\n  /**\n   * Update keyholder permissions (submissive only)\n   */\n  static async updatePermissions(\n    relationshipId: string,\n    permissions: KeyholderPermissions,\n    submissiveUserId: string,\n  ): Promise<void> {\n    try {\n      await keyholderRelationshipDBService.updatePermissions(\n        relationshipId,\n        permissions,\n        submissiveUserId,\n      );\n\n      logger.info(\"Permissions updated\", { relationshipId });\n    } catch (error) {\n      logger.error(\"Failed to update permissions\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * End a keyholder relationship\n   */\n  static async endRelationship(\n    relationshipId: string,\n    userId: string,\n  ): Promise<void> {\n    try {\n      await keyholderRelationshipDBService.endRelationship(\n        relationshipId,\n        userId,\n      );\n\n      logger.info(\"Relationship ended\", { relationshipId, userId });\n    } catch (error) {\n      logger.error(\"Failed to end relationship\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get active invite codes for a submissive\n   */\n  static async getActiveInviteCodes(\n    submissiveUserId: string,\n  ): Promise<InviteCode[]> {\n    try {\n      const inviteCodes =\n        await keyholderRelationshipDBService.getActiveInviteCodes(\n          submissiveUserId,\n        );\n\n      logger.debug(\"Retrieved active invite codes\", {\n        submissiveUserId,\n        count: inviteCodes.length,\n      });\n\n      return inviteCodes;\n    } catch (error) {\n      logger.error(\"Failed to get active invite codes\", {\n        error: error as Error,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Revoke an invite code\n   */\n  static async revokeInviteCode(\n    codeId: string,\n    submissiveUserId: string,\n  ): Promise<void> {\n    try {\n      await keyholderRelationshipDBService.revokeInviteCode(\n        codeId,\n        submissiveUserId,\n      );\n\n      logger.info(\"Invite code revoked\", { codeId });\n    } catch (error) {\n      logger.error(\"Failed to revoke invite code\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * Validate invite code format\n   */\n  static validateInviteCodeFormat(code: string): boolean {\n    // 6-character alphanumeric code\n    const pattern = /^[A-Z0-9]{6}$/;\n    return pattern.test(code);\n  }\n\n  /**\n   * Check if user can create relationships (not already linked as submissive)\n   */\n  static async canCreateInviteCode(userId: string): Promise<boolean> {\n    try {\n      const relationships =\n        await keyholderRelationshipDBService.getRelationshipsForUser(userId);\n\n      // Check if user already has an active relationship as submissive\n      const hasActiveSubmissiveRelationship = relationships.asSubmissive.some(\n        (rel) => rel.status === \"active\",\n      );\n\n      // Currently supporting single keyholder per submissive\n      return !hasActiveSubmissiveRelationship;\n    } catch (error) {\n      logger.error(\"Failed to check invite code creation eligibility\", {\n        error: error as Error,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Get relationship summary for user\n   */\n  static async getRelationshipSummary(userId: string): Promise<{\n    hasActiveKeyholder: boolean;\n    hasSubmissives: boolean;\n    activeKeyholderCount: number;\n    submissiveCount: number;\n  }> {\n    try {\n      const relationships =\n        await keyholderRelationshipDBService.getRelationshipsForUser(userId);\n\n      const activeAsSubmissive = relationships.asSubmissive.filter(\n        (rel) => rel.status === \"active\",\n      );\n      const activeAsKeyholder = relationships.asKeyholder.filter(\n        (rel) => rel.status === \"active\",\n      );\n\n      return {\n        hasActiveKeyholder: activeAsSubmissive.length > 0,\n        hasSubmissives: activeAsKeyholder.length > 0,\n        activeKeyholderCount: activeAsSubmissive.length,\n        submissiveCount: activeAsKeyholder.length,\n      };\n    } catch (error) {\n      logger.error(\"Failed to get relationship summary\", {\n        error: error as Error,\n      });\n      throw error;\n    }\n  }\n}\n\nexport default KeyholderRelationshipService;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/PauseCooldownService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/PauseService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/api/session-service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2186,2189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2186,2189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from \"../storage/dexie\";\nimport { DBSession } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { PauseCooldownService } from \"../PauseCooldownService\";\nimport { EffectiveTimeService } from \"../EffectiveTimeService\";\nimport { PauseService } from \"../PauseService\";\n// import { FirebaseAPI } from './firebase'; // This will be used later\n\nconst logger = serviceLogger(\"SessionService\");\n\nexport class SessionService {\n  static async getCurrentSession(\n    userId: string,\n  ): Promise<DBSession | undefined> {\n    // 1. Try local storage first (fast)\n    const localSession = await db.sessions\n      .where(\"userId\")\n      .equals(userId)\n      .and((session) => !session.endTime) // Active sessions don't have endTime\n      .first();\n\n    // 2. Return local data if it exists (freshness check can be added later)\n    if (localSession) {\n      logger.debug(\"Serving session from local Dexie cache\", { userId });\n      return localSession;\n    }\n\n    // 3. Fetch from Firebase if stale or missing (placeholder)\n    logger.info(\n      \"No local session found. Fetching from Firebase would happen here\",\n      { userId },\n    );\n    // const firebaseSession = await FirebaseAPI.sessions.getCurrent(userId);\n\n    // 4. Update local storage (placeholder)\n    // if (firebaseSession) {\n    //   await db.sessions.put(firebaseSession);\n    // }\n\n    // return firebaseSession;\n    return undefined;\n  }\n\n  /**\n   * Get pause state for current session\n   */\n  static async getPauseState(userId: string) {\n    return PauseCooldownService.canUserPause(userId);\n  }\n\n  /**\n   * Calculate effective time for a session\n   */\n  static getEffectiveTime(session: DBSession, currentTime?: Date) {\n    return EffectiveTimeService.calculateEffectiveTime(session, currentTime);\n  }\n\n  /**\n   * Get session statistics\n   */\n  static getSessionStats(session: DBSession, currentTime?: Date) {\n    return EffectiveTimeService.getSessionStats(session, currentTime);\n  }\n\n  /**\n   * Pause a session\n   */\n  static async pauseSession(\n    sessionId: string,\n    reason: string,\n    customReason?: string,\n  ) {\n    return PauseService.pauseSession(sessionId, reason as any, customReason);\n  }\n\n  /**\n   * Resume a session\n   */\n  static async resumeSession(sessionId: string) {\n    return PauseService.resumeSession(sessionId);\n  }\n\n  /**\n   * Get pause status for a session\n   */\n  static async getPauseStatus(sessionId: string) {\n    return PauseService.getPauseStatus(sessionId);\n  }\n\n  /**\n   * Get pause history for a session\n   */\n  static async getPauseHistory(sessionId: string) {\n    return PauseService.getPauseHistory(sessionId);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/auth/account-linking.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2206,2209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2206,2209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4705,4708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4705,4708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6351,6354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6351,6354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6559,6562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6559,6562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7709,7712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7709,7712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8824,8827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8824,8827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8997,9000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8997,9000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":397,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10663,10666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10663,10666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12583,12586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12583,12586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":497,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":497,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13399,13402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13399,13402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Linking Service\n * Handles secure linking between keyholder and wearer accounts\n */\nimport {\n  doc,\n  setDoc,\n  getDoc,\n  updateDoc,\n  collection,\n  query,\n  where,\n  getDocs,\n  serverTimestamp,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { getFirebaseAuth, getFirestore } from \"../firebase\";\nimport {\n  LinkCode,\n  LinkCodeResponse,\n  AdminRelationship,\n  AdminSession,\n  GenerateLinkCodeRequest,\n  UseLinkCodeRequest,\n  UpdateRelationshipRequest,\n  LinkCodeValidation,\n  AdminPermissions,\n  SecuritySettings,\n  PrivacySettings,\n} from \"../../types/account-linking\";\nimport { ApiResponse } from \"../../types\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport { generateUUID } from \"../../utils/helpers/hash\";\n\nconst logger = serviceLogger(\"AccountLinkingService\");\n\nexport class AccountLinkingService {\n  private static readonly APP_URL = \"https://chastityos.app\";\n  private static readonly LINK_CODE_LENGTH = 12;\n  private static readonly DEFAULT_CODE_EXPIRY_HOURS = 24;\n  private static readonly DEFAULT_SESSION_TIMEOUT_MINUTES = 30;\n\n  /**\n   * Generate a secure link code for account linking\n   */\n  static async generateLinkCode(\n    request: GenerateLinkCodeRequest = {},\n  ): Promise<ApiResponse<LinkCodeResponse>> {\n    try {\n      const auth = await getFirebaseAuth();\n      const db = await getFirestore();\n      const currentUser = auth.currentUser;\n\n      if (!currentUser) {\n        return {\n          success: false,\n          error: \"Authentication required to generate link codes\",\n        };\n      }\n\n      // Generate secure code\n      const code = this.generateSecureCode();\n      const expirationHours =\n        request.expirationHours || this.DEFAULT_CODE_EXPIRY_HOURS;\n      const expiresAt = new Date(Date.now() + expirationHours * 60 * 60 * 1000);\n\n      const linkCodeData: LinkCode = {\n        id: code,\n        wearerId: currentUser.uid,\n        createdAt: serverTimestamp() as Timestamp,\n        expiresAt: Timestamp.fromDate(expiresAt),\n        status: \"pending\",\n        maxUses: request.maxUses || 1,\n        usedBy: null,\n        shareMethod: request.shareMethod || \"manual\",\n      };\n\n      // Save to Firestore\n      await setDoc(doc(db as any, \"linkCodes\", code), linkCodeData);\n\n      const response: LinkCodeResponse = {\n        code,\n        expiresIn: `${expirationHours} hours`,\n        shareUrl: `${this.APP_URL}/link/${code}`,\n      };\n\n      if (request.shareMethod === \"qr\") {\n        response.qrCodeData = this.generateQRCodeData(code);\n      }\n\n      logger.info(\"Link code generated successfully\", {\n        code,\n        userId: currentUser.uid,\n      });\n\n      return {\n        success: true,\n        data: response,\n        message: \"Link code generated successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Failed to generate link code\", { error: error as Error });\n      return {\n        success: false,\n        error: \"Failed to generate link code. Please try again.\",\n      };\n    }\n  }\n\n  /**\n   * Use a link code to establish admin relationship\n   */\n  static async redeemLinkCode(\n    request: UseLinkCodeRequest,\n  ): Promise<ApiResponse<AdminRelationship>> {\n    try {\n      const auth = await getFirebaseAuth();\n      const currentUser = auth.currentUser;\n\n      if (!currentUser) {\n        return {\n          success: false,\n          error: \"Authentication required to use link codes\",\n        };\n      }\n\n      // Validate the code\n      const validation = await this.validateLinkCode(request.code);\n      if (!validation.isValid || !validation.code) {\n        return {\n          success: false,\n          error: validation.error || \"Invalid link code\",\n        };\n      }\n\n      const linkCode = validation.code;\n\n      // Create admin relationship\n      const relationship = await this.createAdminRelationship(\n        currentUser.uid,\n        linkCode.wearerId,\n        request,\n      );\n\n      // Mark code as used\n      await this.markCodeAsUsed(request.code, currentUser.uid);\n\n      logger.info(\"Link code used successfully\", {\n        code: request.code,\n        keyholderId: currentUser.uid,\n        wearerId: linkCode.wearerId,\n      });\n\n      return {\n        success: true,\n        data: relationship,\n        message: \"Account linked successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Failed to use link code\", { error: error as Error });\n      return {\n        success: false,\n        error: \"Failed to use link code. Please try again.\",\n      };\n    }\n  }\n\n  /**\n   * Validate a link code\n   */\n  static async validateLinkCode(code: string): Promise<LinkCodeValidation> {\n    try {\n      const db = await getFirestore();\n      const linkDoc = await getDoc(doc(db as any, \"linkCodes\", code));\n\n      if (!linkDoc.exists()) {\n        return {\n          isValid: false,\n          error: \"Invalid or expired link code\",\n          canUse: false,\n        };\n      }\n\n      const linkData = linkDoc.data() as LinkCode;\n\n      // Check if expired\n      const now = new Date();\n      const expiresAt = linkData.expiresAt.toDate();\n      if (expiresAt < now) {\n        return {\n          isValid: false,\n          error: \"Link code has expired\",\n          canUse: false,\n          code: linkData,\n        };\n      }\n\n      // Check if already used\n      if (linkData.status !== \"pending\" || linkData.usedBy !== null) {\n        return {\n          isValid: false,\n          error: \"Link code has already been used\",\n          canUse: false,\n          code: linkData,\n        };\n      }\n\n      const timeRemaining = Math.floor(\n        (expiresAt.getTime() - now.getTime()) / 1000,\n      );\n\n      return {\n        isValid: true,\n        canUse: true,\n        code: linkData,\n        timeRemaining,\n      };\n    } catch (error) {\n      logger.error(\"Error validating link code\", { error: error as Error });\n      return {\n        isValid: false,\n        error: \"Error validating link code\",\n        canUse: false,\n      };\n    }\n  }\n\n  /**\n   * Get admin relationships for a user\n   */\n  static async getAdminRelationships(\n    userId: string,\n  ): Promise<AdminRelationship[]> {\n    try {\n      const db = await getFirestore();\n\n      // Get relationships where user is either keyholder or wearer\n      const [keyholderQuery, wearerQuery] = await Promise.all([\n        getDocs(\n          query(\n            collection(db as any, \"adminRelationships\"),\n            where(\"keyholderId\", \"==\", userId),\n            where(\"status\", \"==\", \"active\"),\n          ),\n        ),\n        getDocs(\n          query(\n            collection(db as any, \"adminRelationships\"),\n            where(\"wearerId\", \"==\", userId),\n            where(\"status\", \"==\", \"active\"),\n          ),\n        ),\n      ]);\n\n      const relationships: AdminRelationship[] = [];\n\n      keyholderQuery.forEach((doc) => {\n        relationships.push(doc.data() as AdminRelationship);\n      });\n\n      wearerQuery.forEach((doc) => {\n        relationships.push(doc.data() as AdminRelationship);\n      });\n\n      return relationships;\n    } catch (error) {\n      logger.error(\"Failed to get admin relationships\", {\n        error: error as Error,\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Update an existing admin relationship\n   */\n  static async updateRelationship(\n    request: UpdateRelationshipRequest,\n  ): Promise<ApiResponse<AdminRelationship>> {\n    try {\n      const auth = await getFirebaseAuth();\n      const db = await getFirestore();\n      const currentUser = auth.currentUser;\n\n      if (!currentUser) {\n        return {\n          success: false,\n          error: \"Authentication required\",\n        };\n      }\n\n      // Get existing relationship\n      const relationshipDoc = await getDoc(\n        doc(db as any, \"adminRelationships\", request.relationshipId),\n      );\n\n      if (!relationshipDoc.exists()) {\n        return {\n          success: false,\n          error: \"Relationship not found\",\n        };\n      }\n\n      const relationship = relationshipDoc.data() as AdminRelationship;\n\n      // Check permissions\n      const canUpdate =\n        currentUser.uid === relationship.wearerId ||\n        currentUser.uid === relationship.keyholderId;\n\n      if (!canUpdate) {\n        return {\n          success: false,\n          error: \"Permission denied\",\n        };\n      }\n\n      // Prepare update data\n      const updateData: Partial<AdminRelationship> = {};\n\n      if (request.status) {\n        updateData.status = request.status;\n        if (request.status === \"terminated\") {\n          updateData.terminatedAt = serverTimestamp() as Timestamp;\n          updateData.terminatedBy =\n            currentUser.uid === relationship.wearerId ? \"wearer\" : \"keyholder\";\n          updateData.terminationReason = request.terminationReason;\n        }\n      }\n\n      // Update the relationship\n      await updateDoc(\n        doc(db as any, \"adminRelationships\", request.relationshipId),\n        updateData,\n      );\n\n      // Get updated relationship\n      const updatedDoc = await getDoc(\n        doc(db as any, \"adminRelationships\", request.relationshipId),\n      );\n      const updatedRelationship = updatedDoc.data() as AdminRelationship;\n\n      return {\n        success: true,\n        data: updatedRelationship,\n        message: \"Relationship updated successfully\",\n      };\n    } catch (error) {\n      logger.error(\"Failed to update relationship\", { error: error as Error });\n      return {\n        success: false,\n        error: \"Failed to update relationship. Please try again.\",\n      };\n    }\n  }\n\n  /**\n   * Start an admin session\n   */\n  static async startAdminSession(\n    relationshipId: string,\n  ): Promise<ApiResponse<AdminSession>> {\n    try {\n      const auth = await getFirebaseAuth();\n      const db = await getFirestore();\n      const currentUser = auth.currentUser;\n\n      if (!currentUser) {\n        return {\n          success: false,\n          error: \"Authentication required\",\n        };\n      }\n\n      const sessionId = generateUUID();\n      const timeoutMinutes = this.DEFAULT_SESSION_TIMEOUT_MINUTES;\n      const expiresAt = new Date(Date.now() + timeoutMinutes * 60 * 1000);\n\n      const session: AdminSession = {\n        id: sessionId,\n        relationshipId,\n        keyholderId: currentUser.uid,\n        wearerId: \"\", // Will be filled from relationship\n        startedAt: serverTimestamp() as Timestamp,\n        expiresAt: Timestamp.fromDate(expiresAt),\n        lastActivity: serverTimestamp() as Timestamp,\n        actions: {\n          sessionViews: 0,\n          taskActions: 0,\n          settingChanges: 0,\n          emergencyActions: 0,\n          dataExports: 0,\n        },\n        isActive: true,\n      };\n\n      await setDoc(doc(db as any, \"adminSessions\", sessionId), session);\n\n      return {\n        success: true,\n        data: session,\n        message: \"Admin session started\",\n      };\n    } catch (error) {\n      logger.error(\"Failed to start admin session\", { error: error as Error });\n      return {\n        success: false,\n        error: \"Failed to start admin session. Please try again.\",\n      };\n    }\n  }\n\n  // Private methods\n  private static async createAdminRelationship(\n    keyholderId: string,\n    wearerId: string,\n    request: UseLinkCodeRequest,\n  ): Promise<AdminRelationship> {\n    const db = await getFirestore();\n    const relationshipId = generateUUID();\n\n    const defaultPermissions: AdminPermissions = {\n      viewSessions: true,\n      viewEvents: true,\n      viewTasks: true,\n      viewSettings: true,\n      controlSessions: true,\n      manageTasks: true,\n      editSettings: false,\n      setGoals: true,\n      emergencyUnlock: false,\n      forceEnd: false,\n      viewAuditLog: true,\n      exportData: false,\n    };\n\n    const defaultSecurity: SecuritySettings = {\n      requireConfirmation: true,\n      auditLog: true,\n      sessionTimeout: this.DEFAULT_SESSION_TIMEOUT_MINUTES,\n      requireReauth: false,\n      ipRestrictions: [],\n    };\n\n    const defaultPrivacy: PrivacySettings = {\n      wearerCanSeeAdminActions: true,\n      keyholderCanSeePrivateNotes: false,\n      shareStatistics: true,\n      retainDataAfterDisconnect: false,\n      anonymizeHistoricalData: true,\n    };\n\n    const relationship: AdminRelationship = {\n      id: relationshipId,\n      keyholderId,\n      wearerId,\n      establishedAt: serverTimestamp() as Timestamp,\n      status: \"active\",\n      permissions: { ...defaultPermissions, ...request.permissions },\n      security: { ...defaultSecurity, ...request.security },\n      privacy: { ...defaultPrivacy, ...request.privacy },\n      linkMethod: \"code\",\n    };\n\n    await setDoc(\n      doc(db as any, \"adminRelationships\", relationshipId),\n      relationship,\n    );\n    return relationship;\n  }\n\n  private static generateSecureCode(): string {\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    let result = \"\";\n    const array = new Uint8Array(this.LINK_CODE_LENGTH);\n    crypto.getRandomValues(array);\n    for (let i = 0; i < this.LINK_CODE_LENGTH; i++) {\n      result += chars[array[i] % chars.length];\n    }\n    return result;\n  }\n\n  private static generateQRCodeData(code: string): string {\n    return JSON.stringify({\n      type: \"chastityos_link\",\n      code,\n      version: \"1.0\",\n      appUrl: this.APP_URL,\n    });\n  }\n\n  private static async markCodeAsUsed(\n    code: string,\n    keyholderId: string,\n  ): Promise<void> {\n    const db = await getFirestore();\n    await updateDoc(doc(db as any, \"linkCodes\", code), {\n      status: \"used\",\n      usedBy: keyholderId,\n      usedAt: serverTimestamp(),\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/auth/auth-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/cache-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/AchievementDBService.ts","messages":[{"ruleId":"max-params","severity":1,"message":"Async method 'updateLeaderboardEntry' has too many parameters (6). Maximum allowed is 5.","line":610,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":610,"endColumn":31},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (561). Maximum allowed is 500.","line":622,"column":1,"nodeType":null,"messageId":"exceed","endLine":701,"endColumn":1},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":660,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":660,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":679,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":679,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Database Service\n * Backward compatibility wrapper for the new modular achievement services\n * @deprecated Use individual services from './achievements/' for new code\n */\n\nimport { BaseDBService } from \"./BaseDBService\";\nimport { ChastityDB } from \"../storage/ChastityDB\";\nimport {\n  DBAchievement,\n  DBUserAchievement,\n  DBAchievementProgress,\n  DBAchievementNotification,\n  DBLeaderboardEntry,\n  AchievementCategory,\n  AchievementDifficulty,\n  LeaderboardPrivacy,\n} from \"../../types\";\nimport { logger } from \"../../utils/logging\";\n\nexport class AchievementDBService extends BaseDBService {\n  protected db = ChastityDB.getInstance();\n  protected achievementsTable = this.db.achievements;\n  protected userAchievementsTable = this.db.userAchievements;\n  protected achievementProgressTable = this.db.achievementProgress;\n  protected achievementNotificationsTable = this.db.achievementNotifications;\n  protected leaderboardEntriesTable = this.db.leaderboardEntries;\n  // ==================== ACHIEVEMENT CRUD ====================\n\n  /**\n   * Create or update achievement definition\n   */\n  async createAchievement(\n    achievement: Omit<DBAchievement, \"id\" | \"syncStatus\" | \"lastModified\">,\n  ): Promise<string> {\n    try {\n      const achievementData: DBAchievement = {\n        ...achievement,\n        id: this.generateId(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.achievementsTable.add(achievementData);\n      await this.queueSync(\n        \"achievements\",\n        \"create\",\n        achievementData.id,\n        achievementData,\n      );\n\n      logger.info(\n        `Achievement created: ${achievementData.name}`,\n        \"AchievementDBService\",\n      );\n      return achievementData.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to create achievement\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get all achievements (for system reference)\n   */\n  async getAllAchievements(): Promise<DBAchievement[]> {\n    try {\n      return await this.achievementsTable.where(\"isActive\").equals(1).toArray();\n    } catch (error) {\n      logger.error(\"Failed to get achievements\", error, \"AchievementDBService\");\n      return [];\n    }\n  }\n\n  /**\n   * Get achievement by ID\n   */\n  async getAchievementById(id: string): Promise<DBAchievement | null> {\n    try {\n      const achievement = await this.achievementsTable.get(id);\n      return achievement || null;\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievement by ID\",\n        error,\n        \"AchievementDBService\",\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Get achievements by category\n   */\n  async getAchievementsByCategory(\n    category: AchievementCategory,\n  ): Promise<DBAchievement[]> {\n    try {\n      return await this.achievementsTable\n        .where(\"category\")\n        .equals(category)\n        .and((achievement) => achievement.isActive)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievements by category\",\n        error,\n        \"AchievementDBService\",\n      );\n      return [];\n    }\n  }\n\n  // ==================== USER ACHIEVEMENT CRUD ====================\n\n  /**\n   * Award achievement to user\n   */\n  async awardAchievement(\n    userId: string,\n    achievementId: string,\n    progress: number = 100,\n    metadata?: Record<string, unknown>,\n  ): Promise<string> {\n    try {\n      // Check if user already has this achievement\n      const existing = await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.achievementId === achievementId)\n        .first();\n\n      if (existing) {\n        logger.warn(\n          `User ${userId} already has achievement ${achievementId}`,\n          \"AchievementDBService\",\n        );\n        return existing.id;\n      }\n\n      const userAchievement: DBUserAchievement = {\n        id: this.generateId(),\n        userId,\n        achievementId,\n        earnedAt: new Date(),\n        progress,\n        metadata,\n        isVisible: true,\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.userAchievementsTable.add(userAchievement);\n      await this.queueSync(\n        \"userAchievements\",\n        \"create\",\n        userAchievement.id,\n        userAchievement,\n      );\n\n      logger.info(\n        `Achievement ${achievementId} awarded to user ${userId}`,\n        \"AchievementDBService\",\n      );\n      return userAchievement.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to award achievement\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's earned achievements\n   */\n  async getUserAchievements(userId: string): Promise<DBUserAchievement[]> {\n    try {\n      return await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievements\",\n        error,\n        \"AchievementDBService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  async getUserVisibleAchievements(\n    userId: string,\n  ): Promise<DBUserAchievement[]> {\n    try {\n      return await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.isVisible)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user visible achievements\",\n        error,\n        \"AchievementDBService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Toggle achievement visibility\n   */\n  async toggleAchievementVisibility(\n    userId: string,\n    achievementId: string,\n  ): Promise<void> {\n    try {\n      const userAchievement = await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.achievementId === achievementId)\n        .first();\n\n      if (!userAchievement) {\n        throw new Error(\"User achievement not found\");\n      }\n\n      userAchievement.isVisible = !userAchievement.isVisible;\n      userAchievement.lastModified = new Date();\n      userAchievement.syncStatus = \"pending\";\n\n      await this.userAchievementsTable.put(userAchievement);\n      await this.queueSync(\n        \"userAchievements\",\n        \"update\",\n        userAchievement.id,\n        userAchievement,\n      );\n\n      logger.info(\n        `Achievement ${achievementId} visibility toggled for user ${userId}`,\n        \"AchievementDBService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  // ==================== PROGRESS TRACKING ====================\n\n  /**\n   * Update achievement progress\n   */\n  async updateAchievementProgress(\n    userId: string,\n    achievementId: string,\n    currentValue: number,\n    targetValue: number,\n  ): Promise<void> {\n    try {\n      const existing = await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ap) => ap.achievementId === achievementId)\n        .first();\n\n      const progressData: DBAchievementProgress = {\n        id: existing?.id || this.generateId(),\n        userId,\n        achievementId,\n        currentValue,\n        targetValue,\n        isCompleted: currentValue >= targetValue,\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      if (existing) {\n        await this.achievementProgressTable.put(progressData);\n        await this.queueSync(\n          \"achievementProgress\",\n          \"update\",\n          progressData.id,\n          progressData,\n        );\n      } else {\n        await this.achievementProgressTable.add(progressData);\n        await this.queueSync(\n          \"achievementProgress\",\n          \"create\",\n          progressData.id,\n          progressData,\n        );\n      }\n\n      // If completed, award the achievement\n      if (progressData.isCompleted && !existing?.isCompleted) {\n        await this.awardAchievement(userId, achievementId, 100);\n      }\n\n      logger.debug(\n        `Progress updated for ${achievementId}: ${currentValue}/${targetValue}`,\n        \"AchievementDBService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update achievement progress\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's achievement progress\n   */\n  async getUserAchievementProgress(\n    userId: string,\n  ): Promise<DBAchievementProgress[]> {\n    try {\n      return await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievement progress\",\n        error,\n        \"AchievementDBService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get progress for specific achievement\n   */\n  async getAchievementProgress(\n    userId: string,\n    achievementId: string,\n  ): Promise<DBAchievementProgress | null> {\n    try {\n      const progress = await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ap) => ap.achievementId === achievementId)\n        .first();\n\n      return progress || null;\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievement progress\",\n        error,\n        \"AchievementDBService\",\n      );\n      return null;\n    }\n  }\n\n  // ==================== NOTIFICATIONS ====================\n\n  /**\n   * Create achievement notification\n   */\n  async createNotification(\n    userId: string,\n    achievementId: string,\n    type: \"earned\" | \"progress\" | \"milestone\",\n    title: string,\n    message: string,\n  ): Promise<string> {\n    try {\n      const notification: DBAchievementNotification = {\n        id: this.generateId(),\n        userId,\n        achievementId,\n        type,\n        title,\n        message,\n        isRead: false,\n        createdAt: new Date(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.achievementNotificationsTable.add(notification);\n      await this.queueSync(\n        \"achievementNotifications\",\n        \"create\",\n        notification.id,\n        notification,\n      );\n\n      logger.info(\n        `Achievement notification created for user ${userId}`,\n        \"AchievementDBService\",\n      );\n      return notification.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to create achievement notification\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's unread notifications\n   */\n  async getUserUnreadNotifications(\n    userId: string,\n  ): Promise<DBAchievementNotification[]> {\n    try {\n      return await this.achievementNotificationsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((n) => !n.isRead)\n        .reverse()\n        .sortBy(\"createdAt\");\n    } catch (error) {\n      logger.error(\n        \"Failed to get user unread notifications\",\n        error,\n        \"AchievementDBService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Mark notification as read\n   */\n  async markNotificationRead(notificationId: string): Promise<void> {\n    try {\n      const notification =\n        await this.achievementNotificationsTable.get(notificationId);\n      if (notification) {\n        notification.isRead = true;\n        notification.lastModified = new Date();\n        notification.syncStatus = \"pending\";\n\n        await this.achievementNotificationsTable.put(notification);\n        await this.queueSync(\n          \"achievementNotifications\",\n          \"update\",\n          notification.id,\n          notification,\n        );\n      }\n    } catch (error) {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  // ==================== STATISTICS ====================\n\n  /**\n   * Get user achievement statistics\n   */\n  async getUserAchievementStats(userId: string): Promise<{\n    totalEarned: number;\n    totalPoints: number;\n    completionPercentage: number;\n    categoryCounts: Record<AchievementCategory, number>;\n    difficultyBreakdown: Record<AchievementDifficulty, number>;\n  }> {\n    try {\n      const [userAchievements, allAchievements] = await Promise.all([\n        this.getUserAchievements(userId),\n        this.getAllAchievements(),\n      ]);\n\n      const achievementMap = new Map(allAchievements.map((a) => [a.id, a]));\n\n      const totalPoints = userAchievements.reduce((sum, ua) => {\n        const achievement = achievementMap.get(ua.achievementId);\n        return sum + (achievement?.points || 0);\n      }, 0);\n\n      const categoryCounts = {} as Record<AchievementCategory, number>;\n      const difficultyBreakdown = {} as Record<AchievementDifficulty, number>;\n\n      // Initialize counts\n      Object.values(AchievementCategory).forEach(\n        (cat) => (categoryCounts[cat] = 0),\n      );\n      Object.values(AchievementDifficulty).forEach(\n        (diff) => (difficultyBreakdown[diff] = 0),\n      );\n\n      userAchievements.forEach((ua) => {\n        const achievement = achievementMap.get(ua.achievementId);\n        if (achievement) {\n          categoryCounts[achievement.category]++;\n          difficultyBreakdown[achievement.difficulty]++;\n        }\n      });\n\n      return {\n        totalEarned: userAchievements.length,\n        totalPoints,\n        completionPercentage:\n          allAchievements.length > 0\n            ? (userAchievements.length / allAchievements.length) * 100\n            : 0,\n        categoryCounts,\n        difficultyBreakdown,\n      };\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievement stats\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  // ==================== LEADERBOARD METHODS ====================\n\n  /**\n   * Get leaderboard entries for a category and period\n   */\n  async getLeaderboard(\n    category: string,\n    period: string,\n    limit: number = 50,\n  ): Promise<DBLeaderboardEntry[]> {\n    try {\n      return await this.leaderboardEntriesTable\n        .where(\"[category+period]\")\n        .equals([category, period])\n        .reverse()\n        .sortBy(\"rank\")\n        .then((entries) => entries.slice(0, limit));\n    } catch (error) {\n      logger.error(\"Failed to get leaderboard\", error, \"AchievementDBService\");\n      return [];\n    }\n  }\n\n  /**\n   * Get user's rank in a specific leaderboard\n   */\n  async getUserLeaderboardRank(\n    userId: string,\n    category: string,\n    period: string,\n  ): Promise<{\n    rank: number;\n    value: number;\n    totalParticipants: number;\n  } | null> {\n    try {\n      const userEntry = await this.leaderboardEntriesTable\n        .where(\"[userId+category+period]\")\n        .equals([userId, category, period])\n        .first();\n\n      if (!userEntry) return null;\n\n      // Get total participants count\n      const totalParticipants = await this.leaderboardEntriesTable\n        .where(\"[category+period]\")\n        .equals([category, period])\n        .count();\n\n      return {\n        rank: userEntry.rank,\n        value: userEntry.value,\n        totalParticipants,\n      };\n    } catch (error) {\n      logger.error(\n        \"Failed to get user leaderboard rank\",\n        error,\n        \"AchievementDBService\",\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Update user's leaderboard entry\n   */\n  async updateLeaderboardEntry(\n    userId: string,\n    category: string,\n    period: string,\n    value: number,\n    displayName: string = \"Anonymous\",\n    displayNameType: \"real\" | \"username\" | \"anonymous\" = \"anonymous\",\n  ): Promise<void> {\n    try {\n      const entryData: DBLeaderboardEntry = {\n        id: this.generateId(),\n        userId,\n        category: category as AchievementCategory,\n        period: period as \"daily\" | \"weekly\" | \"monthly\" | \"yearly\" | \"allTime\",\n        value,\n        rank: 0, // Will be calculated by ranking algorithm\n        displayName,\n        displayNameType,\n        isAnonymous: displayNameType === \"anonymous\",\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      // Upsert the entry\n      await this.leaderboardEntriesTable.put(entryData);\n\n      await this.queueSync(\n        \"leaderboardEntries\",\n        \"create\",\n        entryData.id,\n        entryData,\n      );\n\n      logger.info(\n        `Updated leaderboard entry for user ${userId}`,\n        \"AchievementDBService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update leaderboard entry\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's leaderboard privacy settings\n   */\n  async getLeaderboardPrivacy(userId: string): Promise<LeaderboardPrivacy> {\n    // This would typically be stored in user settings\n    // For now, return default settings\n    return {\n      participateInGlobal: false,\n      participateInMonthly: false,\n      shareSessionTime: false,\n      shareStreakData: false,\n      shareAchievements: false,\n      displayName: \"anonymous\",\n      showOnPublicProfile: false,\n    };\n  }\n\n  /**\n   * Update user's leaderboard privacy settings\n   */\n  async updateLeaderboardPrivacy(\n    userId: string,\n    settings: LeaderboardPrivacy,\n  ): Promise<void> {\n    try {\n      // This would typically update user settings\n      // For now, just log the action\n      logger.info(\n        `Updated leaderboard privacy for user ${userId}`,\n        \"AchievementDBService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update leaderboard privacy\",\n        error,\n        \"AchievementDBService\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementDBService = new AchievementDBService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/BaseDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/EmergencyService.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'performEmergencyUnlock' has too many lines (88). Maximum allowed is 75.","line":32,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":139,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Emergency Service\n * Handles emergency unlock operations with safety confirmations and audit trails\n */\nimport { sessionDBService } from \"./SessionDBService\";\nimport { eventDBService } from \"./EventDBService\";\nimport { settingsDBService } from \"./SettingsDBService\";\nimport type { EmergencyUnlockReason } from \"../../types/events\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport { generateUUID } from \"../../utils/helpers/hash\";\n\nconst logger = serviceLogger(\"EmergencyService\");\n\nexport interface EmergencyUnlockOptions {\n  sessionId: string;\n  userId: string;\n  reason: EmergencyUnlockReason;\n  additionalNotes?: string;\n}\n\nexport interface EmergencyUnlockResult {\n  success: boolean;\n  message: string;\n  sessionId?: string;\n  cooldownUntil?: Date;\n}\n\nclass EmergencyService {\n  /**\n   * Perform emergency unlock with complete audit trail\n   */\n  async performEmergencyUnlock(\n    options: EmergencyUnlockOptions,\n  ): Promise<EmergencyUnlockResult> {\n    const { sessionId, userId, reason, additionalNotes } = options;\n\n    try {\n      logger.info(\"Starting emergency unlock process\", {\n        sessionId,\n        userId,\n        reason,\n      });\n\n      // 1. Validate session exists and is active\n      const session = await sessionDBService.findById(sessionId);\n      if (!session) {\n        throw new Error(\"Session not found\");\n      }\n\n      if (session.userId !== userId) {\n        throw new Error(\"Session does not belong to user\");\n      }\n\n      if (session.endTime) {\n        throw new Error(\"Session is already ended\");\n      }\n\n      // 2. Check cooldown if enabled\n      const cooldownCheck = await this.checkEmergencyUnlockCooldown(userId);\n      if (!cooldownCheck.allowed) {\n        logger.warn(\"Emergency unlock blocked by cooldown\", {\n          userId,\n          cooldownUntil: cooldownCheck.cooldownUntil,\n        });\n        return {\n          success: false,\n          message: `Emergency unlock on cooldown until ${cooldownCheck.cooldownUntil?.toLocaleString()}`,\n          cooldownUntil: cooldownCheck.cooldownUntil,\n        };\n      }\n\n      // 3. End session immediately (bypasses all restrictions)\n      const endTime = new Date();\n      await sessionDBService.update(sessionId, {\n        endTime,\n        endReason: \"emergency_unlock\",\n        isEmergencyUnlock: true,\n        emergencyReason: reason,\n        emergencyNotes: additionalNotes,\n        isPaused: false,\n        pauseStartTime: undefined,\n      });\n\n      // 4. Calculate session duration for logging\n      const sessionDuration = Math.floor(\n        (endTime.getTime() - session.startTime.getTime()) / 1000,\n      );\n\n      // 5. Log emergency event with detailed information\n      await eventDBService.create({\n        id: generateUUID(),\n        userId,\n        sessionId,\n        type: \"session_end\" as const,\n        timestamp: endTime,\n        details: {\n          endReason: \"emergency_unlock\",\n          emergencyReason: reason,\n          emergencyNotes: additionalNotes,\n          sessionDuration,\n          wasHardcoreMode: session.isHardcoreMode,\n          wasKeyholderControlled: session.keyholderApprovalRequired,\n          accumulatedPauseTime: session.accumulatedPauseTime,\n        },\n        isPrivate: false,\n      });\n\n      // 6. Clear any active restrictions\n      await this.clearActiveRestrictions(userId);\n\n      // 7. Set emergency cooldown period\n      await this.setEmergencyCooldown(userId);\n\n      logger.info(\"Emergency unlock completed successfully\", {\n        sessionId,\n        userId,\n        reason,\n        sessionDuration,\n      });\n\n      return {\n        success: true,\n        message: \"Emergency unlock successful. Session ended immediately.\",\n        sessionId,\n      };\n    } catch (error) {\n      logger.error(\"Emergency unlock failed\", {\n        error: error as Error,\n        sessionId,\n        userId,\n        reason,\n      });\n\n      return {\n        success: false,\n        message: `Emergency unlock failed: ${(error as Error).message}`,\n      };\n    }\n  }\n\n  /**\n   * Check if emergency unlock is allowed (not on cooldown)\n   */\n  private async checkEmergencyUnlockCooldown(userId: string): Promise<{\n    allowed: boolean;\n    cooldownUntil?: Date;\n  }> {\n    try {\n      const settings = await settingsDBService.getSettings(userId);\n      if (!settings || !settings.chastity.emergencyUnlockCooldown) {\n        return { allowed: true };\n      }\n\n      // Check for recent emergency unlocks by getting all events for user\n      const recentEvents = await eventDBService.getEvents(userId, {}, 100, 0);\n\n      const recentEmergencyUnlocks = recentEvents.filter(\n        (event) =>\n          event.type === \"session_end\" &&\n          event.details?.endReason === \"emergency_unlock\" &&\n          event.timestamp.getTime() > Date.now() - 7 * 24 * 60 * 60 * 1000, // Last 7 days\n      );\n\n      if (recentEmergencyUnlocks.length === 0) {\n        return { allowed: true };\n      }\n\n      // Find most recent emergency unlock\n      const lastEmergencyUnlock = recentEmergencyUnlocks.sort(\n        (a, b) => b.timestamp.getTime() - a.timestamp.getTime(),\n      )[0];\n\n      const cooldownHours = settings.chastity.emergencyUnlockCooldown;\n      const cooldownUntil = new Date(\n        lastEmergencyUnlock.timestamp.getTime() +\n          cooldownHours * 60 * 60 * 1000,\n      );\n\n      const isOnCooldown = new Date() < cooldownUntil;\n\n      return {\n        allowed: !isOnCooldown,\n        cooldownUntil: isOnCooldown ? cooldownUntil : undefined,\n      };\n    } catch (error) {\n      logger.error(\"Failed to check emergency unlock cooldown\", {\n        error: error as Error,\n        userId,\n      });\n      // If we can't check cooldown, allow the unlock for safety\n      return { allowed: true };\n    }\n  }\n\n  /**\n   * Clear any active restrictions that might prevent normal app functionality\n   */\n  private async clearActiveRestrictions(userId: string): Promise<void> {\n    try {\n      logger.debug(\"Clearing active restrictions\", { userId });\n\n      // For now, this is a placeholder for future restriction clearing logic\n      // This could include:\n      // - Temporarily disabling hardcore mode restrictions\n      // - Clearing keyholder locks\n      // - Resetting any temporary blocks\n\n      // The actual implementation would depend on how restrictions are stored\n      // and managed in the application\n    } catch (error) {\n      logger.error(\"Failed to clear restrictions\", {\n        error: error as Error,\n        userId,\n      });\n      // Don't throw - restriction clearing is nice-to-have, not critical\n    }\n  }\n\n  /**\n   * Set emergency unlock cooldown period\n   */\n  private async setEmergencyCooldown(userId: string): Promise<void> {\n    try {\n      const settings = await settingsDBService.getSettings(userId);\n      if (!settings || !settings.chastity.emergencyUnlockCooldown) {\n        return; // No cooldown configured\n      }\n\n      logger.debug(\"Emergency cooldown already handled by event logging\", {\n        userId,\n      });\n      // Cooldown is handled by checking recent emergency unlock events\n      // No additional storage needed\n    } catch (error) {\n      logger.error(\"Failed to set emergency cooldown\", {\n        error: error as Error,\n        userId,\n      });\n      // Don't throw - cooldown is a secondary safety feature\n    }\n  }\n\n  /**\n   * Get emergency unlock usage statistics for a user\n   */\n  async getEmergencyUnlockStats(\n    userId: string,\n    daysPeriod: number = 30,\n  ): Promise<{\n    totalEmergencyUnlocks: number;\n    lastEmergencyUnlock?: Date;\n    reasonBreakdown: Record<string, number>;\n    isOnCooldown: boolean;\n    cooldownUntil?: Date;\n  }> {\n    try {\n      const events = await eventDBService.getEvents(userId, {}, 200, 0);\n\n      const startDate = new Date(Date.now() - daysPeriod * 24 * 60 * 60 * 1000);\n      const emergencyUnlocks = events.filter(\n        (event) =>\n          event.type === \"session_end\" &&\n          event.details?.endReason === \"emergency_unlock\" &&\n          event.timestamp >= startDate,\n      );\n\n      const reasonBreakdown: Record<string, number> = {};\n      emergencyUnlocks.forEach((event) => {\n        const reason = (event.details?.emergencyReason as string) || \"Unknown\";\n        reasonBreakdown[reason] = (reasonBreakdown[reason] || 0) + 1;\n      });\n\n      const lastEmergencyUnlock =\n        emergencyUnlocks.length > 0\n          ? emergencyUnlocks.sort(\n              (a, b) => b.timestamp.getTime() - a.timestamp.getTime(),\n            )[0].timestamp\n          : undefined;\n\n      const cooldownCheck = await this.checkEmergencyUnlockCooldown(userId);\n\n      return {\n        totalEmergencyUnlocks: emergencyUnlocks.length,\n        lastEmergencyUnlock,\n        reasonBreakdown,\n        isOnCooldown: !cooldownCheck.allowed,\n        cooldownUntil: cooldownCheck.cooldownUntil,\n      };\n    } catch (error) {\n      logger.error(\"Failed to get emergency unlock stats\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const emergencyService = new EmergencyService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/EventDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/GoalDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/KeyholderRelationshipDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/MigrationService.ts","messages":[{"ruleId":"max-statements","severity":1,"message":"Static async method 'validateDatabaseIntegrity' has too many statements (33). Maximum allowed is 25.","line":291,"column":41,"nodeType":"FunctionExpression","messageId":"exceed","endLine":368,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Migration Service\n * Handles database schema migrations and data transformations\n */\n\nimport { db } from \"../storage/ChastityDB\";\nimport { serviceLogger } from \"../../utils/logging\";\nimport type {\n  DBUser,\n  DBSession,\n  DBEvent,\n  DBTask,\n  DBGoal,\n  DBSettings,\n  DBSyncMeta,\n} from \"../../types/database\";\n\nconst logger = serviceLogger(\"MigrationService\");\n\nexport interface MigrationStep {\n  version: number;\n  description: string;\n  migrate: () => Promise<void>;\n  rollback?: () => Promise<void>;\n}\n\nexport class DBMigrationService {\n  private static migrations: MigrationStep[] = [\n    {\n      version: 2,\n      description: \"Add sync status to existing records\",\n      migrate: async () => {\n        logger.info(\n          \"Running migration v2: Add sync status to existing records\",\n        );\n\n        await db.transaction(\n          \"rw\",\n          db.sessions,\n          db.events,\n          db.tasks,\n          db.goals,\n          async () => {\n            // Update sessions without sync status\n            const sessions = await db.sessions\n              .where(\"syncStatus\")\n              .equals(undefined)\n              .toArray();\n            for (const session of sessions) {\n              await db.sessions.update(session.id, {\n                syncStatus: \"synced\",\n                lastModified: new Date(),\n              });\n            }\n\n            // Update events without sync status\n            const events = await db.events\n              .where(\"syncStatus\")\n              .equals(undefined)\n              .toArray();\n            for (const event of events) {\n              await db.events.update(event.id, {\n                syncStatus: \"synced\",\n                lastModified: new Date(),\n              });\n            }\n\n            // Update tasks without sync status\n            const tasks = await db.tasks\n              .where(\"syncStatus\")\n              .equals(undefined)\n              .toArray();\n            for (const task of tasks) {\n              await db.tasks.update(task.id, {\n                syncStatus: \"synced\",\n                lastModified: new Date(),\n              });\n            }\n\n            // Update goals without sync status\n            const goals = await db.goals\n              .where(\"syncStatus\")\n              .equals(undefined)\n              .toArray();\n            for (const goal of goals) {\n              await db.goals.update(goal.id, {\n                syncStatus: \"synced\",\n                lastModified: new Date(),\n              });\n            }\n          },\n        );\n\n        logger.info(\"Migration v2 completed successfully\");\n      },\n    },\n    {\n      version: 3,\n      description: \"Add isPrivate field to events\",\n      migrate: async () => {\n        logger.info(\"Running migration v3: Add isPrivate field to events\");\n\n        await db.transaction(\"rw\", db.events, async () => {\n          const events = await db.events\n            .where(\"isPrivate\")\n            .equals(undefined)\n            .toArray();\n          for (const event of events) {\n            await db.events.update(event.id, {\n              isPrivate: false, // Default to public for existing events\n            });\n          }\n        });\n\n        logger.info(\"Migration v3 completed successfully\");\n      },\n    },\n  ];\n\n  /**\n   * Run all pending migrations\n   */\n  static async runMigrations(): Promise<void> {\n    try {\n      logger.info(\"Starting database migrations\");\n\n      const currentVersion = db.verno;\n      logger.debug(\"Current database version\", { version: currentVersion });\n\n      // Find migrations that need to be run\n      const pendingMigrations = this.migrations.filter(\n        (migration) => migration.version > currentVersion,\n      );\n\n      if (pendingMigrations.length === 0) {\n        logger.info(\"No migrations needed\");\n        return;\n      }\n\n      logger.info(\"Running migrations\", {\n        count: pendingMigrations.length,\n        versions: pendingMigrations.map((m) => m.version),\n      });\n\n      // Run migrations in order\n      for (const migration of pendingMigrations) {\n        logger.info(\"Running migration\", {\n          version: migration.version,\n          description: migration.description,\n        });\n\n        try {\n          await migration.migrate();\n          logger.info(\"Migration completed\", { version: migration.version });\n        } catch (error) {\n          logger.error(\"Migration failed\", {\n            version: migration.version,\n            error: error as Error,\n          });\n          throw error;\n        }\n      }\n\n      logger.info(\"All migrations completed successfully\");\n    } catch (error) {\n      logger.error(\"Migration process failed\", { error: error as Error });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if migrations are needed\n   */\n  static async checkMigrationsNeeded(): Promise<boolean> {\n    const currentVersion = db.verno;\n    const maxMigrationVersion = Math.max(\n      ...this.migrations.map((m) => m.version),\n    );\n    return currentVersion < maxMigrationVersion;\n  }\n\n  /**\n   * Get migration status information\n   */\n  static async getMigrationStatus(): Promise<{\n    currentVersion: number;\n    latestVersion: number;\n    pendingMigrations: number;\n    migrationsNeeded: boolean;\n  }> {\n    const currentVersion = db.verno;\n    const latestVersion = Math.max(...this.migrations.map((m) => m.version));\n    const pendingMigrations = this.migrations.filter(\n      (m) => m.version > currentVersion,\n    ).length;\n\n    return {\n      currentVersion,\n      latestVersion,\n      pendingMigrations,\n      migrationsNeeded: pendingMigrations > 0,\n    };\n  }\n\n  /**\n   * Backup database before running migrations\n   */\n  static async createBackup(): Promise<{\n    users: DBUser[];\n    sessions: DBSession[];\n    events: DBEvent[];\n    tasks: DBTask[];\n    goals: DBGoal[];\n    settings: DBSettings[];\n    syncMeta: DBSyncMeta[];\n  }> {\n    logger.info(\"Creating database backup\");\n\n    const backup = {\n      users: await db.users.toArray(),\n      sessions: await db.sessions.toArray(),\n      events: await db.events.toArray(),\n      tasks: await db.tasks.toArray(),\n      goals: await db.goals.toArray(),\n      settings: await db.settings.toArray(),\n      syncMeta: await db.syncMeta.toArray(),\n    };\n\n    logger.info(\"Database backup created\", {\n      users: backup.users.length,\n      sessions: backup.sessions.length,\n      events: backup.events.length,\n      tasks: backup.tasks.length,\n      goals: backup.goals.length,\n      settings: backup.settings.length,\n    });\n\n    return backup;\n  }\n\n  /**\n   * Restore database from backup\n   */\n  static async restoreFromBackup(backup: {\n    users: DBUser[];\n    sessions: DBSession[];\n    events: DBEvent[];\n    tasks: DBTask[];\n    goals: DBGoal[];\n    settings: DBSettings[];\n    syncMeta: DBSyncMeta[];\n  }): Promise<void> {\n    logger.info(\"Restoring database from backup\");\n\n    await db.transaction(\n      \"rw\",\n      db.users,\n      db.sessions,\n      db.events,\n      db.tasks,\n      db.goals,\n      db.settings,\n      db.syncMeta,\n      async () => {\n        // Clear existing data\n        await db.users.clear();\n        await db.sessions.clear();\n        await db.events.clear();\n        await db.tasks.clear();\n        await db.goals.clear();\n        await db.settings.clear();\n        await db.syncMeta.clear();\n\n        // Restore from backup\n        await db.users.bulkAdd(backup.users);\n        await db.sessions.bulkAdd(backup.sessions);\n        await db.events.bulkAdd(backup.events);\n        await db.tasks.bulkAdd(backup.tasks);\n        await db.goals.bulkAdd(backup.goals);\n        await db.settings.bulkAdd(backup.settings);\n        await db.syncMeta.bulkAdd(backup.syncMeta);\n      },\n    );\n\n    logger.info(\"Database restored from backup successfully\");\n  }\n\n  /**\n   * Validate database integrity after migration\n   */\n  static async validateDatabaseIntegrity(): Promise<{\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n  }> {\n    logger.info(\"Validating database integrity\");\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      // Check for required fields\n      const sessions = await db.sessions.toArray();\n      for (const session of sessions) {\n        if (!session.syncStatus) {\n          errors.push(`Session ${session.id} missing syncStatus`);\n        }\n        if (!session.lastModified) {\n          errors.push(`Session ${session.id} missing lastModified`);\n        }\n        if (!session.userId) {\n          errors.push(`Session ${session.id} missing userId`);\n        }\n      }\n\n      const events = await db.events.toArray();\n      for (const event of events) {\n        if (!event.syncStatus) {\n          errors.push(`Event ${event.id} missing syncStatus`);\n        }\n        if (event.isPrivate === undefined) {\n          warnings.push(`Event ${event.id} missing isPrivate field`);\n        }\n      }\n\n      const tasks = await db.tasks.toArray();\n      for (const task of tasks) {\n        if (!task.syncStatus) {\n          errors.push(`Task ${task.id} missing syncStatus`);\n        }\n        if (!task.status) {\n          errors.push(`Task ${task.id} missing status`);\n        }\n      }\n\n      // Check referential integrity\n      for (const event of events) {\n        if (event.sessionId) {\n          const session = await db.sessions.get(event.sessionId);\n          if (!session) {\n            warnings.push(\n              `Event ${event.id} references non-existent session ${event.sessionId}`,\n            );\n          }\n        }\n      }\n\n      logger.info(\"Database integrity check completed\", {\n        errors: errors.length,\n        warnings: warnings.length,\n      });\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings,\n      };\n    } catch (error) {\n      logger.error(\"Database integrity check failed\", {\n        error: error as Error,\n      });\n      return {\n        isValid: false,\n        errors: [`Integrity check failed: ${(error as Error).message}`],\n        warnings,\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/PerformanceService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4669,4672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4669,4672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-statements","severity":1,"message":"Static async method 'runBenchmarks' has too many statements (30). Maximum allowed is 25.","line":259,"column":29,"nodeType":"FunctionExpression","messageId":"exceed","endLine":339,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Performance Monitoring Service\n * Monitors and optimizes database query performance\n */\n\nimport { db } from \"../storage/ChastityDB\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"PerformanceService\");\n\nexport interface QueryMetrics {\n  operation: string;\n  table: string;\n  duration: number;\n  recordCount: number;\n  timestamp: Date;\n  queryDetails?: {\n    filter?: Record<string, unknown>;\n    sort?: string;\n    limit?: number;\n    index?: string;\n    error?: string;\n  };\n}\n\nexport interface PerformanceReport {\n  totalQueries: number;\n  averageQueryTime: number;\n  slowestQueries: QueryMetrics[];\n  tableStats: Record<\n    string,\n    {\n      queryCount: number;\n      averageTime: number;\n      totalRecords: number;\n    }\n  >;\n  recommendations: string[];\n}\n\nexport class DBPerformanceService {\n  private static metrics: QueryMetrics[] = [];\n  private static readonly MAX_METRICS = 1000; // Keep last 1000 queries\n  private static readonly SLOW_QUERY_THRESHOLD = 100; // ms\n\n  /**\n   * Record a query metric\n   */\n  static recordQuery(\n    operation: string,\n    table: string,\n    duration: number,\n    recordCount: number,\n    queryDetails?: QueryMetrics[\"queryDetails\"],\n  ): void {\n    const metric: QueryMetrics = {\n      operation,\n      table,\n      duration,\n      recordCount,\n      timestamp: new Date(),\n      queryDetails,\n    };\n\n    this.metrics.push(metric);\n\n    // Keep only the last MAX_METRICS entries\n    if (this.metrics.length > this.MAX_METRICS) {\n      this.metrics = this.metrics.slice(-this.MAX_METRICS);\n    }\n\n    // Log slow queries\n    if (duration > this.SLOW_QUERY_THRESHOLD) {\n      logger.warn(\"Slow query detected\", {\n        operation,\n        table,\n        duration,\n        recordCount,\n        threshold: this.SLOW_QUERY_THRESHOLD,\n      });\n    }\n\n    logger.debug(\"Query recorded\", { operation, table, duration, recordCount });\n  }\n\n  /**\n   * Create a performance wrapper for database operations\n   */\n  static wrapOperation<T>(\n    operation: string,\n    table: string,\n    queryFn: () => Promise<T>,\n  ): Promise<T> {\n    const startTime = performance.now();\n\n    try {\n      const result = await queryFn();\n      const duration = performance.now() - startTime;\n\n      // Determine record count\n      let recordCount = 0;\n      if (Array.isArray(result)) {\n        recordCount = result.length;\n      } else if (result !== null && result !== undefined) {\n        recordCount = 1;\n      }\n\n      this.recordQuery(operation, table, duration, recordCount);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      this.recordQuery(`${operation}_ERROR`, table, duration, 0, {\n        error: (error as Error).message,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generate performance report\n   */\n  static generateReport(): PerformanceReport {\n    if (this.metrics.length === 0) {\n      return {\n        totalQueries: 0,\n        averageQueryTime: 0,\n        slowestQueries: [],\n        tableStats: {},\n        recommendations: [\"No queries recorded yet\"],\n      };\n    }\n\n    const totalQueries = this.metrics.length;\n    const averageQueryTime =\n      this.metrics.reduce((sum, m) => sum + m.duration, 0) / totalQueries;\n\n    // Find slowest queries\n    const slowestQueries = [...this.metrics]\n      .sort((a, b) => b.duration - a.duration)\n      .slice(0, 10);\n\n    // Calculate table statistics\n    const tableStats: Record<\n      string,\n      {\n        queryCount: number;\n        averageTime: number;\n        totalRecords: number;\n      }\n    > = {};\n\n    for (const metric of this.metrics) {\n      if (!tableStats[metric.table]) {\n        tableStats[metric.table] = {\n          queryCount: 0,\n          averageTime: 0,\n          totalRecords: 0,\n        };\n      }\n\n      const stats = tableStats[metric.table];\n      stats.queryCount++;\n      stats.averageTime =\n        (stats.averageTime * (stats.queryCount - 1) + metric.duration) /\n        stats.queryCount;\n      stats.totalRecords += metric.recordCount;\n    }\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(\n      tableStats,\n      slowestQueries,\n    );\n\n    logger.info(\"Performance report generated\", {\n      totalQueries,\n      averageQueryTime: Math.round(averageQueryTime * 100) / 100,\n      tablesAnalyzed: Object.keys(tableStats).length,\n    });\n\n    return {\n      totalQueries,\n      averageQueryTime,\n      slowestQueries,\n      tableStats,\n      recommendations,\n    };\n  }\n\n  /**\n   * Generate performance recommendations\n   */\n  private static generateRecommendations(\n    tableStats: Record<string, any>,\n    slowestQueries: QueryMetrics[],\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Check for slow average query times\n    for (const [table, stats] of Object.entries(tableStats)) {\n      if (stats.averageTime > this.SLOW_QUERY_THRESHOLD) {\n        recommendations.push(\n          `Consider optimizing queries on ${table} table (avg: ${Math.round(stats.averageTime)}ms)`,\n        );\n      }\n    }\n\n    // Check for frequently queried tables\n    const sortedTables = Object.entries(tableStats).sort(\n      ([, a], [, b]) => b.queryCount - a.queryCount,\n    );\n\n    if (sortedTables.length > 0) {\n      const [mostQueriedTable, stats] = sortedTables[0];\n      if (stats.queryCount > totalQueries * 0.4) {\n        recommendations.push(\n          `${mostQueriedTable} table is heavily queried (${stats.queryCount} queries). Consider caching frequently accessed data.`,\n        );\n      }\n    }\n\n    // Check for large result sets\n    const largeResultQueries = slowestQueries.filter(\n      (q) => q.recordCount > 100,\n    );\n    if (largeResultQueries.length > 0) {\n      recommendations.push(\n        `${largeResultQueries.length} queries returned >100 records. Consider implementing pagination.`,\n      );\n    }\n\n    // Check for error patterns\n    const errorQueries = this.metrics.filter((m) =>\n      m.operation.endsWith(\"_ERROR\"),\n    );\n    if (errorQueries.length > totalQueries * 0.05) {\n      recommendations.push(\n        `High error rate detected (${errorQueries.length}/${totalQueries} queries). Review error handling.`,\n      );\n    }\n\n    // General recommendations\n    if (recommendations.length === 0) {\n      recommendations.push(\n        \"Database performance looks good! No specific optimizations needed.\",\n      );\n    } else {\n      recommendations.push(\n        \"Regular performance monitoring is recommended for optimal database performance.\",\n      );\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Run performance benchmarks\n   */\n  static async runBenchmarks(): Promise<{\n    insertPerformance: number;\n    queryPerformance: number;\n    updatePerformance: number;\n    indexEfficiency: number;\n  }> {\n    logger.info(\"Starting performance benchmarks\");\n\n    const testUserId = \"benchmark-user\";\n    const testData = [];\n\n    try {\n      // Clean up any existing benchmark data\n      await db.events.where(\"userId\").equals(testUserId).delete();\n\n      // Benchmark INSERT operations\n      const insertStart = performance.now();\n      for (let i = 0; i < 100; i++) {\n        const id = await db.events.add({\n          id: `benchmark-event-${i}`,\n          userId: testUserId,\n          type: \"note\",\n          details: { notes: `Benchmark event ${i}` },\n          isPrivate: false,\n          timestamp: new Date(),\n          syncStatus: \"pending\",\n          lastModified: new Date(),\n        });\n        testData.push(id);\n      }\n      const insertTime = performance.now() - insertStart;\n\n      // Benchmark QUERY operations\n      const queryStart = performance.now();\n      for (let i = 0; i < 50; i++) {\n        await db.events.where(\"userId\").equals(testUserId).toArray();\n      }\n      const queryTime = performance.now() - queryStart;\n\n      // Benchmark UPDATE operations\n      const updateStart = performance.now();\n      for (const id of testData.slice(0, 50)) {\n        await db.events.update(id, { syncStatus: \"synced\" });\n      }\n      const updateTime = performance.now() - updateStart;\n\n      // Test index efficiency\n      const indexStart = performance.now();\n      await db.events\n        .where(\"[userId+type]\")\n        .equals([testUserId, \"note\"])\n        .toArray();\n      const indexTime = performance.now() - indexStart;\n\n      // Clean up benchmark data\n      await db.events.where(\"userId\").equals(testUserId).delete();\n\n      const results = {\n        insertPerformance: Math.round((insertTime / 100) * 100) / 100, // ms per insert\n        queryPerformance: Math.round((queryTime / 50) * 100) / 100, // ms per query\n        updatePerformance: Math.round((updateTime / 50) * 100) / 100, // ms per update\n        indexEfficiency: Math.round(indexTime * 100) / 100, // ms for indexed query\n      };\n\n      logger.info(\"Performance benchmarks completed\", results);\n      return results;\n    } catch (error) {\n      logger.error(\"Benchmark failed\", { error: error as Error });\n\n      // Clean up on error\n      try {\n        await db.events.where(\"userId\").equals(testUserId).delete();\n      } catch (cleanupError) {\n        logger.error(\"Benchmark cleanup failed\", {\n          error: cleanupError as Error,\n        });\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Clear performance metrics\n   */\n  static clearMetrics(): void {\n    this.metrics = [];\n    logger.info(\"Performance metrics cleared\");\n  }\n\n  /**\n   * Get current metrics\n   */\n  static getMetrics(): QueryMetrics[] {\n    return [...this.metrics];\n  }\n\n  /**\n   * Monitor database size and suggest cleanup\n   */\n  static async analyzeDatabaseSize(): Promise<{\n    totalRecords: number;\n    tableBreakdown: Record<string, number>;\n    sizeRecommendations: string[];\n  }> {\n    logger.info(\"Analyzing database size\");\n\n    const stats = await db.getStats();\n    const totalRecords = Object.values(stats).reduce(\n      (sum, count) => sum + count,\n      0,\n    );\n\n    const sizeRecommendations: string[] = [];\n\n    // Check for large tables\n    Object.entries(stats).forEach(([table, count]) => {\n      if (count > 10000) {\n        sizeRecommendations.push(\n          `${table} table has ${count} records. Consider archiving old data.`,\n        );\n      }\n    });\n\n    // Check for old data\n    const oneYearAgo = new Date();\n    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n\n    const oldEvents = await db.events\n      .where(\"timestamp\")\n      .below(oneYearAgo)\n      .count();\n\n    if (oldEvents > 1000) {\n      sizeRecommendations.push(\n        `${oldEvents} events are over 1 year old. Consider archiving to improve performance.`,\n      );\n    }\n\n    if (sizeRecommendations.length === 0) {\n      sizeRecommendations.push(\"Database size is within recommended limits.\");\n    }\n\n    const results = {\n      totalRecords,\n      tableBreakdown: stats,\n      sizeRecommendations,\n    };\n\n    logger.info(\"Database size analysis completed\", results);\n    return results;\n  }\n}\n\n// Global variable reference\nconst totalQueries = DBPerformanceService.getMetrics().length;\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/RelationshipChastityService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deleteDoc' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'where' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":8},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'startSession' has too many lines (85). Maximum allowed is 75.","line":138,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":236,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4244,4247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4244,4247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4413,4416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4413,4416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6943,6946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6943,6946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9094,9097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9094,9097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":453,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11094,11097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11094,11097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (681). Maximum allowed is 500.","line":637,"column":1,"nodeType":null,"messageId":"exceed","endLine":864,"endColumn":1},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":680,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":680,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16683,16686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16683,16686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":829,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":829,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20323,20326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20323,20326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":859,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":859,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21066,21069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21066,21069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Chastity Service\n * REFACTORED: Now uses domain-focused services for better maintainability\n *\n * This file maintains backward compatibility by re-exporting the facade service\n * that delegates to the appropriate domain services.\n */\nimport {\n  collection,\n  doc,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  getDoc,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  limit,\n  serverTimestamp,\n  writeBatch,\n  onSnapshot,\n  Unsubscribe,\n  Firestore,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport {\n  RelationshipChastityData,\n  RelationshipSession,\n  RelationshipTask,\n  RelationshipEvent,\n  SessionEvent,\n  RelationshipTaskStatus,\n} from \"@/types/relationships\";\nimport { relationshipService } from \"./RelationshipService\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\n\nconst logger = serviceLogger(\"RelationshipChastityService\");\n\nclass RelationshipChastityService {\n  private db: Firestore | null = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  // ==================== CHASTITY DATA MANAGEMENT ====================\n\n  /**\n   * Get chastity data for a relationship\n   */\n  async getChastityData(\n    relationshipId: string,\n  ): Promise<RelationshipChastityData | null> {\n    try {\n      const db = await this.ensureDb();\n      const docSnapshot = await getDoc(doc(db, \"chastityData\", relationshipId));\n\n      if (!docSnapshot.exists()) {\n        return null;\n      }\n\n      const data = {\n        ...docSnapshot.data(),\n        relationshipId: docSnapshot.id,\n      } as RelationshipChastityData;\n\n      logger.debug(\"Retrieved chastity data\", { relationshipId });\n      return data;\n    } catch (error) {\n      logger.error(\"Failed to get chastity data\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update chastity data settings\n   */\n  async updateChastitySettings(\n    relationshipId: string,\n    settings: Partial<RelationshipChastityData[\"settings\"]>,\n    userId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"settings\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to update settings\");\n      }\n\n      await updateDoc(doc(db, \"chastityData\", relationshipId), {\n        settings,\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Updated chastity settings\", {\n        relationshipId,\n        userId,\n        settings,\n      });\n    } catch (error) {\n      logger.error(\"Failed to update chastity settings\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== SESSION MANAGEMENT ====================\n\n  /**\n   * Start a new chastity session\n   */\n  async startSession(\n    relationshipId: string,\n    userId: string,\n    options: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    } = {},\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check if user has permission to start session\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"sessions\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to start session\");\n      }\n\n      // Check if there's already an active session\n      const chastityData = await this.getChastityData(relationshipId);\n      if (chastityData?.currentSession.isActive) {\n        throw new Error(\"A session is already active for this relationship\");\n      }\n\n      const sessionId = generateUUID();\n      const batch = writeBatch(db);\n\n      // Create session record\n      const sessionData: Omit<RelationshipSession, \"createdAt\" | \"updatedAt\"> =\n        {\n          id: sessionId,\n          relationshipId,\n          startTime: serverTimestamp() as any,\n          duration: 0,\n          effectiveDuration: 0,\n          events: [\n            {\n              type: \"start\",\n              timestamp: serverTimestamp() as any,\n              initiatedBy:\n                userId === chastityData?.keyholderId\n                  ? \"keyholder\"\n                  : \"submissive\",\n              reason: options.notes,\n            },\n          ],\n          goalMet: false,\n          keyholderApproval: {\n            required: false,\n          },\n        };\n\n      batch.set(\n        doc(db, \"chastityData\", relationshipId, \"sessions\", sessionId),\n        {\n          ...sessionData,\n          createdAt: serverTimestamp(),\n          updatedAt: serverTimestamp(),\n        },\n      );\n\n      // Update current session in chastity data\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        currentSession: {\n          id: sessionId,\n          isActive: true,\n          startTime: serverTimestamp(),\n          accumulatedPauseTime: 0,\n          keyholderApprovalRequired:\n            chastityData?.settings.requireReasonForEnd || false,\n        },\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Started new session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        options,\n      });\n\n      return sessionId;\n    } catch (error) {\n      logger.error(\"Failed to start session\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n        options,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * End a chastity session\n   */\n  async endSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    endReason?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"sessions\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to end session\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Update session record\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n      const endTime = new Date();\n      const totalDuration =\n        endTime.getTime() - sessionData.startTime.toDate().getTime();\n\n      // Add end event\n      const endEvent: SessionEvent = {\n        type: \"end\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy:\n          userId === (await this.getKeyholderId(relationshipId))\n            ? \"keyholder\"\n            : \"submissive\",\n        reason: endReason,\n      };\n\n      batch.update(sessionRef, {\n        endTime: serverTimestamp(),\n        duration: Math.floor(totalDuration / 1000),\n        events: [...sessionData.events, endEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session in chastity data\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        currentSession: {\n          id: \"\",\n          isActive: false,\n          startTime: serverTimestamp(),\n          accumulatedPauseTime: 0,\n          keyholderApprovalRequired: false,\n        },\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Ended session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        endReason,\n      });\n    } catch (error) {\n      logger.error(\"Failed to end session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Pause a session\n   */\n  async pauseSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    pauseReason?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check if submissive can pause\n      const canPause = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"pauseSession\",\n      );\n\n      if (!canPause) {\n        throw new Error(\"Insufficient permissions to pause session\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Update session with pause event\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n\n      const pauseEvent: SessionEvent = {\n        type: \"pause\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy: \"submissive\",\n        reason: pauseReason,\n      };\n\n      batch.update(sessionRef, {\n        events: [...sessionData.events, pauseEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        \"currentSession.pausedAt\": serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Paused session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        pauseReason,\n      });\n    } catch (error) {\n      logger.error(\"Failed to pause session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Resume a paused session\n   */\n  async resumeSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get current chastity data to calculate pause time\n      const chastityData = await this.getChastityData(relationshipId);\n      if (!chastityData?.currentSession.pausedAt) {\n        throw new Error(\"Session is not paused\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Calculate pause duration\n      const pauseEnd = new Date();\n      const pauseStart = chastityData.currentSession.pausedAt.toDate();\n      const pauseDuration = Math.floor(\n        (pauseEnd.getTime() - pauseStart.getTime()) / 1000,\n      );\n\n      // Update session with resume event\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n\n      const resumeEvent: SessionEvent = {\n        type: \"resume\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy: \"submissive\",\n      };\n\n      batch.update(sessionRef, {\n        events: [...sessionData.events, resumeEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        \"currentSession.pausedAt\": null,\n        \"currentSession.accumulatedPauseTime\":\n          chastityData.currentSession.accumulatedPauseTime + pauseDuration,\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Resumed session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        pauseDuration,\n      });\n    } catch (error) {\n      logger.error(\"Failed to resume session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== TASK MANAGEMENT ====================\n\n  /**\n   * Create a new task\n   */\n  async createTask(\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n    userId: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"tasks\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to create tasks\");\n      }\n\n      const taskId = generateUUID();\n      const isKeyholder =\n        userId === (await this.getKeyholderId(relationshipId));\n\n      const task: Omit<RelationshipTask, \"createdAt\" | \"updatedAt\"> = {\n        id: taskId,\n        relationshipId,\n        text: taskData.text,\n        assignedBy: isKeyholder ? \"keyholder\" : \"submissive\",\n        assignedTo: \"submissive\",\n        dueDate: taskData.dueDate ? serverTimestamp() : undefined,\n        status: RelationshipTaskStatus.PENDING,\n        consequence: taskData.consequence,\n      };\n\n      await addDoc(collection(db, \"chastityData\", relationshipId, \"tasks\"), {\n        ...task,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Created task\", {\n        taskId,\n        relationshipId,\n        userId,\n        isKeyholder,\n      });\n\n      return taskId;\n    } catch (error) {\n      logger.error(\"Failed to create task\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update task status\n   */\n  async updateTaskStatus(\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTaskStatus,\n    userId: string,\n    note?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      const updateData: Record<string, unknown> = {\n        status,\n        updatedAt: serverTimestamp(),\n      };\n\n      // Add role-specific fields\n      const isKeyholder =\n        userId === (await this.getKeyholderId(relationshipId));\n\n      if (status === RelationshipTaskStatus.SUBMITTED && !isKeyholder) {\n        updateData.submittedAt = serverTimestamp();\n        updateData.submissiveNote = note;\n      } else if (\n        (status === RelationshipTaskStatus.APPROVED ||\n          status === RelationshipTaskStatus.REJECTED) &&\n        isKeyholder\n      ) {\n        updateData.approvedAt = serverTimestamp();\n        updateData.keyholderFeedback = note;\n      } else if (status === RelationshipTaskStatus.COMPLETED) {\n        updateData.completedAt = serverTimestamp();\n      }\n\n      await updateDoc(\n        doc(db, \"chastityData\", relationshipId, \"tasks\", taskId),\n        updateData,\n      );\n\n      logger.info(\"Updated task status\", {\n        taskId,\n        relationshipId,\n        status,\n        userId,\n        isKeyholder,\n      });\n    } catch (error) {\n      logger.error(\"Failed to update task status\", {\n        error: error as Error,\n        taskId,\n        relationshipId,\n        status,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get tasks for a relationship\n   */\n  async getTasks(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipTask[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const tasksSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"tasks\"),\n          orderBy(\"createdAt\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const tasks = tasksSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipTask[];\n\n      logger.debug(\"Retrieved tasks\", {\n        relationshipId,\n        count: tasks.length,\n      });\n\n      return tasks;\n    } catch (error) {\n      logger.error(\"Failed to get tasks\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== EVENT LOGGING ====================\n\n  /**\n   * Log an event\n   */\n  async logEvent(\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n    userId: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      const eventId = generateUUID();\n      const isKeyholder =\n        userId === (await this.getKeyholderId(relationshipId));\n\n      const event: Omit<RelationshipEvent, \"createdAt\"> = {\n        id: eventId,\n        relationshipId,\n        type: eventData.type,\n        timestamp: serverTimestamp() as any,\n        details: eventData.details,\n        loggedBy: isKeyholder ? \"keyholder\" : \"submissive\",\n        isPrivate: eventData.isPrivate || false,\n        tags: eventData.tags,\n      };\n\n      await addDoc(collection(db, \"chastityData\", relationshipId, \"events\"), {\n        ...event,\n        createdAt: serverTimestamp(),\n      });\n\n      logger.info(\"Logged event\", {\n        eventId,\n        relationshipId,\n        type: eventData.type,\n        userId,\n        isKeyholder,\n      });\n\n      return eventId;\n    } catch (error) {\n      logger.error(\"Failed to log event\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get events for a relationship\n   */\n  async getEvents(\n    relationshipId: string,\n    limitCount: number = 100,\n  ): Promise<RelationshipEvent[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const eventsSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"events\"),\n          orderBy(\"timestamp\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const events = eventsSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipEvent[];\n\n      logger.debug(\"Retrieved events\", {\n        relationshipId,\n        count: events.length,\n      });\n\n      return events;\n    } catch (error) {\n      logger.error(\"Failed to get events\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Get keyholder ID for a relationship\n   */\n  private async getKeyholderId(relationshipId: string): Promise<string> {\n    const relationship =\n      await relationshipService.getRelationship(relationshipId);\n    if (!relationship) {\n      throw new Error(\"Relationship not found\");\n    }\n    return relationship.keyholderId;\n  }\n\n  /**\n   * Get session history for a relationship\n   */\n  async getSessionHistory(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipSession[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const sessionsSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"sessions\"),\n          orderBy(\"startTime\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const sessions = sessionsSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipSession[];\n\n      logger.debug(\"Retrieved session history\", {\n        relationshipId,\n        count: sessions.length,\n      });\n\n      return sessions;\n    } catch (error) {\n      logger.error(\"Failed to get session history\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== REAL-TIME LISTENERS ====================\n\n  /**\n   * Subscribe to chastity data changes\n   */\n  subscribeToChastityData(\n    relationshipId: string,\n    callback: (data: RelationshipChastityData | null) => void,\n  ): Unsubscribe {\n    return this.ensureDb().then((db) => {\n      return onSnapshot(\n        doc(db, \"chastityData\", relationshipId),\n        (doc) => {\n          const data = doc.exists()\n            ? ({\n                ...doc.data(),\n                relationshipId: doc.id,\n              } as RelationshipChastityData)\n            : null;\n          callback(data);\n        },\n        (error) => {\n          logger.error(\"Error in chastity data subscription\", {\n            error,\n            relationshipId,\n          });\n        },\n      );\n    }) as any;\n  }\n\n  /**\n   * Subscribe to task changes\n   */\n  subscribeToTasks(\n    relationshipId: string,\n    callback: (tasks: RelationshipTask[]) => void,\n  ): Unsubscribe {\n    return this.ensureDb().then((db) => {\n      return onSnapshot(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"tasks\"),\n          orderBy(\"createdAt\", \"desc\"),\n        ),\n        (snapshot) => {\n          const tasks = snapshot.docs.map((doc) => ({\n            ...doc.data(),\n            id: doc.id,\n          })) as RelationshipTask[];\n          callback(tasks);\n        },\n        (error) => {\n          logger.error(\"Error in tasks subscription\", {\n            error,\n            relationshipId,\n          });\n        },\n      );\n    }) as any;\n  }\n}\n\nexport const relationshipChastityService = new RelationshipChastityService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/SessionDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/SettingsDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/TaskDBService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementBadgeService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[570,573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[570,573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Badge Service\n * Handles user achievements, badges, and their visibility\n */\n\nimport { ChastityDB } from \"../../storage/ChastityDB\";\nimport { DBUserAchievement } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementBadgeService {\n  private userAchievementsTable = ChastityDB.userAchievements;\n\n  private generateId(): string {\n    return `ua_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async queueSync(\n    collection: string,\n    operation: string,\n    id: string,\n    _data: any,\n  ): Promise<void> {\n    // Simplified sync queue - would normally integrate with proper sync service\n    logger.debug(`Queued sync: ${operation} ${collection}/${id}`);\n  }\n\n  /**\n   * Award achievement to user\n   */\n  async awardAchievement(\n    userId: string,\n    achievementId: string,\n    progress: number = 100,\n    metadata?: Record<string, unknown>,\n  ): Promise<string> {\n    try {\n      // Check if user already has this achievement\n      const existing = await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.achievementId === achievementId)\n        .first();\n\n      if (existing) {\n        logger.warn(\n          `User ${userId} already has achievement ${achievementId}`,\n          \"AchievementBadgeService\",\n        );\n        return existing.id;\n      }\n\n      const userAchievement: DBUserAchievement = {\n        id: this.generateId(),\n        userId,\n        achievementId,\n        earnedAt: new Date(),\n        progress,\n        metadata,\n        isVisible: true,\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.userAchievementsTable.add(userAchievement);\n      await this.queueSync(\n        \"userAchievements\",\n        \"create\",\n        userAchievement.id,\n        userAchievement,\n      );\n\n      logger.info(\n        `Achievement ${achievementId} awarded to user ${userId}`,\n        \"AchievementBadgeService\",\n      );\n      return userAchievement.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to award achievement\",\n        error,\n        \"AchievementBadgeService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's earned achievements\n   */\n  async getUserAchievements(userId: string): Promise<DBUserAchievement[]> {\n    try {\n      return await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievements\",\n        error,\n        \"AchievementBadgeService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get user's visible achievements (for public profile)\n   */\n  async getUserVisibleAchievements(\n    userId: string,\n  ): Promise<DBUserAchievement[]> {\n    try {\n      return await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.isVisible)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user visible achievements\",\n        error,\n        \"AchievementBadgeService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Toggle achievement visibility\n   */\n  async toggleAchievementVisibility(\n    userId: string,\n    achievementId: string,\n  ): Promise<void> {\n    try {\n      const userAchievement = await this.userAchievementsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ua) => ua.achievementId === achievementId)\n        .first();\n\n      if (!userAchievement) {\n        throw new Error(\"User achievement not found\");\n      }\n\n      userAchievement.isVisible = !userAchievement.isVisible;\n      userAchievement.lastModified = new Date();\n      userAchievement.syncStatus = \"pending\";\n\n      await this.userAchievementsTable.put(userAchievement);\n      await this.queueSync(\n        \"userAchievements\",\n        \"update\",\n        userAchievement.id,\n        userAchievement,\n      );\n\n      logger.info(\n        `Achievement ${achievementId} visibility toggled for user ${userId}`,\n        \"AchievementBadgeService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to toggle achievement visibility\",\n        error,\n        \"AchievementBadgeService\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementBadgeService = new AchievementBadgeService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementCRUDService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[581,584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[581,584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement CRUD Service\n * Handles basic CRUD operations for achievement definitions\n */\n\nimport { ChastityDB } from \"../../storage/ChastityDB\";\nimport { DBAchievement, AchievementCategory } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementCRUDService {\n  private achievementsTable = ChastityDB.achievements;\n\n  private generateId(): string {\n    return `ach_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async queueSync(\n    collection: string,\n    operation: string,\n    id: string,\n    __data: any,\n  ): Promise<void> {\n    // Simplified sync queue - would normally integrate with proper sync service\n    logger.debug(`Queued sync: ${operation} ${collection}/${id}`);\n  }\n\n  /**\n   * Create or update achievement definition\n   */\n  async createAchievement(\n    achievement: Omit<DBAchievement, \"id\" | \"syncStatus\" | \"lastModified\">,\n  ): Promise<string> {\n    try {\n      const achievementData: DBAchievement = {\n        ...achievement,\n        id: this.generateId(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.achievementsTable.add(achievementData);\n      await this.queueSync(\n        \"achievements\",\n        \"create\",\n        achievementData.id,\n        achievementData,\n      );\n\n      logger.info(\n        `Achievement created: ${achievementData.name}`,\n        \"AchievementCRUDService\",\n      );\n      return achievementData.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to create achievement\",\n        error,\n        \"AchievementCRUDService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get all achievements (for system reference)\n   */\n  async getAllAchievements(): Promise<DBAchievement[]> {\n    try {\n      return await this.achievementsTable.where(\"isActive\").equals(1).toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievements\",\n        error,\n        \"AchievementCRUDService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get achievement by ID\n   */\n  async getAchievementById(id: string): Promise<DBAchievement | null> {\n    try {\n      const achievement = await this.achievementsTable.get(id);\n      return achievement || null;\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievement by ID\",\n        error,\n        \"AchievementCRUDService\",\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Get achievements by category\n   */\n  async getAchievementsByCategory(\n    category: AchievementCategory,\n  ): Promise<DBAchievement[]> {\n    try {\n      return await this.achievementsTable\n        .where(\"category\")\n        .equals(category)\n        .and((achievement) => achievement.isActive)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievements by category\",\n        error,\n        \"AchievementCRUDService\",\n      );\n      return [];\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementCRUDService = new AchievementCRUDService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementLeaderboardService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[575,578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[575,578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-params","severity":1,"message":"Async method 'updateLeaderboardEntry' has too many parameters (6). Maximum allowed is 5.","line":96,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":96,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2725,2728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2725,2728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2756,2759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2756,2759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":146,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3643,3646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3643,3646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4128,4131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4128,4131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Leaderboard Service\n * Handles leaderboard operations and rankings\n */\n\nimport { ChastityDB } from \"../../storage/ChastityDB\";\nimport { DBLeaderboardEntry } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementLeaderboardService {\n  private leaderboardEntriesTable = ChastityDB.leaderboardEntries;\n\n  private generateId(): string {\n    return `le_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async queueSync(\n    collection: string,\n    operation: string,\n    id: string,\n    _data: any,\n  ): Promise<void> {\n    // Simplified sync queue - would normally integrate with proper sync service\n    logger.debug(`Queued sync: ${operation} ${collection}/${id}`);\n  }\n\n  /**\n   * Get leaderboard entries for a category and period\n   */\n  async getLeaderboard(\n    category: string,\n    period: string,\n    limit: number = 50,\n  ): Promise<DBLeaderboardEntry[]> {\n    try {\n      return await this.leaderboardEntriesTable\n        .where(\"[category+period]\")\n        .equals([category, period])\n        .reverse()\n        .sortBy(\"rank\")\n        .then((entries) => entries.slice(0, limit));\n    } catch (error) {\n      logger.error(\n        \"Failed to get leaderboard\",\n        error,\n        \"AchievementLeaderboardService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get user's rank in a specific leaderboard\n   */\n  async getUserLeaderboardRank(\n    userId: string,\n    category: string,\n    period: string,\n  ): Promise<{\n    rank: number;\n    value: number;\n    totalParticipants: number;\n  } | null> {\n    try {\n      const userEntry = await this.leaderboardEntriesTable\n        .where(\"[userId+category+period]\")\n        .equals([userId, category, period])\n        .first();\n\n      if (!userEntry) return null;\n\n      // Get total participants count\n      const totalParticipants = await this.leaderboardEntriesTable\n        .where(\"[category+period]\")\n        .equals([category, period])\n        .count();\n\n      return {\n        rank: userEntry.rank,\n        value: userEntry.value,\n        totalParticipants,\n      };\n    } catch (error) {\n      logger.error(\n        \"Failed to get user leaderboard rank\",\n        error,\n        \"AchievementLeaderboardService\",\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Update user's leaderboard entry\n   */\n  async updateLeaderboardEntry(\n    userId: string,\n    category: string,\n    period: string,\n    value: number,\n    displayName: string = \"Anonymous\",\n    displayNameType: \"real\" | \"username\" | \"anonymous\" = \"anonymous\",\n  ): Promise<void> {\n    try {\n      const entryData: DBLeaderboardEntry = {\n        id: this.generateId(),\n        userId,\n        category: category as any,\n        period: period as any,\n        value,\n        rank: 0, // Will be calculated by ranking algorithm\n        displayName,\n        displayNameType,\n        isAnonymous: displayNameType === \"anonymous\",\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      // Upsert the entry\n      await this.leaderboardEntriesTable.put(entryData);\n\n      await this.queueSync(\n        \"leaderboardEntries\",\n        \"create\",\n        entryData.id,\n        entryData,\n      );\n\n      logger.info(\n        `Updated leaderboard entry for user ${userId}`,\n        \"AchievementLeaderboardService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update leaderboard entry\",\n        error,\n        \"AchievementLeaderboardService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's leaderboard privacy settings\n   */\n  async getLeaderboardPrivacy(_userId: string): Promise<any> {\n    // This would typically be stored in user settings\n    // For now, return default settings\n    return {\n      participateInGlobal: false,\n      participateInMonthly: false,\n      shareSessionTime: false,\n      shareStreakData: false,\n      shareAchievements: false,\n      displayName: \"anonymous\",\n      showOnPublicProfile: false,\n    };\n  }\n\n  /**\n   * Update user's leaderboard privacy settings\n   */\n  async updateLeaderboardPrivacy(\n    _userId: string,\n    _settings: any,\n  ): Promise<void> {\n    try {\n      // This would typically update user settings\n      // For now, just log the action\n      logger.info(\n        `Updated leaderboard privacy for user ${_userId}`,\n        \"AchievementLeaderboardService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update leaderboard privacy\",\n        error,\n        \"AchievementLeaderboardService\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementLeaderboardService =\n  new AchievementLeaderboardService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementNotificationService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[597,600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[597,600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Notification Service\n * Handles achievement notifications and alerts\n */\n\nimport { ChastityDB } from \"../../storage/ChastityDB\";\nimport { DBAchievementNotification } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementNotificationService {\n  private achievementNotificationsTable = ChastityDB.achievementNotifications;\n\n  private generateId(): string {\n    return `an_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async queueSync(\n    collection: string,\n    operation: string,\n    id: string,\n    _data: any,\n  ): Promise<void> {\n    // Simplified sync queue - would normally integrate with proper sync service\n    logger.debug(`Queued sync: ${operation} ${collection}/${id}`);\n  }\n\n  /**\n   * Create achievement notification\n   */\n  async createNotification(\n    userId: string,\n    achievementId: string,\n    type: \"earned\" | \"progress\" | \"milestone\",\n    title: string,\n    message: string,\n  ): Promise<string> {\n    try {\n      const notification: DBAchievementNotification = {\n        id: this.generateId(),\n        userId,\n        achievementId,\n        type,\n        title,\n        message,\n        isRead: false,\n        createdAt: new Date(),\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      await this.achievementNotificationsTable.add(notification);\n      await this.queueSync(\n        \"achievementNotifications\",\n        \"create\",\n        notification.id,\n        notification,\n      );\n\n      logger.info(\n        `Achievement notification created for user ${userId}`,\n        \"AchievementNotificationService\",\n      );\n      return notification.id;\n    } catch (error) {\n      logger.error(\n        \"Failed to create achievement notification\",\n        error,\n        \"AchievementNotificationService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's unread notifications\n   */\n  async getUserUnreadNotifications(\n    userId: string,\n  ): Promise<DBAchievementNotification[]> {\n    try {\n      return await this.achievementNotificationsTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((n) => !n.isRead)\n        .reverse()\n        .sortBy(\"createdAt\");\n    } catch (error) {\n      logger.error(\n        \"Failed to get user unread notifications\",\n        error,\n        \"AchievementNotificationService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Mark notification as read\n   */\n  async markNotificationRead(notificationId: string): Promise<void> {\n    try {\n      const notification =\n        await this.achievementNotificationsTable.get(notificationId);\n      if (notification) {\n        notification.isRead = true;\n        notification.lastModified = new Date();\n        notification.syncStatus = \"pending\";\n\n        await this.achievementNotificationsTable.put(notification);\n        await this.queueSync(\n          \"achievementNotifications\",\n          \"update\",\n          notification.id,\n          notification,\n        );\n      }\n    } catch (error) {\n      logger.error(\n        \"Failed to mark notification as read\",\n        error,\n        \"AchievementNotificationService\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementNotificationService =\n  new AchievementNotificationService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementProgressService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[585,588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[585,588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Progress Service\n * Handles progress tracking and updates for achievements\n */\n\nimport { ChastityDB } from \"../../storage/ChastityDB\";\nimport { DBAchievementProgress } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementProgressService {\n  private achievementProgressTable = ChastityDB.achievementProgress;\n\n  private generateId(): string {\n    return `ap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async queueSync(\n    collection: string,\n    operation: string,\n    id: string,\n    _data: any,\n  ): Promise<void> {\n    // Simplified sync queue - would normally integrate with proper sync service\n    logger.debug(`Queued sync: ${operation} ${collection}/${id}`);\n  }\n\n  constructor(\n    private badgeService?: {\n      awardAchievement: (\n        userId: string,\n        achievementId: string,\n        progress: number,\n      ) => Promise<string>;\n    },\n  ) {}\n\n  /**\n   * Update achievement progress\n   */\n  async updateAchievementProgress(\n    userId: string,\n    achievementId: string,\n    currentValue: number,\n    targetValue: number,\n  ): Promise<void> {\n    try {\n      const existing = await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ap) => ap.achievementId === achievementId)\n        .first();\n\n      const progressData: DBAchievementProgress = {\n        id: existing?.id || this.generateId(),\n        userId,\n        achievementId,\n        currentValue,\n        targetValue,\n        isCompleted: currentValue >= targetValue,\n        syncStatus: \"pending\",\n        lastModified: new Date(),\n      };\n\n      if (existing) {\n        await this.achievementProgressTable.put(progressData);\n        await this.queueSync(\n          \"achievementProgress\",\n          \"update\",\n          progressData.id,\n          progressData,\n        );\n      } else {\n        await this.achievementProgressTable.add(progressData);\n        await this.queueSync(\n          \"achievementProgress\",\n          \"create\",\n          progressData.id,\n          progressData,\n        );\n      }\n\n      // If completed, award the achievement (requires badge service)\n      if (\n        progressData.isCompleted &&\n        !existing?.isCompleted &&\n        this.badgeService\n      ) {\n        await this.badgeService.awardAchievement(userId, achievementId, 100);\n      }\n\n      logger.debug(\n        `Progress updated for ${achievementId}: ${currentValue}/${targetValue}`,\n        \"AchievementProgressService\",\n      );\n    } catch (error) {\n      logger.error(\n        \"Failed to update achievement progress\",\n        error,\n        \"AchievementProgressService\",\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get user's achievement progress\n   */\n  async getUserAchievementProgress(\n    userId: string,\n  ): Promise<DBAchievementProgress[]> {\n    try {\n      return await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .toArray();\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievement progress\",\n        error,\n        \"AchievementProgressService\",\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Get progress for specific achievement\n   */\n  async getAchievementProgress(\n    userId: string,\n    achievementId: string,\n  ): Promise<DBAchievementProgress | null> {\n    try {\n      const progress = await this.achievementProgressTable\n        .where(\"userId\")\n        .equals(userId)\n        .and((ap) => ap.achievementId === achievementId)\n        .first();\n\n      return progress || null;\n    } catch (error) {\n      logger.error(\n        \"Failed to get achievement progress\",\n        error,\n        \"AchievementProgressService\",\n      );\n      return null;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementProgressService = new AchievementProgressService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/AchievementStatsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[334,337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[334,337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[428,431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[428,431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1155,1158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1155,1158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1253,1256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1253,1256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1823,1826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1823,1826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Statistics Service\n * Handles statistics aggregation and reporting\n */\n\nimport { AchievementCategory, AchievementDifficulty } from \"../../../types\";\nimport { logger } from \"../../../utils/logging\";\n\nexport class AchievementStatsService {\n  constructor(\n    private crudService?: { getAllAchievements: () => Promise<any[]> },\n    private badgeService?: {\n      getUserAchievements: (userId: string) => Promise<any[]>;\n    },\n  ) {}\n\n  /**\n   * Get user achievement statistics\n   */\n  async getUserAchievementStats(userId: string): Promise<{\n    totalEarned: number;\n    totalPoints: number;\n    completionPercentage: number;\n    categoryCounts: Record<AchievementCategory, number>;\n    difficultyBreakdown: Record<AchievementDifficulty, number>;\n  }> {\n    try {\n      if (!this.crudService || !this.badgeService) {\n        throw new Error(\"Required services not injected\");\n      }\n\n      const [userAchievements, allAchievements] = await Promise.all([\n        this.badgeService.getUserAchievements(userId),\n        this.crudService.getAllAchievements(),\n      ]);\n\n      const achievementMap = new Map(\n        allAchievements.map((a: any) => [a.id, a]),\n      );\n\n      const totalPoints = userAchievements.reduce((sum: number, ua: any) => {\n        const achievement = achievementMap.get(ua.achievementId);\n        return sum + (achievement?.points || 0);\n      }, 0);\n\n      const categoryCounts = {} as Record<AchievementCategory, number>;\n      const difficultyBreakdown = {} as Record<AchievementDifficulty, number>;\n\n      // Initialize counts\n      Object.values(AchievementCategory).forEach(\n        (cat) => (categoryCounts[cat] = 0),\n      );\n      Object.values(AchievementDifficulty).forEach(\n        (diff) => (difficultyBreakdown[diff] = 0),\n      );\n\n      userAchievements.forEach((ua: any) => {\n        const achievement = achievementMap.get(ua.achievementId);\n        if (achievement) {\n          categoryCounts[achievement.category]++;\n          difficultyBreakdown[achievement.difficulty]++;\n        }\n      });\n\n      return {\n        totalEarned: userAchievements.length,\n        totalPoints,\n        completionPercentage:\n          allAchievements.length > 0\n            ? (userAchievements.length / allAchievements.length) * 100\n            : 0,\n        categoryCounts,\n        difficultyBreakdown,\n      };\n    } catch (error) {\n      logger.error(\n        \"Failed to get user achievement stats\",\n        error,\n        \"AchievementStatsService\",\n      );\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const achievementStatsService = new AchievementStatsService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/achievements/index.ts","messages":[{"ruleId":"max-params","severity":1,"message":"Constructor has too many parameters (6). Maximum allowed is 5.","line":57,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":57,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1835,1838],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1835,1838],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1900,1903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1900,1903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1963,1966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1963,1966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Services Index\n * Re-exports all achievement services and provides backward compatibility\n */\n\n// Import all services\nimport {\n  AchievementCRUDService,\n  achievementCRUDService,\n} from \"./AchievementCRUDService\";\nimport {\n  AchievementBadgeService,\n  achievementBadgeService,\n} from \"./AchievementBadgeService\";\nimport {\n  AchievementProgressService,\n  achievementProgressService,\n} from \"./AchievementProgressService\";\nimport {\n  AchievementNotificationService,\n  achievementNotificationService,\n} from \"./AchievementNotificationService\";\nimport {\n  AchievementStatsService,\n  achievementStatsService,\n} from \"./AchievementStatsService\";\nimport {\n  AchievementLeaderboardService,\n  achievementLeaderboardService,\n} from \"./AchievementLeaderboardService\";\n\n// Re-export service classes\nexport {\n  AchievementCRUDService,\n  AchievementBadgeService,\n  AchievementProgressService,\n  AchievementNotificationService,\n  AchievementStatsService,\n  AchievementLeaderboardService,\n};\n\n// Re-export service instances\nexport {\n  achievementCRUDService,\n  achievementBadgeService,\n  achievementProgressService,\n  achievementNotificationService,\n  achievementStatsService,\n  achievementLeaderboardService,\n};\n\n/**\n * Composite Achievement Service for backward compatibility\n * Maintains the original API while delegating to focused services\n */\nexport class AchievementDBService {\n  constructor(\n    private crudService = achievementCRUDService,\n    private badgeService = achievementBadgeService,\n    private progressService = achievementProgressService,\n    private notificationService = achievementNotificationService,\n    private statsService = achievementStatsService,\n    private leaderboardService = achievementLeaderboardService,\n  ) {\n    // Inject dependencies for services that need them\n    (this.progressService as any).badgeService = this.badgeService;\n    (this.statsService as any).crudService = this.crudService;\n    (this.statsService as any).badgeService = this.badgeService;\n  }\n\n  // ==================== ACHIEVEMENT CRUD ====================\n  async createAchievement(\n    ...args: Parameters<typeof this.crudService.createAchievement>\n  ) {\n    return this.crudService.createAchievement(...args);\n  }\n\n  async getAllAchievements(\n    ...args: Parameters<typeof this.crudService.getAllAchievements>\n  ) {\n    return this.crudService.getAllAchievements(...args);\n  }\n\n  async getAchievementById(\n    ...args: Parameters<typeof this.crudService.getAchievementById>\n  ) {\n    return this.crudService.getAchievementById(...args);\n  }\n\n  async getAchievementsByCategory(\n    ...args: Parameters<typeof this.crudService.getAchievementsByCategory>\n  ) {\n    return this.crudService.getAchievementsByCategory(...args);\n  }\n\n  // ==================== USER ACHIEVEMENT MANAGEMENT ====================\n  async awardAchievement(\n    ...args: Parameters<typeof this.badgeService.awardAchievement>\n  ) {\n    return this.badgeService.awardAchievement(...args);\n  }\n\n  async getUserAchievements(\n    ...args: Parameters<typeof this.badgeService.getUserAchievements>\n  ) {\n    return this.badgeService.getUserAchievements(...args);\n  }\n\n  async getUserVisibleAchievements(\n    ...args: Parameters<typeof this.badgeService.getUserVisibleAchievements>\n  ) {\n    return this.badgeService.getUserVisibleAchievements(...args);\n  }\n\n  async toggleAchievementVisibility(\n    ...args: Parameters<typeof this.badgeService.toggleAchievementVisibility>\n  ) {\n    return this.badgeService.toggleAchievementVisibility(...args);\n  }\n\n  // ==================== PROGRESS TRACKING ====================\n  async updateAchievementProgress(\n    ...args: Parameters<typeof this.progressService.updateAchievementProgress>\n  ) {\n    return this.progressService.updateAchievementProgress(...args);\n  }\n\n  async getUserAchievementProgress(\n    ...args: Parameters<typeof this.progressService.getUserAchievementProgress>\n  ) {\n    return this.progressService.getUserAchievementProgress(...args);\n  }\n\n  async getAchievementProgress(\n    ...args: Parameters<typeof this.progressService.getAchievementProgress>\n  ) {\n    return this.progressService.getAchievementProgress(...args);\n  }\n\n  // ==================== NOTIFICATIONS ====================\n  async createNotification(\n    ...args: Parameters<typeof this.notificationService.createNotification>\n  ) {\n    return this.notificationService.createNotification(...args);\n  }\n\n  async getUserUnreadNotifications(\n    ...args: Parameters<\n      typeof this.notificationService.getUserUnreadNotifications\n    >\n  ) {\n    return this.notificationService.getUserUnreadNotifications(...args);\n  }\n\n  async markNotificationRead(\n    ...args: Parameters<typeof this.notificationService.markNotificationRead>\n  ) {\n    return this.notificationService.markNotificationRead(...args);\n  }\n\n  // ==================== STATISTICS ====================\n  async getUserAchievementStats(\n    ...args: Parameters<typeof this.statsService.getUserAchievementStats>\n  ) {\n    return this.statsService.getUserAchievementStats(...args);\n  }\n\n  // ==================== LEADERBOARD ====================\n  async getLeaderboard(\n    ...args: Parameters<typeof this.leaderboardService.getLeaderboard>\n  ) {\n    return this.leaderboardService.getLeaderboard(...args);\n  }\n\n  async getUserLeaderboardRank(\n    ...args: Parameters<typeof this.leaderboardService.getUserLeaderboardRank>\n  ) {\n    return this.leaderboardService.getUserLeaderboardRank(...args);\n  }\n\n  async updateLeaderboardEntry(\n    ...args: Parameters<typeof this.leaderboardService.updateLeaderboardEntry>\n  ) {\n    return this.leaderboardService.updateLeaderboardEntry(...args);\n  }\n\n  async getLeaderboardPrivacy(\n    ...args: Parameters<typeof this.leaderboardService.getLeaderboardPrivacy>\n  ) {\n    return this.leaderboardService.getLeaderboardPrivacy(...args);\n  }\n\n  async updateLeaderboardPrivacy(\n    ...args: Parameters<typeof this.leaderboardService.updateLeaderboardPrivacy>\n  ) {\n    return this.leaderboardService.updateLeaderboardPrivacy(...args);\n  }\n}\n\n// Export singleton instance for backward compatibility\nexport const achievementDBService = new AchievementDBService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastityEventService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[570,573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[570,573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1539,1542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1539,1542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chastity Event Service\n * Handles event logging and history retrieval\n */\nimport {\n  collection,\n  addDoc,\n  getDocs,\n  query,\n  orderBy,\n  limit,\n  serverTimestamp,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { RelationshipEvent } from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\nimport { relationshipCoreService } from \"./RelationshipCoreService\";\n\nconst logger = serviceLogger(\"ChastityEventService\");\n\nclass ChastityEventService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  // ==================== EVENT LOGGING ====================\n\n  /**\n   * Log an event\n   */\n  async logEvent(\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n    userId: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      const eventId = generateUUID();\n      const isKeyholder =\n        userId ===\n        (await relationshipCoreService.getKeyholderId(relationshipId));\n\n      const event: Omit<RelationshipEvent, \"createdAt\"> = {\n        id: eventId,\n        relationshipId,\n        type: eventData.type,\n        timestamp: serverTimestamp() as any,\n        details: eventData.details,\n        loggedBy: isKeyholder ? \"keyholder\" : \"submissive\",\n        isPrivate: eventData.isPrivate || false,\n        tags: eventData.tags,\n      };\n\n      await addDoc(collection(db, \"chastityData\", relationshipId, \"events\"), {\n        ...event,\n        createdAt: serverTimestamp(),\n      });\n\n      logger.info(\"Logged event\", {\n        eventId,\n        relationshipId,\n        type: eventData.type,\n        userId,\n        isKeyholder,\n      });\n\n      return eventId;\n    } catch (error) {\n      logger.error(\"Failed to log event\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get events for a relationship\n   */\n  async getEvents(\n    relationshipId: string,\n    limitCount: number = 100,\n  ): Promise<RelationshipEvent[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const eventsSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"events\"),\n          orderBy(\"timestamp\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const events = eventsSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipEvent[];\n\n      logger.debug(\"Retrieved events\", {\n        relationshipId,\n        count: events.length,\n      });\n\n      return events;\n    } catch (error) {\n      logger.error(\"Failed to get events\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const chastityEventService = new ChastityEventService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastitySessionService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'addDoc' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateDoc' is defined but never used.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[716,719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[716,719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'startSession' has too many lines (86). Maximum allowed is 75.","line":50,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":149,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2213,2216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2213,2216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2382,2385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2382,2385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4912,4915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4912,4915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7092,7095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7092,7095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":368,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":368,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9119,9122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9119,9122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chastity Session Service\n * Handles session lifecycle management (start/end/pause/resume)\n */\nimport {\n  collection,\n  doc,\n  addDoc,\n  updateDoc,\n  getDoc,\n  getDocs,\n  query,\n  orderBy,\n  limit,\n  serverTimestamp,\n  writeBatch,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { RelationshipSession, SessionEvent } from \"@/types/relationships\";\nimport { relationshipService } from \"../RelationshipService\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\nimport { relationshipCoreService } from \"./RelationshipCoreService\";\n\nconst logger = serviceLogger(\"ChastitySessionService\");\n\nclass ChastitySessionService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  // ==================== SESSION MANAGEMENT ====================\n\n  /**\n   * Start a new chastity session\n   */\n  async startSession(\n    relationshipId: string,\n    userId: string,\n    options: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    } = {},\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check if user has permission to start session\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"sessions\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to start session\");\n      }\n\n      // Check if there's already an active session\n      const chastityData =\n        await relationshipCoreService.getChastityData(relationshipId);\n      if (chastityData?.currentSession.isActive) {\n        throw new Error(\"A session is already active for this relationship\");\n      }\n\n      const sessionId = generateUUID();\n      const batch = writeBatch(db);\n\n      // Create session record\n      const sessionData: Omit<RelationshipSession, \"createdAt\" | \"updatedAt\"> =\n        {\n          id: sessionId,\n          relationshipId,\n          startTime: serverTimestamp() as any,\n          duration: 0,\n          effectiveDuration: 0,\n          events: [\n            {\n              type: \"start\",\n              timestamp: serverTimestamp() as any,\n              initiatedBy:\n                userId === chastityData?.keyholderId\n                  ? \"keyholder\"\n                  : \"submissive\",\n              reason: options.notes,\n            },\n          ],\n          goalMet: false,\n          keyholderApproval: {\n            required: false,\n          },\n        };\n\n      batch.set(\n        doc(db, \"chastityData\", relationshipId, \"sessions\", sessionId),\n        {\n          ...sessionData,\n          createdAt: serverTimestamp(),\n          updatedAt: serverTimestamp(),\n        },\n      );\n\n      // Update current session in chastity data\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        currentSession: {\n          id: sessionId,\n          isActive: true,\n          startTime: serverTimestamp(),\n          accumulatedPauseTime: 0,\n          keyholderApprovalRequired:\n            chastityData?.settings.requireReasonForEnd || false,\n        },\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Started new session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        options,\n      });\n\n      return sessionId;\n    } catch (error) {\n      logger.error(\"Failed to start session\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n        options,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * End a chastity session\n   */\n  async endSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    endReason?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"sessions\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to end session\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Update session record\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n      const endTime = new Date();\n      const totalDuration =\n        endTime.getTime() - sessionData.startTime.toDate().getTime();\n\n      // Add end event\n      const endEvent: SessionEvent = {\n        type: \"end\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy:\n          userId ===\n          (await relationshipCoreService.getKeyholderId(relationshipId))\n            ? \"keyholder\"\n            : \"submissive\",\n        reason: endReason,\n      };\n\n      batch.update(sessionRef, {\n        endTime: serverTimestamp(),\n        duration: Math.floor(totalDuration / 1000),\n        events: [...sessionData.events, endEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session in chastity data\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        currentSession: {\n          id: \"\",\n          isActive: false,\n          startTime: serverTimestamp(),\n          accumulatedPauseTime: 0,\n          keyholderApprovalRequired: false,\n        },\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Ended session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        endReason,\n      });\n    } catch (error) {\n      logger.error(\"Failed to end session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Pause a session\n   */\n  async pauseSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    pauseReason?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check if submissive can pause\n      const canPause = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"pauseSession\",\n      );\n\n      if (!canPause) {\n        throw new Error(\"Insufficient permissions to pause session\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Update session with pause event\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n\n      const pauseEvent: SessionEvent = {\n        type: \"pause\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy: \"submissive\",\n        reason: pauseReason,\n      };\n\n      batch.update(sessionRef, {\n        events: [...sessionData.events, pauseEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        \"currentSession.pausedAt\": serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Paused session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        pauseReason,\n      });\n    } catch (error) {\n      logger.error(\"Failed to pause session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Resume a paused session\n   */\n  async resumeSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get current chastity data to calculate pause time\n      const chastityData =\n        await relationshipCoreService.getChastityData(relationshipId);\n      if (!chastityData?.currentSession.pausedAt) {\n        throw new Error(\"Session is not paused\");\n      }\n\n      const batch = writeBatch(db);\n\n      // Calculate pause duration\n      const pauseEnd = new Date();\n      const pauseStart = chastityData.currentSession.pausedAt.toDate();\n      const pauseDuration = Math.floor(\n        (pauseEnd.getTime() - pauseStart.getTime()) / 1000,\n      );\n\n      // Update session with resume event\n      const sessionRef = doc(\n        db,\n        \"chastityData\",\n        relationshipId,\n        \"sessions\",\n        sessionId,\n      );\n      const sessionDoc = await getDoc(sessionRef);\n\n      if (!sessionDoc.exists()) {\n        throw new Error(\"Session not found\");\n      }\n\n      const sessionData = sessionDoc.data() as RelationshipSession;\n\n      const resumeEvent: SessionEvent = {\n        type: \"resume\",\n        timestamp: serverTimestamp() as any,\n        initiatedBy: \"submissive\",\n      };\n\n      batch.update(sessionRef, {\n        events: [...sessionData.events, resumeEvent],\n        updatedAt: serverTimestamp(),\n      });\n\n      // Update current session\n      batch.update(doc(db, \"chastityData\", relationshipId), {\n        \"currentSession.pausedAt\": null,\n        \"currentSession.accumulatedPauseTime\":\n          chastityData.currentSession.accumulatedPauseTime + pauseDuration,\n        updatedAt: serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      logger.info(\"Resumed session\", {\n        sessionId,\n        relationshipId,\n        userId,\n        pauseDuration,\n      });\n    } catch (error) {\n      logger.error(\"Failed to resume session\", {\n        error: error as Error,\n        sessionId,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get session history for a relationship\n   */\n  async getSessionHistory(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipSession[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const sessionsSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"sessions\"),\n          orderBy(\"startTime\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const sessions = sessionsSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipSession[];\n\n      logger.debug(\"Retrieved session history\", {\n        relationshipId,\n        count: sessions.length,\n      });\n\n      return sessions;\n    } catch (error) {\n      logger.error(\"Failed to get session history\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const chastitySessionService = new ChastitySessionService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/ChastityTaskService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[709,712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[709,712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2938,2941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2938,2941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5833,5836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5833,5836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chastity Task Service\n * Handles task creation, updates, and management\n */\nimport {\n  collection,\n  doc,\n  addDoc,\n  updateDoc,\n  getDocs,\n  query,\n  orderBy,\n  limit,\n  serverTimestamp,\n  onSnapshot,\n  Unsubscribe,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport {\n  RelationshipTask,\n  RelationshipTaskStatus,\n} from \"@/types/relationships\";\nimport { relationshipService } from \"../RelationshipService\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\nimport { relationshipCoreService } from \"./RelationshipCoreService\";\n\nconst logger = serviceLogger(\"ChastityTaskService\");\n\nclass ChastityTaskService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  // ==================== TASK MANAGEMENT ====================\n\n  /**\n   * Create a new task\n   */\n  async createTask(\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n    userId: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"tasks\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to create tasks\");\n      }\n\n      const taskId = generateUUID();\n      const isKeyholder =\n        userId ===\n        (await relationshipCoreService.getKeyholderId(relationshipId));\n\n      const task: Omit<RelationshipTask, \"createdAt\" | \"updatedAt\"> = {\n        id: taskId,\n        relationshipId,\n        text: taskData.text,\n        assignedBy: isKeyholder ? \"keyholder\" : \"submissive\",\n        assignedTo: \"submissive\",\n        dueDate: taskData.dueDate ? serverTimestamp() : undefined,\n        status: RelationshipTaskStatus.PENDING,\n        consequence: taskData.consequence,\n      };\n\n      await addDoc(collection(db, \"chastityData\", relationshipId, \"tasks\"), {\n        ...task,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Created task\", {\n        taskId,\n        relationshipId,\n        userId,\n        isKeyholder,\n      });\n\n      return taskId;\n    } catch (error) {\n      logger.error(\"Failed to create task\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update task status\n   */\n  async updateTaskStatus(\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTaskStatus,\n    userId: string,\n    note?: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      const updateData: any = {\n        status,\n        updatedAt: serverTimestamp(),\n      };\n\n      // Add role-specific fields\n      const isKeyholder =\n        userId ===\n        (await relationshipCoreService.getKeyholderId(relationshipId));\n\n      if (status === RelationshipTaskStatus.SUBMITTED && !isKeyholder) {\n        updateData.submittedAt = serverTimestamp();\n        updateData.submissiveNote = note;\n      } else if (\n        (status === RelationshipTaskStatus.APPROVED ||\n          status === RelationshipTaskStatus.REJECTED) &&\n        isKeyholder\n      ) {\n        updateData.approvedAt = serverTimestamp();\n        updateData.keyholderFeedback = note;\n      } else if (status === RelationshipTaskStatus.COMPLETED) {\n        updateData.completedAt = serverTimestamp();\n      }\n\n      await updateDoc(\n        doc(db, \"chastityData\", relationshipId, \"tasks\", taskId),\n        updateData,\n      );\n\n      logger.info(\"Updated task status\", {\n        taskId,\n        relationshipId,\n        status,\n        userId,\n        isKeyholder,\n      });\n    } catch (error) {\n      logger.error(\"Failed to update task status\", {\n        error: error as Error,\n        taskId,\n        relationshipId,\n        status,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get tasks for a relationship\n   */\n  async getTasks(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipTask[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const tasksSnapshot = await getDocs(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"tasks\"),\n          orderBy(\"createdAt\", \"desc\"),\n          limit(limitCount),\n        ),\n      );\n\n      const tasks = tasksSnapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipTask[];\n\n      logger.debug(\"Retrieved tasks\", {\n        relationshipId,\n        count: tasks.length,\n      });\n\n      return tasks;\n    } catch (error) {\n      logger.error(\"Failed to get tasks\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== REAL-TIME LISTENERS ====================\n\n  /**\n   * Subscribe to task changes\n   */\n  subscribeToTasks(\n    relationshipId: string,\n    callback: (tasks: RelationshipTask[]) => void,\n  ): Unsubscribe {\n    return this.ensureDb().then((db) => {\n      return onSnapshot(\n        query(\n          collection(db, \"chastityData\", relationshipId, \"tasks\"),\n          orderBy(\"createdAt\", \"desc\"),\n        ),\n        (snapshot) => {\n          const tasks = snapshot.docs.map((doc) => ({\n            ...doc.data(),\n            id: doc.id,\n          })) as RelationshipTask[];\n          callback(tasks);\n        },\n        (error) => {\n          logger.error(\"Error in tasks subscription\", {\n            error,\n            relationshipId,\n          });\n        },\n      );\n    }) as any;\n  }\n}\n\nexport const chastityTaskService = new ChastityTaskService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/RelationshipCoreService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'collection' is defined but never used.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[548,551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[548,551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3378,3381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3378,3381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Core Service\n * Handles basic chastity data CRUD operations\n */\nimport {\n  collection,\n  doc,\n  updateDoc,\n  getDoc,\n  serverTimestamp,\n  onSnapshot,\n  Unsubscribe,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { RelationshipChastityData } from \"@/types/relationships\";\nimport { relationshipService } from \"../RelationshipService\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"RelationshipCoreService\");\n\nclass RelationshipCoreService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  // ==================== CHASTITY DATA MANAGEMENT ====================\n\n  /**\n   * Get chastity data for a relationship\n   */\n  async getChastityData(\n    relationshipId: string,\n  ): Promise<RelationshipChastityData | null> {\n    try {\n      const db = await this.ensureDb();\n      const docSnapshot = await getDoc(doc(db, \"chastityData\", relationshipId));\n\n      if (!docSnapshot.exists()) {\n        return null;\n      }\n\n      const data = {\n        ...docSnapshot.data(),\n        relationshipId: docSnapshot.id,\n      } as RelationshipChastityData;\n\n      logger.debug(\"Retrieved chastity data\", { relationshipId });\n      return data;\n    } catch (error) {\n      logger.error(\"Failed to get chastity data\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Update chastity data settings\n   */\n  async updateChastitySettings(\n    relationshipId: string,\n    settings: Partial<RelationshipChastityData[\"settings\"]>,\n    userId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check permissions\n      const hasPermission = await relationshipService.checkPermission(\n        relationshipId,\n        userId,\n        \"settings\",\n      );\n\n      if (!hasPermission) {\n        throw new Error(\"Insufficient permissions to update settings\");\n      }\n\n      await updateDoc(doc(db, \"chastityData\", relationshipId), {\n        settings,\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Updated chastity settings\", {\n        relationshipId,\n        userId,\n        settings,\n      });\n    } catch (error) {\n      logger.error(\"Failed to update chastity settings\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== REAL-TIME LISTENERS ====================\n\n  /**\n   * Subscribe to chastity data changes\n   */\n  subscribeToChastityData(\n    relationshipId: string,\n    callback: (data: RelationshipChastityData | null) => void,\n  ): Unsubscribe {\n    return this.ensureDb().then((db) => {\n      return onSnapshot(\n        doc(db, \"chastityData\", relationshipId),\n        (doc) => {\n          const data = doc.exists()\n            ? ({\n                ...doc.data(),\n                relationshipId: doc.id,\n              } as RelationshipChastityData)\n            : null;\n          callback(data);\n        },\n        (error) => {\n          logger.error(\"Error in chastity data subscription\", {\n            error,\n            relationshipId,\n          });\n        },\n      );\n    }) as any;\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  /**\n   * Get keyholder ID for a relationship\n   */\n  async getKeyholderId(relationshipId: string): Promise<string> {\n    const relationship =\n      await relationshipService.getRelationship(relationshipId);\n    if (!relationship) {\n      throw new Error(\"Relationship not found\");\n    }\n    return relationship.keyholderId;\n  }\n}\n\nexport const relationshipCoreService = new RelationshipCoreService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/RelationshipPermissionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationship-chastity/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'relationshipPermissionService' is defined but never used.","line":27,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Chastity Services Index\n * Provides backward compatibility facade and exports all services\n */\n\n// Export individual services\nexport { relationshipCoreService } from \"./RelationshipCoreService\";\nexport { chastitySessionService } from \"./ChastitySessionService\";\nexport { chastityTaskService } from \"./ChastityTaskService\";\nexport { chastityEventService } from \"./ChastityEventService\";\nexport { relationshipPermissionService } from \"./RelationshipPermissionService\";\n\n// Re-export types for convenience\nexport type {\n  RelationshipChastityData,\n  RelationshipSession,\n  RelationshipTask,\n  RelationshipEvent,\n  SessionEvent,\n  RelationshipTaskStatus,\n} from \"@/types/relationships\";\n\nimport { relationshipCoreService } from \"./RelationshipCoreService\";\nimport { chastitySessionService } from \"./ChastitySessionService\";\nimport { chastityTaskService } from \"./ChastityTaskService\";\nimport { chastityEventService } from \"./ChastityEventService\";\nimport { relationshipPermissionService } from \"./RelationshipPermissionService\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport type {\n  RelationshipChastityData,\n  RelationshipSession,\n  RelationshipTask,\n  RelationshipEvent,\n  RelationshipTaskStatus,\n} from \"@/types/relationships\";\n\nconst logger = serviceLogger(\"RelationshipChastityServiceFacade\");\n\n/**\n * Facade class that maintains backward compatibility\n * Delegates calls to appropriate domain services\n */\nclass RelationshipChastityServiceFacade {\n  // ==================== CHASTITY DATA MANAGEMENT ====================\n\n  async getChastityData(\n    relationshipId: string,\n  ): Promise<RelationshipChastityData | null> {\n    return relationshipCoreService.getChastityData(relationshipId);\n  }\n\n  async updateChastitySettings(\n    relationshipId: string,\n    settings: Partial<RelationshipChastityData[\"settings\"]>,\n    userId: string,\n  ): Promise<void> {\n    return relationshipCoreService.updateChastitySettings(\n      relationshipId,\n      settings,\n      userId,\n    );\n  }\n\n  // ==================== SESSION MANAGEMENT ====================\n\n  async startSession(\n    relationshipId: string,\n    userId: string,\n    options: {\n      goalDuration?: number;\n      isHardcoreMode?: boolean;\n      notes?: string;\n    } = {},\n  ): Promise<string> {\n    return chastitySessionService.startSession(relationshipId, userId, options);\n  }\n\n  async endSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    endReason?: string,\n  ): Promise<void> {\n    return chastitySessionService.endSession(\n      relationshipId,\n      sessionId,\n      userId,\n      endReason,\n    );\n  }\n\n  async pauseSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n    pauseReason?: string,\n  ): Promise<void> {\n    return chastitySessionService.pauseSession(\n      relationshipId,\n      sessionId,\n      userId,\n      pauseReason,\n    );\n  }\n\n  async resumeSession(\n    relationshipId: string,\n    sessionId: string,\n    userId: string,\n  ): Promise<void> {\n    return chastitySessionService.resumeSession(\n      relationshipId,\n      sessionId,\n      userId,\n    );\n  }\n\n  async getSessionHistory(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipSession[]> {\n    return chastitySessionService.getSessionHistory(relationshipId, limitCount);\n  }\n\n  // ==================== TASK MANAGEMENT ====================\n\n  async createTask(\n    relationshipId: string,\n    taskData: {\n      text: string;\n      dueDate?: Date;\n      consequence?: RelationshipTask[\"consequence\"];\n    },\n    userId: string,\n  ): Promise<string> {\n    return chastityTaskService.createTask(relationshipId, taskData, userId);\n  }\n\n  async updateTaskStatus(\n    relationshipId: string,\n    taskId: string,\n    status: RelationshipTaskStatus,\n    userId: string,\n    note?: string,\n  ): Promise<void> {\n    return chastityTaskService.updateTaskStatus(\n      relationshipId,\n      taskId,\n      status,\n      userId,\n      note,\n    );\n  }\n\n  async getTasks(\n    relationshipId: string,\n    limitCount: number = 50,\n  ): Promise<RelationshipTask[]> {\n    return chastityTaskService.getTasks(relationshipId, limitCount);\n  }\n\n  // ==================== EVENT LOGGING ====================\n\n  async logEvent(\n    relationshipId: string,\n    eventData: {\n      type: RelationshipEvent[\"type\"];\n      details: RelationshipEvent[\"details\"];\n      isPrivate?: boolean;\n      tags?: string[];\n    },\n    userId: string,\n  ): Promise<string> {\n    return chastityEventService.logEvent(relationshipId, eventData, userId);\n  }\n\n  async getEvents(\n    relationshipId: string,\n    limitCount: number = 100,\n  ): Promise<RelationshipEvent[]> {\n    return chastityEventService.getEvents(relationshipId, limitCount);\n  }\n\n  // ==================== REAL-TIME LISTENERS ====================\n\n  subscribeToChastityData(\n    relationshipId: string,\n    callback: (data: RelationshipChastityData | null) => void,\n  ) {\n    return relationshipCoreService.subscribeToChastityData(\n      relationshipId,\n      callback,\n    );\n  }\n\n  subscribeToTasks(\n    relationshipId: string,\n    callback: (tasks: RelationshipTask[]) => void,\n  ) {\n    return chastityTaskService.subscribeToTasks(relationshipId, callback);\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  async getKeyholderId(relationshipId: string): Promise<string> {\n    return relationshipCoreService.getKeyholderId(relationshipId);\n  }\n}\n\n// Export singleton instance for backward compatibility\nexport const relationshipChastityService =\n  new RelationshipChastityServiceFacade();\n\n// Log successful split\nlogger.info(\n  \"RelationshipChastityService successfully split into domain services\",\n  {\n    services: [\n      \"RelationshipCoreService\",\n      \"ChastitySessionService\",\n      \"ChastityTaskService\",\n      \"ChastityEventService\",\n      \"RelationshipPermissionService\",\n    ],\n  },\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipCRUDService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RelationshipStatus' is defined but never used.","line":17,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[537,540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[537,540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship CRUD Service\n * Handles basic Create, Read, Update, Delete operations for relationships\n */\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  onSnapshot,\n  Unsubscribe,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { Relationship, RelationshipStatus } from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"RelationshipCRUDService\");\n\nexport class RelationshipCRUDService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Get relationships for a user (both as submissive and keyholder)\n   */\n  async getUserRelationships(userId: string): Promise<Relationship[]> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get relationships where user is submissive\n      const submissiveRelationships = await getDocs(\n        query(\n          collection(db, \"relationships\"),\n          where(\"submissiveId\", \"==\", userId),\n          orderBy(\"createdAt\", \"desc\"),\n        ),\n      );\n\n      // Get relationships where user is keyholder\n      const keyholderRelationships = await getDocs(\n        query(\n          collection(db, \"relationships\"),\n          where(\"keyholderId\", \"==\", userId),\n          orderBy(\"createdAt\", \"desc\"),\n        ),\n      );\n\n      const allRelationships = [\n        ...submissiveRelationships.docs.map((doc) => ({\n          ...doc.data(),\n          id: doc.id,\n        })),\n        ...keyholderRelationships.docs.map((doc) => ({\n          ...doc.data(),\n          id: doc.id,\n        })),\n      ] as Relationship[];\n\n      // Remove duplicates (shouldn't happen but just in case)\n      const uniqueRelationships = allRelationships.filter(\n        (rel, index, self) => index === self.findIndex((r) => r.id === rel.id),\n      );\n\n      logger.debug(\"Retrieved user relationships\", {\n        userId,\n        count: uniqueRelationships.length,\n      });\n\n      return uniqueRelationships;\n    } catch (error) {\n      logger.error(\"Failed to get user relationships\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get a specific relationship by ID\n   */\n  async getRelationship(relationshipId: string): Promise<Relationship | null> {\n    try {\n      const db = await this.ensureDb();\n\n      const relationshipDoc = await getDoc(\n        doc(db, \"relationships\", relationshipId),\n      );\n\n      if (!relationshipDoc.exists()) {\n        return null;\n      }\n\n      const relationship = {\n        ...relationshipDoc.data(),\n        id: relationshipDoc.id,\n      } as Relationship;\n\n      logger.debug(\"Retrieved relationship\", { relationshipId });\n      return relationship;\n    } catch (error) {\n      logger.error(\"Failed to get relationship\", {\n        error: error as Error,\n        relationshipId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get relationship between two specific users\n   */\n  async getRelationshipBetweenUsers(\n    user1Id: string,\n    user2Id: string,\n  ): Promise<Relationship | null> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check both directions (user1 as submissive, user2 as keyholder)\n      let relationshipQuery = query(\n        collection(db, \"relationships\"),\n        where(\"submissiveId\", \"==\", user1Id),\n        where(\"keyholderId\", \"==\", user2Id),\n      );\n\n      let relationships = await getDocs(relationshipQuery);\n\n      if (relationships.empty) {\n        // Check the other direction (user2 as submissive, user1 as keyholder)\n        relationshipQuery = query(\n          collection(db, \"relationships\"),\n          where(\"submissiveId\", \"==\", user2Id),\n          where(\"keyholderId\", \"==\", user1Id),\n        );\n\n        relationships = await getDocs(relationshipQuery);\n      }\n\n      if (relationships.empty) {\n        return null;\n      }\n\n      const relationship = {\n        ...relationships.docs[0].data(),\n        id: relationships.docs[0].id,\n      } as Relationship;\n\n      logger.debug(\"Retrieved relationship between users\", {\n        user1Id,\n        user2Id,\n        relationshipId: relationship.id,\n      });\n\n      return relationship;\n    } catch (error) {\n      logger.error(\"Failed to get relationship between users\", {\n        error: error as Error,\n        user1Id,\n        user2Id,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Listen to relationship changes for a user\n   */\n  subscribeToUserRelationships(\n    userId: string,\n    callback: (relationships: Relationship[]) => void,\n  ): Unsubscribe {\n    const unsubscribers: Unsubscribe[] = [];\n\n    const handleRelationships = async () => {\n      try {\n        const relationships = await this.getUserRelationships(userId);\n        callback(relationships);\n      } catch (error) {\n        logger.error(\"Error in relationship subscription\", {\n          error: error as Error,\n          userId,\n        });\n      }\n    };\n\n    // Set up real-time listeners\n    this.ensureDb().then((db) => {\n      // Listen to relationships where user is submissive\n      const submissiveUnsub = onSnapshot(\n        query(\n          collection(db, \"relationships\"),\n          where(\"submissiveId\", \"==\", userId),\n        ),\n        handleRelationships,\n      );\n\n      // Listen to relationships where user is keyholder\n      const keyholderUnsub = onSnapshot(\n        query(\n          collection(db, \"relationships\"),\n          where(\"keyholderId\", \"==\", userId),\n        ),\n        handleRelationships,\n      );\n\n      unsubscribers.push(submissiveUnsub, keyholderUnsub);\n    });\n\n    return () => {\n      unsubscribers.forEach((unsub) => unsub());\n    };\n  }\n}\n\nexport const relationshipCRUDService = new RelationshipCRUDService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipInviteService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1197,1200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1197,1200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8558,8561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8558,8561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8892,8895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8892,8895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Invitation Service\n * Handles relationship request operations (invitations)\n */\nimport {\n  collection,\n  doc,\n  addDoc,\n  updateDoc,\n  getDoc,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  serverTimestamp,\n  writeBatch,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport {\n  Relationship,\n  RelationshipRequest,\n  RelationshipStatus,\n  RelationshipRequestStatus,\n  DefaultRelationshipPermissions,\n} from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\nimport { relationshipCRUDService } from \"./RelationshipCRUDService\";\n\nconst logger = serviceLogger(\"RelationshipInviteService\");\n\n/**\n * Default permissions for new relationships\n */\nconst getDefaultPermissions = (): DefaultRelationshipPermissions => ({\n  keyholderCanEdit: {\n    sessions: true,\n    tasks: true,\n    goals: true,\n    punishments: true,\n    settings: false, // Keep settings private by default\n  },\n  submissiveCanPause: true,\n  emergencyUnlock: true,\n  requireApproval: {\n    sessionEnd: false,\n    taskCompletion: true,\n    goalChanges: true,\n  },\n});\n\nexport class RelationshipInviteService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Send a relationship request to another user\n   */\n  async sendRelationshipRequest(\n    fromUserId: string,\n    toUserId: string,\n    fromRole: \"submissive\" | \"keyholder\",\n    message?: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n      const requestId = generateUUID();\n\n      // Check if a request already exists between these users\n      const existingRequests = await getDocs(\n        query(\n          collection(db, \"relationshipRequests\"),\n          where(\"fromUserId\", \"==\", fromUserId),\n          where(\"toUserId\", \"==\", toUserId),\n          where(\"status\", \"==\", RelationshipRequestStatus.PENDING),\n        ),\n      );\n\n      if (!existingRequests.empty) {\n        throw new Error(\"A pending request already exists between these users\");\n      }\n\n      // Check if they already have an active relationship\n      const existingRelationship =\n        await relationshipCRUDService.getRelationshipBetweenUsers(\n          fromUserId,\n          toUserId,\n        );\n      if (\n        existingRelationship &&\n        existingRelationship.status === RelationshipStatus.ACTIVE\n      ) {\n        throw new Error(\n          \"An active relationship already exists between these users\",\n        );\n      }\n\n      const toRole = fromRole === \"submissive\" ? \"keyholder\" : \"submissive\";\n      const expirationDate = new Date();\n      expirationDate.setDate(expirationDate.getDate() + 7); // Expire in 7 days\n\n      const request: Omit<RelationshipRequest, \"createdAt\" | \"expiresAt\"> = {\n        id: requestId,\n        fromUserId,\n        toUserId,\n        fromRole,\n        toRole,\n        status: RelationshipRequestStatus.PENDING,\n        message,\n      };\n\n      await addDoc(collection(db, \"relationshipRequests\"), {\n        ...request,\n        createdAt: serverTimestamp(),\n        expiresAt: expirationDate,\n      });\n\n      logger.info(\"Relationship request sent\", {\n        requestId,\n        fromUserId,\n        toUserId,\n        fromRole,\n        toRole,\n      });\n\n      return requestId;\n    } catch (error) {\n      logger.error(\"Failed to send relationship request\", {\n        error: error as Error,\n        fromUserId,\n        toUserId,\n        fromRole,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Accept a relationship request\n   */\n  async acceptRelationshipRequest(\n    requestId: string,\n    acceptingUserId: string,\n  ): Promise<string> {\n    try {\n      const db = await this.ensureDb();\n      const batch = writeBatch(db);\n\n      // Get the request\n      const requestDoc = await getDoc(\n        doc(db, \"relationshipRequests\", requestId),\n      );\n      if (!requestDoc.exists()) {\n        throw new Error(\"Relationship request not found\");\n      }\n\n      const request = requestDoc.data() as RelationshipRequest;\n\n      // Verify the accepting user is the target of the request\n      if (request.toUserId !== acceptingUserId) {\n        throw new Error(\"Only the target user can accept this request\");\n      }\n\n      // Verify request is still pending\n      if (request.status !== RelationshipRequestStatus.PENDING) {\n        throw new Error(\"Request is no longer pending\");\n      }\n\n      // Create the relationship\n      const relationshipId = generateUUID();\n      const submissiveId =\n        request.toRole === \"submissive\" ? request.toUserId : request.fromUserId;\n      const keyholderId =\n        request.toRole === \"keyholder\" ? request.toUserId : request.fromUserId;\n\n      const relationship: Omit<\n        Relationship,\n        \"createdAt\" | \"updatedAt\" | \"establishedAt\"\n      > = {\n        id: relationshipId,\n        submissiveId,\n        keyholderId,\n        status: RelationshipStatus.ACTIVE,\n        permissions: getDefaultPermissions(),\n        notes: request.message,\n      };\n\n      // Add relationship to batch\n      batch.set(doc(db, \"relationships\", relationshipId), {\n        ...relationship,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        establishedAt: serverTimestamp(),\n      });\n\n      // Update request status\n      batch.update(doc(db, \"relationshipRequests\", requestId), {\n        status: RelationshipRequestStatus.ACCEPTED,\n        respondedAt: serverTimestamp(),\n      });\n\n      // Initialize chastity data for the relationship\n      await this.initializeChastityData(\n        relationshipId,\n        submissiveId,\n        keyholderId,\n        batch,\n      );\n\n      // Commit all changes\n      await batch.commit();\n\n      logger.info(\"Relationship request accepted\", {\n        requestId,\n        relationshipId,\n        submissiveId,\n        keyholderId,\n      });\n\n      return relationshipId;\n    } catch (error) {\n      logger.error(\"Failed to accept relationship request\", {\n        error: error as Error,\n        requestId,\n        acceptingUserId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Reject a relationship request\n   */\n  async rejectRelationshipRequest(\n    requestId: string,\n    rejectingUserId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get the request\n      const requestDoc = await getDoc(\n        doc(db, \"relationshipRequests\", requestId),\n      );\n      if (!requestDoc.exists()) {\n        throw new Error(\"Relationship request not found\");\n      }\n\n      const request = requestDoc.data() as RelationshipRequest;\n\n      // Verify the rejecting user is the target of the request\n      if (request.toUserId !== rejectingUserId) {\n        throw new Error(\"Only the target user can reject this request\");\n      }\n\n      // Update request status\n      await updateDoc(doc(db, \"relationshipRequests\", requestId), {\n        status: RelationshipRequestStatus.REJECTED,\n        respondedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Relationship request rejected\", {\n        requestId,\n        rejectingUserId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to reject relationship request\", {\n        error: error as Error,\n        requestId,\n        rejectingUserId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get pending requests for a user\n   */\n  async getPendingRequests(userId: string): Promise<RelationshipRequest[]> {\n    try {\n      const db = await this.ensureDb();\n\n      const requests = await getDocs(\n        query(\n          collection(db, \"relationshipRequests\"),\n          where(\"toUserId\", \"==\", userId),\n          where(\"status\", \"==\", RelationshipRequestStatus.PENDING),\n          orderBy(\"createdAt\", \"desc\"),\n        ),\n      );\n\n      const result = requests.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipRequest[];\n\n      logger.debug(\"Retrieved pending requests\", {\n        userId,\n        count: result.length,\n      });\n\n      return result;\n    } catch (error) {\n      logger.error(\"Failed to get pending requests\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize chastity data for a new relationship\n   */\n  private async initializeChastityData(\n    relationshipId: string,\n    submissiveId: string,\n    keyholderId: string,\n    batch?: any,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n      const useBatch = batch || writeBatch(db);\n\n      const chastityData = {\n        relationshipId,\n        submissiveId,\n        keyholderId,\n        currentSession: {\n          id: \"\",\n          isActive: false,\n          startTime: serverTimestamp() as any,\n          accumulatedPauseTime: 0,\n          keyholderApprovalRequired: false,\n        },\n        goals: {\n          personal: {\n            duration: 0,\n            type: \"soft\",\n            setBy: \"submissive\",\n          },\n          keyholder: {\n            minimumDuration: 0,\n            canBeModified: true,\n          },\n        },\n        settings: {\n          allowPausing: true,\n          pauseCooldown: 300, // 5 minutes\n          requireReasonForEnd: false,\n          trackingEnabled: true,\n        },\n      };\n\n      useBatch.set(doc(db, \"chastityData\", relationshipId), {\n        ...chastityData,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      if (!batch) {\n        await useBatch.commit();\n      }\n\n      logger.info(\"Initialized chastity data\", {\n        relationshipId,\n        submissiveId,\n        keyholderId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to initialize chastity data\", {\n        error: error as Error,\n        relationshipId,\n        submissiveId,\n        keyholderId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const relationshipInviteService = new RelationshipInviteService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipRoleService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[514,517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[514,517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Role Service\n * Handles role and permission management for relationships\n */\nimport { doc, updateDoc, serverTimestamp } from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { RelationshipPermissions } from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { relationshipCRUDService } from \"./RelationshipCRUDService\";\n\nconst logger = serviceLogger(\"RelationshipRoleService\");\n\nexport class RelationshipRoleService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Update relationship permissions\n   */\n  async updateRelationshipPermissions(\n    relationshipId: string,\n    permissions: RelationshipPermissions,\n    updatingUserId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get the relationship to verify the user can update permissions\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n      if (!relationship) {\n        throw new Error(\"Relationship not found\");\n      }\n\n      // Only keyholder can modify permissions\n      if (relationship.keyholderId !== updatingUserId) {\n        throw new Error(\"Only keyholder can modify permissions\");\n      }\n\n      await updateDoc(doc(db, \"relationships\", relationshipId), {\n        permissions,\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Updated relationship permissions\", {\n        relationshipId,\n        updatingUserId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to update relationship permissions\", {\n        error: error as Error,\n        relationshipId,\n        updatingUserId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a user has permission to perform an action in a relationship\n   */\n  async checkPermission(\n    relationshipId: string,\n    userId: string,\n    action:\n      | keyof RelationshipPermissions[\"keyholderCanEdit\"]\n      | \"pauseSession\"\n      | \"emergencyUnlock\",\n  ): Promise<boolean> {\n    try {\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n      if (!relationship) {\n        return false;\n      }\n\n      const isSubmissive = relationship.submissiveId === userId;\n      const isKeyholder = relationship.keyholderId === userId;\n\n      if (!isSubmissive && !isKeyholder) {\n        return false;\n      }\n\n      // Check specific permissions\n      if (action === \"pauseSession\") {\n        return isSubmissive && relationship.permissions.submissiveCanPause;\n      }\n\n      if (action === \"emergencyUnlock\") {\n        return isSubmissive && relationship.permissions.emergencyUnlock;\n      }\n\n      // For keyholder edit permissions\n      if (isKeyholder && action in relationship.permissions.keyholderCanEdit) {\n        return relationship.permissions.keyholderCanEdit[\n          action as keyof RelationshipPermissions[\"keyholderCanEdit\"]\n        ];\n      }\n\n      return false;\n    } catch (error) {\n      logger.error(\"Failed to check permission\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n        action,\n      });\n      return false;\n    }\n  }\n}\n\nexport const relationshipRoleService = new RelationshipRoleService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipSearchService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[902,905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[902,905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-statements","severity":1,"message":"Async method 'searchRelationships' has too many statements (27). Maximum allowed is 25.","line":61,"column":28,"nodeType":"FunctionExpression","messageId":"exceed","endLine":132,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Search Service\n * Handles search, filter, and query operations for relationships\n */\nimport {\n  collection,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  limit,\n  startAfter,\n  DocumentSnapshot,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport {\n  Relationship,\n  RelationshipStatus,\n  RelationshipRequest,\n  RelationshipRequestStatus,\n} from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"RelationshipSearchService\");\n\nexport interface RelationshipSearchFilters {\n  status?: RelationshipStatus[];\n  userId?: string;\n  role?: \"submissive\" | \"keyholder\" | \"both\";\n  startDate?: Date;\n  endDate?: Date;\n}\n\nexport interface RelationshipSearchResult {\n  relationships: Relationship[];\n  hasMore: boolean;\n  lastDoc?: DocumentSnapshot;\n}\n\nexport class RelationshipSearchService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Search relationships with filters and pagination\n   */\n  async searchRelationships(\n    filters: RelationshipSearchFilters = {},\n    pageSize: number = 20,\n    lastDoc?: DocumentSnapshot,\n  ): Promise<RelationshipSearchResult> {\n    try {\n      const db = await this.ensureDb();\n      let relationshipQuery = collection(db, \"relationships\");\n\n      // Apply filters\n      const queryConstraints = [];\n\n      if (filters.status && filters.status.length > 0) {\n        queryConstraints.push(where(\"status\", \"in\", filters.status));\n      }\n\n      if (filters.userId) {\n        if (filters.role === \"submissive\") {\n          queryConstraints.push(where(\"submissiveId\", \"==\", filters.userId));\n        } else if (filters.role === \"keyholder\") {\n          queryConstraints.push(where(\"keyholderId\", \"==\", filters.userId));\n        }\n        // For \"both\" or undefined role, we'd need to do two separate queries\n        // and merge results (not implemented here for simplicity)\n      }\n\n      if (filters.startDate) {\n        queryConstraints.push(where(\"createdAt\", \">=\", filters.startDate));\n      }\n\n      if (filters.endDate) {\n        queryConstraints.push(where(\"createdAt\", \"<=\", filters.endDate));\n      }\n\n      // Add ordering and pagination\n      queryConstraints.push(orderBy(\"createdAt\", \"desc\"));\n      queryConstraints.push(limit(pageSize + 1)); // Get one extra to check if there are more\n\n      if (lastDoc) {\n        queryConstraints.push(startAfter(lastDoc));\n      }\n\n      const finalQuery = query(relationshipQuery, ...queryConstraints);\n      const snapshot = await getDocs(finalQuery);\n\n      const relationships = snapshot.docs.slice(0, pageSize).map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as Relationship[];\n\n      const hasMore = snapshot.docs.length > pageSize;\n      const newLastDoc = hasMore ? snapshot.docs[pageSize - 1] : undefined;\n\n      logger.debug(\"Searched relationships\", {\n        filters,\n        count: relationships.length,\n        hasMore,\n      });\n\n      return {\n        relationships,\n        hasMore,\n        lastDoc: newLastDoc,\n      };\n    } catch (error) {\n      logger.error(\"Failed to search relationships\", {\n        error: error as Error,\n        filters,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get active relationships for a user\n   */\n  async getActiveRelationships(userId: string): Promise<Relationship[]> {\n    const result = await this.searchRelationships(\n      {\n        userId,\n        status: [RelationshipStatus.ACTIVE],\n        role: \"both\",\n      },\n      50,\n    ); // Get up to 50 active relationships\n\n    return result.relationships;\n  }\n\n  /**\n   * Get relationship history for a user\n   */\n  async getRelationshipHistory(\n    userId: string,\n    pageSize: number = 20,\n    lastDoc?: DocumentSnapshot,\n  ): Promise<RelationshipSearchResult> {\n    return this.searchRelationships(\n      {\n        userId,\n        status: [RelationshipStatus.ENDED],\n        role: \"both\",\n      },\n      pageSize,\n      lastDoc,\n    );\n  }\n\n  /**\n   * Search relationship requests with filters\n   */\n  async searchRelationshipRequests(\n    userId: string,\n    direction: \"sent\" | \"received\" | \"both\" = \"both\",\n    status?: RelationshipRequestStatus[],\n    pageSize: number = 20,\n  ): Promise<RelationshipRequest[]> {\n    try {\n      const db = await this.ensureDb();\n      const requests: RelationshipRequest[] = [];\n\n      // Helper function to execute a query\n      const executeQuery = async (field: string, value: string) => {\n        const queryConstraints = [\n          where(field, \"==\", value),\n          orderBy(\"createdAt\", \"desc\"),\n          limit(pageSize),\n        ];\n\n        if (status && status.length > 0) {\n          queryConstraints.unshift(where(\"status\", \"in\", status));\n        }\n\n        const requestQuery = query(\n          collection(db, \"relationshipRequests\"),\n          ...queryConstraints,\n        );\n\n        const snapshot = await getDocs(requestQuery);\n        return snapshot.docs.map((doc) => ({\n          ...doc.data(),\n          id: doc.id,\n        })) as RelationshipRequest[];\n      };\n\n      // Get sent requests\n      if (direction === \"sent\" || direction === \"both\") {\n        const sentRequests = await executeQuery(\"fromUserId\", userId);\n        requests.push(...sentRequests);\n      }\n\n      // Get received requests\n      if (direction === \"received\" || direction === \"both\") {\n        const receivedRequests = await executeQuery(\"toUserId\", userId);\n        requests.push(...receivedRequests);\n      }\n\n      // Remove duplicates and sort by creation date\n      const uniqueRequests = requests\n        .filter(\n          (req, index, self) =>\n            index === self.findIndex((r) => r.id === req.id),\n        )\n        .sort((a, b) => b.createdAt.toMillis() - a.createdAt.toMillis())\n        .slice(0, pageSize);\n\n      logger.debug(\"Searched relationship requests\", {\n        userId,\n        direction,\n        status,\n        count: uniqueRequests.length,\n      });\n\n      return uniqueRequests;\n    } catch (error) {\n      logger.error(\"Failed to search relationship requests\", {\n        error: error as Error,\n        userId,\n        direction,\n        status,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Find relationships by participant IDs\n   */\n  async findRelationshipsByParticipants(\n    participantIds: string[],\n    status?: RelationshipStatus[],\n  ): Promise<Relationship[]> {\n    if (participantIds.length !== 2) {\n      throw new Error(\"Exactly 2 participant IDs are required\");\n    }\n\n    const [user1Id, user2Id] = participantIds;\n    const filters: RelationshipSearchFilters = { status };\n\n    try {\n      // Search in both directions\n      const results1 = await this.searchRelationships(\n        {\n          ...filters,\n          userId: user1Id,\n          role: \"submissive\",\n        },\n        10,\n      );\n\n      const results2 = await this.searchRelationships(\n        {\n          ...filters,\n          userId: user1Id,\n          role: \"keyholder\",\n        },\n        10,\n      );\n\n      // Filter results to only include relationships with both participants\n      const allRelationships = [\n        ...results1.relationships,\n        ...results2.relationships,\n      ];\n      const matchingRelationships = allRelationships.filter(\n        (rel) =>\n          (rel.submissiveId === user1Id && rel.keyholderId === user2Id) ||\n          (rel.submissiveId === user2Id && rel.keyholderId === user1Id),\n      );\n\n      // Remove duplicates\n      return matchingRelationships.filter(\n        (rel, index, self) => index === self.findIndex((r) => r.id === rel.id),\n      );\n    } catch (error) {\n      logger.error(\"Failed to find relationships by participants\", {\n        error: error as Error,\n        participantIds,\n        status,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const relationshipSearchService = new RelationshipSearchService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is assigned a value but never used.","line":16,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1471,1474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1471,1474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1705,1708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1705,1708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2504,2507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2504,2507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2756,2759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2756,2759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3704,3707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3704,3707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3833,3836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3833,3836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3849,3852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3849,3852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4216,4219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4216,4219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4267,4270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4267,4270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4610,4613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4610,4613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4810,4813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4810,4813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4837,4840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4837,4840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5097,5100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5097,5100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Service - Composite Service\n *\n * This service composes all relationship operation services to maintain\n * backward compatibility while providing access to modular functionality.\n */\nimport { relationshipCRUDService } from \"./RelationshipCRUDService\";\nimport { relationshipInviteService } from \"./RelationshipInviteService\";\nimport { relationshipRoleService } from \"./RelationshipRoleService\";\nimport { relationshipStatusService } from \"./RelationshipStatusService\";\nimport { relationshipValidationService } from \"./RelationshipValidationService\";\nimport { relationshipSearchService } from \"./RelationshipSearchService\";\nimport { relationshipStatsService } from \"./RelationshipStatsService\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"RelationshipService\");\n\n/**\n * Main Relationship Service that delegates to specialized services\n * Maintains backward compatibility with existing code\n */\nclass RelationshipService {\n  // CRUD Operations\n  async getUserRelationships(userId: string) {\n    return relationshipCRUDService.getUserRelationships(userId);\n  }\n\n  async getRelationship(relationshipId: string) {\n    return relationshipCRUDService.getRelationship(relationshipId);\n  }\n\n  async getRelationshipBetweenUsers(user1Id: string, user2Id: string) {\n    return relationshipCRUDService.getRelationshipBetweenUsers(\n      user1Id,\n      user2Id,\n    );\n  }\n\n  subscribeToUserRelationships(userId: string, callback: any) {\n    return relationshipCRUDService.subscribeToUserRelationships(\n      userId,\n      callback,\n    );\n  }\n\n  // Invitation Operations\n  async sendRelationshipRequest(\n    fromUserId: string,\n    toUserId: string,\n    fromRole: any,\n    message?: string,\n  ) {\n    return relationshipInviteService.sendRelationshipRequest(\n      fromUserId,\n      toUserId,\n      fromRole,\n      message,\n    );\n  }\n\n  async acceptRelationshipRequest(requestId: string, acceptingUserId: string) {\n    return relationshipInviteService.acceptRelationshipRequest(\n      requestId,\n      acceptingUserId,\n    );\n  }\n\n  async rejectRelationshipRequest(requestId: string, rejectingUserId: string) {\n    return relationshipInviteService.rejectRelationshipRequest(\n      requestId,\n      rejectingUserId,\n    );\n  }\n\n  async getPendingRequests(userId: string) {\n    return relationshipInviteService.getPendingRequests(userId);\n  }\n\n  // Role and Permission Operations\n  async updateRelationshipPermissions(\n    relationshipId: string,\n    permissions: any,\n    updatingUserId: string,\n  ) {\n    return relationshipRoleService.updateRelationshipPermissions(\n      relationshipId,\n      permissions,\n      updatingUserId,\n    );\n  }\n\n  async checkPermission(relationshipId: string, userId: string, action: any) {\n    return relationshipRoleService.checkPermission(\n      relationshipId,\n      userId,\n      action,\n    );\n  }\n\n  // Status Operations\n  async endRelationship(relationshipId: string, endingUserId: string) {\n    return relationshipStatusService.endRelationship(\n      relationshipId,\n      endingUserId,\n    );\n  }\n\n  async pauseRelationship(relationshipId: string, pausingUserId: string) {\n    return relationshipStatusService.pauseRelationship(\n      relationshipId,\n      pausingUserId,\n    );\n  }\n\n  async resumeRelationship(relationshipId: string, resumingUserId: string) {\n    return relationshipStatusService.resumeRelationship(\n      relationshipId,\n      resumingUserId,\n    );\n  }\n\n  // Validation Operations\n  async validateRelationshipCreation(user1Id: string, user2Id: string) {\n    return relationshipValidationService.validateRelationshipCreation(\n      user1Id,\n      user2Id,\n    );\n  }\n\n  validatePermissions(permissions: any) {\n    return relationshipValidationService.validatePermissions(permissions);\n  }\n\n  validateStatusTransition(currentStatus: any, newStatus: any) {\n    return relationshipValidationService.validateStatusTransition(\n      currentStatus,\n      newStatus,\n    );\n  }\n\n  async validateUserAccess(relationshipId: string, userId: string) {\n    return relationshipValidationService.validateUserAccess(\n      relationshipId,\n      userId,\n    );\n  }\n\n  // Search Operations\n  async searchRelationships(\n    filters: any = {},\n    pageSize: number = 20,\n    lastDoc?: any,\n  ) {\n    return relationshipSearchService.searchRelationships(\n      filters,\n      pageSize,\n      lastDoc,\n    );\n  }\n\n  async getActiveRelationships(userId: string) {\n    return relationshipSearchService.getActiveRelationships(userId);\n  }\n\n  async getRelationshipHistory(\n    userId: string,\n    pageSize: number = 20,\n    lastDoc?: any,\n  ) {\n    return relationshipSearchService.getRelationshipHistory(\n      userId,\n      pageSize,\n      lastDoc,\n    );\n  }\n\n  async searchRelationshipRequests(\n    userId: string,\n    direction: any = \"both\",\n    status?: any,\n    pageSize: number = 20,\n  ) {\n    return relationshipSearchService.searchRelationshipRequests(\n      userId,\n      direction,\n      status,\n      pageSize,\n    );\n  }\n\n  async findRelationshipsByParticipants(\n    participantIds: string[],\n    status?: any,\n  ) {\n    return relationshipSearchService.findRelationshipsByParticipants(\n      participantIds,\n      status,\n    );\n  }\n\n  // Statistics Operations\n  async getUserRelationshipStats(userId: string) {\n    return relationshipStatsService.getUserRelationshipStats(userId);\n  }\n\n  async getRecentActivity(userId: string, limitCount: number = 10) {\n    return relationshipStatsService.getRecentActivity(userId, limitCount);\n  }\n\n  // Direct access to specialized services for advanced usage\n  get crud() {\n    return relationshipCRUDService;\n  }\n\n  get invites() {\n    return relationshipInviteService;\n  }\n\n  get roles() {\n    return relationshipRoleService;\n  }\n\n  get status() {\n    return relationshipStatusService;\n  }\n\n  get validation() {\n    return relationshipValidationService;\n  }\n\n  get search() {\n    return relationshipSearchService;\n  }\n\n  get stats() {\n    return relationshipStatsService;\n  }\n}\n\nexport const relationshipService = new RelationshipService();\n\n// Also export individual services for direct access\nexport {\n  relationshipCRUDService,\n  relationshipInviteService,\n  relationshipRoleService,\n  relationshipStatusService,\n  relationshipValidationService,\n  relationshipSearchService,\n  relationshipStatsService,\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipStatsService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1278,1281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1278,1281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'getRecentActivity' has too many lines (83). Maximum allowed is 75.","line":296,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":388,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Statistics Service\n * Handles statistics and reporting for relationships\n */\nimport {\n  collection,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  limit,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport {\n  Relationship,\n  RelationshipStatus,\n  RelationshipRequest,\n  RelationshipRequestStatus,\n} from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"RelationshipStatsService\");\n\nexport interface RelationshipStats {\n  totalRelationships: number;\n  activeRelationships: number;\n  pausedRelationships: number;\n  endedRelationships: number;\n  averageRelationshipDuration?: number; // in days\n  longestRelationship?: number; // in days\n  shortestRelationship?: number; // in days\n}\n\nexport interface RelationshipRequestStats {\n  totalRequests: number;\n  pendingRequests: number;\n  acceptedRequests: number;\n  rejectedRequests: number;\n  expiredRequests: number;\n  acceptanceRate: number; // percentage\n}\n\nexport interface UserRelationshipStats {\n  asSubmissive: RelationshipStats;\n  asKeyholder: RelationshipStats;\n  requestStats: {\n    sent: RelationshipRequestStats;\n    received: RelationshipRequestStats;\n  };\n}\n\nexport class RelationshipStatsService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Get comprehensive relationship statistics for a user\n   */\n  async getUserRelationshipStats(\n    userId: string,\n  ): Promise<UserRelationshipStats> {\n    try {\n      const [\n        submissiveStats,\n        keyholderStats,\n        sentRequestStats,\n        receivedRequestStats,\n      ] = await Promise.all([\n        this.getRelationshipStatsForRole(userId, \"submissive\"),\n        this.getRelationshipStatsForRole(userId, \"keyholder\"),\n        this.getRequestStatsForDirection(userId, \"sent\"),\n        this.getRequestStatsForDirection(userId, \"received\"),\n      ]);\n\n      const userStats: UserRelationshipStats = {\n        asSubmissive: submissiveStats,\n        asKeyholder: keyholderStats,\n        requestStats: {\n          sent: sentRequestStats,\n          received: receivedRequestStats,\n        },\n      };\n\n      logger.debug(\"Retrieved user relationship stats\", {\n        userId,\n        stats: userStats,\n      });\n\n      return userStats;\n    } catch (error) {\n      logger.error(\"Failed to get user relationship stats\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get relationship statistics for a specific role\n   */\n  private async getRelationshipStatsForRole(\n    userId: string,\n    role: \"submissive\" | \"keyholder\",\n  ): Promise<RelationshipStats> {\n    try {\n      const db = await this.ensureDb();\n      const userField = role === \"submissive\" ? \"submissiveId\" : \"keyholderId\";\n\n      const relationshipsQuery = query(\n        collection(db, \"relationships\"),\n        where(userField, \"==\", userId),\n        orderBy(\"createdAt\", \"desc\"),\n      );\n\n      const snapshot = await getDocs(relationshipsQuery);\n      const relationships = snapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as Relationship[];\n\n      return this.calculateRelationshipStats(relationships);\n    } catch (error) {\n      logger.error(\"Failed to get relationship stats for role\", {\n        error: error as Error,\n        userId,\n        role,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate statistics from a list of relationships\n   */\n  private calculateRelationshipStats(\n    relationships: Relationship[],\n  ): RelationshipStats {\n    const stats: RelationshipStats = {\n      totalRelationships: relationships.length,\n      activeRelationships: 0,\n      pausedRelationships: 0,\n      endedRelationships: 0,\n    };\n\n    if (relationships.length === 0) {\n      return stats;\n    }\n\n    const durations: number[] = [];\n    const now = new Date();\n\n    relationships.forEach((rel) => {\n      // Count by status\n      switch (rel.status) {\n        case RelationshipStatus.ACTIVE:\n          stats.activeRelationships++;\n          break;\n        case RelationshipStatus.PAUSED:\n          stats.pausedRelationships++;\n          break;\n        case RelationshipStatus.ENDED:\n          stats.endedRelationships++;\n          break;\n      }\n\n      // Calculate duration for ended relationships\n      if (\n        rel.status === RelationshipStatus.ENDED &&\n        rel.endedAt &&\n        rel.establishedAt\n      ) {\n        const duration =\n          (rel.endedAt.toMillis() - rel.establishedAt.toMillis()) /\n          (1000 * 60 * 60 * 24);\n        durations.push(duration);\n      } else if (\n        rel.status === RelationshipStatus.ACTIVE &&\n        rel.establishedAt\n      ) {\n        // For active relationships, calculate current duration\n        const duration =\n          (now.getTime() - rel.establishedAt.toMillis()) /\n          (1000 * 60 * 60 * 24);\n        durations.push(duration);\n      }\n    });\n\n    // Calculate duration statistics\n    if (durations.length > 0) {\n      stats.averageRelationshipDuration =\n        durations.reduce((a, b) => a + b, 0) / durations.length;\n      stats.longestRelationship = Math.max(...durations);\n      stats.shortestRelationship = Math.min(...durations);\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get request statistics for a specific direction\n   */\n  private async getRequestStatsForDirection(\n    userId: string,\n    direction: \"sent\" | \"received\",\n  ): Promise<RelationshipRequestStats> {\n    try {\n      const db = await this.ensureDb();\n      const userField = direction === \"sent\" ? \"fromUserId\" : \"toUserId\";\n\n      const requestsQuery = query(\n        collection(db, \"relationshipRequests\"),\n        where(userField, \"==\", userId),\n        orderBy(\"createdAt\", \"desc\"),\n      );\n\n      const snapshot = await getDocs(requestsQuery);\n      const requests = snapshot.docs.map((doc) => ({\n        ...doc.data(),\n        id: doc.id,\n      })) as RelationshipRequest[];\n\n      return this.calculateRequestStats(requests);\n    } catch (error) {\n      logger.error(\"Failed to get request stats for direction\", {\n        error: error as Error,\n        userId,\n        direction,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate statistics from a list of relationship requests\n   */\n  private calculateRequestStats(\n    requests: RelationshipRequest[],\n  ): RelationshipRequestStats {\n    const stats: RelationshipRequestStats = {\n      totalRequests: requests.length,\n      pendingRequests: 0,\n      acceptedRequests: 0,\n      rejectedRequests: 0,\n      expiredRequests: 0,\n      acceptanceRate: 0,\n    };\n\n    if (requests.length === 0) {\n      return stats;\n    }\n\n    requests.forEach((req) => {\n      switch (req.status) {\n        case RelationshipRequestStatus.PENDING:\n          stats.pendingRequests++;\n          break;\n        case RelationshipRequestStatus.ACCEPTED:\n          stats.acceptedRequests++;\n          break;\n        case RelationshipRequestStatus.REJECTED:\n          stats.rejectedRequests++;\n          break;\n        case RelationshipRequestStatus.EXPIRED:\n          stats.expiredRequests++;\n          break;\n      }\n    });\n\n    // Calculate acceptance rate (accepted / (accepted + rejected))\n    const decidedRequests = stats.acceptedRequests + stats.rejectedRequests;\n    if (decidedRequests > 0) {\n      stats.acceptanceRate = (stats.acceptedRequests / decidedRequests) * 100;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get recent relationship activity for a user\n   */\n  async getRecentActivity(\n    userId: string,\n    limitCount: number = 10,\n  ): Promise<{\n    recentRelationships: Relationship[];\n    recentRequests: RelationshipRequest[];\n  }> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get recent relationships (both as submissive and keyholder)\n      const [submissiveRels, keyholderRels, sentRequests, receivedRequests] =\n        await Promise.all([\n          getDocs(\n            query(\n              collection(db, \"relationships\"),\n              where(\"submissiveId\", \"==\", userId),\n              orderBy(\"updatedAt\", \"desc\"),\n              limit(limitCount),\n            ),\n          ),\n          getDocs(\n            query(\n              collection(db, \"relationships\"),\n              where(\"keyholderId\", \"==\", userId),\n              orderBy(\"updatedAt\", \"desc\"),\n              limit(limitCount),\n            ),\n          ),\n          getDocs(\n            query(\n              collection(db, \"relationshipRequests\"),\n              where(\"fromUserId\", \"==\", userId),\n              orderBy(\"createdAt\", \"desc\"),\n              limit(limitCount),\n            ),\n          ),\n          getDocs(\n            query(\n              collection(db, \"relationshipRequests\"),\n              where(\"toUserId\", \"==\", userId),\n              orderBy(\"createdAt\", \"desc\"),\n              limit(limitCount),\n            ),\n          ),\n        ]);\n\n      // Combine and sort relationships\n      const allRelationships = [\n        ...submissiveRels.docs.map((doc) => ({ ...doc.data(), id: doc.id })),\n        ...keyholderRels.docs.map((doc) => ({ ...doc.data(), id: doc.id })),\n      ] as Relationship[];\n\n      const uniqueRelationships = allRelationships\n        .filter(\n          (rel, index, self) =>\n            index === self.findIndex((r) => r.id === rel.id),\n        )\n        .sort((a, b) => b.updatedAt.toMillis() - a.updatedAt.toMillis())\n        .slice(0, limitCount);\n\n      // Combine and sort requests\n      const allRequests = [\n        ...sentRequests.docs.map((doc) => ({ ...doc.data(), id: doc.id })),\n        ...receivedRequests.docs.map((doc) => ({ ...doc.data(), id: doc.id })),\n      ] as RelationshipRequest[];\n\n      const uniqueRequests = allRequests\n        .filter(\n          (req, index, self) =>\n            index === self.findIndex((r) => r.id === req.id),\n        )\n        .sort((a, b) => b.createdAt.toMillis() - a.createdAt.toMillis())\n        .slice(0, limitCount);\n\n      logger.debug(\"Retrieved recent activity\", {\n        userId,\n        relationshipsCount: uniqueRelationships.length,\n        requestsCount: uniqueRequests.length,\n      });\n\n      return {\n        recentRelationships: uniqueRelationships,\n        recentRequests: uniqueRequests,\n      };\n    } catch (error) {\n      logger.error(\"Failed to get recent activity\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const relationshipStatsService = new RelationshipStatsService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipStatusService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[515,518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[515,518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Status Service\n * Handles status updates and transitions for relationships\n */\nimport { doc, updateDoc, serverTimestamp } from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { RelationshipStatus } from \"@/types/relationships\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { relationshipCRUDService } from \"./RelationshipCRUDService\";\n\nconst logger = serviceLogger(\"RelationshipStatusService\");\n\nexport class RelationshipStatusService {\n  private db: any = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * End a relationship\n   */\n  async endRelationship(\n    relationshipId: string,\n    endingUserId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get the relationship to verify the user can end it\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n      if (!relationship) {\n        throw new Error(\"Relationship not found\");\n      }\n\n      // Both parties can end the relationship\n      if (\n        relationship.submissiveId !== endingUserId &&\n        relationship.keyholderId !== endingUserId\n      ) {\n        throw new Error(\n          \"Only relationship participants can end the relationship\",\n        );\n      }\n\n      await updateDoc(doc(db, \"relationships\", relationshipId), {\n        status: RelationshipStatus.ENDED,\n        endedAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Relationship ended\", {\n        relationshipId,\n        endingUserId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to end relationship\", {\n        error: error as Error,\n        relationshipId,\n        endingUserId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Pause a relationship\n   */\n  async pauseRelationship(\n    relationshipId: string,\n    pausingUserId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get the relationship to verify the user can pause it\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n      if (!relationship) {\n        throw new Error(\"Relationship not found\");\n      }\n\n      // Both parties can pause the relationship\n      if (\n        relationship.submissiveId !== pausingUserId &&\n        relationship.keyholderId !== pausingUserId\n      ) {\n        throw new Error(\n          \"Only relationship participants can pause the relationship\",\n        );\n      }\n\n      await updateDoc(doc(db, \"relationships\", relationshipId), {\n        status: RelationshipStatus.PAUSED,\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Relationship paused\", {\n        relationshipId,\n        pausingUserId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to pause relationship\", {\n        error: error as Error,\n        relationshipId,\n        pausingUserId,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Resume a paused relationship\n   */\n  async resumeRelationship(\n    relationshipId: string,\n    resumingUserId: string,\n  ): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n\n      // Get the relationship to verify the user can resume it\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n      if (!relationship) {\n        throw new Error(\"Relationship not found\");\n      }\n\n      // Verify relationship is currently paused\n      if (relationship.status !== RelationshipStatus.PAUSED) {\n        throw new Error(\"Relationship is not currently paused\");\n      }\n\n      // Both parties can resume the relationship\n      if (\n        relationship.submissiveId !== resumingUserId &&\n        relationship.keyholderId !== resumingUserId\n      ) {\n        throw new Error(\n          \"Only relationship participants can resume the relationship\",\n        );\n      }\n\n      await updateDoc(doc(db, \"relationships\", relationshipId), {\n        status: RelationshipStatus.ACTIVE,\n        updatedAt: serverTimestamp(),\n      });\n\n      logger.info(\"Relationship resumed\", {\n        relationshipId,\n        resumingUserId,\n      });\n    } catch (error) {\n      logger.error(\"Failed to resume relationship\", {\n        error: error as Error,\n        relationshipId,\n        resumingUserId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const relationshipStatusService = new RelationshipStatusService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/RelationshipValidationService.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'validatePermissions' has too many lines (79). Maximum allowed is 75.","line":73,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":161,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Validation Service\n * Handles business rules and validation for relationships\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport {\n  Relationship,\n  RelationshipStatus,\n  RelationshipPermissions,\n} from \"@/types/relationships\";\nimport { relationshipCRUDService } from \"./RelationshipCRUDService\";\n\nconst logger = serviceLogger(\"RelationshipValidationService\");\n\nexport class RelationshipValidationService {\n  /**\n   * Validate if two users can establish a relationship\n   */\n  async validateRelationshipCreation(\n    user1Id: string,\n    user2Id: string,\n  ): Promise<{ valid: boolean; error?: string }> {\n    try {\n      // Users cannot have relationships with themselves\n      if (user1Id === user2Id) {\n        return {\n          valid: false,\n          error: \"Users cannot establish relationships with themselves\",\n        };\n      }\n\n      // Check if they already have an active relationship\n      const existingRelationship =\n        await relationshipCRUDService.getRelationshipBetweenUsers(\n          user1Id,\n          user2Id,\n        );\n\n      if (existingRelationship) {\n        if (existingRelationship.status === RelationshipStatus.ACTIVE) {\n          return {\n            valid: false,\n            error: \"An active relationship already exists between these users\",\n          };\n        }\n\n        if (existingRelationship.status === RelationshipStatus.PAUSED) {\n          return {\n            valid: false,\n            error:\n              \"A paused relationship exists between these users. Resume it instead.\",\n          };\n        }\n      }\n\n      return { valid: true };\n    } catch (error) {\n      logger.error(\"Failed to validate relationship creation\", {\n        error: error as Error,\n        user1Id,\n        user2Id,\n      });\n      return {\n        valid: false,\n        error: \"Unable to validate relationship creation\",\n      };\n    }\n  }\n\n  /**\n   * Validate relationship permissions\n   */\n  validatePermissions(permissions: RelationshipPermissions): {\n    valid: boolean;\n    error?: string;\n  } {\n    try {\n      // Ensure all required permission fields are present\n      if (\n        !permissions.keyholderCanEdit ||\n        typeof permissions.keyholderCanEdit !== \"object\"\n      ) {\n        return {\n          valid: false,\n          error: \"Invalid keyholderCanEdit permissions structure\",\n        };\n      }\n\n      if (\n        !permissions.requireApproval ||\n        typeof permissions.requireApproval !== \"object\"\n      ) {\n        return {\n          valid: false,\n          error: \"Invalid requireApproval permissions structure\",\n        };\n      }\n\n      // Validate boolean fields\n      if (typeof permissions.submissiveCanPause !== \"boolean\") {\n        return {\n          valid: false,\n          error: \"submissiveCanPause must be a boolean\",\n        };\n      }\n\n      if (typeof permissions.emergencyUnlock !== \"boolean\") {\n        return {\n          valid: false,\n          error: \"emergencyUnlock must be a boolean\",\n        };\n      }\n\n      // Validate keyholder edit permissions\n      const keyholderEditFields = [\n        \"sessions\",\n        \"tasks\",\n        \"goals\",\n        \"punishments\",\n        \"settings\",\n      ];\n      for (const field of keyholderEditFields) {\n        if (\n          typeof permissions.keyholderCanEdit[\n            field as keyof typeof permissions.keyholderCanEdit\n          ] !== \"boolean\"\n        ) {\n          return {\n            valid: false,\n            error: `keyholderCanEdit.${field} must be a boolean`,\n          };\n        }\n      }\n\n      // Validate approval requirements\n      const approvalFields = [\"sessionEnd\", \"taskCompletion\", \"goalChanges\"];\n      for (const field of approvalFields) {\n        if (\n          typeof permissions.requireApproval[\n            field as keyof typeof permissions.requireApproval\n          ] !== \"boolean\"\n        ) {\n          return {\n            valid: false,\n            error: `requireApproval.${field} must be a boolean`,\n          };\n        }\n      }\n\n      return { valid: true };\n    } catch (error) {\n      logger.error(\"Failed to validate permissions\", {\n        error: error as Error,\n        permissions,\n      });\n      return {\n        valid: false,\n        error: \"Unable to validate permissions structure\",\n      };\n    }\n  }\n\n  /**\n   * Validate relationship status transition\n   */\n  validateStatusTransition(\n    currentStatus: RelationshipStatus,\n    newStatus: RelationshipStatus,\n  ): { valid: boolean; error?: string } {\n    const validTransitions = {\n      [RelationshipStatus.PENDING]: [\n        RelationshipStatus.ACTIVE,\n        RelationshipStatus.ENDED,\n      ],\n      [RelationshipStatus.ACTIVE]: [\n        RelationshipStatus.PAUSED,\n        RelationshipStatus.ENDED,\n      ],\n      [RelationshipStatus.PAUSED]: [\n        RelationshipStatus.ACTIVE,\n        RelationshipStatus.ENDED,\n      ],\n      [RelationshipStatus.ENDED]: [], // Ended relationships cannot transition to other states\n    };\n\n    if (!validTransitions[currentStatus].includes(newStatus)) {\n      return {\n        valid: false,\n        error: `Cannot transition from ${currentStatus} to ${newStatus}`,\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Validate user access to relationship\n   */\n  async validateUserAccess(\n    relationshipId: string,\n    userId: string,\n  ): Promise<{ valid: boolean; error?: string; relationship?: Relationship }> {\n    try {\n      const relationship =\n        await relationshipCRUDService.getRelationship(relationshipId);\n\n      if (!relationship) {\n        return {\n          valid: false,\n          error: \"Relationship not found\",\n        };\n      }\n\n      const isParticipant =\n        relationship.submissiveId === userId ||\n        relationship.keyholderId === userId;\n\n      if (!isParticipant) {\n        return {\n          valid: false,\n          error: \"User is not a participant in this relationship\",\n        };\n      }\n\n      return {\n        valid: true,\n        relationship,\n      };\n    } catch (error) {\n      logger.error(\"Failed to validate user access\", {\n        error: error as Error,\n        relationshipId,\n        userId,\n      });\n      return {\n        valid: false,\n        error: \"Unable to validate user access\",\n      };\n    }\n  }\n}\n\nexport const relationshipValidationService =\n  new RelationshipValidationService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/database/relationships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/feedbackService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/migration/DataMigrationService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":8},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3904,3907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3904,3907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5798,5801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5798,5801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6392,6395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6392,6395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7560,7563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7560,7563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":324,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8224,8227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8224,8227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":370,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9335,9338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9335,9338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":393,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10060,10063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10060,10063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":438,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":438,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11148,11151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11148,11151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":460,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":460,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11804,11807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11804,11807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (502). Maximum allowed is 500.","line":639,"column":1,"nodeType":null,"messageId":"exceed","endLine":642,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Data Migration Service\n * Handles migration from single-user to relationship-based architecture\n */\nimport {\n  collection,\n  doc,\n  getDocs,\n  getDoc,\n  writeBatch,\n  query,\n  serverTimestamp,\n  Firestore,\n} from \"firebase/firestore\";\nimport { getFirestore } from \"@/services/firebase\";\nimport { relationshipService } from \"@/services/database/relationships\";\nimport {\n  Relationship,\n  RelationshipStatus,\n  RelationshipChastityData,\n  RelationshipSession,\n  RelationshipTask,\n  RelationshipEvent,\n} from \"@/types\";\nimport type { TaskStatus, EventType } from \"@/types/database\";\nimport { serviceLogger } from \"@/utils/logging\";\nimport { generateUUID } from \"@/utils\";\n\nconst logger = serviceLogger(\"DataMigrationService\");\n\nexport interface MigrationResult {\n  success: boolean;\n  relationshipId?: string;\n  migratedSessions: number;\n  migratedTasks: number;\n  migratedEvents: number;\n  errors: string[];\n}\n\nclass DataMigrationService {\n  private db: Firestore | null = null;\n\n  constructor() {\n    this.initializeDb();\n  }\n\n  private async initializeDb() {\n    this.db = await getFirestore();\n  }\n\n  private async ensureDb() {\n    if (!this.db) {\n      await this.initializeDb();\n    }\n    return this.db;\n  }\n\n  /**\n   * Migrate single-user data to relationship-based architecture\n   * This creates a \"self-relationship\" where user is both submissive and keyholder\n   */\n  async migrateSingleUserData(userId: string): Promise<MigrationResult> {\n    const result: MigrationResult = {\n      success: false,\n      migratedSessions: 0,\n      migratedTasks: 0,\n      migratedEvents: 0,\n      errors: [],\n    };\n\n    try {\n      const db = await this.ensureDb();\n\n      // Check if migration is needed\n      const validationResult = await this.validateMigrationEligibility(userId);\n      if (!validationResult.isEligible) {\n        result.errors.push(validationResult.reason);\n        return result;\n      }\n\n      // Set up relationship and chastity data\n      const relationshipId = generateUUID();\n      const batch = writeBatch(db);\n      await this.setupRelationshipAndChastityData(\n        batch,\n        userId,\n        relationshipId,\n      );\n\n      // Migrate data collections\n      const sessionCount = await this.migrateSessionsData(\n        batch,\n        userId,\n        relationshipId,\n        result,\n      );\n      const taskCount = await this.migrateTasksData(\n        batch,\n        userId,\n        relationshipId,\n        result,\n      );\n      const eventCount = await this.migrateEventsData(\n        batch,\n        userId,\n        relationshipId,\n        result,\n      );\n\n      // Commit all changes\n      await this.executeMigrationBatch(batch);\n\n      // Update results\n      result.success = true;\n      result.relationshipId = relationshipId;\n      result.migratedSessions = sessionCount;\n      result.migratedTasks = taskCount;\n      result.migratedEvents = eventCount;\n\n      logger.info(\"Successfully migrated single-user data\", {\n        userId,\n        relationshipId,\n        result,\n      });\n    } catch (error) {\n      result.errors.push(`Migration failed: ${(error as Error).message}`);\n      logger.error(\"Failed to migrate single-user data\", {\n        error: error as Error,\n        userId,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate if user is eligible for migration\n   */\n  private async validateMigrationEligibility(\n    userId: string,\n  ): Promise<{ isEligible: boolean; reason: string }> {\n    const existingRelationships =\n      await relationshipService.getUserRelationships(userId);\n    if (existingRelationships.length > 0) {\n      return {\n        isEligible: false,\n        reason: \"User already has relationships - migration not needed\",\n      };\n    }\n    return { isEligible: true, reason: \"\" };\n  }\n\n  /**\n   * Set up relationship and chastity data structures\n   */\n  private async setupRelationshipAndChastityData(\n    batch: any,\n    userId: string,\n    relationshipId: string,\n  ): Promise<void> {\n    const db = await this.ensureDb();\n\n    // Create relationship\n    const relationship = this.createSelfRelationship(userId, relationshipId);\n    batch.set(doc(db, \"relationships\", relationshipId), {\n      ...relationship,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n      establishedAt: serverTimestamp(),\n    });\n\n    // Create chastity data\n    const chastityData = this.createChastityData(userId, relationshipId);\n    batch.set(doc(db, \"chastityData\", relationshipId), {\n      ...chastityData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n  }\n\n  /**\n   * Create self-relationship configuration\n   */\n  private createSelfRelationship(\n    userId: string,\n    relationshipId: string,\n  ): Omit<Relationship, \"createdAt\" | \"updatedAt\" | \"establishedAt\"> {\n    return {\n      id: relationshipId,\n      submissiveId: userId,\n      keyholderId: userId, // Self-relationship\n      status: RelationshipStatus.ACTIVE,\n      permissions: {\n        keyholderCanEdit: {\n          sessions: true,\n          tasks: true,\n          goals: true,\n          punishments: true,\n          settings: true,\n        },\n        submissiveCanPause: true,\n        emergencyUnlock: true,\n        requireApproval: {\n          sessionEnd: false,\n          taskCompletion: false,\n          goalChanges: false,\n        },\n      },\n      notes: \"Migrated from single-user system\",\n    };\n  }\n\n  /**\n   * Create chastity data configuration\n   */\n  private createChastityData(\n    userId: string,\n    relationshipId: string,\n  ): Omit<RelationshipChastityData, \"createdAt\" | \"updatedAt\"> {\n    return {\n      relationshipId,\n      submissiveId: userId,\n      keyholderId: userId,\n      currentSession: {\n        id: \"\",\n        isActive: false,\n        startTime: serverTimestamp() as any,\n        accumulatedPauseTime: 0,\n        keyholderApprovalRequired: false,\n      },\n      goals: {\n        personal: {\n          duration: 0,\n          type: \"soft\",\n          setBy: \"submissive\",\n        },\n        keyholder: {\n          minimumDuration: 0,\n          canBeModified: true,\n        },\n      },\n      settings: {\n        allowPausing: true,\n        pauseCooldown: 300,\n        requireReasonForEnd: false,\n        trackingEnabled: true,\n      },\n    };\n  }\n\n  /**\n   * Migrate sessions data to new relationship structure\n   */\n  private async migrateSessionsData(\n    batch: any,\n    userId: string,\n    relationshipId: string,\n    result: MigrationResult,\n  ): Promise<number> {\n    try {\n      const db = await this.ensureDb();\n      const sessionsSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"sessions\"),\n      );\n      let migratedCount = 0;\n\n      for (const sessionDoc of sessionsSnapshot.docs) {\n        const oldSession = sessionDoc.data();\n        const newSession = this.transformSessionData(\n          sessionDoc.id,\n          relationshipId,\n          oldSession,\n        );\n\n        batch.set(\n          doc(db, \"chastityData\", relationshipId, \"sessions\", sessionDoc.id),\n          {\n            ...newSession,\n            createdAt: oldSession.createdAt || serverTimestamp(),\n            updatedAt: serverTimestamp(),\n          },\n        );\n        migratedCount++;\n      }\n\n      return migratedCount;\n    } catch (error) {\n      result.errors.push(\n        `Failed to migrate sessions: ${(error as Error).message}`,\n      );\n      return 0;\n    }\n  }\n\n  /**\n   * Transform session data to new format\n   */\n  private transformSessionData(\n    sessionId: string,\n    relationshipId: string,\n    oldSession: any,\n  ): Omit<RelationshipSession, \"createdAt\" | \"updatedAt\"> {\n    return {\n      id: sessionId,\n      relationshipId,\n      startTime: oldSession.startTime || serverTimestamp(),\n      endTime: oldSession.endTime,\n      duration: oldSession.duration || 0,\n      effectiveDuration:\n        oldSession.effectiveDuration || oldSession.duration || 0,\n      events: [], // Legacy sessions won't have detailed events\n      goalMet: oldSession.goalMet || false,\n      keyholderApproval: {\n        required: false,\n        granted: true,\n      },\n    };\n  }\n\n  /**\n   * Migrate tasks data to new relationship structure\n   */\n  private async migrateTasksData(\n    batch: any,\n    userId: string,\n    relationshipId: string,\n    result: MigrationResult,\n  ): Promise<number> {\n    try {\n      const db = await this.ensureDb();\n      const tasksSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"tasks\"),\n      );\n      let migratedCount = 0;\n\n      for (const taskDoc of tasksSnapshot.docs) {\n        const oldTask = taskDoc.data();\n        const newTask = this.transformTaskData(\n          taskDoc.id,\n          relationshipId,\n          oldTask,\n        );\n\n        batch.set(\n          doc(db, \"chastityData\", relationshipId, \"tasks\", taskDoc.id),\n          {\n            ...newTask,\n            createdAt: oldTask.createdAt || serverTimestamp(),\n            updatedAt: serverTimestamp(),\n          },\n        );\n        migratedCount++;\n      }\n\n      return migratedCount;\n    } catch (error) {\n      result.errors.push(\n        `Failed to migrate tasks: ${(error as Error).message}`,\n      );\n      return 0;\n    }\n  }\n\n  /**\n   * Transform task data to new format\n   */\n  private transformTaskData(\n    taskId: string,\n    relationshipId: string,\n    oldTask: any,\n  ): Omit<RelationshipTask, \"createdAt\" | \"updatedAt\"> {\n    return {\n      id: taskId,\n      relationshipId,\n      text: oldTask.text || \"Migrated task\",\n      assignedBy: \"submissive\", // Assume self-assigned for migration\n      assignedTo: \"submissive\",\n      dueDate: oldTask.dueDate,\n      status: this.mapTaskStatus(oldTask.status),\n      submittedAt: oldTask.submittedAt,\n      approvedAt: oldTask.approvedAt,\n      completedAt: oldTask.completedAt,\n      submissiveNote: oldTask.submissiveNote,\n      keyholderFeedback: oldTask.keyholderFeedback,\n      consequence: oldTask.consequence,\n    };\n  }\n\n  /**\n   * Migrate events data to new relationship structure\n   */\n  private async migrateEventsData(\n    batch: any,\n    userId: string,\n    relationshipId: string,\n    result: MigrationResult,\n  ): Promise<number> {\n    try {\n      const db = await this.ensureDb();\n      const eventsSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"events\"),\n      );\n      let migratedCount = 0;\n\n      for (const eventDoc of eventsSnapshot.docs) {\n        const oldEvent = eventDoc.data();\n        const newEvent = this.transformEventData(\n          eventDoc.id,\n          relationshipId,\n          oldEvent,\n        );\n\n        batch.set(\n          doc(db, \"chastityData\", relationshipId, \"events\", eventDoc.id),\n          {\n            ...newEvent,\n            createdAt: oldEvent.createdAt || serverTimestamp(),\n          },\n        );\n        migratedCount++;\n      }\n\n      return migratedCount;\n    } catch (error) {\n      result.errors.push(\n        `Failed to migrate events: ${(error as Error).message}`,\n      );\n      return 0;\n    }\n  }\n\n  /**\n   * Transform event data to new format\n   */\n  private transformEventData(\n    eventId: string,\n    relationshipId: string,\n    oldEvent: any,\n  ): Omit<RelationshipEvent, \"createdAt\"> {\n    return {\n      id: eventId,\n      relationshipId,\n      type: this.mapEventType(oldEvent.type),\n      timestamp: oldEvent.timestamp || serverTimestamp(),\n      details: {\n        duration: oldEvent.details?.duration,\n        notes: oldEvent.details?.notes || oldEvent.notes,\n        mood: oldEvent.details?.mood,\n        participants: [\"submissive\"], // Default for migration\n      },\n      loggedBy: \"submissive\",\n      isPrivate: oldEvent.isPrivate || false,\n      tags: oldEvent.tags || [],\n    };\n  }\n\n  /**\n   * Execute the migration batch commit\n   */\n  private async executeMigrationBatch(batch: any): Promise<void> {\n    await batch.commit();\n  }\n\n  /**\n   * Check if a user needs data migration\n   */\n  async needsMigration(userId: string): Promise<boolean> {\n    try {\n      const db = await this.ensureDb();\n\n      // Check if user has relationships\n      const relationships =\n        await relationshipService.getUserRelationships(userId);\n      if (relationships.length > 0) {\n        return false; // Already has relationships\n      }\n\n      // Check if user has legacy data\n      const userDoc = await getDoc(doc(db, \"users\", userId));\n      if (!userDoc.exists()) {\n        return false; // No data to migrate\n      }\n\n      // Check for legacy collections\n      const sessionsSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"sessions\"),\n      );\n      const tasksSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"tasks\"),\n      );\n      const eventsSnapshot = await getDocs(\n        collection(db, \"users\", userId, \"events\"),\n      );\n\n      const hasLegacyData =\n        !sessionsSnapshot.empty ||\n        !tasksSnapshot.empty ||\n        !eventsSnapshot.empty;\n\n      logger.debug(\"Checked migration status\", {\n        userId,\n        hasLegacyData,\n        sessionsCount: sessionsSnapshot.size,\n        tasksCount: tasksSnapshot.size,\n        eventsCount: eventsSnapshot.size,\n      });\n\n      return hasLegacyData;\n    } catch (error) {\n      logger.error(\"Failed to check migration status\", {\n        error: error as Error,\n        userId,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Create a relationship invitation for migrated users\n   * This allows them to invite a keyholder after migration\n   */\n  async createPostMigrationInvitation(\n    userId: string,\n    keyholderEmail: string,\n    message?: string,\n  ): Promise<string> {\n    try {\n      // This would create a special invitation type for post-migration\n      // The keyholder would join the existing self-relationship\n      // For now, use the standard relationship request system\n\n      // First, get user's email from their profile\n      const userDoc = await getDoc(doc(await this.ensureDb(), \"users\", userId));\n      if (!userDoc.exists()) {\n        throw new Error(\"User not found\");\n      }\n\n      // This is a placeholder for the actual invitation system\n      // In a real implementation, you'd send an email invitation\n      // with a special link to join the existing relationship\n\n      logger.info(\"Created post-migration invitation\", {\n        userId,\n        keyholderEmail,\n        message,\n      });\n\n      return generateUUID(); // Return invitation ID\n    } catch (error) {\n      logger.error(\"Failed to create post-migration invitation\", {\n        error: error as Error,\n        userId,\n        keyholderEmail,\n      });\n      throw error;\n    }\n  }\n\n  // ==================== UTILITY METHODS ====================\n\n  /**\n   * Map legacy task status to new status\n   */\n  private mapTaskStatus(oldStatus: string | unknown): TaskStatus {\n    const statusMap: Record<string, TaskStatus> = {\n      pending: \"pending\",\n      in_progress: \"pending\",\n      submitted: \"submitted\",\n      approved: \"approved\",\n      rejected: \"rejected\",\n      completed: \"completed\",\n      overdue: \"pending\", // Reset overdue to pending\n    };\n\n    if (typeof oldStatus === \"string\" && statusMap[oldStatus]) {\n      return statusMap[oldStatus];\n    }\n\n    return \"pending\"; // Default fallback\n  }\n\n  /**\n   * Map legacy event type to new event type\n   */\n  private mapEventType(oldType: string | unknown): EventType {\n    const typeMap: Record<string, EventType> = {\n      orgasm: \"orgasm\",\n      sexual_activity: \"sexual_activity\",\n      milestone: \"milestone\",\n      note: \"note\",\n      session_start: \"note\", // Convert to note\n      session_end: \"note\", // Convert to note\n      session_pause: \"note\", // Convert to note\n      session_resume: \"note\", // Convert to note\n    };\n\n    if (typeof oldType === \"string\" && typeMap[oldType]) {\n      return typeMap[oldType];\n    }\n\n    return \"note\"; // Default fallback\n  }\n\n  /**\n   * Clean up legacy data after successful migration\n   * WARNING: This permanently deletes old data\n   */\n  async cleanupLegacyData(userId: string): Promise<void> {\n    try {\n      const db = await this.ensureDb();\n      const batch = writeBatch(db);\n\n      // Delete legacy collections\n      const collections = [\"sessions\", \"tasks\", \"events\", \"eventLog\"];\n\n      for (const collectionName of collections) {\n        const snapshot = await getDocs(\n          collection(db, \"users\", userId, collectionName),\n        );\n        snapshot.docs.forEach((doc) => {\n          batch.delete(doc.ref);\n        });\n      }\n\n      await batch.commit();\n\n      logger.info(\"Cleaned up legacy data\", {\n        userId,\n        collectionsDeleted: collections.length,\n      });\n    } catch (error) {\n      logger.error(\"Failed to cleanup legacy data\", {\n        error: error as Error,\n        userId,\n      });\n      throw error;\n    }\n  }\n}\n\nexport const dataMigrationService = new DataMigrationService();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/storage/ChastityDB.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/storage/dexie.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/AchievementDataSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'where' is defined but never used.","line":9,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDocs' is defined but never used.","line":9,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDoc' is defined but never used.","line":9,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'syncConflictResolver' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is assigned a value but never used. Allowed unused args must match /^_/u.","line":28,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":74,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":86,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":94,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Achievement Data Synchronization Service\n * Handles sync operations for achievement progress data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type { DBBase, SyncOptions, SyncResult } from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"AchievementDataSync\");\n\n// Note: This is a placeholder service for achievement sync\n// The actual achievement database service would need to be implemented\n// when the achievement system is fully developed\n\nexport class AchievementDataSync extends FirebaseSyncCore {\n  private readonly collectionName = \"achievements\";\n\n  constructor() {\n    super();\n    logger.info(\"AchievementDataSync initialized\");\n  }\n\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Achievement sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", this.collectionName, userId);\n\n      // TODO: Implement achievement sync when achievement system is ready\n      logger.info(\"Achievement sync placeholder - no operations performed\");\n\n      this.logSyncOperation(\"Completed sync\", this.collectionName, userId, 0);\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Achievement sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    // TODO: Implement when achievement database service exists\n    logger.debug(\"Achievement getPendingDocs placeholder\", { userId });\n    return [];\n  }\n\n  async markDocsAsSynced(ids: string[]): Promise<void> {\n    // TODO: Implement when achievement database service exists\n    logger.debug(\"Achievement markDocsAsSynced placeholder\", {\n      count: ids.length,\n    });\n  }\n\n  async applyRemoteChanges(docs: DBBase[], result?: SyncResult): Promise<void> {\n    // TODO: Implement when achievement database service exists\n    logger.debug(\"Achievement applyRemoteChanges placeholder\", {\n      count: docs.length,\n    });\n  }\n\n  /**\n   * Future implementation methods for achievement sync\n   */\n  private async uploadLocalChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    // TODO: Implement achievement upload logic\n    logger.debug(\"Achievement upload placeholder\", { userId });\n  }\n\n  private async downloadRemoteChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    // TODO: Implement achievement download logic\n    logger.debug(\"Achievement download placeholder\", { userId });\n  }\n\n  private async getRemoteDoc(\n    userId: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    // TODO: Implement when needed\n    logger.debug(\"Achievement getRemoteDoc placeholder\", { userId, docId });\n    return null;\n  }\n\n  private async updateLocalDoc(data: DBBase): Promise<void> {\n    // TODO: Implement when achievement database service exists\n    logger.debug(\"Achievement updateLocalDoc placeholder\", { docId: data.id });\n  }\n\n  private async createLocalDoc(data: DBBase): Promise<void> {\n    // TODO: Implement when achievement database service exists\n    logger.debug(\"Achievement createLocalDoc placeholder\", { docId: data.id });\n  }\n\n  private async updateRemoteDoc(userId: string, data: DBBase): Promise<void> {\n    // TODO: Implement when needed\n    logger.debug(\"Achievement updateRemoteDoc placeholder\", {\n      userId,\n      docId: data.id,\n    });\n  }\n}\n\nexport const achievementDataSync = new AchievementDataSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/ConflictResolver.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2502,2505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2502,2505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2524,2527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2524,2527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2654,2657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2654,2657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2704,2707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2704,2707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3053,3056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3053,3056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3335,3338],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3335,3338],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3558,3561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3558,3561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4071,4074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4071,4074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4104,4107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4104,4107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4183,4186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4183,4186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Conflict Resolver\n * Implements strategies for resolving data conflicts between local and remote versions\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport type {\n  DBSession,\n  DBTask,\n  DBSettings,\n  ConflictInfo,\n  SettingsConflict,\n} from \"@/types/database\";\n\nconst logger = serviceLogger(\"ConflictResolver\");\n\nclass ConflictResolver {\n  constructor() {\n    logger.info(\"ConflictResolver initialized\");\n  }\n\n  /**\n   * Resolve conflict for a session document\n   * Strategy: Latest timestamp wins\n   */\n  resolveSessionConflict(local: DBSession, remote: DBSession): DBSession {\n    logger.debug(`Resolving session conflict for ${local.id}`);\n    return local.lastModified > remote.lastModified ? local : remote;\n  }\n\n  /**\n   * Resolve conflict for a task document\n   * Strategy: Merge status updates intelligently\n   */\n  resolveTaskConflict(local: DBTask, remote: DBTask): DBTask {\n    logger.debug(`Resolving task conflict for ${local.id}`);\n\n    const statusOrder: DBTask[\"status\"][] = [\n      \"pending\",\n      \"submitted\",\n      \"rejected\",\n      \"approved\",\n      \"completed\",\n      \"cancelled\",\n    ];\n\n    const localStatusIndex = statusOrder.indexOf(local.status);\n    const remoteStatusIndex = statusOrder.indexOf(remote.status);\n\n    const resolvedStatus =\n      localStatusIndex > remoteStatusIndex ? local.status : remote.status;\n\n    return {\n      ...remote, // remote wins for most fields\n      ...local, // but local wins for some fields if newer\n      status: resolvedStatus,\n      lastModified: new Date(), // new timestamp\n      syncStatus: \"synced\", // mark as synced\n    };\n  }\n\n  /**\n   * Resolve conflict for a settings document\n   * Strategy: Merge non-conflicting fields and queue user choice for conflicts\n   */\n  resolveSettingsConflict(local: DBSettings, remote: DBSettings): DBSettings {\n    logger.debug(`Resolving settings conflict for ${local.userId}`);\n\n    // Start with the remote settings as base\n    const merged: DBSettings = { ...remote };\n    const conflicts: SettingsConflict[] = [];\n\n    // System fields that should use latest timestamp\n    const systemFields = [\"lastModified\", \"syncStatus\", \"userId\"];\n\n    // Check each field for conflicts\n    Object.keys(local).forEach((key) => {\n      if (local[key as keyof DBSettings] !== remote[key as keyof DBSettings]) {\n        if (systemFields.includes(key)) {\n          // System fields: latest timestamp wins\n          if (local.lastModified > remote.lastModified) {\n            (merged as any)[key] = (local as any)[key];\n          }\n        } else {\n          // For complex objects, do deep comparison\n          const localVal = (local as any)[key];\n          const remoteVal = (remote as any)[key];\n\n          if (typeof localVal === \"object\" && typeof remoteVal === \"object\") {\n            // Merge objects recursively where possible\n            if (\n              key === \"notifications\" ||\n              key === \"privacy\" ||\n              key === \"chastity\" ||\n              key === \"display\"\n            ) {\n              (merged as any)[key] = this.mergeSettingsObject(\n                localVal,\n                remoteVal,\n                local.lastModified,\n                remote.lastModified,\n              );\n            } else {\n              // For other objects, use timestamp rule\n              (merged as any)[key] =\n                local.lastModified > remote.lastModified ? localVal : remoteVal;\n            }\n          } else {\n            // Simple values: use timestamp rule for automatic resolution\n            (merged as any)[key] =\n              local.lastModified > remote.lastModified ? localVal : remoteVal;\n          }\n        }\n      }\n    });\n\n    // Update metadata\n    merged.lastModified = new Date();\n    merged.syncStatus = \"synced\";\n\n    logger.info(`Settings conflict resolved for ${local.userId}`, {\n      conflictsFound: conflicts.length,\n      resolvedAutomatically: true,\n    });\n\n    return merged;\n  }\n\n  /**\n   * Merge settings objects intelligently\n   */\n  private mergeSettingsObject(\n    local: Record<string, any>,\n    remote: Record<string, any>,\n    localTimestamp: Date,\n    remoteTimestamp: Date,\n  ): Record<string, any> {\n    const merged = { ...remote };\n\n    Object.keys(local).forEach((key) => {\n      if (local[key] !== remote[key]) {\n        // Use latest timestamp for individual settings\n        merged[key] =\n          localTimestamp > remoteTimestamp ? local[key] : remote[key];\n      }\n    });\n\n    return merged;\n  }\n\n  /**\n   * Check if two documents have a conflict\n   */\n  hasConflict<T extends { lastModified: Date; syncStatus: string }>(\n    local: T,\n    remote: T,\n  ): boolean {\n    // If both have been modified since last sync, there's a potential conflict\n    return (\n      local.syncStatus === \"pending\" &&\n      Math.abs(local.lastModified.getTime() - remote.lastModified.getTime()) >\n        1000\n    ); // 1 second tolerance\n  }\n\n  /**\n   * Create conflict info for manual resolution\n   */\n  createConflictInfo(\n    type: ConflictInfo[\"type\"],\n    collection: string,\n    documentId: string,\n    localData: Record<string, unknown>,\n    remoteData: Record<string, unknown>,\n  ): ConflictInfo {\n    return {\n      type,\n      collection,\n      documentId,\n      localData,\n      remoteData,\n      detectedAt: new Date(),\n      resolution: \"pending\",\n    };\n  }\n}\n\nexport const conflictResolver = new ConflictResolver();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/EventDataSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_lastModified' is assigned a value but never used.","line":252,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":252,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_syncStatus' is assigned a value but never used.","line":253,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":253,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Data Synchronization Service\n * Handles sync operations for event logging data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db, eventDBService } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type {\n  DBBase,\n  DBEvent,\n  SyncOptions,\n  SyncResult,\n} from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"EventDataSync\");\n\nexport class EventDataSync extends FirebaseSyncCore {\n  private readonly collectionName = \"events\";\n\n  constructor() {\n    super();\n    logger.info(\"EventDataSync initialized\");\n  }\n\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Event sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", this.collectionName, userId);\n\n      await this.uploadLocalChanges(userId, result);\n      await this.downloadRemoteChanges(userId, result);\n\n      if (result.conflicts.length > 0) {\n        const resolvedDocs = await syncConflictResolver.handleConflicts(\n          result.conflicts,\n          options.conflictResolution || \"auto\",\n        );\n\n        for (const doc of resolvedDocs) {\n          await this.updateLocalDoc(doc);\n          await this.updateRemoteDoc(userId, doc);\n        }\n      }\n\n      this.logSyncOperation(\n        \"Completed sync\",\n        this.collectionName,\n        userId,\n        result.operations.uploaded + result.operations.downloaded,\n      );\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Event sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    return eventDBService.getPendingSync(userId);\n  }\n\n  async markDocsAsSynced(ids: string[]): Promise<void> {\n    await eventDBService.bulkMarkAsSynced(ids);\n  }\n\n  async applyRemoteChanges(docs: DBBase[], result?: SyncResult): Promise<void> {\n    for (const docData of docs) {\n      const localDoc = await eventDBService.findById(docData.id);\n\n      if (localDoc) {\n        if (syncConflictResolver.hasConflict(localDoc, docData)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"download_conflict\",\n            this.collectionName,\n            docData.id,\n            localDoc as Record<string, unknown>,\n            docData as Record<string, unknown>,\n          );\n\n          if (result) {\n            result.conflicts.push(conflictInfo);\n            this.updateSyncResult(result, \"conflicts\");\n          } else {\n            const resolved =\n              await syncConflictResolver.autoResolveConflict(conflictInfo);\n            await this.updateLocalDoc(resolved);\n          }\n        } else {\n          await this.updateLocalDoc(docData);\n          if (result) this.updateSyncResult(result, \"downloaded\");\n        }\n      } else {\n        await this.createLocalDoc(docData);\n        if (result) this.updateSyncResult(result, \"downloaded\");\n      }\n    }\n  }\n\n  private async uploadLocalChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const pendingDocs = await this.getPendingDocs(userId);\n\n    if (pendingDocs.length === 0) return;\n\n    this.logSyncOperation(\n      \"Uploading changes\",\n      this.collectionName,\n      userId,\n      pendingDocs.length,\n    );\n\n    const { firestore, batch } = await this.createBatch();\n    const syncedIds: string[] = [];\n\n    for (const docData of pendingDocs) {\n      try {\n        const remoteDoc = await this.getRemoteDoc(userId, docData.id);\n\n        if (remoteDoc && syncConflictResolver.hasConflict(docData, remoteDoc)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"upload_conflict\",\n            this.collectionName,\n            docData.id,\n            docData as Record<string, unknown>,\n            remoteDoc as Record<string, unknown>,\n          );\n          result.conflicts.push(conflictInfo);\n          this.updateSyncResult(result, \"conflicts\");\n          continue;\n        }\n\n        const docRef = this.getDocRef(\n          firestore,\n          userId,\n          this.collectionName,\n          docData.id,\n        );\n        batch.set(\n          docRef,\n          { ...docData, lastModified: new Date() },\n          { merge: true },\n        );\n        syncedIds.push(docData.id);\n        this.updateSyncResult(result, \"uploaded\");\n      } catch (error) {\n        logger.error(`Failed to prepare upload for ${docData.id}`, {\n          error: error as Error,\n        });\n        throw error;\n      }\n    }\n\n    if (syncedIds.length > 0) {\n      await batch.commit();\n      await this.markDocsAsSynced(syncedIds);\n    }\n  }\n\n  private async downloadRemoteChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const { firestore } = await this.createBatch();\n    const syncMeta = await db.syncMeta.get(this.collectionName);\n    const lastSync = syncMeta ? syncMeta.lastSync : new Date(0);\n\n    this.logSyncOperation(\"Downloading changes\", this.collectionName, userId);\n\n    const collectionRef = this.getCollectionRef(\n      firestore,\n      userId,\n      this.collectionName,\n    );\n    const q = query(\n      collectionRef,\n      where(\"lastModified\", \">\", this.toFirestoreTimestamp(lastSync)),\n    );\n\n    const querySnapshot = await getDocs(q);\n    const remoteDocs = querySnapshot.docs.map(\n      (doc) => ({ id: doc.id, ...doc.data() }) as DBBase,\n    );\n\n    if (remoteDocs.length > 0) {\n      this.logSyncOperation(\n        \"Downloaded changes\",\n        this.collectionName,\n        userId,\n        remoteDocs.length,\n      );\n      await this.applyRemoteChanges(remoteDocs, result);\n      await db.syncMeta.update(this.collectionName, { lastSync: new Date() });\n    }\n  }\n\n  private async getRemoteDoc(\n    userId: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    try {\n      const { firestore } = await this.createBatch();\n      const docRef = this.getDocRef(\n        firestore,\n        userId,\n        this.collectionName,\n        docId,\n      );\n      const docSnap = await getDoc(docRef);\n\n      if (!docSnap.exists()) return null;\n\n      const docData = docSnap.data();\n      return { id: docId, ...docData } as DBBase;\n    } catch (error) {\n      logger.error(\"Failed to get remote event document\", {\n        error: error as Error,\n        docId,\n      });\n      return null;\n    }\n  }\n\n  private async updateLocalDoc(data: DBBase): Promise<void> {\n    await eventDBService.update(data.id, data);\n  }\n\n  private async createLocalDoc(data: DBBase): Promise<void> {\n    const {\n      lastModified: _lastModified,\n      syncStatus: _syncStatus,\n      ...rest\n    } = data;\n    await eventDBService.create(\n      rest as Omit<DBEvent, \"lastModified\" | \"syncStatus\">,\n    );\n  }\n\n  private async updateRemoteDoc(userId: string, data: DBBase): Promise<void> {\n    const { firestore, batch } = await this.createBatch();\n    const docRef = this.getDocRef(\n      firestore,\n      userId,\n      this.collectionName,\n      data.id,\n    );\n    batch.set(docRef, data, { merge: true });\n    await batch.commit();\n  }\n}\n\nexport const eventDataSync = new EventDataSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseListeners.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/FirebaseSyncCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/OfflineQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/RelationshipDataSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'query' is defined but never used.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'where' is defined but never used.","line":9,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDocs' is defined but never used.","line":9,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDoc' is defined but never used.","line":9,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'syncConflictResolver' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is assigned a value but never used. Allowed unused args must match /^_/u.","line":28,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":74,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":86,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used. Allowed unused args must match /^_/u.","line":94,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Relationship Data Synchronization Service\n * Handles sync operations for relationship and account linking data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type { DBBase, SyncOptions, SyncResult } from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"RelationshipDataSync\");\n\n// Note: This is a placeholder service for relationship sync\n// The actual relationship database service would need to be implemented\n// when the relationship/account linking system is fully developed\n\nexport class RelationshipDataSync extends FirebaseSyncCore {\n  private readonly collectionName = \"relationships\";\n\n  constructor() {\n    super();\n    logger.info(\"RelationshipDataSync initialized\");\n  }\n\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Relationship sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", this.collectionName, userId);\n\n      // TODO: Implement relationship sync when relationship system is ready\n      logger.info(\"Relationship sync placeholder - no operations performed\");\n\n      this.logSyncOperation(\"Completed sync\", this.collectionName, userId, 0);\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Relationship sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    // TODO: Implement when relationship database service exists\n    logger.debug(\"Relationship getPendingDocs placeholder\", { userId });\n    return [];\n  }\n\n  async markDocsAsSynced(ids: string[]): Promise<void> {\n    // TODO: Implement when relationship database service exists\n    logger.debug(\"Relationship markDocsAsSynced placeholder\", {\n      count: ids.length,\n    });\n  }\n\n  async applyRemoteChanges(docs: DBBase[], result?: SyncResult): Promise<void> {\n    // TODO: Implement when relationship database service exists\n    logger.debug(\"Relationship applyRemoteChanges placeholder\", {\n      count: docs.length,\n    });\n  }\n\n  /**\n   * Future implementation methods for relationship sync\n   */\n  private async uploadLocalChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    // TODO: Implement relationship upload logic\n    logger.debug(\"Relationship upload placeholder\", { userId });\n  }\n\n  private async downloadRemoteChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    // TODO: Implement relationship download logic\n    logger.debug(\"Relationship download placeholder\", { userId });\n  }\n\n  private async getRemoteDoc(\n    userId: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    // TODO: Implement when needed\n    logger.debug(\"Relationship getRemoteDoc placeholder\", { userId, docId });\n    return null;\n  }\n\n  private async updateLocalDoc(data: DBBase): Promise<void> {\n    // TODO: Implement when relationship database service exists\n    logger.debug(\"Relationship updateLocalDoc placeholder\", { docId: data.id });\n  }\n\n  private async createLocalDoc(data: DBBase): Promise<void> {\n    // TODO: Implement when relationship database service exists\n    logger.debug(\"Relationship createLocalDoc placeholder\", { docId: data.id });\n  }\n\n  private async updateRemoteDoc(userId: string, data: DBBase): Promise<void> {\n    // TODO: Implement when needed\n    logger.debug(\"Relationship updateRemoteDoc placeholder\", {\n      userId,\n      docId: data.id,\n    });\n  }\n}\n\nexport const relationshipDataSync = new RelationshipDataSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/SessionDataSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_lastModified' is assigned a value but never used.","line":255,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":255,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_syncStatus' is assigned a value but never used.","line":256,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":256,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Data Synchronization Service\n * Handles sync operations for session and tracking data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db, sessionDBService } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type {\n  DBBase,\n  DBSession,\n  SyncOptions,\n  SyncResult,\n} from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"SessionDataSync\");\n\nexport class SessionDataSync extends FirebaseSyncCore {\n  private readonly collectionName = \"sessions\";\n\n  constructor() {\n    super();\n    logger.info(\"SessionDataSync initialized\");\n  }\n\n  /**\n   * Sync session data collection\n   */\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Session sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", this.collectionName, userId);\n\n      await this.uploadLocalChanges(userId, result);\n      await this.downloadRemoteChanges(userId, result);\n\n      if (result.conflicts.length > 0) {\n        const resolvedDocs = await syncConflictResolver.handleConflicts(\n          result.conflicts,\n          options.conflictResolution || \"auto\",\n        );\n\n        for (const doc of resolvedDocs) {\n          await this.updateLocalDoc(doc);\n          await this.updateRemoteDoc(userId, doc);\n        }\n      }\n\n      this.logSyncOperation(\n        \"Completed sync\",\n        this.collectionName,\n        userId,\n        result.operations.uploaded + result.operations.downloaded,\n      );\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Session sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    return sessionDBService.getPendingSync(userId);\n  }\n\n  async markDocsAsSynced(ids: string[]): Promise<void> {\n    await sessionDBService.bulkMarkAsSynced(ids);\n  }\n\n  async applyRemoteChanges(docs: DBBase[], result?: SyncResult): Promise<void> {\n    for (const docData of docs) {\n      const localDoc = await sessionDBService.findById(docData.id);\n\n      if (localDoc) {\n        if (syncConflictResolver.hasConflict(localDoc, docData)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"download_conflict\",\n            this.collectionName,\n            docData.id,\n            localDoc as Record<string, unknown>,\n            docData as Record<string, unknown>,\n          );\n\n          if (result) {\n            result.conflicts.push(conflictInfo);\n            this.updateSyncResult(result, \"conflicts\");\n          } else {\n            const resolved =\n              await syncConflictResolver.autoResolveConflict(conflictInfo);\n            await this.updateLocalDoc(resolved);\n          }\n        } else {\n          await this.updateLocalDoc(docData);\n          if (result) this.updateSyncResult(result, \"downloaded\");\n        }\n      } else {\n        await this.createLocalDoc(docData);\n        if (result) this.updateSyncResult(result, \"downloaded\");\n      }\n    }\n  }\n\n  private async uploadLocalChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const pendingDocs = await this.getPendingDocs(userId);\n\n    if (pendingDocs.length === 0) return;\n\n    this.logSyncOperation(\n      \"Uploading changes\",\n      this.collectionName,\n      userId,\n      pendingDocs.length,\n    );\n\n    const { firestore, batch } = await this.createBatch();\n    const syncedIds: string[] = [];\n\n    for (const docData of pendingDocs) {\n      try {\n        const remoteDoc = await this.getRemoteDoc(userId, docData.id);\n\n        if (remoteDoc && syncConflictResolver.hasConflict(docData, remoteDoc)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"upload_conflict\",\n            this.collectionName,\n            docData.id,\n            docData as Record<string, unknown>,\n            remoteDoc as Record<string, unknown>,\n          );\n          result.conflicts.push(conflictInfo);\n          this.updateSyncResult(result, \"conflicts\");\n          continue;\n        }\n\n        const docRef = this.getDocRef(\n          firestore,\n          userId,\n          this.collectionName,\n          docData.id,\n        );\n        batch.set(\n          docRef,\n          { ...docData, lastModified: new Date() },\n          { merge: true },\n        );\n        syncedIds.push(docData.id);\n        this.updateSyncResult(result, \"uploaded\");\n      } catch (error) {\n        logger.error(`Failed to prepare upload for ${docData.id}`, {\n          error: error as Error,\n        });\n        throw error;\n      }\n    }\n\n    if (syncedIds.length > 0) {\n      await batch.commit();\n      await this.markDocsAsSynced(syncedIds);\n    }\n  }\n\n  private async downloadRemoteChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const { firestore } = await this.createBatch();\n    const syncMeta = await db.syncMeta.get(this.collectionName);\n    const lastSync = syncMeta ? syncMeta.lastSync : new Date(0);\n\n    this.logSyncOperation(\"Downloading changes\", this.collectionName, userId);\n\n    const collectionRef = this.getCollectionRef(\n      firestore,\n      userId,\n      this.collectionName,\n    );\n    const q = query(\n      collectionRef,\n      where(\"lastModified\", \">\", this.toFirestoreTimestamp(lastSync)),\n    );\n\n    const querySnapshot = await getDocs(q);\n    const remoteDocs = querySnapshot.docs.map(\n      (doc) => ({ id: doc.id, ...doc.data() }) as DBBase,\n    );\n\n    if (remoteDocs.length > 0) {\n      this.logSyncOperation(\n        \"Downloaded changes\",\n        this.collectionName,\n        userId,\n        remoteDocs.length,\n      );\n      await this.applyRemoteChanges(remoteDocs, result);\n      await db.syncMeta.update(this.collectionName, { lastSync: new Date() });\n    }\n  }\n\n  private async getRemoteDoc(\n    userId: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    try {\n      const { firestore } = await this.createBatch();\n      const docRef = this.getDocRef(\n        firestore,\n        userId,\n        this.collectionName,\n        docId,\n      );\n      const docSnap = await getDoc(docRef);\n\n      if (!docSnap.exists()) return null;\n\n      const docData = docSnap.data();\n      return { id: docId, ...docData } as DBBase;\n    } catch (error) {\n      logger.error(\"Failed to get remote session document\", {\n        error: error as Error,\n        docId,\n      });\n      return null;\n    }\n  }\n\n  private async updateLocalDoc(data: DBBase): Promise<void> {\n    await sessionDBService.update(data.id, data);\n  }\n\n  private async createLocalDoc(data: DBBase): Promise<void> {\n    const {\n      lastModified: _lastModified,\n      syncStatus: _syncStatus,\n      ...rest\n    } = data;\n    await sessionDBService.create(\n      rest as Omit<DBSession, \"lastModified\" | \"syncStatus\">,\n    );\n  }\n\n  private async updateRemoteDoc(userId: string, data: DBBase): Promise<void> {\n    const { firestore, batch } = await this.createBatch();\n    const docRef = this.getDocRef(\n      firestore,\n      userId,\n      this.collectionName,\n      data.id,\n    );\n    batch.set(docRef, data, { merge: true });\n    await batch.commit();\n  }\n}\n\nexport const sessionDataSync = new SessionDataSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/SyncConflictResolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/TaskDataSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_lastModified' is assigned a value but never used.","line":372,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_syncStatus' is assigned a value but never used.","line":373,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":373,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task Data Synchronization Service\n * Handles sync operations for task and goal data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db, taskDBService, goalDBService } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type {\n  DBBase,\n  DBTask,\n  DBGoal,\n  SyncOptions,\n  SyncResult,\n} from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"TaskDataSync\");\n\nexport class TaskDataSync extends FirebaseSyncCore {\n  private readonly taskCollectionName = \"tasks\";\n  private readonly goalCollectionName = \"goals\";\n\n  constructor() {\n    super();\n    logger.info(\"TaskDataSync initialized\");\n  }\n\n  /**\n   * Sync both tasks and goals collections\n   */\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Task/Goal sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", \"tasks+goals\", userId);\n\n      // Sync tasks first\n      await this.syncTasks(userId, result, options);\n\n      // Then sync goals\n      await this.syncGoals(userId, result, options);\n\n      this.logSyncOperation(\n        \"Completed sync\",\n        \"tasks+goals\",\n        userId,\n        result.operations.uploaded + result.operations.downloaded,\n      );\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Task/Goal sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  /**\n   * Sync only tasks collection\n   */\n  async syncTasks(\n    userId: string,\n    result?: SyncResult,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    const taskResult = result || this.initializeSyncResult();\n\n    await this.syncSpecificCollection(\n      userId,\n      this.taskCollectionName,\n      taskDBService,\n      taskResult,\n      options,\n    );\n\n    return taskResult;\n  }\n\n  /**\n   * Sync only goals collection\n   */\n  async syncGoals(\n    userId: string,\n    result?: SyncResult,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    const goalResult = result || this.initializeSyncResult();\n\n    await this.syncSpecificCollection(\n      userId,\n      this.goalCollectionName,\n      goalDBService,\n      goalResult,\n      options,\n    );\n\n    return goalResult;\n  }\n\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    const taskDocs = await taskDBService.getPendingSync(userId);\n    const goalDocs = await goalDBService.getPendingSync(userId);\n    return [...taskDocs, ...goalDocs];\n  }\n\n  async markDocsAsSynced(_ids: string[]): Promise<void> {\n    // This method is not used directly since we handle tasks and goals separately\n    // in the specific collection sync methods\n  }\n\n  async applyRemoteChanges(\n    _docs: DBBase[],\n    _result?: SyncResult,\n  ): Promise<void> {\n    // This method is not used directly since we handle tasks and goals separately\n    // in the specific collection sync methods\n  }\n\n  /**\n   * Sync a specific collection (tasks or goals)\n   */\n  private async syncSpecificCollection(\n    userId: string,\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    result: SyncResult,\n    options: SyncOptions,\n  ): Promise<void> {\n    this.logSyncOperation(\"Starting sync\", collectionName, userId);\n\n    await this.uploadLocalChangesForCollection(\n      userId,\n      collectionName,\n      dbService,\n      result,\n    );\n    await this.downloadRemoteChangesForCollection(\n      userId,\n      collectionName,\n      dbService,\n      result,\n    );\n\n    if (result.conflicts.length > 0) {\n      const conflictsForCollection = result.conflicts.filter(\n        (c) => c.collection === collectionName,\n      );\n      if (conflictsForCollection.length > 0) {\n        const resolvedDocs = await syncConflictResolver.handleConflicts(\n          conflictsForCollection,\n          options.conflictResolution || \"auto\",\n        );\n\n        for (const doc of resolvedDocs) {\n          await this.updateLocalDocForCollection(\n            collectionName,\n            dbService,\n            doc,\n          );\n          await this.updateRemoteDoc(userId, collectionName, doc);\n        }\n      }\n    }\n  }\n\n  private async uploadLocalChangesForCollection(\n    userId: string,\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    result: SyncResult,\n  ): Promise<void> {\n    const pendingDocs = await dbService.getPendingSync(userId);\n\n    if (pendingDocs.length === 0) return;\n\n    this.logSyncOperation(\n      \"Uploading changes\",\n      collectionName,\n      userId,\n      pendingDocs.length,\n    );\n\n    const { firestore, batch } = await this.createBatch();\n    const syncedIds: string[] = [];\n\n    for (const docData of pendingDocs) {\n      try {\n        const remoteDoc = await this.getRemoteDoc(\n          userId,\n          collectionName,\n          docData.id,\n        );\n\n        if (remoteDoc && syncConflictResolver.hasConflict(docData, remoteDoc)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"upload_conflict\",\n            collectionName,\n            docData.id,\n            docData as Record<string, unknown>,\n            remoteDoc as Record<string, unknown>,\n          );\n          result.conflicts.push(conflictInfo);\n          this.updateSyncResult(result, \"conflicts\");\n          continue;\n        }\n\n        const docRef = this.getDocRef(\n          firestore,\n          userId,\n          collectionName,\n          docData.id,\n        );\n        batch.set(\n          docRef,\n          { ...docData, lastModified: new Date() },\n          { merge: true },\n        );\n        syncedIds.push(docData.id);\n        this.updateSyncResult(result, \"uploaded\");\n      } catch (error) {\n        logger.error(`Failed to prepare upload for ${docData.id}`, {\n          error: error as Error,\n        });\n        throw error;\n      }\n    }\n\n    if (syncedIds.length > 0) {\n      await batch.commit();\n      await dbService.bulkMarkAsSynced(syncedIds);\n    }\n  }\n\n  private async downloadRemoteChangesForCollection(\n    userId: string,\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    result: SyncResult,\n  ): Promise<void> {\n    const { firestore } = await this.createBatch();\n    const syncMeta = await db.syncMeta.get(collectionName);\n    const lastSync = syncMeta ? syncMeta.lastSync : new Date(0);\n\n    this.logSyncOperation(\"Downloading changes\", collectionName, userId);\n\n    const collectionRef = this.getCollectionRef(\n      firestore,\n      userId,\n      collectionName,\n    );\n    const q = query(\n      collectionRef,\n      where(\"lastModified\", \">\", this.toFirestoreTimestamp(lastSync)),\n    );\n\n    const querySnapshot = await getDocs(q);\n    const remoteDocs = querySnapshot.docs.map(\n      (doc) => ({ id: doc.id, ...doc.data() }) as DBBase,\n    );\n\n    if (remoteDocs.length > 0) {\n      this.logSyncOperation(\n        \"Downloaded changes\",\n        collectionName,\n        userId,\n        remoteDocs.length,\n      );\n      await this.applyRemoteChangesForCollection(\n        collectionName,\n        dbService,\n        remoteDocs,\n        result,\n      );\n      await db.syncMeta.update(collectionName, { lastSync: new Date() });\n    }\n  }\n\n  private async applyRemoteChangesForCollection(\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    docs: DBBase[],\n    result: SyncResult,\n  ): Promise<void> {\n    for (const docData of docs) {\n      const localDoc = await dbService.findById(docData.id);\n\n      if (localDoc) {\n        if (syncConflictResolver.hasConflict(localDoc, docData)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"download_conflict\",\n            collectionName,\n            docData.id,\n            localDoc as Record<string, unknown>,\n            docData as Record<string, unknown>,\n          );\n\n          result.conflicts.push(conflictInfo);\n          this.updateSyncResult(result, \"conflicts\");\n        } else {\n          await this.updateLocalDocForCollection(\n            collectionName,\n            dbService,\n            docData,\n          );\n          this.updateSyncResult(result, \"downloaded\");\n        }\n      } else {\n        await this.createLocalDocForCollection(\n          collectionName,\n          dbService,\n          docData,\n        );\n        this.updateSyncResult(result, \"downloaded\");\n      }\n    }\n  }\n\n  private async getRemoteDoc(\n    userId: string,\n    collectionName: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    try {\n      const { firestore } = await this.createBatch();\n      const docRef = this.getDocRef(firestore, userId, collectionName, docId);\n      const docSnap = await getDoc(docRef);\n\n      if (!docSnap.exists()) return null;\n\n      const docData = docSnap.data();\n      return { id: docId, ...docData } as DBBase;\n    } catch (error) {\n      logger.error(`Failed to get remote ${collectionName} document`, {\n        error: error as Error,\n        docId,\n      });\n      return null;\n    }\n  }\n\n  private async updateLocalDocForCollection(\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    data: DBBase,\n  ): Promise<void> {\n    await dbService.update(data.id, data);\n  }\n\n  private async createLocalDocForCollection(\n    collectionName: string,\n    dbService: typeof taskDBService | typeof goalDBService,\n    data: DBBase,\n  ): Promise<void> {\n    const {\n      lastModified: _lastModified,\n      syncStatus: _syncStatus,\n      ...rest\n    } = data;\n    if (collectionName === \"tasks\") {\n      await (dbService as typeof taskDBService).create(\n        rest as Omit<DBTask, \"lastModified\" | \"syncStatus\">,\n      );\n    } else {\n      await (dbService as typeof goalDBService).create(\n        rest as Omit<DBGoal, \"lastModified\" | \"syncStatus\">,\n      );\n    }\n  }\n\n  private async updateRemoteDoc(\n    userId: string,\n    collectionName: string,\n    data: DBBase,\n  ): Promise<void> {\n    const { firestore, batch } = await this.createBatch();\n    const docRef = this.getDocRef(firestore, userId, collectionName, data.id);\n    batch.set(docRef, data, { merge: true });\n    await batch.commit();\n  }\n}\n\nexport const taskDataSync = new TaskDataSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/UserSettingsSync.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_lastModified' is assigned a value but never used.","line":289,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_syncStatus' is assigned a value but never used.","line":290,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":290,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Settings Synchronization Service\n * Handles sync operations for user settings data\n */\nimport { serviceLogger } from \"@/utils/logging\";\nimport { db, settingsDBService } from \"../database\";\nimport { FirebaseSyncCore } from \"./FirebaseSyncCore\";\nimport type {\n  DBBase,\n  DBSettings,\n  SyncOptions,\n  SyncResult,\n} from \"@/types/database\";\nimport { query, where, getDocs, getDoc } from \"firebase/firestore\";\nimport { syncConflictResolver } from \"./SyncConflictResolver\";\n\nconst logger = serviceLogger(\"UserSettingsSync\");\n\nexport class UserSettingsSync extends FirebaseSyncCore {\n  private readonly collectionName = \"settings\";\n\n  constructor() {\n    super();\n    logger.info(\"UserSettingsSync initialized\");\n  }\n\n  /**\n   * Sync user settings collection\n   */\n  async syncCollection(\n    userId: string,\n    options: SyncOptions = {},\n  ): Promise<SyncResult> {\n    if (this.isSyncing) {\n      throw new Error(\"Settings sync already in progress\");\n    }\n\n    await this.validateUser(userId);\n    this.validateConnectivity();\n\n    this.isSyncing = true;\n    const result = this.initializeSyncResult();\n\n    try {\n      this.logSyncOperation(\"Starting sync\", this.collectionName, userId);\n\n      // Upload pending local changes\n      await this.uploadLocalChanges(userId, result);\n\n      // Download remote changes\n      await this.downloadRemoteChanges(userId, result);\n\n      // Handle conflicts if any\n      if (result.conflicts.length > 0) {\n        const resolvedDocs = await syncConflictResolver.handleConflicts(\n          result.conflicts,\n          options.conflictResolution || \"auto\",\n        );\n\n        // Apply resolved documents\n        for (const doc of resolvedDocs) {\n          await this.updateLocalDoc(doc);\n          await this.updateRemoteDoc(userId, doc);\n        }\n      }\n\n      this.logSyncOperation(\n        \"Completed sync\",\n        this.collectionName,\n        userId,\n        result.operations.uploaded + result.operations.downloaded,\n      );\n    } catch (error) {\n      result.success = false;\n      result.error = error as Error;\n      logger.error(\"Settings sync failed\", {\n        error: error as Error,\n        userId,\n      });\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get pending settings documents for sync\n   */\n  async getPendingDocs(userId: string): Promise<DBBase[]> {\n    return settingsDBService.getPendingSync(userId);\n  }\n\n  /**\n   * Mark settings documents as synced\n   */\n  async markDocsAsSynced(ids: string[]): Promise<void> {\n    await settingsDBService.bulkMarkAsSynced(ids);\n  }\n\n  /**\n   * Apply remote settings changes to local storage\n   */\n  async applyRemoteChanges(docs: DBBase[], result?: SyncResult): Promise<void> {\n    for (const docData of docs) {\n      const localDoc = await settingsDBService.findById(docData.id);\n\n      if (localDoc) {\n        // Check for conflicts\n        if (syncConflictResolver.hasConflict(localDoc, docData)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"download_conflict\",\n            this.collectionName,\n            docData.id,\n            localDoc as Record<string, unknown>,\n            docData as Record<string, unknown>,\n          );\n\n          if (result) {\n            result.conflicts.push(conflictInfo);\n            this.updateSyncResult(result, \"conflicts\");\n          } else {\n            // Auto-resolve if no result tracking\n            const resolved =\n              await syncConflictResolver.autoResolveConflict(conflictInfo);\n            await this.updateLocalDoc(resolved);\n          }\n        } else {\n          // No conflict, apply remote changes\n          await this.updateLocalDoc(docData);\n          if (result) this.updateSyncResult(result, \"downloaded\");\n        }\n      } else {\n        // New document from server\n        await this.createLocalDoc(docData);\n        if (result) this.updateSyncResult(result, \"downloaded\");\n      }\n    }\n  }\n\n  /**\n   * Upload local settings changes to Firebase\n   */\n  private async uploadLocalChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const pendingDocs = await this.getPendingDocs(userId);\n\n    if (pendingDocs.length === 0) return;\n\n    this.logSyncOperation(\n      \"Uploading changes\",\n      this.collectionName,\n      userId,\n      pendingDocs.length,\n    );\n\n    const { firestore, batch } = await this.createBatch();\n    const syncedIds: string[] = [];\n\n    for (const docData of pendingDocs) {\n      try {\n        // Check for conflicts before uploading\n        const remoteDoc = await this.getRemoteDoc(userId, docData.id);\n\n        if (remoteDoc && syncConflictResolver.hasConflict(docData, remoteDoc)) {\n          const conflictInfo = syncConflictResolver.createConflictInfo(\n            \"upload_conflict\",\n            this.collectionName,\n            docData.id,\n            docData as Record<string, unknown>,\n            remoteDoc as Record<string, unknown>,\n          );\n          result.conflicts.push(conflictInfo);\n          this.updateSyncResult(result, \"conflicts\");\n          continue;\n        }\n\n        const docRef = this.getDocRef(\n          firestore,\n          userId,\n          this.collectionName,\n          docData.id,\n        );\n        batch.set(\n          docRef,\n          { ...docData, lastModified: new Date() },\n          { merge: true },\n        );\n        syncedIds.push(docData.id);\n        this.updateSyncResult(result, \"uploaded\");\n      } catch (error) {\n        logger.error(`Failed to prepare upload for ${docData.id}`, {\n          error: error as Error,\n        });\n        throw error;\n      }\n    }\n\n    if (syncedIds.length > 0) {\n      await batch.commit();\n      await this.markDocsAsSynced(syncedIds);\n    }\n  }\n\n  /**\n   * Download remote settings changes\n   */\n  private async downloadRemoteChanges(\n    userId: string,\n    result: SyncResult,\n  ): Promise<void> {\n    const { firestore } = await this.createBatch();\n    const syncMeta = await db.syncMeta.get(this.collectionName);\n    const lastSync = syncMeta ? syncMeta.lastSync : new Date(0);\n\n    this.logSyncOperation(\"Downloading changes\", this.collectionName, userId);\n\n    const collectionRef = this.getCollectionRef(\n      firestore,\n      userId,\n      this.collectionName,\n    );\n    const q = query(\n      collectionRef,\n      where(\"lastModified\", \">\", this.toFirestoreTimestamp(lastSync)),\n    );\n\n    const querySnapshot = await getDocs(q);\n    const remoteDocs = querySnapshot.docs.map(\n      (doc) => ({ id: doc.id, ...doc.data() }) as DBBase,\n    );\n\n    if (remoteDocs.length > 0) {\n      this.logSyncOperation(\n        \"Downloaded changes\",\n        this.collectionName,\n        userId,\n        remoteDocs.length,\n      );\n      await this.applyRemoteChanges(remoteDocs, result);\n      await db.syncMeta.update(this.collectionName, { lastSync: new Date() });\n    }\n  }\n\n  /**\n   * Get remote settings document\n   */\n  private async getRemoteDoc(\n    userId: string,\n    docId: string,\n  ): Promise<DBBase | null> {\n    try {\n      const { firestore } = await this.createBatch();\n      const docRef = this.getDocRef(\n        firestore,\n        userId,\n        this.collectionName,\n        docId,\n      );\n      const docSnap = await getDoc(docRef);\n\n      if (!docSnap.exists()) return null;\n\n      const docData = docSnap.data();\n      return { id: docId, ...docData } as DBBase;\n    } catch (error) {\n      logger.error(\"Failed to get remote settings document\", {\n        error: error as Error,\n        docId,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Update local settings document\n   */\n  private async updateLocalDoc(data: DBBase): Promise<void> {\n    await settingsDBService.update(data.id, data);\n  }\n\n  /**\n   * Create local settings document\n   */\n  private async createLocalDoc(data: DBBase): Promise<void> {\n    const {\n      lastModified: _lastModified,\n      syncStatus: _syncStatus,\n      ...rest\n    } = data;\n    await settingsDBService.create(\n      rest as Omit<DBSettings, \"lastModified\" | \"syncStatus\">,\n    );\n  }\n\n  /**\n   * Update remote settings document\n   */\n  private async updateRemoteDoc(userId: string, data: DBBase): Promise<void> {\n    const { firestore, batch } = await this.createBatch();\n    const docRef = this.getDocRef(\n      firestore,\n      userId,\n      this.collectionName,\n      data.id,\n    );\n    batch.set(docRef, data, { merge: true });\n    await batch.commit();\n  }\n}\n\nexport const userSettingsSync = new UserSettingsSync();\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/connectionStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/services/sync/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/formStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (250). Maximum allowed is 75.","line":84,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":375,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'removed' is assigned a value but never used.","line":123,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Form Store - Form State Management\n * Manages form state, validation, and dirty tracking for complex forms\n */\nimport React from \"react\";\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\n// Define common form field value types\nexport type FormFieldValue =\n  | string\n  | number\n  | boolean\n  | Date\n  | string[]\n  | null\n  | undefined;\n\nexport interface FormField {\n  value: FormFieldValue;\n  error?: string;\n  touched: boolean;\n  dirty: boolean;\n}\n\nexport interface FormState {\n  // Form registry - stores forms by ID\n  forms: Record<\n    string,\n    {\n      fields: Record<string, FormField>;\n      isSubmitting: boolean;\n      isValid: boolean;\n      isDirty: boolean;\n      submitCount: number;\n      lastSubmitted?: Date;\n    }\n  >;\n\n  // Actions\n  createForm: (\n    formId: string,\n    initialValues?: Record<string, FormFieldValue>,\n  ) => void;\n  destroyForm: (formId: string) => void;\n  setFieldValue: (\n    formId: string,\n    fieldName: string,\n    value: FormFieldValue,\n  ) => void;\n  setFieldError: (formId: string, fieldName: string, error?: string) => void;\n  touchField: (formId: string, fieldName: string) => void;\n  resetForm: (\n    formId: string,\n    newValues?: Record<string, FormFieldValue>,\n  ) => void;\n  setSubmitting: (formId: string, isSubmitting: boolean) => void;\n  incrementSubmitCount: (formId: string) => void;\n\n  // Validation\n  validateField: (\n    formId: string,\n    fieldName: string,\n    validator: (value: FormFieldValue) => string | undefined,\n  ) => void;\n  validateForm: (\n    formId: string,\n    validators: Record<string, (value: FormFieldValue) => string | undefined>,\n  ) => boolean;\n\n  // Utility getters\n  getForm: (formId: string) => FormState[\"forms\"][string] | undefined;\n  getFieldValue: (formId: string, fieldName: string) => FormFieldValue;\n  getFieldError: (formId: string, fieldName: string) => string | undefined;\n  isFieldTouched: (formId: string, fieldName: string) => boolean;\n  isFieldDirty: (formId: string, fieldName: string) => boolean;\n  isFormValid: (formId: string) => boolean;\n  isFormDirty: (formId: string) => boolean;\n  isFormSubmitting: (formId: string) => boolean;\n}\n\nexport const useFormStore = create<FormState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      forms: {},\n\n      // Actions\n      createForm: (formId: string, initialValues = {}) =>\n        set(\n          (state) => {\n            if (state.forms[formId]) return state; // Don't recreate existing forms\n\n            const fields: Record<string, FormField> = {};\n            Object.entries(initialValues).forEach(([key, value]) => {\n              fields[key] = {\n                value,\n                touched: false,\n                dirty: false,\n              };\n            });\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  fields,\n                  isSubmitting: false,\n                  isValid: true,\n                  isDirty: false,\n                  submitCount: 0,\n                },\n              },\n            };\n          },\n          false,\n          `createForm:${formId}`,\n        ),\n\n      destroyForm: (formId: string) =>\n        set(\n          (state) => {\n            const { [formId]: removed, ...rest } = state.forms;\n            return { forms: rest };\n          },\n          false,\n          `destroyForm:${formId}`,\n        ),\n\n      setFieldValue: (\n        formId: string,\n        fieldName: string,\n        value: FormFieldValue,\n      ) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            const field = form.fields[fieldName] || {\n              value: undefined,\n              touched: false,\n              dirty: false,\n            };\n            const isDirty = field.value !== value;\n\n            const updatedFields = {\n              ...form.fields,\n              [fieldName]: {\n                ...field,\n                value,\n                dirty: isDirty,\n              },\n            };\n\n            const formIsDirty = Object.values(updatedFields).some(\n              (f) => f.dirty,\n            );\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  fields: updatedFields,\n                  isDirty: formIsDirty,\n                },\n              },\n            };\n          },\n          false,\n          `setFieldValue:${formId}.${fieldName}`,\n        ),\n\n      setFieldError: (formId: string, fieldName: string, error?: string) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            const field = form.fields[fieldName] || {\n              value: \"\",\n              touched: false,\n              dirty: false,\n            };\n            const updatedFields = {\n              ...form.fields,\n              [fieldName]: {\n                ...field,\n                error,\n              },\n            };\n\n            const isValid = !Object.values(updatedFields).some((f) => f.error);\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  fields: updatedFields,\n                  isValid,\n                },\n              },\n            };\n          },\n          false,\n          `setFieldError:${formId}.${fieldName}`,\n        ),\n\n      touchField: (formId: string, fieldName: string) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            const field = form.fields[fieldName] || {\n              value: undefined,\n              touched: false,\n              dirty: false,\n            };\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  fields: {\n                    ...form.fields,\n                    [fieldName]: {\n                      ...field,\n                      touched: true,\n                    },\n                  },\n                },\n              },\n            };\n          },\n          false,\n          `touchField:${formId}.${fieldName}`,\n        ),\n\n      resetForm: (formId: string, newValues = {}) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            const fields: Record<string, FormField> = {};\n            Object.entries(newValues).forEach(([key, value]) => {\n              fields[key] = {\n                value,\n                touched: false,\n                dirty: false,\n              };\n            });\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  fields,\n                  isDirty: false,\n                  isValid: true,\n                },\n              },\n            };\n          },\n          false,\n          `resetForm:${formId}`,\n        ),\n\n      setSubmitting: (formId: string, isSubmitting: boolean) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  isSubmitting,\n                  ...(isSubmitting ? {} : { lastSubmitted: new Date() }),\n                },\n              },\n            };\n          },\n          false,\n          `setSubmitting:${formId}`,\n        ),\n\n      incrementSubmitCount: (formId: string) =>\n        set(\n          (state) => {\n            const form = state.forms[formId];\n            if (!form) return state;\n\n            return {\n              forms: {\n                ...state.forms,\n                [formId]: {\n                  ...form,\n                  submitCount: form.submitCount + 1,\n                },\n              },\n            };\n          },\n          false,\n          `incrementSubmitCount:${formId}`,\n        ),\n\n      // Validation\n      validateField: (\n        formId: string,\n        fieldName: string,\n        validator: (value: FormFieldValue) => string | undefined,\n      ) => {\n        const form = get().forms[formId];\n        if (!form) return;\n\n        const field = form.fields[fieldName];\n        if (!field) return;\n\n        const error = validator(field.value);\n        get().setFieldError(formId, fieldName, error);\n      },\n\n      validateForm: (\n        formId: string,\n        validators: Record<\n          string,\n          (value: FormFieldValue) => string | undefined\n        >,\n      ) => {\n        const form = get().forms[formId];\n        if (!form) return false;\n\n        let isValid = true;\n        Object.entries(validators).forEach(([fieldName, validator]) => {\n          const field = form.fields[fieldName];\n          if (!field) return;\n\n          const error = validator(field.value);\n          get().setFieldError(formId, fieldName, error);\n          if (error) isValid = false;\n        });\n\n        return isValid;\n      },\n\n      // Utility getters\n      getForm: (formId: string) => get().forms[formId],\n\n      getFieldValue: (formId: string, fieldName: string) =>\n        get().forms[formId]?.fields[fieldName]?.value,\n\n      getFieldError: (formId: string, fieldName: string) =>\n        get().forms[formId]?.fields[fieldName]?.error,\n\n      isFieldTouched: (formId: string, fieldName: string) =>\n        get().forms[formId]?.fields[fieldName]?.touched ?? false,\n\n      isFieldDirty: (formId: string, fieldName: string) =>\n        get().forms[formId]?.fields[fieldName]?.dirty ?? false,\n\n      isFormValid: (formId: string) => get().forms[formId]?.isValid ?? false,\n\n      isFormDirty: (formId: string) => get().forms[formId]?.isDirty ?? false,\n\n      isFormSubmitting: (formId: string) =>\n        get().forms[formId]?.isSubmitting ?? false,\n    }),\n    {\n      name: \"form-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useForm = (formId: string) =>\n  useFormStore((state) => state.forms[formId]);\n\nexport const useFormField = (formId: string, fieldName: string) =>\n  useFormStore((state) => state.forms[formId]?.fields[fieldName]);\n\nexport const useFormActions = () =>\n  useFormStore((state) => ({\n    createForm: state.createForm,\n    destroyForm: state.destroyForm,\n    setFieldValue: state.setFieldValue,\n    setFieldError: state.setFieldError,\n    touchField: state.touchField,\n    resetForm: state.resetForm,\n    setSubmitting: state.setSubmitting,\n    validateField: state.validateField,\n    validateForm: state.validateForm,\n  }));\n\n// Utility hook for easier form management\nexport const useFormManager = (formId: string, initialValues = {}) => {\n  const form = useForm(formId);\n  const actions = useFormActions();\n\n  // Auto-create form on mount\n  React.useEffect(() => {\n    if (!form) {\n      actions.createForm(formId, initialValues);\n    }\n  }, [formId, form, actions, initialValues]);\n\n  // Auto-destroy form on unmount\n  React.useEffect(() => {\n    return () => {\n      actions.destroyForm(formId);\n    };\n  }, [formId, actions]);\n\n  return {\n    form,\n    ...actions,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/keyholderStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (185). Maximum allowed is 75.","line":76,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":296,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Keyholder Store\n * UI state management for keyholder mode functionality\n * Zustand store - handles keyholder UI state only\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\nimport { sha256 } from \"@/utils/helpers/hash\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"KeyholderStore\");\n\nexport interface KeyholderState {\n  // UI State\n  isKeyholderModeUnlocked: boolean;\n  keyholderMessage: string;\n  isPasswordDialogOpen: boolean;\n  isPasswordSettingMode: boolean;\n\n  // Form State\n  passwordAttempt: string;\n  newPassword: string;\n  confirmPassword: string;\n\n  // Loading States\n  isCheckingPassword: boolean;\n  isSavingPassword: boolean;\n}\n\nexport interface KeyholderActions {\n  // Password Management\n  checkPassword: (passwordAttempt: string, storedHash: string) => Promise<void>;\n  setTempPassword: (keyholderName: string) => Promise<string>;\n  setPermanentPassword: (\n    newPassword: string,\n    onSave: (hash: string) => Promise<void>,\n  ) => Promise<void>;\n\n  // UI Actions\n  unlockKeyholderMode: () => void;\n  lockKeyholderControls: () => void;\n  setMessage: (message: string) => void;\n  clearMessage: () => void;\n\n  // Dialog Management\n  openPasswordDialog: () => void;\n  closePasswordDialog: () => void;\n  setPasswordSettingMode: (isSettingMode: boolean) => void;\n\n  // Form Actions\n  setPasswordAttempt: (password: string) => void;\n  setNewPassword: (password: string) => void;\n  setConfirmPassword: (password: string) => void;\n  clearForm: () => void;\n\n  // Reset\n  resetStore: () => void;\n}\n\nexport interface KeyholderStore extends KeyholderState, KeyholderActions {}\n\nconst initialState: KeyholderState = {\n  isKeyholderModeUnlocked: false,\n  keyholderMessage: \"\",\n  isPasswordDialogOpen: false,\n  isPasswordSettingMode: false,\n  passwordAttempt: \"\",\n  newPassword: \"\",\n  confirmPassword: \"\",\n  isCheckingPassword: false,\n  isSavingPassword: false,\n};\n\nexport const useKeyholderStore = create<KeyholderStore>()(\n  devtools(\n    (set, get) => ({\n      ...initialState,\n\n      // Password Management\n      checkPassword: async (passwordAttempt: string, storedHash: string) => {\n        const state = get();\n\n        if (state.isCheckingPassword) {\n          logger.debug(\"Password check already in progress\");\n          return;\n        }\n\n        set({ isCheckingPassword: true, keyholderMessage: \"\" });\n\n        try {\n          logger.debug(\"Checking keyholder password\");\n\n          if (!storedHash) {\n            const message =\n              \"Error: No keyholder password is set in the database.\";\n            set({\n              keyholderMessage: message,\n              isCheckingPassword: false,\n            });\n            logger.warn(\"No keyholder password hash found\");\n            return;\n          }\n\n          const attemptHash = await sha256(passwordAttempt);\n\n          if (attemptHash === storedHash) {\n            set({\n              isKeyholderModeUnlocked: true,\n              keyholderMessage: \"Controls are now unlocked.\",\n              isPasswordDialogOpen: false,\n              passwordAttempt: \"\",\n              isCheckingPassword: false,\n            });\n            logger.info(\"Keyholder password correct, mode unlocked\");\n          } else {\n            set({\n              keyholderMessage: \"Incorrect password. Please try again.\",\n              passwordAttempt: \"\",\n              isCheckingPassword: false,\n            });\n            logger.warn(\"Incorrect keyholder password attempt\");\n          }\n        } catch (error) {\n          const message = \"Failed to check password. Please try again.\";\n          set({\n            keyholderMessage: message,\n            isCheckingPassword: false,\n          });\n          logger.error(\"Error checking keyholder password\", {\n            error: error as Error,\n          });\n        }\n      },\n\n      setTempPassword: async (keyholderName: string): Promise<string> => {\n        try {\n          logger.debug(\"Generating temporary keyholder password\", {\n            keyholderName,\n          });\n\n          const tempPassword = Math.random()\n            .toString(36)\n            .substring(2, 8)\n            .toUpperCase();\n          const message = `Your keyholder password is: ${tempPassword}. This is now the permanent password unless you set a custom one.`;\n\n          set({ keyholderMessage: message });\n\n          logger.info(\"Temporary keyholder password generated\");\n          return tempPassword;\n        } catch (error) {\n          const message = \"Failed to generate temporary password.\";\n          set({ keyholderMessage: message });\n          logger.error(\"Error generating temporary password\", {\n            error: error as Error,\n          });\n          throw error;\n        }\n      },\n\n      setPermanentPassword: async (\n        newPassword: string,\n        onSave: (hash: string) => Promise<void>,\n      ) => {\n        const state = get();\n\n        if (state.isSavingPassword) {\n          logger.debug(\"Password save already in progress\");\n          return;\n        }\n\n        if (!newPassword || newPassword.length < 6) {\n          set({\n            keyholderMessage: \"Password must be at least 6 characters long.\",\n          });\n          return;\n        }\n\n        set({ isSavingPassword: true, keyholderMessage: \"\" });\n\n        try {\n          logger.debug(\"Setting permanent keyholder password\");\n\n          const newHash = await sha256(newPassword);\n          await onSave(newHash);\n\n          set({\n            keyholderMessage:\n              \"Permanent password has been updated successfully!\",\n            newPassword: \"\",\n            confirmPassword: \"\",\n            isPasswordSettingMode: false,\n            isPasswordDialogOpen: false,\n            isSavingPassword: false,\n          });\n\n          logger.info(\"Permanent keyholder password updated successfully\");\n        } catch (error) {\n          const message = \"Failed to update password. Please try again.\";\n          set({\n            keyholderMessage: message,\n            isSavingPassword: false,\n          });\n          logger.error(\"Error setting permanent password\", {\n            error: error as Error,\n          });\n        }\n      },\n\n      // UI Actions\n      unlockKeyholderMode: () => {\n        set({\n          isKeyholderModeUnlocked: true,\n          keyholderMessage: \"Controls are now unlocked.\",\n          isPasswordDialogOpen: false,\n        });\n        logger.info(\"Keyholder mode unlocked manually\");\n      },\n\n      lockKeyholderControls: () => {\n        set({\n          isKeyholderModeUnlocked: false,\n          keyholderMessage: \"\",\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n        logger.info(\"Keyholder controls locked\");\n      },\n\n      setMessage: (message: string) => {\n        set({ keyholderMessage: message });\n      },\n\n      clearMessage: () => {\n        set({ keyholderMessage: \"\" });\n      },\n\n      // Dialog Management\n      openPasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: true,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n        });\n      },\n\n      closePasswordDialog: () => {\n        set({\n          isPasswordDialogOpen: false,\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          isPasswordSettingMode: false,\n        });\n      },\n\n      setPasswordSettingMode: (isSettingMode: boolean) => {\n        set({\n          isPasswordSettingMode: isSettingMode,\n          keyholderMessage: \"\",\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n        });\n      },\n\n      // Form Actions\n      setPasswordAttempt: (password: string) => {\n        set({ passwordAttempt: password });\n      },\n\n      setNewPassword: (password: string) => {\n        set({ newPassword: password });\n      },\n\n      setConfirmPassword: (password: string) => {\n        set({ confirmPassword: password });\n      },\n\n      clearForm: () => {\n        set({\n          passwordAttempt: \"\",\n          newPassword: \"\",\n          confirmPassword: \"\",\n          keyholderMessage: \"\",\n        });\n      },\n\n      // Reset\n      resetStore: () => {\n        set(initialState);\n        logger.debug(\"Keyholder store reset to initial state\");\n      },\n    }),\n    {\n      name: \"keyholder-store\",\n      // Only enable devtools in development\n      enabled:\n        import.meta.env.MODE === \"development\" ||\n        import.meta.env.MODE === \"nightly\",\n    },\n  ),\n);\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/modalStore.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'React' is not defined.","line":12,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":18},{"ruleId":"zustand-safe-patterns/zustand-selective-subscriptions","severity":1,"message":"Use selective subscriptions instead of subscribing to entire store. Replace useUIStore() with useUIStore(state => state.specificValue) to prevent unnecessary re-renders. See docs/development/architecture/data-flow.md for performance patterns.","line":181,"column":37,"nodeType":"CallExpression","messageId":"useSelectiveSubscription","endLine":181,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Modal Store - UI Interaction State\n * Manages modal visibility, content, and confirmation dialogs\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\n// Define specific prop types for different modal types\nexport interface BaseModalProps {\n  isOpen: boolean;\n  title?: string;\n  content?: React.ReactNode;\n  onConfirm?: () => void;\n  onCancel?: () => void;\n  confirmText?: string;\n  cancelText?: string;\n  size?: \"sm\" | \"md\" | \"lg\" | \"xl\";\n  closable?: boolean;\n}\n\nexport interface ConfirmModalProps extends BaseModalProps {\n  message?: string;\n  confirmButtonStyle?: \"primary\" | \"danger\" | \"warning\";\n}\n\nexport interface TaskDetailsModalProps extends BaseModalProps {\n  taskId?: string;\n  taskData?: {\n    title: string;\n    description?: string;\n    dueDate?: Date;\n    status?: string;\n  };\n}\n\nexport interface EventDetailsModalProps extends BaseModalProps {\n  eventId?: string;\n  eventData?: {\n    type: string;\n    timestamp: Date;\n    details?: Record<string, unknown>;\n  };\n}\n\nexport interface AccountLinkingModalProps extends BaseModalProps {\n  linkingCode?: string;\n  qrCodeData?: string;\n}\n\n// Union type for all possible modal configurations\nexport type ModalConfig =\n  | ConfirmModalProps\n  | TaskDetailsModalProps\n  | EventDetailsModalProps\n  | AccountLinkingModalProps\n  | BaseModalProps;\n\nexport interface ModalState {\n  // Modal registry\n  modals: Record<string, ModalConfig>;\n\n  // Actions\n  openModal: (id: string, config?: Partial<ModalConfig>) => void;\n  closeModal: (id: string) => void;\n  closeAllModals: () => void;\n  updateModal: (id: string, updates: Partial<ModalConfig>) => void;\n\n  // Utility methods\n  isModalOpen: (id: string) => boolean;\n  getModal: (id: string) => ModalConfig | undefined;\n}\n\nexport const useModalStore = create<ModalState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      modals: {},\n\n      // Actions\n      openModal: (id: string, config: Partial<ModalConfig> = {}) =>\n        set(\n          (state) => ({\n            modals: {\n              ...state.modals,\n              [id]: {\n                isOpen: true,\n                size: \"md\",\n                closable: true,\n                ...config,\n              },\n            },\n          }),\n          false,\n          `openModal:${id}`,\n        ),\n\n      closeModal: (id: string) =>\n        set(\n          (state) => ({\n            modals: {\n              ...state.modals,\n              [id]: {\n                ...state.modals[id],\n                isOpen: false,\n              },\n            },\n          }),\n          false,\n          `closeModal:${id}`,\n        ),\n\n      closeAllModals: () =>\n        set(\n          (state) => {\n            const updatedModals = { ...state.modals };\n            Object.keys(updatedModals).forEach((id) => {\n              updatedModals[id] = {\n                ...updatedModals[id],\n                isOpen: false,\n              };\n            });\n            return { modals: updatedModals };\n          },\n          false,\n          \"closeAllModals\",\n        ),\n\n      updateModal: (id: string, updates: Partial<ModalConfig>) =>\n        set(\n          (state) => ({\n            modals: {\n              ...state.modals,\n              [id]: {\n                ...state.modals[id],\n                ...updates,\n              },\n            },\n          }),\n          false,\n          `updateModal:${id}`,\n        ),\n\n      // Utility methods\n      isModalOpen: (id: string) => {\n        const modal = get().modals[id];\n        return modal?.isOpen ?? false;\n      },\n\n      getModal: (id: string) => {\n        return get().modals[id];\n      },\n    }),\n    {\n      name: \"modal-store\",\n    },\n  ),\n);\n\n// Common modal IDs as constants to prevent typos\nexport const MODAL_IDS = {\n  CONFIRM_DELETE: \"confirmDelete\",\n  CONFIRM_END_SESSION: \"confirmEndSession\",\n  TASK_DETAILS: \"taskDetails\",\n  EVENT_DETAILS: \"eventDetails\",\n  SETTINGS_RESET: \"settingsReset\",\n  ACCOUNT_LINKING: \"accountLinking\",\n  PRIVACY_POLICY: \"privacyPolicy\",\n  TERMS_OF_SERVICE: \"termsOfService\",\n  HELP: \"help\",\n} as const;\n\n// Selector hooks for better performance\nexport const useModal = (id: string) =>\n  useModalStore((state) => state.modals[id]);\n\nexport const useIsModalOpen = (id: string) =>\n  useModalStore((state) => state.isModalOpen(id));\n\n// Utility hooks for common modal patterns\nexport const useConfirmModal = () => {\n  const { openModal, closeModal } = useModalStore();\n\n  const openConfirmModal = (\n    title: string,\n    message: string,\n    onConfirm: () => void,\n    confirmText = \"Confirm\",\n    cancelText = \"Cancel\",\n  ) => {\n    openModal(MODAL_IDS.CONFIRM_DELETE, {\n      title,\n      content: message,\n      onConfirm: () => {\n        onConfirm();\n        closeModal(MODAL_IDS.CONFIRM_DELETE);\n      },\n      onCancel: () => closeModal(MODAL_IDS.CONFIRM_DELETE),\n      confirmText,\n      cancelText,\n    });\n  };\n\n  return { openConfirmModal };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/navigationStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'get' is defined but never used. Allowed unused args must match /^_/u.","line":36,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Navigation Store - Pure UI State\n * Manages navigation state, breadcrumbs, and mobile menu\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\nexport interface NavigationState {\n  // Current page/route\n  currentPage: string;\n\n  // Breadcrumbs for navigation\n  breadcrumbs: string[];\n\n  // Mobile menu state\n  isMobileMenuOpen: boolean;\n\n  // Page loading state\n  isPageLoading: boolean;\n\n  // Actions\n  setCurrentPage: (page: string) => void;\n  setBreadcrumbs: (breadcrumbs: string[]) => void;\n  toggleMobileMenu: () => void;\n  setMobileMenuOpen: (isOpen: boolean) => void;\n  setPageLoading: (isLoading: boolean) => void;\n\n  // Utility actions\n  addBreadcrumb: (breadcrumb: string) => void;\n  removeBreadcrumb: () => void;\n  clearBreadcrumbs: () => void;\n}\n\nexport const useNavigationStore = create<NavigationState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      currentPage: \"dashboard\",\n      breadcrumbs: [],\n      isMobileMenuOpen: false,\n      isPageLoading: false,\n\n      // Actions\n      setCurrentPage: (page: string) =>\n        set({ currentPage: page }, false, \"setCurrentPage\"),\n\n      setBreadcrumbs: (breadcrumbs: string[]) =>\n        set({ breadcrumbs }, false, \"setBreadcrumbs\"),\n\n      toggleMobileMenu: () =>\n        set(\n          (state) => ({ isMobileMenuOpen: !state.isMobileMenuOpen }),\n          false,\n          \"toggleMobileMenu\",\n        ),\n\n      setMobileMenuOpen: (isOpen: boolean) =>\n        set({ isMobileMenuOpen: isOpen }, false, \"setMobileMenuOpen\"),\n\n      setPageLoading: (isLoading: boolean) =>\n        set({ isPageLoading: isLoading }, false, \"setPageLoading\"),\n\n      // Utility actions\n      addBreadcrumb: (breadcrumb: string) =>\n        set(\n          (state) => ({\n            breadcrumbs: [...state.breadcrumbs, breadcrumb],\n          }),\n          false,\n          \"addBreadcrumb\",\n        ),\n\n      removeBreadcrumb: () =>\n        set(\n          (state) => ({\n            breadcrumbs: state.breadcrumbs.slice(0, -1),\n          }),\n          false,\n          \"removeBreadcrumb\",\n        ),\n\n      clearBreadcrumbs: () =>\n        set({ breadcrumbs: [] }, false, \"clearBreadcrumbs\"),\n    }),\n    {\n      name: \"navigation-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useCurrentPage = () =>\n  useNavigationStore((state) => state.currentPage);\n\nexport const useBreadcrumbs = () =>\n  useNavigationStore((state) => state.breadcrumbs);\n\nexport const useIsMobileMenuOpen = () =>\n  useNavigationStore((state) => state.isMobileMenuOpen);\n\nexport const useIsPageLoading = () =>\n  useNavigationStore((state) => state.isPageLoading);\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/notificationStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (78). Maximum allowed is 75.","line":51,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":143,"endColumn":7}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Store - Temporary UI Feedback\n * Manages toast messages, alerts, and temporary UI feedback\n */\nimport { create } from \"zustand\";\nimport { devtools } from \"zustand/middleware\";\n\nexport interface Notification {\n  id: string;\n  type: \"success\" | \"error\" | \"warning\" | \"info\";\n  title?: string;\n  message: string;\n  duration?: number; // in milliseconds, 0 means persistent\n  dismissible?: boolean;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  timestamp: Date;\n}\n\nexport interface NotificationState {\n  // Notifications list\n  notifications: Notification[];\n\n  // Actions\n  addNotification: (\n    notification: Omit<Notification, \"id\" | \"timestamp\">,\n  ) => string;\n  removeNotification: (id: string) => void;\n  clearAllNotifications: () => void;\n  updateNotification: (id: string, updates: Partial<Notification>) => void;\n\n  // Convenience methods\n  showSuccess: (message: string, title?: string, duration?: number) => string;\n  showError: (message: string, title?: string, duration?: number) => string;\n  showWarning: (message: string, title?: string, duration?: number) => string;\n  showInfo: (message: string, title?: string, duration?: number) => string;\n}\n\n// Default durations for different notification types\nconst DEFAULT_DURATIONS = {\n  success: 4000,\n  error: 0, // Persistent for errors\n  warning: 6000,\n  info: 4000,\n};\n\nexport const useNotificationStore = create<NotificationState>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      notifications: [],\n\n      // Actions\n      addNotification: (notification) => {\n        const id = `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        const newNotification: Notification = {\n          id,\n          timestamp: new Date(),\n          duration: DEFAULT_DURATIONS[notification.type],\n          dismissible: true,\n          ...notification,\n        };\n\n        set(\n          (state) => ({\n            notifications: [...state.notifications, newNotification],\n          }),\n          false,\n          `addNotification:${notification.type}`,\n        );\n\n        // Auto-remove notification after duration if specified\n        if (newNotification.duration && newNotification.duration > 0) {\n          setTimeout(() => {\n            useNotificationStore.getState().removeNotification(id);\n          }, newNotification.duration);\n        }\n\n        return id;\n      },\n\n      removeNotification: (id: string) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.filter((n) => n.id !== id),\n          }),\n          false,\n          `removeNotification:${id}`,\n        ),\n\n      clearAllNotifications: () =>\n        set({ notifications: [] }, false, \"clearAllNotifications\"),\n\n      updateNotification: (id: string, updates: Partial<Notification>) =>\n        set(\n          (state) => ({\n            notifications: state.notifications.map((n) =>\n              n.id === id ? { ...n, ...updates } : n,\n            ),\n          }),\n          false,\n          `updateNotification:${id}`,\n        ),\n\n      // Convenience methods\n      showSuccess: (message: string, title?: string, duration?: number) => {\n        return get().addNotification({\n          type: \"success\",\n          message,\n          title,\n          duration,\n        });\n      },\n\n      showError: (message: string, title?: string, duration?: number) => {\n        return get().addNotification({\n          type: \"error\",\n          message,\n          title,\n          duration,\n        });\n      },\n\n      showWarning: (message: string, title?: string, duration?: number) => {\n        return get().addNotification({\n          type: \"warning\",\n          message,\n          title,\n          duration,\n        });\n      },\n\n      showInfo: (message: string, title?: string, duration?: number) => {\n        return get().addNotification({\n          type: \"info\",\n          message,\n          title,\n          duration,\n        });\n      },\n    }),\n    {\n      name: \"notification-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useNotifications = () =>\n  useNotificationStore((state) => state.notifications);\n\nexport const useNotificationActions = () =>\n  useNotificationStore((state) => ({\n    addNotification: state.addNotification,\n    removeNotification: state.removeNotification,\n    clearAllNotifications: state.clearAllNotifications,\n    showSuccess: state.showSuccess,\n    showError: state.showError,\n    showWarning: state.showWarning,\n    showInfo: state.showInfo,\n  }));\n\n// Utility hooks for common notification patterns\nexport const useErrorHandler = () => {\n  const { showError } = useNotificationActions();\n\n  const handleError = (error: Error | string, title = \"Error\") => {\n    const message = typeof error === \"string\" ? error : error.message;\n    return showError(message, title);\n  };\n\n  return { handleError };\n};\n\nexport const useSuccessHandler = () => {\n  const { showSuccess } = useNotificationActions();\n\n  const handleSuccess = (message: string, title = \"Success\") => {\n    return showSuccess(message, title);\n  };\n\n  return { handleSuccess };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/themeStore.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (211). Maximum allowed is 75.","line":143,"column":7,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":413,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Theme Store\n * UI state management for theme preferences, animations, and layout settings\n * Zustand store - handles theme and UI preference state\n */\nimport { create } from \"zustand\";\nimport { devtools, persist } from \"zustand/middleware\";\nimport { serviceLogger } from \"@/utils/logging\";\n\nconst logger = serviceLogger(\"ThemeStore\");\n\nexport type ThemeMode = \"light\" | \"dark\" | \"system\";\nexport type ColorScheme = \"nightly\" | \"classic\" | \"high-contrast\";\nexport type FontSize = \"sm\" | \"md\" | \"lg\" | \"xl\";\nexport type AnimationSpeed = \"none\" | \"reduced\" | \"normal\" | \"fast\";\n\nexport interface ThemeState {\n  // Theme settings\n  mode: ThemeMode;\n  colorScheme: ColorScheme;\n\n  // Typography\n  fontSize: FontSize;\n\n  // Animations and motion\n  animationSpeed: AnimationSpeed;\n  reduceMotion: boolean;\n\n  // Layout preferences\n  compactMode: boolean;\n  showSidebar: boolean;\n  sidebarCollapsed: boolean;\n\n  // Accessibility\n  highContrast: boolean;\n  focusIndicators: boolean;\n\n  // UI preferences\n  showTooltips: boolean;\n  showHints: boolean;\n  autoSave: boolean;\n\n  // System detection\n  systemPrefersDark: boolean;\n  systemPrefersReducedMotion: boolean;\n}\n\nexport interface ThemeActions {\n  // Theme management\n  setMode: (mode: ThemeMode) => void;\n  setColorScheme: (scheme: ColorScheme) => void;\n  toggleMode: () => void;\n\n  // Typography\n  setFontSize: (size: FontSize) => void;\n  increaseFontSize: () => void;\n  decreaseFontSize: () => void;\n\n  // Animations and motion\n  setAnimationSpeed: (speed: AnimationSpeed) => void;\n  setReduceMotion: (reduce: boolean) => void;\n  toggleReduceMotion: () => void;\n\n  // Layout preferences\n  setCompactMode: (compact: boolean) => void;\n  toggleCompactMode: () => void;\n  setShowSidebar: (show: boolean) => void;\n  toggleSidebar: () => void;\n  setSidebarCollapsed: (collapsed: boolean) => void;\n  toggleSidebarCollapse: () => void;\n\n  // Accessibility\n  setHighContrast: (enabled: boolean) => void;\n  toggleHighContrast: () => void;\n  setFocusIndicators: (enabled: boolean) => void;\n  toggleFocusIndicators: () => void;\n\n  // UI preferences\n  setShowTooltips: (show: boolean) => void;\n  toggleTooltips: () => void;\n  setShowHints: (show: boolean) => void;\n  toggleHints: () => void;\n  setAutoSave: (enabled: boolean) => void;\n  toggleAutoSave: () => void;\n\n  // System detection\n  updateSystemPreferences: () => void;\n\n  // Computed getters\n  getEffectiveMode: () => \"light\" | \"dark\";\n  getEffectiveAnimationSpeed: () => AnimationSpeed;\n  shouldReduceMotion: () => boolean;\n\n  // Presets\n  applyPreset: (\n    preset: \"default\" | \"minimal\" | \"accessible\" | \"performance\",\n  ) => void;\n\n  // Reset\n  resetToDefaults: () => void;\n  resetStore: () => void;\n}\n\nexport interface ThemeStore extends ThemeState, ThemeActions {}\n\nconst defaultState: ThemeState = {\n  mode: \"system\",\n  colorScheme: \"nightly\",\n  fontSize: \"md\",\n  animationSpeed: \"normal\",\n  reduceMotion: false,\n  compactMode: false,\n  showSidebar: true,\n  sidebarCollapsed: false,\n  highContrast: false,\n  focusIndicators: true,\n  showTooltips: true,\n  showHints: true,\n  autoSave: true,\n  systemPrefersDark: false,\n  systemPrefersReducedMotion: false,\n};\n\n// Helper functions\nconst detectSystemPreferences = () => {\n  if (typeof window === \"undefined\") {\n    return { dark: false, reducedMotion: false };\n  }\n\n  const prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n  const prefersReducedMotion = window.matchMedia(\n    \"(prefers-reduced-motion: reduce)\",\n  ).matches;\n\n  return { dark: prefersDark, reducedMotion: prefersReducedMotion };\n};\n\nconst fontSizeOrder: FontSize[] = [\"sm\", \"md\", \"lg\", \"xl\"];\n\nexport const useThemeStore = create<ThemeStore>()(\n  devtools(\n    persist(\n      (set, get) => ({\n        ...defaultState,\n\n        // Theme management\n        setMode: (mode: ThemeMode) => {\n          set({ mode });\n          logger.debug(\"Theme mode set\", { mode });\n\n          // Apply theme class to document\n          if (typeof document !== \"undefined\") {\n            const effectiveMode = get().getEffectiveMode();\n            document.documentElement.classList.toggle(\n              \"dark\",\n              effectiveMode === \"dark\",\n            );\n          }\n        },\n\n        setColorScheme: (scheme: ColorScheme) => {\n          set({ colorScheme: scheme });\n          logger.debug(\"Color scheme set\", { scheme });\n\n          // Apply color scheme class to document\n          if (typeof document !== \"undefined\") {\n            document.documentElement.className =\n              document.documentElement.className\n                .replace(/scheme-\\w+/g, \"\")\n                .concat(` scheme-${scheme}`);\n          }\n        },\n\n        toggleMode: () => {\n          const { mode } = get();\n          const newMode: ThemeMode =\n            mode === \"light\" ? \"dark\" : mode === \"dark\" ? \"system\" : \"light\";\n          get().setMode(newMode);\n        },\n\n        // Typography\n        setFontSize: (size: FontSize) => {\n          set({ fontSize: size });\n          logger.debug(\"Font size set\", { size });\n\n          // Apply font size class to document\n          if (typeof document !== \"undefined\") {\n            document.documentElement.className =\n              document.documentElement.className\n                .replace(/text-size-\\w+/g, \"\")\n                .concat(` text-size-${size}`);\n          }\n        },\n\n        increaseFontSize: () => {\n          const { fontSize } = get();\n          const currentIndex = fontSizeOrder.indexOf(fontSize);\n          if (currentIndex < fontSizeOrder.length - 1) {\n            const newSize = fontSizeOrder[currentIndex + 1];\n            if (newSize) {\n              get().setFontSize(newSize);\n            }\n          }\n        },\n\n        decreaseFontSize: () => {\n          const { fontSize } = get();\n          const currentIndex = fontSizeOrder.indexOf(fontSize);\n          if (currentIndex > 0) {\n            const newSize = fontSizeOrder[currentIndex - 1];\n            if (newSize) {\n              get().setFontSize(newSize);\n            }\n          }\n        },\n\n        // Animations and motion\n        setAnimationSpeed: (speed: AnimationSpeed) => {\n          set({ animationSpeed: speed });\n          logger.debug(\"Animation speed set\", { speed });\n        },\n\n        setReduceMotion: (reduce: boolean) => {\n          set({ reduceMotion: reduce });\n          logger.debug(\"Reduce motion set\", { reduce });\n        },\n\n        toggleReduceMotion: () => {\n          const { reduceMotion } = get();\n          get().setReduceMotion(!reduceMotion);\n        },\n\n        // Layout preferences\n        setCompactMode: (compact: boolean) => {\n          set({ compactMode: compact });\n          logger.debug(\"Compact mode set\", { compact });\n        },\n\n        toggleCompactMode: () => {\n          const { compactMode } = get();\n          get().setCompactMode(!compactMode);\n        },\n\n        setShowSidebar: (show: boolean) => {\n          set({ showSidebar: show });\n          logger.debug(\"Show sidebar set\", { show });\n        },\n\n        toggleSidebar: () => {\n          const { showSidebar } = get();\n          get().setShowSidebar(!showSidebar);\n        },\n\n        setSidebarCollapsed: (collapsed: boolean) => {\n          set({ sidebarCollapsed: collapsed });\n          logger.debug(\"Sidebar collapsed set\", { collapsed });\n        },\n\n        toggleSidebarCollapse: () => {\n          const { sidebarCollapsed } = get();\n          get().setSidebarCollapsed(!sidebarCollapsed);\n        },\n\n        // Accessibility\n        setHighContrast: (enabled: boolean) => {\n          set({ highContrast: enabled });\n          logger.debug(\"High contrast set\", { enabled });\n\n          // Apply high contrast class to document\n          if (typeof document !== \"undefined\") {\n            document.documentElement.classList.toggle(\"high-contrast\", enabled);\n          }\n        },\n\n        toggleHighContrast: () => {\n          const { highContrast } = get();\n          get().setHighContrast(!highContrast);\n        },\n\n        setFocusIndicators: (enabled: boolean) => {\n          set({ focusIndicators: enabled });\n          logger.debug(\"Focus indicators set\", { enabled });\n        },\n\n        toggleFocusIndicators: () => {\n          const { focusIndicators } = get();\n          get().setFocusIndicators(!focusIndicators);\n        },\n\n        // UI preferences\n        setShowTooltips: (show: boolean) => {\n          set({ showTooltips: show });\n          logger.debug(\"Show tooltips set\", { show });\n        },\n\n        toggleTooltips: () => {\n          const { showTooltips } = get();\n          get().setShowTooltips(!showTooltips);\n        },\n\n        setShowHints: (show: boolean) => {\n          set({ showHints: show });\n          logger.debug(\"Show hints set\", { show });\n        },\n\n        toggleHints: () => {\n          const { showHints } = get();\n          get().setShowHints(!showHints);\n        },\n\n        setAutoSave: (enabled: boolean) => {\n          set({ autoSave: enabled });\n          logger.debug(\"Auto save set\", { enabled });\n        },\n\n        toggleAutoSave: () => {\n          const { autoSave } = get();\n          get().setAutoSave(!autoSave);\n        },\n\n        // System detection\n        updateSystemPreferences: () => {\n          const { dark, reducedMotion } = detectSystemPreferences();\n\n          set({\n            systemPrefersDark: dark,\n            systemPrefersReducedMotion: reducedMotion,\n          });\n\n          logger.debug(\"System preferences updated\", { dark, reducedMotion });\n\n          // Update effective mode if using system preference\n          const { mode } = get();\n          if (mode === \"system\") {\n            get().setMode(\"system\"); // Triggers re-application of theme\n          }\n        },\n\n        // Computed getters\n        getEffectiveMode: () => {\n          const { mode, systemPrefersDark } = get();\n\n          if (mode === \"system\") {\n            return systemPrefersDark ? \"dark\" : \"light\";\n          }\n\n          return mode;\n        },\n\n        getEffectiveAnimationSpeed: () => {\n          const { animationSpeed, systemPrefersReducedMotion } = get();\n\n          if (systemPrefersReducedMotion) {\n            return \"none\";\n          }\n\n          return animationSpeed;\n        },\n\n        shouldReduceMotion: () => {\n          const { reduceMotion, systemPrefersReducedMotion } = get();\n          return reduceMotion || systemPrefersReducedMotion;\n        },\n\n        // Presets\n        applyPreset: (\n          preset: \"default\" | \"minimal\" | \"accessible\" | \"performance\",\n        ) => {\n          const presets = {\n            default: {\n              ...defaultState,\n            },\n            minimal: {\n              ...defaultState,\n              showTooltips: false,\n              showHints: false,\n              animationSpeed: \"reduced\" as AnimationSpeed,\n              compactMode: true,\n            },\n            accessible: {\n              ...defaultState,\n              highContrast: true,\n              focusIndicators: true,\n              fontSize: \"lg\" as FontSize,\n              reduceMotion: true,\n              animationSpeed: \"none\" as AnimationSpeed,\n            },\n            performance: {\n              ...defaultState,\n              animationSpeed: \"none\" as AnimationSpeed,\n              reduceMotion: true,\n              showTooltips: false,\n              autoSave: false,\n            },\n          };\n\n          const presetConfig = presets[preset];\n          set(presetConfig);\n\n          logger.info(\"Theme preset applied\", { preset });\n        },\n\n        // Reset\n        resetToDefaults: () => {\n          set(defaultState);\n          logger.info(\"Theme reset to defaults\");\n        },\n\n        resetStore: () => {\n          set(defaultState);\n          logger.debug(\"Theme store reset to initial state\");\n        },\n      }),\n      {\n        name: \"theme-store\",\n        // Only persist certain settings\n        partialize: (state) => ({\n          mode: state.mode,\n          colorScheme: state.colorScheme,\n          fontSize: state.fontSize,\n          animationSpeed: state.animationSpeed,\n          reduceMotion: state.reduceMotion,\n          compactMode: state.compactMode,\n          showSidebar: state.showSidebar,\n          sidebarCollapsed: state.sidebarCollapsed,\n          highContrast: state.highContrast,\n          focusIndicators: state.focusIndicators,\n          showTooltips: state.showTooltips,\n          showHints: state.showHints,\n          autoSave: state.autoSave,\n        }),\n      },\n    ),\n    {\n      name: \"theme-store\",\n      // Only enable devtools in development\n      enabled:\n        import.meta.env.MODE === \"development\" ||\n        import.meta.env.MODE === \"nightly\",\n    },\n  ),\n);\n\n// Initialize system preferences and listen for changes\nif (typeof window !== \"undefined\") {\n  // Initial detection\n  useThemeStore.getState().updateSystemPreferences();\n\n  // Listen for system preference changes\n  const darkModeQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n  const reducedMotionQuery = window.matchMedia(\n    \"(prefers-reduced-motion: reduce)\",\n  );\n\n  darkModeQuery.addEventListener(\"change\", () => {\n    useThemeStore.getState().updateSystemPreferences();\n  });\n\n  reducedMotionQuery.addEventListener(\"change\", () => {\n    useThemeStore.getState().updateSystemPreferences();\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/stores/uiPreferencesStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'get' is defined but never used. Allowed unused args must match /^_/u.","line":58,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UI Preferences Store - Local UI Settings\n * Manages theme, animations, layout settings with localStorage persistence\n */\nimport React from \"react\";\nimport { create } from \"zustand\";\nimport { persist, devtools } from \"zustand/middleware\";\n\nexport interface UIPreferencesState {\n  // Theme settings\n  theme: \"light\" | \"dark\";\n\n  // Animation preferences\n  animations: boolean;\n\n  // Layout preferences\n  compactMode: boolean;\n  sidebarCollapsed: boolean;\n\n  // Accessibility preferences\n  highContrast: boolean;\n  fontSize: \"sm\" | \"md\" | \"lg\";\n\n  // Debug/development preferences\n  showDebugInfo: boolean;\n  showPerformanceMetrics: boolean;\n\n  // Actions\n  setTheme: (theme: \"light\" | \"dark\") => void;\n  toggleAnimations: () => void;\n  setCompactMode: (compact: boolean) => void;\n  toggleSidebar: () => void;\n  setSidebarCollapsed: (collapsed: boolean) => void;\n  toggleHighContrast: () => void;\n  setFontSize: (size: \"sm\" | \"md\" | \"lg\") => void;\n  toggleDebugInfo: () => void;\n  togglePerformanceMetrics: () => void;\n\n  // Utility actions\n  resetToDefaults: () => void;\n  applySystemTheme: () => void;\n}\n\nconst defaultState = {\n  theme: \"dark\" as const,\n  animations: true,\n  compactMode: false,\n  sidebarCollapsed: false,\n  highContrast: false,\n  fontSize: \"md\" as const,\n  showDebugInfo: false,\n  showPerformanceMetrics: false,\n};\n\nexport const useUIPreferencesStore = create<UIPreferencesState>()(\n  devtools(\n    persist(\n      (set, get) => ({\n        // Initial state\n        ...defaultState,\n\n        // Actions\n        setTheme: (theme: \"light\" | \"dark\") =>\n          set({ theme }, false, \"setTheme\"),\n\n        toggleAnimations: () =>\n          set(\n            (state) => ({ animations: !state.animations }),\n            false,\n            \"toggleAnimations\",\n          ),\n\n        setCompactMode: (compact: boolean) =>\n          set({ compactMode: compact }, false, \"setCompactMode\"),\n\n        toggleSidebar: () =>\n          set(\n            (state) => ({ sidebarCollapsed: !state.sidebarCollapsed }),\n            false,\n            \"toggleSidebar\",\n          ),\n\n        setSidebarCollapsed: (collapsed: boolean) =>\n          set({ sidebarCollapsed: collapsed }, false, \"setSidebarCollapsed\"),\n\n        toggleHighContrast: () =>\n          set(\n            (state) => ({ highContrast: !state.highContrast }),\n            false,\n            \"toggleHighContrast\",\n          ),\n\n        setFontSize: (size: \"sm\" | \"md\" | \"lg\") =>\n          set({ fontSize: size }, false, \"setFontSize\"),\n\n        toggleDebugInfo: () =>\n          set(\n            (state) => ({ showDebugInfo: !state.showDebugInfo }),\n            false,\n            \"toggleDebugInfo\",\n          ),\n\n        togglePerformanceMetrics: () =>\n          set(\n            (state) => ({\n              showPerformanceMetrics: !state.showPerformanceMetrics,\n            }),\n            false,\n            \"togglePerformanceMetrics\",\n          ),\n\n        // Utility actions\n        resetToDefaults: () => set(defaultState, false, \"resetToDefaults\"),\n\n        applySystemTheme: () => {\n          const systemPrefersDark = window.matchMedia(\n            \"(prefers-color-scheme: dark)\",\n          ).matches;\n          set(\n            { theme: systemPrefersDark ? \"dark\" : \"light\" },\n            false,\n            \"applySystemTheme\",\n          );\n        },\n      }),\n      {\n        name: \"ui-preferences\", // localStorage key\n        // Only persist certain preferences\n        partialize: (state) => ({\n          theme: state.theme,\n          animations: state.animations,\n          compactMode: state.compactMode,\n          sidebarCollapsed: state.sidebarCollapsed,\n          highContrast: state.highContrast,\n          fontSize: state.fontSize,\n        }),\n      },\n    ),\n    {\n      name: \"ui-preferences-store\",\n    },\n  ),\n);\n\n// Selector hooks for better performance\nexport const useTheme = () => useUIPreferencesStore((state) => state.theme);\n\nexport const useAnimations = () =>\n  useUIPreferencesStore((state) => state.animations);\n\nexport const useCompactMode = () =>\n  useUIPreferencesStore((state) => state.compactMode);\n\nexport const useSidebarCollapsed = () =>\n  useUIPreferencesStore((state) => state.sidebarCollapsed);\n\nexport const useHighContrast = () =>\n  useUIPreferencesStore((state) => state.highContrast);\n\nexport const useFontSize = () =>\n  useUIPreferencesStore((state) => state.fontSize);\n\nexport const useShowDebugInfo = () =>\n  useUIPreferencesStore((state) => state.showDebugInfo);\n\nexport const useShowPerformanceMetrics = () =>\n  useUIPreferencesStore((state) => state.showPerformanceMetrics);\n\n// Theme effect hook to apply theme to document\nexport const useThemeEffect = () => {\n  const theme = useTheme();\n\n  React.useEffect(() => {\n    document.documentElement.setAttribute(\"data-theme\", theme);\n    document.documentElement.classList.remove(\"light\", \"dark\");\n    document.documentElement.classList.add(theme);\n  }, [theme]);\n};\n\n// System theme listener hook\nexport const useSystemThemeListener = () => {\n  const applySystemTheme = useUIPreferencesStore(\n    (state) => state.applySystemTheme,\n  );\n\n  React.useEffect(() => {\n    const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    const handleChange = () => applySystemTheme();\n\n    mediaQuery.addEventListener(\"change\", handleChange);\n    return () => mediaQuery.removeEventListener(\"change\", handleChange);\n  }, [applySystemTheme]);\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/account-linking.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3891,3894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3891,3894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6007,6010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6007,6010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7124,7127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7124,7127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":311,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7917,7920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7917,7920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":324,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8201,8204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8201,8204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Account Linking Types\n * Types for the private keyholder-wearer account linking system\n */\nimport { Timestamp } from \"firebase/firestore\";\n\n// ==================== LINK CODE TYPES ====================\n\nexport interface LinkCode {\n  id: string;\n  wearerId: string;\n  createdAt: Timestamp;\n  expiresAt: Timestamp;\n  status: \"pending\" | \"used\" | \"expired\";\n  maxUses: number;\n  usedBy: string | null;\n  usedAt?: Timestamp;\n  // Optional metadata\n  shareMethod?: \"manual\" | \"qr\" | \"email\" | \"url\";\n  ipAddress?: string;\n}\n\nexport interface LinkCodeResponse {\n  code: string;\n  expiresIn: string;\n  shareUrl?: string;\n  qrCodeData?: string;\n}\n\n// ==================== ADMIN RELATIONSHIP TYPES ====================\n\nexport interface AdminRelationship {\n  id: string;\n  keyholderId: string; // Admin account UID\n  wearerId: string; // Managed account UID\n\n  // Relationship metadata\n  establishedAt: Timestamp;\n  status: \"active\" | \"paused\" | \"terminated\";\n\n  // Admin permissions - what keyholder can access/control\n  permissions: AdminPermissions;\n\n  // Security settings\n  security: SecuritySettings;\n\n  // Privacy settings\n  privacy: PrivacySettings;\n\n  // Linking metadata\n  linkMethod: \"code\" | \"qr\" | \"email\";\n  lastAdminAccess?: Timestamp;\n  terminatedAt?: Timestamp;\n  terminatedBy?: \"wearer\" | \"keyholder\";\n  terminationReason?: string;\n}\n\nexport interface AdminPermissions {\n  // Data access\n  viewSessions: boolean; // See all session history\n  viewEvents: boolean; // See sexual event logs\n  viewTasks: boolean; // See task history\n  viewSettings: boolean; // See wearer's settings\n\n  // Control permissions\n  controlSessions: boolean; // Start/stop sessions, set requirements\n  manageTasks: boolean; // Create, approve, reject tasks\n  editSettings: boolean; // Modify wearer's settings\n  setGoals: boolean; // Set minimum chastity requirements\n\n  // Emergency controls\n  emergencyUnlock: boolean; // Override emergency unlock codes\n  forceEnd: boolean; // Force end sessions regardless of settings\n\n  // Admin actions\n  viewAuditLog: boolean; // See admin action history\n  exportData: boolean; // Export wearer's data\n}\n\nexport interface SecuritySettings {\n  requireConfirmation: boolean; // Require wearer confirmation for major changes\n  auditLog: boolean; // Log all admin actions\n  sessionTimeout: number; // How long admin session lasts (minutes)\n  requireReauth: boolean; // Require password re-entry for sensitive actions\n  ipRestrictions: string[]; // Allowed IP addresses (optional)\n  allowedHours?: {\n    // Time restrictions (optional)\n    start: string; // \"09:00\"\n    end: string; // \"21:00\"\n    timezone: string;\n  };\n}\n\nexport interface PrivacySettings {\n  wearerCanSeeAdminActions: boolean; // Wearer sees what keyholder does\n  keyholderCanSeePrivateNotes: boolean; // Access to private notes/events\n  shareStatistics: boolean; // Share aggregated stats with keyholder\n  retainDataAfterDisconnect: boolean; // Keep historical data accessible\n  anonymizeHistoricalData: boolean; // Remove keyholder identity from old logs\n}\n\n// ==================== ADMIN SESSION TYPES ====================\n\nexport interface AdminSession {\n  id: string;\n  relationshipId: string;\n  keyholderId: string;\n  wearerId: string;\n  startedAt: Timestamp;\n  expiresAt: Timestamp;\n  lastActivity: Timestamp;\n  actions: AdminActionSummary;\n  ipAddress?: string;\n  userAgent?: string;\n  isActive: boolean;\n}\n\nexport interface AdminActionSummary {\n  sessionViews: number;\n  taskActions: number;\n  settingChanges: number;\n  emergencyActions: number;\n  dataExports: number;\n}\n\n// ==================== ADMIN ACTION LOG TYPES ====================\n\nexport interface AdminAction {\n  id: string;\n  sessionId: string;\n  relationshipId: string;\n  keyholderId: string;\n  wearerId: string;\n\n  // Action details\n  type: AdminActionType;\n  target: string; // What was acted upon\n  details: Record<string, any>; // Action-specific data\n\n  // Metadata\n  timestamp: Timestamp;\n  ipAddress?: string;\n  userAgent?: string;\n\n  // Wearer awareness\n  wearerNotified: boolean;\n  wearerApprovalRequired?: boolean;\n  wearerApprovalStatus?: \"pending\" | \"approved\" | \"denied\";\n}\n\nexport type AdminActionType =\n  | \"session_start\"\n  | \"session_end\"\n  | \"session_pause\"\n  | \"session_resume\"\n  | \"session_extend\"\n  | \"task_create\"\n  | \"task_approve\"\n  | \"task_reject\"\n  | \"task_modify\"\n  | \"setting_change\"\n  | \"goal_set\"\n  | \"goal_modify\"\n  | \"emergency_unlock\"\n  | \"force_end\"\n  | \"data_export\"\n  | \"view_data\"\n  | \"relationship_pause\"\n  | \"relationship_terminate\";\n\n// ==================== UI STATE TYPES ====================\n\nexport interface AccountLinkingState {\n  // Link generation\n  isGeneratingCode: boolean;\n  currentLinkCode: LinkCodeResponse | null;\n  linkCodeError: string | null;\n\n  // Code usage\n  isUsingCode: boolean;\n  codeUsageError: string | null;\n\n  // Relationship management\n  adminRelationships: AdminRelationship[];\n  selectedWearerId: string | null;\n\n  // Admin session\n  currentAdminSession: AdminSession | null;\n  isAdminSessionActive: boolean;\n\n  // UI state\n  showQRCode: boolean;\n  showDisconnectionDialog: boolean;\n  showPermissionEditor: boolean;\n}\n\n// ==================== API REQUEST/RESPONSE TYPES ====================\n\nexport interface GenerateLinkCodeRequest {\n  expirationHours?: number; // Default 24\n  maxUses?: number; // Default 1\n  shareMethod?: \"manual\" | \"qr\" | \"email\" | \"url\";\n  recipientEmail?: string; // If sharing via email\n}\n\nexport interface UseLinkCodeRequest {\n  code: string;\n  permissions?: Partial<AdminPermissions>;\n  security?: Partial<SecuritySettings>;\n  privacy?: Partial<PrivacySettings>;\n}\n\nexport interface UpdateRelationshipRequest {\n  relationshipId: string;\n  permissions?: Partial<AdminPermissions>;\n  security?: Partial<SecuritySettings>;\n  privacy?: Partial<PrivacySettings>;\n  status?: \"active\" | \"paused\" | \"terminated\";\n  terminationReason?: string;\n}\n\nexport interface AdminActionRequest {\n  type: AdminActionType;\n  target: string;\n  details: Record<string, any>;\n  requireWearerApproval?: boolean;\n}\n\n// ==================== VALIDATION TYPES ====================\n\nexport interface LinkCodeValidation {\n  isValid: boolean;\n  error?: string;\n  code?: LinkCode;\n  canUse: boolean;\n  timeRemaining?: number; // seconds until expiration\n}\n\nexport interface RelationshipValidation {\n  canPerformAction: boolean;\n  reason?: string;\n  requiresConfirmation?: boolean;\n  requiresReauth?: boolean;\n}\n\n// ==================== SHARING TYPES ====================\n\nexport interface QRCodeData {\n  type: \"chastityos_link\";\n  code: string;\n  version: string;\n  appUrl: string;\n}\n\nexport interface SecureLinkUrl {\n  url: string;\n  token: string;\n  expiresAt: Timestamp;\n}\n\nexport interface EmailShareData {\n  recipientEmail: string;\n  linkCode: string;\n  senderName?: string;\n  customMessage?: string;\n  expiresIn: string;\n}\n\n// ==================== AUDIT LOG TYPES ====================\n\nexport interface AuditLogEntry {\n  id: string;\n  relationshipId: string;\n  timestamp: Timestamp;\n  actor: \"keyholder\" | \"wearer\" | \"system\";\n  actorId: string;\n  action: string;\n  details: Record<string, any>;\n  severity: \"info\" | \"warning\" | \"critical\";\n  category: \"access\" | \"permission\" | \"data\" | \"security\" | \"relationship\";\n}\n\nexport interface AuditLogFilters {\n  relationshipId?: string;\n  actor?: \"keyholder\" | \"wearer\" | \"system\";\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  severity?: \"info\" | \"warning\" | \"critical\";\n  category?: string;\n  limit?: number;\n  offset?: number;\n}\n\n// ==================== NOTIFICATION TYPES ====================\n\nexport interface AdminNotification {\n  id: string;\n  relationshipId: string;\n  recipientId: string; // wearer or keyholder\n  recipientType: \"wearer\" | \"keyholder\";\n\n  type:\n    | \"admin_action\"\n    | \"permission_change\"\n    | \"session_timeout\"\n    | \"security_alert\";\n  title: string;\n  message: string;\n  details?: Record<string, any>;\n\n  createdAt: Timestamp;\n  readAt?: Timestamp;\n  isRead: boolean;\n  priority: \"low\" | \"normal\" | \"high\" | \"urgent\";\n}\n\n// ==================== ERROR TYPES ====================\n\nexport interface AccountLinkingError {\n  code: string;\n  message: string;\n  details?: Record<string, any>;\n  timestamp: Timestamp;\n  userId?: string;\n  relationshipId?: string;\n}\n\nexport type LinkingErrorCode =\n  | \"INVALID_CODE\"\n  | \"EXPIRED_CODE\"\n  | \"CODE_ALREADY_USED\"\n  | \"UNAUTHORIZED\"\n  | \"RELATIONSHIP_EXISTS\"\n  | \"PERMISSION_DENIED\"\n  | \"SESSION_EXPIRED\"\n  | \"RATE_LIMITED\"\n  | \"NETWORK_ERROR\"\n  | \"VALIDATION_ERROR\";\n","usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/feedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/types/relationships.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/formatting/date.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/formatting/time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/hash.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/helpers/string.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/iconImport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/logging.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/utils/systemInfo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/runner/work/chastityOS/chastityOS/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]